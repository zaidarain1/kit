const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-CT7htynR.js","./hooks.module-D2GFMjWD.js","./inherits_browser-C9npxwRG.js","./index-BE7fuU30.js","./index.es-Mgm5-TKN.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _d, _queries, _e, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f, _mutations, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _i, _client2, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _j, _listener, _listeners, _cancelled, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _format, _val, _tens, _FixedNumber_instances, checkFormat_fn, checkValue_fn, add_fn, sub_fn, mul_fn, div_fn, _names, _data2, _dataLength, _Writer_instances, writeData_fn, _data3, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn, _r, _s, _v, _networkV, _privateKey, _options, _type, _to, _data4, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId2, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _Transaction_instances, getSerialized_fn, _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn, _offset2, _tokens, _TokenString_instances, subTokenString_fn, _ParamType_instances, walkAsync_fn, _AbiCoder_instances, getCoder_fn, _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn, _transactions, _logs, _startBlock, _iface, _iface2, _filter, _k, _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn, _feeDataFunc, _url2, _processFunc, _name, _chainId3, _plugins, _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn, _provider2, _poll, _running, _tag, _lastBlock, _filter2, _hash, _provider3, _filter3, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn, _VoidSigner_instances, throwUnsupported_fn, _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _FilterIdSubscriber_instances, poll_fn3, teardown_fn, _event, _options3, _nextId2, _payloads, _drainTimer, _notReady, _network2, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn, _pollingInterval, _connect, _l, _plugin, _provider5, _filter4, _filterId, _paused, _emitPromise, _logFilter, _callbacks, _subs2, _pending, _connect2, _websocket, _configs, _height, _initialSyncPromise, _FallbackProvider_instances, getNextConfig_fn, addRunner_fn, initialSync_fn, checkQuorum_fn, waitForQuorum_fn, _noncePromise, _delta, _request2, _signingKey, _data5, _checksum, _words, _WordlistOwl_instances, loadWords_fn, _HDNodeWallet_instances, account_fn, _HDNodeWallet_static, fromSeed_fn, _Wallet_static, _m, fromAccount_fn, _accent;
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime$1 = { exports: {} };
var reactJsxRuntime_production_min$1 = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$4 = Symbol.for("react.profiler"), t$3 = Symbol.for("react.provider"), u$3 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A$1(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = z$1 && a2[z$1] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$1.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$3(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$3;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$1 = /\/+/g;
function Q$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2) a2 = null;
  var h2 = false;
  if (null === a2) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a2.$$typeof) {
        case l$3:
        case n$5:
          h2 = true;
      }
  }
  if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
    return a3;
  })) : null != c2 && (O$1(c2) && (c2 = N$3(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
    k2 = a2[g2];
    var f2 = d2 + Q$1(k2, g2);
    h2 += R$1(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$1(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2) return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$1(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status) return a2._result.default;
  throw a2._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$1(a2)) throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$4;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
    for (f2 in b2) J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$3, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$3, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a2) {
  var b2 = M$1.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: y, _payload: { _status: -1, _result: a2 }, _init: T$1 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a2();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a2, b2) {
  return U$1.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$1.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$1.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$1.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$1.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$1.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$1.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$1.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$1.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$1.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$1.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$1.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs$1(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$4 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: true, ref: true, __self: true, __source: true };
function q$3(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2) m$3.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
}
reactJsxRuntime_production_min$1.Fragment = l$2;
reactJsxRuntime_production_min$1.jsx = q$3;
reactJsxRuntime_production_min$1.jsxs = q$3;
{
  jsxRuntime$1.exports = reactJsxRuntime_production_min$1;
}
var jsxRuntimeExports$1 = jsxRuntime$1.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a2[d2];
      if (0 < g2(e2, b2)) a2[d2] = b2, a2[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length) return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a: for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
        else if (n2 < e2 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v3 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K2(H2, b2.startTime - a2);
    }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v3 = h2(r2); null !== v3 && (!(v3.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v3.callback;
        if ("function" === typeof d2) {
          v3.callback = null;
          y2 = v3.priorityLevel;
          var e2 = d2(v3.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v3.callback = e2 : v3 === h2(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v3 = h2(r2);
      }
      if (null !== v3) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v3 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T9 = new MessageChannel(), U5 = T9.port2;
    T9.port1.onmessage = R2;
    S2 = function() {
      U5.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2)) return true;
  if (ja.call(la, a2)) return false;
  if (ka.test(a2)) return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$2(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z[a2] = new v$2(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z[b2] = new v$2(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z[a2] = new v$2(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z[a2] = new v$2(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z[a2] = new v$2(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z[a2] = new v$2(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z[a2] = new v$2(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z[a2] = new v$2(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z[a2] = new v$2(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z[b2] = new v$2(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z.hasOwnProperty(b2) ? z[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A = Object.assign, La;
function Ma(a2) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a2, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a2.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2) return null;
  if ("function" === typeof a2) return a2.displayName || a2.name || null;
  if ("string" === typeof a2) return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2) switch (a2.$$typeof) {
    case Ca:
      return (a2.displayName || "Context") + ".Consumer";
    case Ba:
      return (a2._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a2.render;
      a2 = a2.displayName;
      a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      return a2;
    case Ga:
      return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
    case Ha:
      b2 = a2._payload;
      a2 = a2._init;
      try {
        return Qa(a2(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2) return false;
  var b2 = a2._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2) return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
  } else a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$3(91));
  return A({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
    for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
  }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$3(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$3(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$3(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$3(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb) throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib) return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
      a2 = !d2;
      break a;
    default:
      a2 = false;
  }
  if (a2) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$3(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a2) {
  Lb = false;
}
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$3(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2) throw Error(p$3(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2) throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a2;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$3(190));
  }
  if (3 !== c2.tag) throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2) return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn) return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2) hd(a2, b2, d2, id$4, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$4, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a2, b2, d2, null, c2);
  }
}
var id$4 = null;
function Yc(a2, b2, c2, d2) {
  id$4 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
  else if (c2 = b2.tag, 13 === c2) {
    a2 = Wb(b2);
    if (null !== a2) return a2;
    a2 = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a2 = null;
  } else b2 !== a2 && (a2 = null);
  id$4 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2) return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id$1 = A({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id$1), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie) return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2)) return a2;
}
function ve(a2, b2) {
  if ("change" === a2) return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2) return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2) return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2)) return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2])) return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a2 = b2.contentWindow;
    else break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2]) return Xe[a2];
  if (!We[a2]) return a2;
  var b2 = We[a2], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
        else if (me(h3)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae) b: {
        switch (a2) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2) return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2) throw Error(p$3(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a2.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a2;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2) return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
        if (c2 = a2[Of]) return c2;
        a2 = Mf(a2);
      }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
  throw Error(p$3(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a2, b2, c2) {
  if (H.current !== Vf) throw Error(p$3(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$3(108, Ra(a2) || "Unknown", e2));
  return A({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a2);
  G(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2) throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2)) throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
      }
    } else {
      if (Dg(a2)) throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2;
      I = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg) return false;
  if (!I) return Fg(a2), I = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2)) throw Hg(), Error(p$3(418));
    for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2) throw Error(p$3(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$3(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2) throw Error(p$3(284));
    if (!c2._owner) throw Error(p$3(290, a2));
  }
  return a2;
}
function Mg(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function Ng(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function Og(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = Pg(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Lg(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
      Mg(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      Mg(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$3(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c2(
      e3,
      m3
    ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a3, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a3;
                a3 = d3;
                break a;
              } else {
                c2(a3, d3);
                break;
              }
              else b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n2(a3, d3, f3, h3);
      if (Ka(f3)) return t2(a3, d3, f3, h3);
      Mg(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a2) {
  var b2 = Wg.current;
  E(Wg);
  a2._currentValue = b2;
}
function bh(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2) break;
    a2 = a2.return;
  }
}
function ch(a2, b2) {
  Xg = a2;
  Zg = Yg = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
}
function eh(a2) {
  var b2 = a2._currentValue;
  if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$3(308));
    Yg = a2;
    Xg.dependencies = { lanes: 0, firstContext: a2 };
  } else Yg = Yg.next = a2;
  return b2;
}
var fh = null;
function gh(a2) {
  null === fh ? fh = [a2] : fh.push(a2);
}
function hh(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a2, d2);
}
function ih(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function mh(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a2, c2);
}
function oh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function ph(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function sh(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
    var d2 = a2[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$3(191, e2));
      e2.call(d2);
    }
  }
}
var th = {}, uh = Uf(th), vh$1 = Uf(th), wh = Uf(th);
function xh(a2) {
  if (a2 === th) throw Error(p$3(174));
  return a2;
}
function yh(a2, b2) {
  G(wh, b2);
  G(vh$1, a2);
  G(uh, th);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh$1);
  E(wh);
}
function Ah(a2) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G(vh$1, a2), G(uh, c2));
}
function Bh(a2) {
  vh$1.current === a2 && (E(uh), E(vh$1));
}
var L = Uf(0);
function Ch(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N$2 = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p$3(321));
}
function Mh(a2, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
  return true;
}
function Nh(a2, b2, c2, d2, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
  a2 = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$3(301));
      f2 += 1;
      O = N$2 = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a2 = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N$2 && null !== N$2.next;
  Hh = 0;
  O = N$2 = M = null;
  Ih = false;
  if (b2) throw Error(p$3(300));
  return a2;
}
function Sh() {
  var a2 = 0 !== Kh;
  Kh = 0;
  return a2;
}
function Th() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a2 : O = O.next = a2;
  return O;
}
function Uh() {
  if (null === N$2) {
    var a2 = M.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else a2 = N$2.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2) O = b2, N$2 = a2;
  else {
    if (null === a2) throw Error(p$3(310));
    N$2 = a2;
    a2 = { memoizedState: N$2.memoizedState, baseState: N$2.baseState, baseQueue: N$2.baseQueue, queue: N$2.queue, next: null };
    null === O ? M.memoizedState = O = a2 : O = O.next = a2;
  }
  return O;
}
function Vh(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Wh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = N$2, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a2, b2) {
  var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q) throw Error(p$3(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function ci(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a2);
}
function ai(a2, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a2);
  });
}
function ei(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a2) {
  var b2 = ih(a2, 1);
  null !== b2 && gi(b2, a2, 1, -1);
}
function hi(a2) {
  var b2 = Th();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ii.bind(null, M, a2);
  return [b2.memoizedState, a2];
}
function bi(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a2, b2, c2, d2) {
  var e2 = Th();
  M.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a2, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N$2) {
    var g2 = N$2.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a2, b2) {
  return ki(8390656, 8, a2, b2);
}
function $h(a2, b2) {
  return li(2048, 8, a2, b2);
}
function ni(a2, b2) {
  return li(4, 2, a2, b2);
}
function oi(a2, b2) {
  return li(4, 4, a2, b2);
}
function pi(a2, b2) {
  if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
    b2.current = null;
  };
}
function qi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return li(4, 4, pi.bind(null, b2, a2), c2);
}
function ri() {
}
function si(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ti(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function ui(a2, b2, c2) {
  if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh |= c2, a2.baseState = true);
  return b2;
}
function vi(a2, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a2, b2, c2) {
  var d2 = yi(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, c2);
  else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a2, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a2, b2, c2) {
  var d2 = yi(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = hh(a2, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a2, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a2) {
  var b2 = a2.alternate;
  return a2 === M || null !== b2 && b2 === M;
}
function Ai(a2, b2) {
  Jh = Ih = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Bi(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
  Th().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ki(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ki(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = xi.bind(null, M, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = Th();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
  return Th().memoizedState = a2;
}, useTransition: function() {
  var a2 = hi(false), b2 = a2[0];
  a2 = vi.bind(null, a2[1]);
  Th().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = M, e2 = Th();
  if (I) {
    if (void 0 === c2) throw Error(p$3(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q) throw Error(p$3(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a2) {
    var b2 = Uh();
    return ui(b2, N$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a2) {
  var b2 = Uh();
  return null === N$2 ? b2.memoizedState = a2 : ui(b2, N$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a2, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Di(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = R(), d2 = yi(a2), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a2, e2, d2);
  null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
} };
function Fi(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = {};
  kh(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function Ji(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Ki(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi$1 = d2);
    Li(a2, b2);
  };
  return c2;
}
function Qi(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a2, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Ui(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Vi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
}
function Yi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a2, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, d2, e2);
  return b2.child;
}
function $i(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
    a2 = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref) return Zi(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = Pg(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function bj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (dh = true);
    else return b2.lanes = a2.lanes, Zi(a2, b2, e2);
  }
  return cj(a2, b2, c2, d2, e2);
}
function dj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a2, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G(ej, fj);
    fj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a2, b2, e2, c2);
  return b2.child;
}
function gj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a2, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, c2, e2);
  return b2.child;
}
function hj(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a2, b2, c2, d2, f2, e2);
}
function jj(a2, b2, c2, d2, e2, f2) {
  gj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  yh(a2, b2.containerInfo);
}
function lj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a2, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function oj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
  G(L, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a2, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function sj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a2.child, null, c2);
  a2 = qj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function rj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$3(422))), sj(a2, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$3(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi(d2, a2, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$3(421)));
    return sj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a2.return, b2, c2);
}
function wj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a2, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
      if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
      else if (19 === a2.tag) vj(a2, c2, b2);
      else if (null !== a2.child) {
        a2.child.return = a2;
        a2 = a2.child;
        continue;
      }
      if (a2 === b2) break a;
      for (; null === a2.sibling; ) {
        if (null === a2.return || a2.return === b2) break a;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      a2 = a2.sibling;
    }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a2 = e2.alternate;
        if (null !== a2 && null === Ch(a2)) {
          b2.child = e2;
          break;
        }
        a2 = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a2;
      }
      wj(b2, true, c2, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a2 && b2.child !== a2.child) throw Error(p$3(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = Pg(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
        G(L, L.current & 1);
        a2 = Zi(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2) return xj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a2, b2, c2);
  }
  return Zi(a2, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A({}, e2, { value: void 0 });
        d2 = A({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a2, b2) {
  if (!I) switch (a2.tailMode) {
    case "hidden":
      b2 = a2.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a2.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a2.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
  }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Ej(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$3(166));
          S$1(b2);
          return null;
        }
        a2 = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a2
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          zj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a2);
                D("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a2
                );
                D("load", a2);
                e2 = d2;
                break;
              case "details":
                D("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A({}, d2, { value: void 0 });
                D("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$3(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2) switch (a2.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                break;
              case 5:
                true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$1(b2);
      return null;
    case 13:
      E(L);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2) throw Error(p$3(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$3(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return ah(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2) return S$1(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Dj(f2, false);
      else {
        if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
          g2 = Ch(a2);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
            G(L, L.current & 1 | 2);
            return b2.child;
          }
          a2 = a2.sibling;
        }
        null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a2 = Ch(g2), null !== a2) {
          if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S$1(b2), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
function Ij(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate) throw Error(p$3(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W(a2, b2, d2);
  }
  else c2.current = null;
}
function Mj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a2, b2, d2);
  }
}
var Nj = false;
function Oj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else a: {
      c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a2) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; ) if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V = a2;
  else for (; null !== V; ) {
    b2 = V;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$3(163));
      }
    } catch (F2) {
      W(b2, b2.return, F2);
    }
    a2 = b2.sibling;
    if (null !== a2) {
      a2.return = b2.return;
      V = a2;
      break;
    }
    V = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Sj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Sj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Tj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Uj(a2) {
  a: for (; ; ) {
    for (; null === a2.sibling; ) {
      if (null === a2.return || Tj(a2.return)) return null;
      a2 = a2.return;
    }
    a2.sibling.return = a2.return;
    for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
      if (a2.flags & 2) continue a;
      if (null === a2.child || 4 === a2.tag) continue a;
      else a2.child.return = a2, a2 = a2.child;
    }
    if (!(a2.flags & 2)) return a2.stateNode;
  }
}
function Vj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
}
var X = null, Xj = false;
function Yj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
}
function Zj(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X, e2 = Xj;
      X = null;
      Yj(a2, b2, c2);
      X = d2;
      Xj = e2;
      null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Xj;
      X = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a2, b2, c2);
      X = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a2, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W(c2, b2, h2);
      }
      Yj(a2, b2, c2);
      break;
    case 21:
      Yj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a2, b2, c2), U = d2) : Yj(a2, b2, c2);
      break;
    default:
      Yj(a2, b2, c2);
  }
}
function ak(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a2, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X) throw Error(p$3(160));
      Zj(f2, g2, e2);
      X = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
}
function dk(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        try {
          Pj(3, a2, a2.return), Qj(3, a2);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        try {
          Pj(5, a2, a2.return);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        if (null === a2.stateNode) throw Error(p$3(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W(a2, a2.return, t2);
      }
      break;
    case 4:
      ck(b2, a2);
      ek(a2);
      break;
    case 13:
      ck(b2, a2);
      ek(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a2), U = l2) : ck(b2, a2);
      ek(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V = a2, m2 = a2.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a2; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a2) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a2) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a2);
      ek(a2);
      d2 & 4 && ak(a2);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a2
      ), ek(a2);
  }
}
function ek(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a2);
          Wj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
          Vj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function hk(a2, b2, c2) {
  V = a2;
  ik(a2);
}
function ik(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2) for (V = e2; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a2);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a2);
  }
}
function kk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U || Qj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$3(163));
        }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function gk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a2) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function jk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi$1 = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a2) {
  if (0 === (a2.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a2 = C;
  if (0 !== a2) return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function gi(a2, b2, c2, d2) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$3(185));
  Ac(a2, c2, d2);
  if (0 === (K & 2) || a2 !== Q) a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
      0 === (K & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Gk(a2, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Hk() && a2.callbackNode !== c2) return null;
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Ik(a2, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a2 || Z !== b2) uk = null, Gj = B() + 500, Kk(a2, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a2, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Nk(a2, e2)));
    if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
    if (6 === b2) Ck(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Pk(a2, tk, uk);
          break;
        case 3:
          Ck(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0)) break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 4:
          Ck(a2, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 5:
          Pk(a2, tk, uk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  Dk(a2, B());
  return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
}
function Nk(a2, b2) {
  var c2 = sk;
  a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
  a2 = Ik(a2, b2);
  2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a2;
}
function Fj(a2) {
  null === tk ? tk = a2 : tk.push.apply(tk, a2);
}
function Ok(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a2, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a2) {
  if (0 !== (K & 6)) throw Error(p$3(327));
  Hk();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1)) return Dk(a2, B()), null;
  var c2 = Ik(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
  }
  if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B()), c2;
  if (6 === c2) throw Error(p$3(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Pk(a2, tk, uk);
  Dk(a2, B());
  return null;
}
function Qk(a2, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a2(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a2) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a2) return a2();
  } finally {
    C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y) for (c2 = Y.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H);
        Eh();
        break;
      case 5:
        Bh(d2);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d2.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q = a2;
  Y = a2 = Pg(a2.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    fh = null;
  }
  return a2;
}
function Mk(a2, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N$2 = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si$1(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si$1(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a2 = mk.current;
  mk.current = Rh;
  return null === a2 ? Rh : a2;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a2, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a2 || Z !== b2) uk = null, Kk(a2, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a2, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y) throw Error(p$3(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; ) Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); ) Uk(Y);
}
function Uk(a2) {
  var b2 = Vk(a2.alternate, a2, fj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Sk(a2) : Y = b2;
  nk.current = null;
}
function Sk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a2, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a2, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
function Wk(a2, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2) return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current) throw Error(p$3(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a2, c2);
    dk(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    hk(c2);
    dc();
    K = h2;
    C = g2;
    ok.transition = f2;
  } else a2.current = c2;
  vk && (vk = false, wk = a2, xk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a2, B());
  if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a2 = Pi$1, Pi$1 = null, a2;
  0 !== (xk & 1) && 0 !== a2.tag && Hk();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a2 = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a2 ? 16 : a2;
      if (null === wk) var d2 = false;
      else {
        a2 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$3(331));
        var e2 = K;
        K |= 4;
        for (V = a2.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V = x2;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a2.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
          else b: for (g2 = w2; null !== V; ) {
            h2 = V;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na) {
              W(h2, h2.return, na);
            }
            if (h2 === g2) {
              V = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V = F2;
              break b;
            }
            V = h2.return;
          }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a2);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a2, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a2, b2, 1);
  a2 = nh(a2, b2, 1);
  b2 = R();
  null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
}
function W(a2, b2, c2) {
  if (3 === a2.tag) Xk(a2, a2, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a2, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
        a2 = Ji(c2, a2);
        a2 = Qi(b2, a2, 1);
        b2 = nh(b2, a2, 1);
        a2 = R();
        null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
  Dk(a2, b2);
}
function Yk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a2 = ih(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
}
function uj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a2, c2);
}
function bk(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a2, c2);
}
var Vk;
Vk = function(a2, b2, c2) {
  if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
    dh = 0 !== (a2.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a2, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a2 = Ci(d2, a2);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a2, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a2) throw Error(p$3(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a2, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ji(Error(p$3(423)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ji(Error(p$3(424)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
          Xi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return oj(a2, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a2, b2, d2, e2, c2);
    case 7:
      return Xi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$3(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a2, b2, d2, e2, c2);
    case 15:
      return bj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a2, c2);
    case 19:
      return xj(a2, b2, c2);
    case 22:
      return dj(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
};
function Fk(a2, b2) {
  return ac(a2, b2);
}
function $k(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new $k(a2, b2, c2, d2);
}
function aj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function Zk(a2) {
  if ("function" === typeof a2) return aj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da) return 11;
    if (a2 === Ga) return 14;
  }
  return 2;
}
function Pg(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Rg(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2) aj(a2) && (g2 = 1);
  else if ("string" === typeof a2) g2 = 5;
  else a: switch (a2) {
    case ya:
      return Tg(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
    case Ea:
      return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
    case Fa:
      return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
    case Ia:
      return pj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$3(130, null == a2 ? a2 : typeof a2, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function pj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function Qg(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function Sg(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function al(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new al(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a2;
}
function cl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function dl(a2) {
  if (!a2) return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$3(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2)) return bg(a2, c2, b2);
  }
  return b2;
}
function el(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = bl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = dl(null);
  c2 = a2.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Dk(a2, d2);
  return a2;
}
function fl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = nh(e2, b2, g2);
  null !== a2 && (gi(a2, e2, g2, f2), oh(a2, e2, g2));
  return g2;
}
function gl(a2) {
  a2 = a2.current;
  if (!a2.child) return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function hl(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a2, b2) {
  hl(a2, b2);
  (a2 = a2.alternate) && hl(a2, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ll(a2) {
  this._internalRoot = a2;
}
ml.prototype.render = ll.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$3(409));
  fl(a2, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Rk(function() {
      fl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a2) {
  this._internalRoot = a2;
}
ml.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function nl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function pl() {
}
function ql(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = gl(g2);
        f2.call(a3);
      };
    }
    var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk();
    return g2;
  }
  for (; e2 = a2.lastChild; ) a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = gl(k2);
      h2.call(a3);
    };
  }
  var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = gl(g2);
        h2.call(a3);
      };
    }
    fl(b2, g2, a2, e2);
  } else g2 = ql(c2, b2, a2, e2, d2);
  return gl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a2, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a2, 1, c3);
        }
      }), il(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = ih(a2, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a2, 134217728, c2);
    }
    il(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = yi(a2), c2 = ih(a2, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a2, b2, d2);
    }
    il(a2, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a2, b2) {
  var c2 = C;
  try {
    return C = a2, b2();
  } finally {
    C = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$3(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a2) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$3(200));
  return cl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!nl(a2)) throw Error(p$3(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2) return null;
  if (1 === a2.nodeType) return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render) throw Error(p$3(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$3(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Rk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$3(200));
  return rl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!nl(a2)) throw Error(p$3(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$3(200));
  return rl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!ol(a2)) throw Error(p$3(40));
  return a2._reactRootContainer ? (Rk(function() {
    rl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!ol(c2)) throw Error(p$3(200));
  if (null == a2 || void 0 === a2._reactInternals) throw Error(p$3(38));
  return rl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs$1(reactDomExports);
var m$2 = reactDomExports;
{
  client.createRoot = m$2.createRoot;
  client.hydrateRoot = m$2.hydrateRoot;
}
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = reactExports.createContext({});
function useVisualElementContext() {
  return reactExports.useContext(MotionContext).visualElement;
}
const PresenceContext = reactExports.createContext(null);
const isBrowser$2 = typeof document !== "undefined";
const useIsomorphicLayoutEffect$2 = isBrowser$2 ? reactExports.useLayoutEffect : reactExports.useEffect;
const LazyContext = reactExports.createContext({ strict: false });
function useVisualElement(Component2, visualState, props, createVisualElement) {
  const parent2 = useVisualElementContext();
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component2, {
      visualState,
      parent: parent2,
      props,
      presenceId: presenceContext ? presenceContext.id : void 0,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  useIsomorphicLayoutEffect$2(() => {
    visualElement && visualElement.render();
  });
  const useAnimateChangesEffect = window.HandoffAppearAnimations ? useIsomorphicLayoutEffect$2 : reactExports.useEffect;
  useAnimateChangesEffect(() => {
    if (visualElement && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  return visualElement;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v3) {
  return typeof v3 === "string" || Array.isArray(v3);
}
function isAnimationControls(v3) {
  return typeof v3 === "object" && typeof v3.start === "function";
}
const variantProps$1 = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps$1.some((name2) => isVariantLabel(props[name2]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context2) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== false ? context2 : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const createDefinition = (propNames) => ({
  isEnabled: (props) => propNames.some((name2) => !!props[name2])
});
const featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features) {
  for (const key in features) {
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}
function useConstant(init2) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
let id$3 = 1;
function useProjectionId() {
  return useConstant(() => {
    if (globalProjectionState.hasEverUpdated) {
      return id$3++;
    }
  });
}
const LayoutGroupContext = reactExports.createContext({});
class VisualElementHandler extends React.Component {
  /**
   * Update visual element props as soon as we know this update is going to be commited.
   */
  getSnapshotBeforeUpdate() {
    const { visualElement, props } = this.props;
    if (visualElement)
      visualElement.setProps(props);
    return null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
const SwitchLayoutGroupContext = reactExports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component: Component2 }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    let features = null;
    const context2 = useCreateMotionContext(props);
    const projectionId = isStatic ? void 0 : useProjectionId();
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$2) {
      context2.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement);
      const lazyStrictMode = reactExports.useContext(LazyContext).strict;
      const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
      if (context2.visualElement) {
        features = context2.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          lazyStrictMode,
          preloadedFeatures,
          projectionId,
          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,
          initialLayoutGroupConfig
        );
      }
    }
    return reactExports.createElement(
      VisualElementHandler,
      { visualElement: context2.visualElement, props: configAndProps },
      features,
      reactExports.createElement(MotionContext.Provider, { value: context2 }, useRender(Component2, props, projectionId, useMotionRef(visualState, context2.visualElement, externalRef), visualState, isStatic, context2.visualElement))
    );
  }
  const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component2;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig2) {
  function custom2(Component2, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig2(Component2, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom2;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom2, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom2(key));
      }
      return componentCache.get(key);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component2) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component2)
  ) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key, { layout, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const sortTransformProps = (a2, b2) => transformPropOrder.indexOf(a2) - transformPropOrder.indexOf(b2);
function buildTransform({ transform, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  transformKeys2.sort(sortTransformProps);
  for (const key of transformKeys2) {
    transformString += `${translateAlias[key] || key}(${transform[key]}) `;
  }
  if (enableHardwareAcceleration && !transform.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function isCSSVariable$1(key) {
  return key.startsWith("--");
}
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp$3 = (min2, max2, v3) => Math.min(Math.max(v3, min2), max2);
const number$2 = {
  test: (v3) => typeof v3 === "number",
  parse: parseFloat,
  transform: (v3) => v3
};
const alpha = {
  ...number$2,
  transform: (v3) => clamp$3(0, 1, v3)
};
const scale = {
  ...number$2,
  default: 1
};
const sanitize = (v3) => Math.round(v3 * 1e5) / 1e5;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$1(v3) {
  return typeof v3 === "string";
}
const createUnitType = (unit) => ({
  test: (v3) => isString$1(v3) && v3.endsWith(unit) && v3.split(" ").length === 1,
  parse: parseFloat,
  transform: (v3) => `${v3}${unit}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v3) => percent.parse(v3) / 100,
  transform: (v3) => percent.transform(v3 * 100)
};
const int = {
  ...number$2,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style, vars: vars2, transform, transformKeys: transformKeys2, transformOrigin: transformOrigin2 } = state;
  transformKeys2.length = 0;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (isCSSVariable$1(key)) {
      vars2[key] = value;
      continue;
    }
    const valueType = numberValueTypes[key];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key)) {
      hasTransform2 = true;
      transform[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin2[key] = valueAsType;
    } else {
      style[key] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  htmlProps.style = style;
  return htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a2) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset2, size2) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset2);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component2), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component2, props, projectionId, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component2);
    const filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return reactExports.createElement(Component2, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars: vars2 }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars2) {
    element.style.setProperty(key, vars2[key]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom2, currentValues2 = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom2 !== void 0 ? custom2 : props.custom, currentValues2, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom2 !== void 0 ? custom2 : props.custom, currentValues2, currentVelocity);
  }
  return definition;
}
const isKeyframesTarget = (v3) => {
  return Array.isArray(v3);
};
const isCustomValue = (v3) => {
  return Boolean(v3 && typeof v3 === "object" && v3.mix && v3.toValue);
};
const resolveFinalValueInKeyframes = (v3) => {
  return isKeyframesTarget(v3) ? v3[v3.length - 1] || 0 : v3;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context2, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context2, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context2 = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config2, props, context2, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context2, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context2 && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context2.initial;
    if (animate2 === void 0)
      animate2 = context2.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list2.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values[key] = valueTarget;
        }
      }
      for (const key in transitionEnd)
        values[key] = transitionEnd[key];
    });
  }
  return values;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e2) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component2, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  const baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    projectionNodeConstructor,
    Component: Component2
  };
}
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function useDomEvent(ref, eventName, handler, options) {
  reactExports.useEffect(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
function useFocusGesture({ whileFocus, visualElement }) {
  const { animationState } = visualElement;
  const onFocus = reactExports.useCallback(() => {
    animationState && animationState.setActive(AnimationType.Focus, true);
  }, [animationState]);
  const onBlur = reactExports.useCallback(() => {
    animationState && animationState.setActive(AnimationType.Focus, false);
  }, [animationState]);
  useDomEvent(visualElement, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement, "blur", whileFocus ? onBlur : void 0);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, eventName, handler && addPointerInfo(handler), options);
}
function createLock(name2) {
  let lock2 = null;
  return () => {
    const openLock = () => {
      lock2 = null;
    };
    if (lock2 === null) {
      lock2 = name2;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock2 = false;
  if (drag2 === "y") {
    lock2 = globalVerticalLock();
  } else if (drag2 === "x") {
    lock2 = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock2 = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock2;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
function createHoverEvent(visualElement, isActive, applyVariants, callback) {
  return (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    if (applyVariants && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Hover, isActive);
    }
    callback && callback(event, info);
  };
}
function useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement }) {
  usePointerEvent(visualElement, "pointerenter", reactExports.useMemo(() => {
    return onHoverStart || whileHover ? createHoverEvent(visualElement, true, Boolean(whileHover), onHoverStart) : void 0;
  }, [onHoverStart, Boolean(whileHover), visualElement]), { passive: !onHoverStart });
  usePointerEvent(visualElement, "pointerleave", reactExports.useMemo(() => {
    return onHoverEnd || whileHover ? createHoverEvent(visualElement, false, Boolean(whileHover), onHoverEnd) : void 0;
  }, [onHoverStart, Boolean(whileHover), visualElement]), { passive: !onHoverEnd });
}
const isNodeOrChild = (parent2, child) => {
  if (!child) {
    return false;
  } else if (parent2 === child) {
    return true;
  } else {
    return isNodeOrChild(parent2, child.parentElement);
  }
};
function useUnmountEffect(callback) {
  return reactExports.useEffect(() => () => callback(), []);
}
const combineFunctions = (a2, b2) => (v3) => b2(a2(v3));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, ...props }) {
  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  const isPressing = reactExports.useRef(false);
  const cancelPointerEndListeners = reactExports.useRef(null);
  const eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || props["onPointerDown"])
  };
  function removePointerEndListener() {
    cancelPointerEndListeners.current && cancelPointerEndListeners.current();
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    removePointerEndListener();
    isPressing.current = false;
    const latestProps = visualElement.getProps();
    if (latestProps.whileTap && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Tap, false);
    }
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    var _a2, _b2, _c2, _d2;
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement.current, event.target) ? (_b2 = (_a2 = visualElement.getProps()).onTapCancel) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info) : (_d2 = (_c2 = visualElement.getProps()).onTap) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, event, info);
  }
  function onPointerCancel(event, info) {
    var _a2, _b2;
    if (!checkPointerEnd())
      return;
    (_b2 = (_a2 = visualElement.getProps()).onTapCancel) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info);
  }
  const startPress = reactExports.useCallback((event, info) => {
    var _a2;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    const latestProps = visualElement.getProps();
    if (latestProps.whileTap && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Tap, true);
    }
    (_a2 = latestProps.onTapStart) === null || _a2 === void 0 ? void 0 : _a2.call(latestProps, event, info);
  }, [Boolean(onTapStart), visualElement]);
  usePointerEvent(visualElement, "pointerdown", hasPressListeners ? startPress : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
function useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {
  const state = reactExports.useRef({
    hasEnteredView: false,
    isInView: false
  });
  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state.current.hasEnteredView)
    shouldObserve = false;
  const useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver$1;
  useObserver(shouldObserve, state.current, visualElement, viewport);
}
const thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver$1(shouldObserve, state, visualElement, { root: root2, margin: rootMargin, amount = "some", once }) {
  reactExports.useEffect(() => {
    if (!shouldObserve || !visualElement.current)
      return;
    const options = {
      root: root2 === null || root2 === void 0 ? void 0 : root2.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const intersectionCallback = (entry) => {
      const { isIntersecting } = entry;
      if (state.isInView === isIntersecting)
        return;
      state.isInView = isIntersecting;
      if (once && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      if (visualElement.animationState) {
        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);
      }
      const props = visualElement.getProps();
      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(visualElement.current, options, intersectionCallback);
  }, [shouldObserve, root2, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback: fallback2 = true }) {
  reactExports.useEffect(() => {
    if (!shouldObserve || !fallback2)
      return;
    requestAnimationFrame(() => {
      state.hasEnteredView = true;
      const { onViewportEnter } = visualElement.getProps();
      onViewportEnter && onViewportEnter(null);
      if (visualElement.animationState) {
        visualElement.animationState.setActive(AnimationType.InView, true);
      }
    });
  }, [shouldObserve]);
}
const makeRenderlessComponent = (hook) => (props) => {
  hook(props);
  return null;
};
const gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};
function usePresence$2() {
  const context2 = reactExports.useContext(PresenceContext);
  if (context2 === null)
    return [true, null];
  const { isPresent, onExitComplete, register: register2 } = context2;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => register2(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}
const isNumericalString = (v3) => /^\-?\d*\.?\d+$/.test(v3);
const isZeroValueString = (v3) => /^0[^.\s]+$/.test(v3);
const frameData = {
  delta: 0,
  timestamp: 0
};
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer2 = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer2.indexOf(callback) === -1) {
        buffer2.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
const flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frameData);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frameData);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frameData.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed), 1);
  frameData.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
function addUniqueItem(arr, item2) {
  if (arr.indexOf(item2) === -1)
    arr.push(item2);
}
function removeItem(arr, item2) {
  const index2 = arr.indexOf(item2);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a2, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init2, options = {}) {
    this.version = "8.5.5";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v3, render = true) => {
      this.prev = this.current;
      this.current = v3;
      const { delta, timestamp } = frameData;
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        sync.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => sync.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init2;
    this.canTrackVelocity = isFloat(this.current);
    this.owner = options.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        sync.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v3, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v3, render);
    } else {
      this.passiveEffect(v3, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = prev;
    this.timeDelta = delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v3) {
    this.updateAndNotify(v3);
    this.prev = v3;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve) || null;
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    this.animation = null;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
const isColorString = (type, testProp) => (v3) => {
  return Boolean(isString$1(v3) && singleColorRegex.test(v3) && v3.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v3, testProp));
};
const splitColor = (aName, bName, cName) => (v3) => {
  if (!isString$1(v3))
    return v3;
  const [a2, b2, c2, alpha2] = v3.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v3) => clamp$3(0, 255, v3);
const rgbUnit = {
  ...number$2,
  transform: (v3) => Math.round(clampRgbUnit(v3))
};
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v3) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v3.length > 5) {
    r2 = v3.substring(1, 3);
    g2 = v3.substring(3, 5);
    b2 = v3.substring(5, 7);
    a2 = v3.substring(7, 9);
  } else {
    r2 = v3.substring(1, 2);
    g2 = v3.substring(2, 3);
    b2 = v3.substring(3, 4);
    a2 = v3.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v3) => rgba.test(v3) || hex.test(v3) || hsla.test(v3),
  parse: (v3) => {
    if (rgba.test(v3)) {
      return rgba.parse(v3);
    } else if (hsla.test(v3)) {
      return hsla.parse(v3);
    } else {
      return hex.parse(v3);
    }
  },
  transform: (v3) => {
    return isString$1(v3) ? v3 : v3.hasOwnProperty("red") ? rgba.transform(v3) : hsla.transform(v3);
  }
};
const colorToken = "${c}";
const numberToken = "${n}";
function test(v3) {
  var _a2, _b2;
  return isNaN(v3) && isString$1(v3) && (((_a2 = v3.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) || 0) + (((_b2 = v3.match(colorRegex)) === null || _b2 === void 0 ? void 0 : _b2.length) || 0) > 0;
}
function analyseComplexValue(v3) {
  if (typeof v3 === "number")
    v3 = `${v3}`;
  const values = [];
  let numColors = 0;
  let numNumbers = 0;
  const colors2 = v3.match(colorRegex);
  if (colors2) {
    numColors = colors2.length;
    v3 = v3.replace(colorRegex, colorToken);
    values.push(...colors2.map(color.parse));
  }
  const numbers = v3.match(floatRegex);
  if (numbers) {
    numNumbers = numbers.length;
    v3 = v3.replace(floatRegex, numberToken);
    values.push(...numbers.map(number$2.parse));
  }
  return { values, numColors, numNumbers, tokenised: v3 };
}
function parse$3(v3) {
  return analyseComplexValue(v3).values;
}
function createTransformer(source) {
  const { values, numColors, tokenised } = analyseComplexValue(source);
  const numValues = values.length;
  return (v3) => {
    let output2 = tokenised;
    for (let i = 0; i < numValues; i++) {
      output2 = output2.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v3[i]) : sanitize(v3[i]));
    }
    return output2;
  };
}
const convertNumbersToZero = (v3) => typeof v3 === "number" ? 0 : v3;
function getAnimatableNone$1(v3) {
  const parsed = parse$3(v3);
  const transformer = createTransformer(v3);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = { test, parse: parse$3, createTransformer, getAnimatableNone: getAnimatableNone$1 };
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v3) {
  const [name2, value] = v3.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v3;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v3;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name2 + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = {
  ...complex,
  getAnimatableNone: (v3) => {
    const functions = v3.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v3;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  var _a2;
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a2 = defaultValueType.getAnimatableNone) === null || _a2 === void 0 ? void 0 : _a2.call(defaultValueType, value);
}
const testValueType = (v3) => (type) => type.test(v3);
const auto = {
  test: (v3) => v3 === "auto",
  parse: (v3) => v3
};
const dimensionValueTypes = [number$2, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v3) => dimensionValueTypes.find(testValueType(v3));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v3) => valueTypes.find(testValueType(v3));
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key) => current[key] = value.get());
  return current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom2) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom2 !== void 0 ? custom2 : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a2, _b2;
  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i = 0; i < numNewValues; i++) {
    const key = newValueKeys[i];
    const targetValue = target[key];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b2 = (_a2 = origin[key]) !== null && _a2 !== void 0 ? _a2 : visualElement.readValue(key)) !== null && _b2 !== void 0 ? _b2 : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement.addValue(key, motionValue(value, { owner: visualElement }));
    if (origin[key] === void 0) {
      origin[key] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  const valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement) {
  var _a2;
  const origin = {};
  for (const key in target) {
    const transitionOrigin = getOriginFromTransition(key, transition);
    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a2 = visualElement.getValue(key)) === null || _a2 === void 0 ? void 0 : _a2.get();
  }
  return origin;
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
var invariant = function() {
};
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const instantAnimationState = {
  current: false
};
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const easeIn = (p2) => p2 * p2;
const easeOut = reverseEasing(easeIn);
const easeInOut = mirrorEasing(easeIn);
const mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from, to, v3) => {
  const fromExpo = from * from;
  return Math.sqrt(Math.max(0, v3 * (to * to - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v3) => colorTypes.find((type) => type.test(v3));
function asRGBA(color2) {
  const type = getColorType(color2);
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v3) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v3);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v3);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v3);
    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v3);
    return rgba.transform(blended);
  };
};
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v3) => mix(origin, target, v3);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
const mixArray = (from, to) => {
  const output2 = [...from];
  const numValues = output2.length;
  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v3) => {
    for (let i = 0; i < numValues; i++) {
      output2[i] = blendValue[i](v3);
    }
    return output2;
  };
};
const mixObject = (origin, target) => {
  const output2 = { ...origin, ...target };
  const blendValue = {};
  for (const key in output2) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v3) => {
    for (const key in blendValue) {
      output2[key] = blendValue[key](v3);
    }
    return output2;
  };
};
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.values, targetStats.values), template);
  } else {
    return (p2) => `${p2 > 0 ? target : origin}`;
  }
};
const progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
const mixNumber = (from, to) => (p2) => mix(from, to, p2);
function detectMixerFactory(v3) {
  if (typeof v3 === "number") {
    return mixNumber;
  } else if (typeof v3 === "string") {
    if (color.test(v3)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v3)) {
    return mixArray;
  } else if (typeof v3 === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output2, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output2[0]);
  const numMixers = output2.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output2[i], output2[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input2, output2, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input2.length;
  invariant(inputLength === output2.length);
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1);
  if (input2[0] > input2[inputLength - 1]) {
    input2 = [...input2].reverse();
    output2 = [...output2].reverse();
  }
  const mixers = createMixers(output2, ease, mixer);
  const numMixers = mixers.length;
  const interpolator = (v3) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input2.length - 2; i++) {
        if (v3 < input2[i + 1])
          break;
      }
    }
    const progressInRange = progress(input2[i], input2[i + 1], v3);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v3) => interpolator(clamp$3(input2[0], input2[inputLength - 1], v3)) : interpolator;
}
const noop$3 = (any) => any;
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$3;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const easingLookup = {
  linear: noop$3,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0);
    return easingLookup[definition];
  }
  return definition;
};
const isEasingArray = (ease) => {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value2, i) => i !== 0 ? i / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o2) => o2 * duration);
}
function keyframes({ keyframes: keyframeValues, ease = easeInOut, times, duration = 300 }) {
  keyframeValues = [...keyframeValues];
  const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  function createInterpolator() {
    return interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state.value = interpolator(t2);
      state.done = t2 >= duration;
      return state;
    },
    flipTarget: () => {
      keyframeValues.reverse();
      interpolator = createInterpolator();
    }
  };
}
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$3(minDamping, maxDamping, dampingRatio);
  duration = clamp$3(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
const velocitySampleDuration = 5;
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  let origin = keyframes2[0];
  let target = keyframes2[keyframes2.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let initialVelocity = velocity ? -(velocity / 1e3) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  function createSpring() {
    const initialDelta = target - origin;
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
    restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t2 !== 0) {
          if (dampingRatio < 1) {
            const prevT = Math.max(0, t2 - velocitySampleDuration);
            currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t2 - prevT);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    flipTarget: () => {
      initialVelocity = -initialVelocity;
      [origin, target] = [target, origin];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a2, b2) => typeof a2 === "string" || typeof b2 === "string";
const zero = (_t) => 0;
function decay({
  /**
   * The decay animation dynamically calculates an end of the animation
   * based on the initial keyframe, so we only need to define a single keyframe
   * as default.
   */
  keyframes: keyframes2 = [0],
  velocity = 0,
  power = 0.8,
  timeConstant = 350,
  restDelta = 0.5,
  modifyTarget
}) {
  const origin = keyframes2[0];
  const state = { done: false, value: origin };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}
const types$1 = {
  decay,
  keyframes,
  tween: keyframes,
  spring
};
function loopElapsed(elapsed, duration, delay2 = 0) {
  return elapsed - duration - delay2;
}
function reverseElapsed(elapsed, duration = 0, delay2 = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;
}
function hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;
}
const framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => sync.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate$1({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, keyframes: keyframes$1, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type = "keyframes", ...options }) {
  var _a2, _b2;
  const initialElapsed = elapsed;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = duration;
  let isComplete2 = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = types$1[keyframes$1.length > 2 ? "keyframes" : type] || keyframes;
  const origin = keyframes$1[0];
  const target = keyframes$1[keyframes$1.length - 1];
  let state = { done: false, value: origin };
  if ((_b2 = (_a2 = animator).needsInterpolation) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, origin, target)) {
    interpolateFromNumber = interpolate([0, 100], [origin, target], {
      clamp: false
    });
    keyframes$1 = [0, 100];
  }
  const animation = animator({
    ...options,
    duration,
    keyframes: keyframes$1
  });
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete2 = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls && driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete2) {
      state = animation.next(Math.max(0, elapsed));
      if (interpolateFromNumber)
        state.value = interpolateFromNumber(state.value);
      isComplete2 = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate && onUpdate(state.value);
    if (isComplete2) {
      if (repeatCount === 0) {
        computedDuration = computedDuration !== void 0 ? computedDuration : elapsed;
      }
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay && onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop && onStop();
      driverControls && driverControls.stop();
    },
    /**
     * Set the current time of the animation. This is purposefully
     * mirroring the WAAPI animation API to make them interchanagable.
     * Going forward this file should be ported more towards
     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts
     * Which behaviourally adheres to WAAPI as far as possible.
     *
     * WARNING: This is not safe to use for most animations. We currently
     * only use it for handoff from WAAPI within Framer.
     *
     * This animation function consumes time every frame rather than being sampled for time.
     * So the sample() method performs some headless frames to ensure
     * repeats are handled correctly. Ideally in the future we will replace
     * that method with this, once repeat calculations are pure.
     */
    set currentTime(t2) {
      elapsed = initialElapsed;
      update(t2);
    },
    /**
     * animate() can't yet be sampled for time, instead it
     * consumes time. So to sample it we have to run a low
     * temporal-resolution version.
     */
    sample: (t2) => {
      elapsed = initialElapsed;
      const sampleResolution = duration && typeof duration === "number" ? Math.max(duration * 0.5, 50) : 50;
      let sampleElapsed = 0;
      update(0);
      while (sampleElapsed <= t2) {
        const remaining = t2 - sampleElapsed;
        update(Math.min(remaining, sampleResolution));
        sampleElapsed += sampleResolution;
      }
      return state;
    }
  };
}
function isWaapiSupportedEasing(easing) {
  return !easing || // Default easing
  Array.isArray(easing) || // Bezier curve
  typeof easing === "string" && supportedWaapiEasing[easing];
}
const cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return Array.isArray(easing) ? cubicBezierAsString(easing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease, times } = {}) {
  return element.animate({ [valueName]: keyframes2, offset: times }, {
    delay: delay2,
    duration,
    easing: mapEasingToNativeEasing(ease),
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
const featureTests = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
};
const results = {};
const supports = {};
for (const key in featureTests) {
  supports[key] = () => {
    if (results[key] === void 0)
      results[key] = featureTests[key]();
    return results[key];
  };
}
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index2];
}
const acceleratedValues = /* @__PURE__ */ new Set(["opacity"]);
const sampleDelta = 10;
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
  const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0;
  if (!canAccelerateAnimation)
    return false;
  let { keyframes: keyframes2, duration = 300, elapsed = 0, ease } = options;
  if (options.type === "spring" || !isWaapiSupportedEasing(options.ease)) {
    if (options.repeat === Infinity)
      return;
    const sampleAnimation = animate$1({ ...options, elapsed: 0 });
    let state = { done: false, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state.done && t2 < 2e4) {
      state = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state.value);
      t2 += sampleDelta;
    }
    keyframes2 = pregeneratedKeyframes;
    duration = t2 - sampleDelta;
    ease = "linear";
  }
  const animation = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    delay: -elapsed,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease
  });
  animation.onfinish = () => {
    value.set(getFinalKeyframe(keyframes2, options));
    sync.update(() => animation.cancel());
    onComplete && onComplete();
  };
  return {
    get currentTime() {
      return animation.currentTime || 0;
    },
    set currentTime(t2) {
      animation.currentTime = t2;
    },
    stop: () => {
      const { currentTime } = animation;
      if (currentTime) {
        const sampleAnimation = animate$1({ ...options, autoplay: false });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      sync.update(() => animation.cancel());
    }
  };
}
function delay$1(callback, timeout) {
  const start = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelSync.read(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  sync.read(checkElapsed, true);
  return () => cancelSync.read(checkElapsed);
}
function createInstantAnimation({ keyframes: keyframes2, elapsed, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes2[keyframes2.length - 1]);
    onComplete && onComplete();
  };
  return elapsed ? { stop: delay$1(setValue, -elapsed) } : setValue();
}
function inertia({ keyframes: keyframes2, velocity = 0, min: min2, max: max2, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  const origin = keyframes2[0];
  let currentAnimation;
  function isOutOfBounds(v3) {
    return min2 !== void 0 && v3 < min2 || max2 !== void 0 && v3 > max2;
  }
  function findNearestBoundary(v3) {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v3) < Math.abs(max2 - v3) ? min2 : max2;
  }
  function startAnimation(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate$1({
      keyframes: [0, 1],
      velocity: 0,
      ...options,
      driver,
      onUpdate: (v3) => {
        var _a2;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v3);
        (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v3);
      },
      onComplete,
      onStop
    });
  }
  function startSpring(options) {
    startAnimation({
      type: "spring",
      stiffness: bounceStiffness,
      damping: bounceDamping,
      restDelta,
      ...options
    });
  }
  if (isOutOfBounds(origin)) {
    startSpring({
      velocity,
      keyframes: [origin, findNearestBoundary(origin)]
    });
  } else {
    let target = power * velocity + origin;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = findNearestBoundary(target);
    const heading = boundary === min2 ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = (v3) => {
      prev = current;
      current = v3;
      velocity = velocityPerSecond(v3 - prev, frameData.delta);
      if (heading === 1 && v3 > boundary || heading === -1 && v3 < boundary) {
        startSpring({ keyframes: [v3, boundary], velocity });
      }
    };
    startAnimation({
      type: "decay",
      keyframes: [origin, 0],
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}
const underDampedSpring = () => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
});
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const linearTween = () => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else {
    const factory2 = defaultTransitions[valueKey] || defaultTransitions.default;
    return factory2(keyframes2[1]);
  }
};
const isAnimatable = (key, value) => {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone("", potentialUnitType);
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
function getKeyframes(value, valueName, target, transition) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let origin = transition.from !== void 0 ? transition.from : value.get();
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone(valueName, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  if (Array.isArray(target)) {
    if (target[0] === null) {
      target[0] = origin;
    }
    return target;
  } else {
    return [origin, target];
  }
}
const createMotionValueAnimation = (valueName, value, target, transition = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition, valueName) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const keyframes2 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes2[0];
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    let options = {
      keyframes: keyframes2,
      velocity: value.getVelocity(),
      ...valueTransition,
      elapsed,
      onUpdate: (v3) => {
        value.set(v3);
        valueTransition.onUpdate && valueTransition.onUpdate(v3);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(options);
    } else if (valueTransition.type === "inertia") {
      return inertia(options);
    }
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(valueName, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    const visualElement = value.owner;
    const element = visualElement && visualElement.current;
    if (visualElement && element instanceof HTMLElement && !(visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onUpdate)) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animate$1(options);
  };
};
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = animateTarget(visualElement, resolvedDefinition, options);
  }
  return animation.then(() => visualElement.notify("AnimationComplete", definition));
}
function animateVariant(visualElement, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(visualElement, variant, options.custom);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();
  const getChildAnimations = ((_a2 = visualElement.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.size) ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(last);
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a2;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && ((_a2 = visualElement.animationState) === null || _a2 === void 0 ? void 0 : _a2.getState()[type]);
  for (const key in target) {
    const value = visualElement.getValue(key);
    const valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = { delay: delay2, elapsed: 0, ...transition };
    if (window.HandoffAppearAnimations && !value.hasAnimated) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);
      }
    }
    let animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition));
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key);
      animation = animation.then(() => willChange.remove(key));
    }
    animations2.push(animation);
  }
  return Promise.all(animations2).then(() => {
    transitionEnd && setTarget(visualElement, transitionEnd);
  });
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
const variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(options, changedActiveType) {
    const props = visualElement.getProps();
    const context2 = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context2[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context2[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        removedKeys.delete(key);
        typeState.needsAnimating[key] = true;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a2;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach((child) => {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    [AnimationType.Animate]: createTypeState(true),
    [AnimationType.InView]: createTypeState(),
    [AnimationType.Hover]: createTypeState(),
    [AnimationType.Tap]: createTypeState(),
    [AnimationType.Drag]: createTypeState(),
    [AnimationType.Focus]: createTypeState(),
    [AnimationType.Exit]: createTypeState()
  };
}
const animations = {
  animation: makeRenderlessComponent(({ visualElement, animate: animate2 }) => {
    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));
    if (isAnimationControls(animate2)) {
      reactExports.useEffect(() => animate2.subscribe(visualElement), [animate2]);
    }
  }),
  exit: makeRenderlessComponent((props) => {
    const { custom: custom2, visualElement } = props;
    const [isPresent, safeToRemove] = usePresence$2();
    const presenceContext = reactExports.useContext(PresenceContext);
    reactExports.useEffect(() => {
      visualElement.isPresent = isPresent;
      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {
        custom: presenceContext && presenceContext.custom || custom2
      });
      if (animation && !isPresent) {
        animation.then(safeToRemove);
      }
    }, [isPresent]);
  })
};
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x);
  const yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      sync.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent2) {
  target.min = parent2.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent2) {
  calcRelativeAxis(target.x, relative.x, parent2.x);
  calcRelativeAxis(target.y, relative.y, parent2.y);
}
function calcRelativeAxisPosition(target, layout, parent2) {
  target.min = layout.min - parent2.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent2) {
  calcRelativeAxisPosition(target.x, layout.x, parent2.x);
  calcRelativeAxisPosition(target.y, layout.y, parent2.y);
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mix(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mix(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$3(0, 1, origin);
}
function rebaseAxisConstraints(layout, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  var _a2, _b2;
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    if (((_b2 = (_a2 = node.instance) === null || _a2 === void 0 ? void 0 : _a2.style) === null || _b2 === void 0 ? void 0 : _b2.display) === "contents")
      continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys$1);
  transformAxis(box.y, transform, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    if (this.visualElement.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      var _a2;
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        var _a3, _b2;
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const measuredAxis = (_b2 = (_a3 = this.visualElement.projection) === null || _a3 === void 0 ? void 0 : _a3.layout) === null || _b2 === void 0 ? void 0 : _b2.layoutBox[axis];
          if (measuredAxis) {
            const length = calcLength(measuredAxis);
            current = length * (parseFloat(current) / 100);
          }
        }
        this.originPoint[axis] = current;
      });
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
      (_a2 = this.visualElement.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Drag, true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  }
  cancel() {
    var _a2, _b2;
    this.isDragging = false;
    if (this.visualElement.projection) {
      this.visualElement.projection.isAnimationBlocked = false;
    }
    (_a2 = this.panSession) === null || _a2 === void 0 ? void 0 : _a2.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_b2 = this.visualElement.animationState) === null || _b2 === void 0 ? void 0 : _b2.setActive(AnimationType.Drag, false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = (constraints === null || constraints === void 0 ? void 0 : constraints[axis]) || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(createMotionValueAnimation(axis, axisValue, 0, transition));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    var _a2;
    const dragKey = "_drag" + axis.toUpperCase();
    const externalMotionValue = this.visualElement.getProps()[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, ((_a2 = this.visualElement.getProps().initial) === null || _a2 === void 0 ? void 0 : _a2[axis]) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mix(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    var _a2;
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mix(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    var _a2;
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
function useDrag(props) {
  const { dragControls: groupDragControls, visualElement } = props;
  const dragControls = useConstant(() => new VisualElementDragControls(visualElement));
  reactExports.useEffect(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);
  reactExports.useEffect(() => dragControls.addListeners(), [dragControls]);
}
function usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement }) {
  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  const panSession = reactExports.useRef(null);
  const { transformPagePoint } = reactExports.useContext(MotionConfigContext);
  const handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: (event, info) => {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  reactExports.useEffect(() => {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(() => panSession.current && panSession.current.end());
}
const drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};
function isCSSVariable(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback2] = match;
  return [token, fallback2];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback2] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable(fallback2)) {
    return getVariableValue(fallback2, element, depth + 1);
  } else {
    return fallback2;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariable(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key in target) {
    const current = target[key];
    if (!isCSSVariable(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd && transitionEnd[key] === void 0) {
      transitionEnd[key] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
const isPositionalKey = (key) => positionalKeys.has(key);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const isNumOrPxType = (v3) => v3 === number$2 || v3 === px;
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
const convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key) => {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    value && value.jump(origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (!visualElement.hasValue(key))
      return;
    let from = origin[key];
    let fromType = findDimensionValueType(from);
    const to = target[key];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = findDimensionValueType(from);
      for (let i = fromIndex; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
        } else {
          invariant(findDimensionValueType(to[i]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key, value]) => {
        visualElement.getValue(key).set(value);
      });
    }
    visualElement.render();
    if (isBrowser$2 && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser$2)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next, prev) {
  const { willChange } = next;
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  constructor({ parent: parent2, props, reducedMotionConfig, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.isPresent = true;
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => sync.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent2;
    this.props = props;
    this.depth = parent2 ? parent2.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent2 && parent2.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance) {
    var _a2;
    this.current = instance;
    if (this.projection) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.setProps(this.props);
  }
  unmount() {
    var _a2, _b2, _c2;
    (_a2 = this.projection) === null || _a2 === void 0 ? void 0 : _a2.unmount();
    cancelSync.update(this.notifyUpdate);
    cancelSync.render(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    (_b2 = this.removeFromVariantTree) === null || _b2 === void 0 ? void 0 : _b2.call(this);
    (_c2 = this.parent) === null || _c2 === void 0 ? void 0 : _c2.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && sync.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type)
      return 0;
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {
    const features = [];
    for (let i = 0; i < numFeatures; i++) {
      const name2 = featureNames[i];
      const { isEnabled: isEnabled2, Component: Component2 } = featureDefinitions[name2];
      if (isEnabled2(renderedProps) && Component2) {
        features.push(reactExports.createElement(Component2, {
          key: name2,
          ...renderedProps,
          visualElement: this
        }));
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout === "string" ? layout : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return features;
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  setProps(props) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    const prevProps = this.props;
    this.props = props;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listener = props["on" + key];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name2) {
    var _a2;
    return (_a2 = this.props.variants) === null || _a2 === void 0 ? void 0 : _a2[name2];
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    var _a2;
    return this.isVariantNode ? this : (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.getClosestVariantNode();
  }
  getVariantContext(startAtParent = false) {
    var _a2, _b2;
    if (startAtParent)
      return (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.getVariantContext();
    if (!this.isControllingVariants) {
      const context22 = ((_b2 = this.parent) === null || _b2 === void 0 ? void 0 : _b2.getVariantContext()) || {};
      if (this.props.initial !== void 0) {
        context22.initial = this.props.initial;
      }
      return context22;
    }
    const context2 = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name2 = variantProps[i];
      const prop = this.props[name2];
      if (isVariantLabel(prop) || prop === false) {
        context2[name2] = prop;
      }
    }
    return context2;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    var _a2;
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      (_a2 = closestVariantNode.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    if (value !== this.values.get(key)) {
      this.removeValue(key);
      this.bindToMotionValue(key, value);
    }
    this.values.set(key, value);
    this.latestValues[key] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    var _a2;
    this.values.delete(key);
    (_a2 = this.valueSubscriptions.get(key)) === null || _a2 === void 0 ? void 0 : _a2();
    this.valueSubscriptions.delete(key);
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key) {
    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a2;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a2 = resolveVariantFromProps(this.props, initial)) === null || _a2 === void 0 ? void 0 : _a2[key] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    var _a2;
    (_a2 = this.events[eventName]) === null || _a2 === void 0 ? void 0 : _a2.notify(...args);
  }
}
const variantProps = ["initial", ...variantPriorityOrder];
const numVariantProps = variantProps.length;
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    var _a2;
    return (_a2 = props.style) === null || _a2 === void 0 ? void 0 : _a2[key];
  }
  removeValueFromRenderState(key, { vars: vars2, style }) {
    delete vars2[key];
    delete style[key];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target
    };
  }
}
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$2(instance);
      const value = (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options, props) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    var _a2;
    if (transformProps.has(key)) {
      return ((_a2 = getDefaultValueType(key)) === null || _a2 === void 0 ? void 0 : _a2.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component2, options) => {
  return isSVGComponent(Component2) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node.target.x);
    const y2 = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y2}%`;
  }
};
const varToken = "_$css";
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const containsCSSVariables = latest.includes("var(");
    const cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, (match) => {
        cssVariables.push(match);
        return varToken;
      });
    }
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    let output2 = template(shadow);
    if (containsCSSVariables) {
      let i = 0;
      output2 = output2.replace(varToken, () => {
        const cssVariable = cssVariables[i];
        i++;
        return cssVariable;
      });
    }
    return output2;
  }
};
class MeasureLayoutWithContext extends React.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        sync.postRender(() => {
          var _a2;
          if (!((_a2 = projection.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length)) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      if (!projection.currentAnimation && projection.isLead()) {
        this.safeToRemove();
      }
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence$2();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return React.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const layoutFeatures = {
  measureLayout: MeasureLayout
};
function animate(from, to, transition = {}) {
  const value = isMotionValue(from) ? from : motionValue(from);
  value.start(createMotionValueAnimation("", value, to, transition));
  return {
    stop: () => value.stop(),
    isAnimating: () => value.isAnimating()
  };
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop$3);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(progress(min2, max2, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    var _a2;
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if ((_a2 = node.root) === null || _a2 === void 0 ? void 0 : _a2.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      var _a2, _b2, _c2, _d2, _e2;
      (_b2 = (_a2 = node.options).onExitComplete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      (_e2 = (_c2 = node.resumingFrom) === null || _c2 === void 0 ? void 0 : (_d2 = _c2.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d2);
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id$2 = 0;
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(elementId, latestValues = {}, parent2 = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id$2++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isTransformDirty = false;
      this.isProjectionDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.potentialNodes = /* @__PURE__ */ new Map();
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.elementId = elementId;
      this.latestValues = latestValues;
      this.root = parent2 ? parent2.root || parent2 : this;
      this.path = parent2 ? [...parent2.path, parent2] : [];
      this.parent = parent2;
      this.depth = parent2 ? parent2.depth + 1 : 0;
      elementId && this.root.registerPotentialNode(elementId, this);
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name2, handler) {
      if (!this.eventHandlers.has(name2)) {
        this.eventHandlers.set(name2, new SubscriptionManager());
      }
      return this.eventHandlers.get(name2).add(handler);
    }
    notifyListeners(name2, ...args) {
      const subscriptionManager = this.eventHandlers.get(name2);
      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);
    }
    hasListeners(name2) {
      return this.eventHandlers.has(name2);
    }
    registerPotentialNode(elementId, node) {
      this.potentialNodes.set(elementId, node);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = false) {
      var _a2;
      if (this.instance)
        return;
      this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
      this.instance = instance;
      const { layoutId, layout, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.children.add(this);
      this.elementId && this.root.potentialNodes.delete(this.elementId);
      if (isLayoutDirty && (layout || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay$1(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          var _a3, _b2, _c2, _d2, _e2;
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = (_b2 = (_a3 = this.options.transition) !== null && _a3 !== void 0 ? _a3 : visualElement.getDefaultTransition()) !== null && _b2 !== void 0 ? _b2 : defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || ((_c2 = this.resumeFrom) === null || _c2 === void 0 ? void 0 : _c2.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged && this.animationProgress === 0) {
              finishAnimation(this);
            }
            this.isLead() && ((_e2 = (_d2 = this.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d2));
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      var _a2, _b2;
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.remove(this);
      (_b2 = this.parent) === null || _b2 === void 0 ? void 0 : _b2.children.delete(this);
      this.instance = void 0;
      cancelSync.preRender(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var _a2;
      return this.isAnimationBlocked || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimationBlocked()) || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      var _a2;
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      (_a2 = this.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      var _a2;
      return (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      var _a2, _b2, _c2;
      if (this.root.isUpdateBlocked()) {
        (_b2 = (_a2 = this.options).onExitComplete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout } = this.options;
      if (layoutId === void 0 && !layout)
        return;
      this.prevTransformTemplateValue = (_c2 = this.getTransformTemplate()) === null || _c2 === void 0 ? void 0 : _c2(this.latestValues, "");
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    // Note: Currently only running on root node
    didUpdate() {
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating)
        return;
      this.isUpdating = false;
      if (this.potentialNodes.size) {
        this.potentialNodes.forEach(mountNodeEarly);
        this.potentialNodes.clear();
      }
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      flushSync.update();
      flushSync.preRender();
      flushSync.render();
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      sync.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      sync.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      var _a2;
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.notify("LayoutMeasure", this.layout.layoutBox, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.layoutBox);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      var _a2;
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplateValue = (_a2 = this.getTransformTemplate()) === null || _a2 === void 0 ? void 0 : _a2(this.latestValues, "");
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll: scroll2 } = this.root;
      if (scroll2) {
        translateAxis(box.x, scroll2.offset.x);
        translateAxis(box.y, scroll2.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll: scroll2, options } = node;
        if (node !== this.root && scroll2 && options.layoutScroll) {
          if (scroll2.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      var _a2;
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a2 = node.snapshot) === null || _a2 === void 0 ? void 0 : _a2.layoutBox, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    /**
     *
     */
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.isProjectionDirty = true;
      this.root.scheduleUpdateProjection();
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    /**
     * Frame calculations
     */
    resolveTargetDelta() {
      var _a2;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      if (!this.isProjectionDirty && !this.attemptToResolveRelativeTarget)
        return;
      const { layout, layoutId } = this.options;
      if (!this.layout || !(layout || layoutId))
        return;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout) {
          this.relativeParent = relativeParent;
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.target)) {
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target) {
          this.relativeParent = relativeParent;
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if ((this.parent.relativeTarget || this.parent.targetDelta || this.parent.options.layoutRoot) && this.parent.layout) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    calcProjection() {
      var _a2;
      const { isProjectionDirty, isTransformDirty } = this;
      this.isProjectionDirty = this.isTransformDirty = false;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (isProjectionDirty)
        canSkip = false;
      if (isShared && isTransformDirty)
        canSkip = false;
      if (canSkip)
        return;
      const { layout, layoutId } = this.options;
      this.isTreeAnimating = Boolean(((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      const { target } = lead;
      if (!target)
        return;
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a2, _b2, _c2;
      (_b2 = (_a2 = this.options).scheduleRender) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      notifyAll && ((_c2 = this.getStack()) === null || _c2 === void 0 ? void 0 : _c2.scheduleRender());
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      var _a2, _b2;
      const snapshot = this.snapshot;
      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const isSharedLayoutAnimation = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.source) !== ((_a2 = this.layout) === null || _a2 === void 0 ? void 0 : _a2.source);
      const isOnlyMember = (((_b2 = this.getStack()) === null || _b2 === void 0 ? void 0 : _b2.members.length) || 0) <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      this.mixTargetDelta = (latest) => {
        var _a3;
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a3 = this.relativeParent) === null || _a3 === void 0 ? void 0 : _a3.layout)) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      var _a2, _b2;
      this.notifyListeners("animationStart");
      (_a2 = this.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      if (this.resumingFrom) {
        (_b2 = this.resumingFrom.currentAnimation) === null || _b2 === void 0 ? void 0 : _b2.stop();
      }
      if (this.pendingAnimation) {
        cancelSync.update(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = sync.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animate(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            var _a3;
            this.mixTargetDelta(latest);
            (_a3 = options.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(options, latest);
          },
          onComplete: () => {
            var _a3;
            (_a3 = options.onComplete) === null || _a3 === void 0 ? void 0 : _a3.call(options);
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var _a2;
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var _a2;
      if (this.currentAnimation) {
        (_a2 = this.mixTargetDelta) === null || _a2 === void 0 ? void 0 : _a2.call(this, animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout)
        return;
      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      var _a2, _b2, _c2;
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      node.promote({
        transition: (_a2 = node.options.initialPromotionConfig) === null || _a2 === void 0 ? void 0 : _a2.transition,
        preserveFollowOpacity: (_c2 = (_b2 = node.options.initialPromotionConfig) === null || _b2 === void 0 ? void 0 : _b2.shouldPreserveFollowOpacity) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, node)
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i = 0; i < transformAxes.length; i++) {
        const key = "rotate" + transformAxes[i];
        if (latestValues[key]) {
          resetValues[key] = latestValues[key];
          visualElement.setStaticValue(key, 0);
        }
      }
      visualElement === null || visualElement === void 0 ? void 0 : visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a2, _b2;
      const styles = {};
      if (!this.instance || this.isSVG)
        return styles;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles.visibility = "";
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b2 = (_a2 = valuesToRender.opacity) !== null && _a2 !== void 0 ? _a2 : this.latestValues.opacity) !== null && _b2 !== void 0 ? _b2 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a2;
        return (_a2 = node.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a2, _b2, _c2;
  const snapshot = ((_a2 = node.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_c2 = (_b2 = node.options).onExitComplete) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  node.isProjectionDirty || (node.isProjectionDirty = Boolean(node.parent && node.parent.isProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = Boolean(node.parent && node.parent.isTransformDirty));
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output2, delta, p2) {
  output2.translate = mix(delta.translate, 0, p2);
  output2.scale = mix(delta.scale, 1, p2);
  output2.origin = delta.origin;
  output2.originPoint = delta.originPoint;
}
function mixAxis(output2, from, to, p2) {
  output2.min = mix(from.min, to.min, p2);
  output2.max = mix(from.max, to.max, p2);
}
function mixBox(output2, from, to, p2) {
  mixAxis(output2.x, from.x, to.x, p2);
  mixAxis(output2.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, elementId) {
  let searchNode = node.root;
  for (let i = node.path.length - 1; i >= 0; i--) {
    if (Boolean(node.path[i].instance)) {
      searchNode = node.path[i];
      break;
    }
  }
  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  const element = searchElement.querySelector(`[data-projection-id="${elementId}"]`);
  if (element)
    node.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutFeatures
};
const motion = /* @__PURE__ */ createMotionProxy((Component2, config2) => createDomMotionConfig(Component2, config2, featureBundle, createDomVisualElement, HTMLProjectionNode));
function useIsMounted() {
  const isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = reactExports.useState(0);
  const forceRender = reactExports.useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = reactExports.useCallback(() => sync.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size2 = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  reactExports.useInsertionEffect(() => {
    const { width, height, top, left } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return reactExports.createElement(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2 }, reactExports.cloneElement(children, { ref }));
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom: custom2, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const context2 = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom: custom2,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete2 of presenceChildren.values()) {
          if (!isComplete2)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = reactExports.createElement(PopChild, { isPresent }, children);
  }
  return reactExports.createElement(PresenceContext.Provider, { value: context2 }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
const getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom: custom2, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
  if (exitBeforeEnter) {
    mode = "wait";
  }
  let [forceRender] = useForceUpdate();
  const forceRenderLayoutGroup = reactExports.useContext(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exiting = /* @__PURE__ */ new Set();
  const presentChildren = reactExports.useRef(childrenToRender);
  const allChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = reactExports.useRef(true);
  useIsomorphicLayoutEffect$2(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return reactExports.createElement(reactExports.Fragment, null, childrenToRender.map((child) => reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key = presentKeys[i];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    }
  }
  if (mode === "wait" && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach((key) => {
    if (targetKeys.indexOf(key) !== -1)
      return;
    const child = allChildren.get(key);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key);
    const onExit = () => {
      allChildren.delete(key);
      exiting.delete(key);
      const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false)
          return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom2, presenceAffectsLayout, mode }, child));
  });
  childrenToRender = childrenToRender.map((child) => {
    const key = child.key;
    return exiting.has(key) ? child : reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);
  });
  return reactExports.createElement(reactExports.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map((child) => reactExports.cloneElement(child)));
};
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
function __rest$1(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p2 in contextIn) context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f2, name2, prefix) {
  if (typeof name2 === "symbol") name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$1(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v3) {
      return step([n2, v3]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o2[k22] = m2[k2];
};
function __exportStar(m2, o2) {
  for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2)) __createBinding(o2, m2, p2);
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i >= o2.length) o2 = void 0;
      return { value: o2 && o2[i++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i = 0, il2 = arguments.length; i < il2; i++) s2 += arguments[i].length;
  for (var r2 = Array(s2), k2 = 0, i = 0; i < il2; i++)
    for (var a2 = arguments[i], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray$1(to, from, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v3) {
  return this instanceof __await ? (this.v = v3, this) : new __await(v3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f2) {
    return function(v3) {
      return Promise.resolve(v3).then(f2, reject);
    };
  }
  function verb(n2, f2) {
    if (g2[n2]) {
      i[n2] = function(v3) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v3, a2, b2]) > 1 || resume(n2, v3);
        });
      };
      if (f2) i[n2] = f2(i[n2]);
    }
  }
  function resume(n2, v3) {
    try {
      step(g2[n2](v3));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v3) {
    if (f2(v3), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v3) {
      return (p2 = !p2) ? { value: __await(o2[n2](v3)), done: false } : f2 ? f2(v3) : v3;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o2[n2](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d2, v3) {
    Promise.resolve(v3).then(function(v5) {
      resolve({ value: v5, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function(o2, v3) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
} : function(o2, v3) {
  o2["default"] = v3;
};
function __importStar(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding(result, mod2, k2);
  }
  __setModuleDefault(result, mod2);
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet$4(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet$3(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function __disposeResources(env) {
  function fail(e2) {
    env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;
    env.hasError = true;
  }
  var r2, s2 = 0;
  function next() {
    while (r2 = env.stack.pop()) {
      try {
        if (!r2.async && s2 === 1) return s2 = 0, env.stack.push(r2), Promise.resolve().then(next);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s2 |= 2, Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
        } else s2 |= 1;
      } catch (e2) {
        fail(e2);
      }
    }
    if (s2 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
const tslib_es6 = {
  __extends,
  __assign: __assign$2,
  __rest: __rest$1,
  __decorate,
  __param,
  __metadata,
  __awaiter: __awaiter$1,
  __generator: __generator$1,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray: __spreadArray$1,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet: __classPrivateFieldGet$4,
  __classPrivateFieldSet: __classPrivateFieldSet$3,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign$2;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter: __awaiter$1,
  __classPrivateFieldGet: __classPrivateFieldGet$4,
  __classPrivateFieldIn,
  __classPrivateFieldSet: __classPrivateFieldSet$3,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator: __generator$1,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest: __rest$1,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray: __spreadArray$1,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const defaultColors = {
  black: "#000000",
  white: "#ffffff",
  inherit: "inherit",
  transparent: "transparent",
  positive: "#1FC266",
  negative: "#C2501F",
  info: "#0076CC",
  warning: "#F4B03E",
  gradientBackdrop: `linear-gradient(
    243.18deg, 
    rgba(86, 52, 189, 0.85) 0%, 
    rgba(49, 41, 223, 0.85) 63.54%, 
    rgba(7, 98, 149, 0.85) 100%
  )`,
  gradientPrimary: `linear-gradient(89.69deg, #4411E1 0.27%, #7537F9 99.73%)`,
  gradientSecondary: `linear-gradient(32.51deg, #951990 -15.23%, #3A35B1 48.55%, #20A8B0 100%)`,
  arbitrumDark: "#212D44",
  arbitrumLight: "#93D4FF",
  avalanceDark: "#810C0C",
  avalanceLight: "#FF8080",
  bscDark: "#584508",
  bscLight: "#FCCF43",
  ethereumDark: "#132362",
  ethereumLight: "#AABBFF",
  gnosisDark: "#084246",
  gnosisLight: "#8CF6FD",
  polygonDark: "#350881",
  polygonLight: "#C7A6FF"
};
const dark = {
  ...defaultColors,
  text100: "rgba(255, 255, 255, 1)",
  text80: "rgba(255, 255, 255, 0.8)",
  text50: "rgba(255, 255, 255, 0.5)",
  textInverse100: "rgba(0, 0, 0, 1)",
  backgroundPrimary: "rgba(0, 0, 0, 1)",
  backgroundSecondary: "rgba(255, 255, 255, 0.1)",
  backgroundContrast: "rgba(0, 0, 0, 0.5)",
  backgroundMuted: "rgba(255, 255, 255, 0.05)",
  backgroundControl: "rgba(255, 255, 255, 0.25)",
  backgroundInverse: "rgba(255, 255, 255, 1)",
  backgroundBackdrop: "rgba(34, 34, 34, 0.9)",
  backgroundOverlay: "rgba(0, 0, 0, 0.7)",
  backgroundRaised: "rgba(54, 54, 54, 0.7)",
  buttonGlass: "rgba(255, 255, 255, 0.15)",
  buttonEmphasis: "rgba(0, 0, 0, 0.5)",
  buttonInverse: "rgba(255, 255, 255, 0.8)",
  borderNormal: "rgba(255, 255, 255, 0.25)",
  borderFocus: "rgba(255, 255, 255, 0.5)"
};
const light = {
  ...defaultColors,
  text100: "rgba(0, 0, 0, 1)",
  text80: "rgba(0, 0, 0, 0.8)",
  text50: "rgba(0, 0, 0, 0.5)",
  textInverse100: "rgba(255, 255, 255, 1)",
  backgroundPrimary: "rgba(244, 244, 244, 1)",
  backgroundSecondary: "rgba(0, 0, 0, 0.1)",
  backgroundContrast: "rgba(244, 244, 244, 0.5)",
  backgroundMuted: "rgba(0, 0, 0, 0.05)",
  backgroundControl: "rgba(0, 0, 0, 0.25)",
  backgroundInverse: "rgba(0, 0, 0, 1)",
  backgroundBackdrop: "rgba(221, 221, 221, 0.9)",
  backgroundOverlay: "rgba(244, 244, 244, 0.7)",
  backgroundRaised: "rgba(192, 192, 192, 0.7)",
  buttonGlass: "rgba(0, 0, 0, 0.15)",
  buttonEmphasis: "rgba(255, 255, 255, 0.5)",
  buttonInverse: "rgba(0, 0, 0, 0.8)",
  borderNormal: "rgba(0, 0, 0, 0.25)",
  borderFocus: "rgba(0, 0, 0, 0.5)"
};
const colors = {
  dark,
  light
};
const text = {
  inherit: {
    fontFamily: "inherit",
    fontSize: "inherit",
    lineHeight: "inherit",
    letterSpacing: "inherit",
    fontWeight: "inherit"
  },
  xlarge: {
    fontFamily: "body",
    fontSize: "xlarge",
    lineHeight: "9",
    letterSpacing: "none",
    fontWeight: "bold"
  },
  large: {
    fontFamily: "body",
    fontSize: "large",
    lineHeight: "7",
    letterSpacing: "normal",
    fontWeight: "semibold"
  },
  medium: {
    fontFamily: "body",
    fontSize: "medium",
    lineHeight: "6",
    letterSpacing: "normal",
    fontWeight: "bold"
  },
  normal: {
    fontFamily: "body",
    fontSize: "normal",
    lineHeight: "5",
    letterSpacing: "wide",
    fontWeight: "normal"
  },
  small: {
    fontFamily: "body",
    fontSize: "small",
    lineHeight: "4",
    letterSpacing: "wide",
    fontWeight: "medium"
  },
  xsmall: {
    fontFamily: "body",
    fontSize: "xsmall",
    lineHeight: "4",
    letterSpacing: "wide",
    fontWeight: "bold"
  },
  code: {
    fontFamily: "mono",
    fontSize: "normal",
    lineHeight: "5",
    letterSpacing: "none",
    fontWeight: "normal"
  }
};
const breakpoints = {
  sm: 0,
  md: 480,
  lg: 769,
  xl: 1281
};
var colorSchemeVars = { colors: { black: "var(--seq-colors-black)", white: "var(--seq-colors-white)", inherit: "var(--seq-colors-inherit)", transparent: "var(--seq-colors-transparent)", positive: "var(--seq-colors-positive)", negative: "var(--seq-colors-negative)", info: "var(--seq-colors-info)", warning: "var(--seq-colors-warning)", gradientBackdrop: "var(--seq-colors-gradient-backdrop)", gradientPrimary: "var(--seq-colors-gradient-primary)", gradientSecondary: "var(--seq-colors-gradient-secondary)", arbitrumDark: "var(--seq-colors-arbitrum-dark)", arbitrumLight: "var(--seq-colors-arbitrum-light)", avalanceDark: "var(--seq-colors-avalance-dark)", avalanceLight: "var(--seq-colors-avalance-light)", bscDark: "var(--seq-colors-bsc-dark)", bscLight: "var(--seq-colors-bsc-light)", ethereumDark: "var(--seq-colors-ethereum-dark)", ethereumLight: "var(--seq-colors-ethereum-light)", gnosisDark: "var(--seq-colors-gnosis-dark)", gnosisLight: "var(--seq-colors-gnosis-light)", polygonDark: "var(--seq-colors-polygon-dark)", polygonLight: "var(--seq-colors-polygon-light)", text100: "var(--seq-colors-text100)", text80: "var(--seq-colors-text80)", text50: "var(--seq-colors-text50)", textInverse100: "var(--seq-colors-text-inverse100)", backgroundPrimary: "var(--seq-colors-background-primary)", backgroundSecondary: "var(--seq-colors-background-secondary)", backgroundContrast: "var(--seq-colors-background-contrast)", backgroundMuted: "var(--seq-colors-background-muted)", backgroundControl: "var(--seq-colors-background-control)", backgroundInverse: "var(--seq-colors-background-inverse)", backgroundBackdrop: "var(--seq-colors-background-backdrop)", backgroundOverlay: "var(--seq-colors-background-overlay)", backgroundRaised: "var(--seq-colors-background-raised)", buttonGlass: "var(--seq-colors-button-glass)", buttonEmphasis: "var(--seq-colors-button-emphasis)", buttonInverse: "var(--seq-colors-button-inverse)", borderNormal: "var(--seq-colors-border-normal)", borderFocus: "var(--seq-colors-border-focus)" } };
var vars = { blur: { blur: "var(--seq-blur-blur)", none: "var(--seq-blur-none)" }, borderWidths: { none: "var(--seq-border-widths-none)", thin: "var(--seq-border-widths-thin)", thick: "var(--seq-border-widths-thick)" }, fonts: { inherit: "var(--seq-fonts-inherit)", body: "var(--seq-fonts-body)", mono: "var(--seq-fonts-mono)" }, fontSizes: { inherit: "var(--seq-font-sizes-inherit)", xsmall: "var(--seq-font-sizes-xsmall)", small: "var(--seq-font-sizes-small)", normal: "var(--seq-font-sizes-normal)", medium: "var(--seq-font-sizes-medium)", large: "var(--seq-font-sizes-large)", xlarge: "var(--seq-font-sizes-xlarge)" }, fontWeights: { inherit: "var(--seq-font-weights-inherit)", normal: "var(--seq-font-weights-normal)", medium: "var(--seq-font-weights-medium)", semibold: "var(--seq-font-weights-semibold)", bold: "var(--seq-font-weights-bold)" }, letterSpacings: { inherit: "var(--seq-letter-spacings-inherit)", none: "var(--seq-letter-spacings-none)", normal: "var(--seq-letter-spacings-normal)", wide: "var(--seq-letter-spacings-wide)" }, lineHeights: { "4": "var(--seq-line-heights-4)", "5": "var(--seq-line-heights-5)", "6": "var(--seq-line-heights-6)", "7": "var(--seq-line-heights-7)", "9": "var(--seq-line-heights-9)", inherit: "var(--seq-line-heights-inherit)" }, opacity: { "0": "var(--seq-opacity-0)", "50": "var(--seq-opacity-50)", "80": "var(--seq-opacity-80)", "100": "var(--seq-opacity-100)" }, radii: { none: "var(--seq-radii-none)", xs: "var(--seq-radii-xs)", sm: "var(--seq-radii-sm)", md: "var(--seq-radii-md)", lg: "var(--seq-radii-lg)", circle: "var(--seq-radii-circle)" }, space: { "0": "var(--seq-space-0)", "1": "var(--seq-space-1)", "2": "var(--seq-space-2)", "3": "var(--seq-space-3)", "4": "var(--seq-space-4)", "5": "var(--seq-space-5)", "6": "var(--seq-space-6)", "7": "var(--seq-space-7)", "8": "var(--seq-space-8)", "9": "var(--seq-space-9)", "10": "var(--seq-space-10)", "12": "var(--seq-space-12)", "14": "var(--seq-space-14)", "16": "var(--seq-space-16)", "18": "var(--seq-space-18)", "20": "var(--seq-space-20)", "0.25": "var(--seq-space-0_25)", "0.5": "var(--seq-space-0_5)", "1.5": "var(--seq-space-1_5)" }, zIndex: { "0": "var(--seq-z-index-0)", "1": "var(--seq-z-index-1)", "10": "var(--seq-z-index-10)", "20": "var(--seq-z-index-20)", "30": "var(--seq-z-index-30)", "40": "var(--seq-z-index-40)", "50": "var(--seq-z-index-50)", "-1": "var(--seq-z-index--1)", auto: "var(--seq-z-index-auto)" }, colors: { black: "var(--seq-colors-black)", white: "var(--seq-colors-white)", inherit: "var(--seq-colors-inherit)", transparent: "var(--seq-colors-transparent)", positive: "var(--seq-colors-positive)", negative: "var(--seq-colors-negative)", info: "var(--seq-colors-info)", warning: "var(--seq-colors-warning)", gradientBackdrop: "var(--seq-colors-gradient-backdrop)", gradientPrimary: "var(--seq-colors-gradient-primary)", gradientSecondary: "var(--seq-colors-gradient-secondary)", arbitrumDark: "var(--seq-colors-arbitrum-dark)", arbitrumLight: "var(--seq-colors-arbitrum-light)", avalanceDark: "var(--seq-colors-avalance-dark)", avalanceLight: "var(--seq-colors-avalance-light)", bscDark: "var(--seq-colors-bsc-dark)", bscLight: "var(--seq-colors-bsc-light)", ethereumDark: "var(--seq-colors-ethereum-dark)", ethereumLight: "var(--seq-colors-ethereum-light)", gnosisDark: "var(--seq-colors-gnosis-dark)", gnosisLight: "var(--seq-colors-gnosis-light)", polygonDark: "var(--seq-colors-polygon-dark)", polygonLight: "var(--seq-colors-polygon-light)", text100: "var(--seq-colors-text100)", text80: "var(--seq-colors-text80)", text50: "var(--seq-colors-text50)", textInverse100: "var(--seq-colors-text-inverse100)", backgroundPrimary: "var(--seq-colors-background-primary)", backgroundSecondary: "var(--seq-colors-background-secondary)", backgroundContrast: "var(--seq-colors-background-contrast)", backgroundMuted: "var(--seq-colors-background-muted)", backgroundControl: "var(--seq-colors-background-control)", backgroundInverse: "var(--seq-colors-background-inverse)", backgroundBackdrop: "var(--seq-colors-background-backdrop)", backgroundOverlay: "var(--seq-colors-background-overlay)", backgroundRaised: "var(--seq-colors-background-raised)", buttonGlass: "var(--seq-colors-button-glass)", buttonEmphasis: "var(--seq-colors-button-emphasis)", buttonInverse: "var(--seq-colors-button-inverse)", borderNormal: "var(--seq-colors-border-normal)", borderFocus: "var(--seq-colors-border-focus)" } };
function toPrimitive$1(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey$1(t2) {
  var i = toPrimitive$1(t2, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty$1$1(obj, key, value) {
  key = toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$1$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var createSprinkles$1 = (composeStyles2) => function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var sprinklesStyles = Object.assign({}, ...args.map((a2) => a2.styles));
  var sprinklesKeys = Object.keys(sprinklesStyles);
  var shorthandNames = sprinklesKeys.filter((property) => "mappings" in sprinklesStyles[property]);
  var sprinklesFn = (props) => {
    var classNames = [];
    var shorthands = {};
    var nonShorthands = _objectSpread2$1({}, props);
    var hasShorthands = false;
    for (var shorthand of shorthandNames) {
      var value = props[shorthand];
      if (value != null) {
        var sprinkle = sprinklesStyles[shorthand];
        hasShorthands = true;
        for (var propMapping of sprinkle.mappings) {
          shorthands[propMapping] = value;
          if (nonShorthands[propMapping] == null) {
            delete nonShorthands[propMapping];
          }
        }
      }
    }
    var finalProps = hasShorthands ? _objectSpread2$1(_objectSpread2$1({}, shorthands), nonShorthands) : props;
    var _loop = function _loop2() {
      var propValue = finalProps[prop];
      var sprinkle2 = sprinklesStyles[prop];
      try {
        if (sprinkle2.mappings) {
          return 1;
        }
        if (typeof propValue === "string" || typeof propValue === "number") {
          if (false) ;
          classNames.push(sprinkle2.values[propValue].defaultClass);
        } else if (Array.isArray(propValue)) {
          for (var responsiveIndex = 0; responsiveIndex < propValue.length; responsiveIndex++) {
            var responsiveValue = propValue[responsiveIndex];
            if (responsiveValue != null) {
              var conditionName = sprinkle2.responsiveArray[responsiveIndex];
              if (false) ;
              classNames.push(sprinkle2.values[responsiveValue].conditions[conditionName]);
            }
          }
        } else {
          for (var _conditionName in propValue) {
            var _value2 = propValue[_conditionName];
            if (_value2 != null) {
              if (false) ;
              classNames.push(sprinkle2.values[_value2].conditions[_conditionName]);
            }
          }
        }
      } catch (e2) {
        throw e2;
      }
    };
    for (var prop in finalProps) {
      if (_loop()) continue;
    }
    return composeStyles2(classNames.join(" "));
  };
  return Object.assign(sprinklesFn, {
    properties: new Set(sprinklesKeys)
  });
};
var composeStyles = (classList) => classList;
var createSprinkles = function createSprinkles2() {
  return createSprinkles$1(composeStyles)(...arguments);
};
var sprinkles = createSprinkles({ conditions: { defaultCondition: "sm", conditionNames: ["sm", "md", "lg", "xl"], responsiveArray: void 0 }, styles: { borderWidth: { mappings: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"] }, borderRadius: { mappings: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderLeftRadius: { mappings: ["borderBottomLeftRadius", "borderTopLeftRadius"] }, borderRightRadius: { mappings: ["borderBottomRightRadius", "borderTopRightRadius"] }, borderTopRadius: { mappings: ["borderTopLeftRadius", "borderTopRightRadius"] }, borderBottomRadius: { mappings: ["borderBottomLeftRadius", "borderBottomRightRadius"] }, margin: { mappings: ["marginTop", "marginBottom", "marginLeft", "marginRight"] }, marginX: { mappings: ["marginLeft", "marginRight"] }, marginY: { mappings: ["marginTop", "marginBottom"] }, overflow: { mappings: ["overflowX", "overflowY"] }, padding: { mappings: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"] }, paddingX: { mappings: ["paddingLeft", "paddingRight"] }, paddingY: { mappings: ["paddingTop", "paddingBottom"] }, placeItems: { mappings: ["justifyContent", "alignItems"] }, inset: { mappings: ["top", "bottom", "left", "right"] }, width: { values: { "0": { conditions: { sm: "fyvr10", md: "fyvr11", lg: "fyvr12", xl: "fyvr13" }, defaultClass: "fyvr10" }, "1": { conditions: { sm: "fyvr14", md: "fyvr15", lg: "fyvr16", xl: "fyvr17" }, defaultClass: "fyvr14" }, "2": { conditions: { sm: "fyvr18", md: "fyvr19", lg: "fyvr1a", xl: "fyvr1b" }, defaultClass: "fyvr18" }, "3": { conditions: { sm: "fyvr1c", md: "fyvr1d", lg: "fyvr1e", xl: "fyvr1f" }, defaultClass: "fyvr1c" }, "4": { conditions: { sm: "fyvr1g", md: "fyvr1h", lg: "fyvr1i", xl: "fyvr1j" }, defaultClass: "fyvr1g" }, "5": { conditions: { sm: "fyvr1k", md: "fyvr1l", lg: "fyvr1m", xl: "fyvr1n" }, defaultClass: "fyvr1k" }, "6": { conditions: { sm: "fyvr1o", md: "fyvr1p", lg: "fyvr1q", xl: "fyvr1r" }, defaultClass: "fyvr1o" }, "7": { conditions: { sm: "fyvr1s", md: "fyvr1t", lg: "fyvr1u", xl: "fyvr1v" }, defaultClass: "fyvr1s" }, "8": { conditions: { sm: "fyvr1w", md: "fyvr1x", lg: "fyvr1y", xl: "fyvr1z" }, defaultClass: "fyvr1w" }, "9": { conditions: { sm: "fyvr110", md: "fyvr111", lg: "fyvr112", xl: "fyvr113" }, defaultClass: "fyvr110" }, "10": { conditions: { sm: "fyvr114", md: "fyvr115", lg: "fyvr116", xl: "fyvr117" }, defaultClass: "fyvr114" }, "12": { conditions: { sm: "fyvr118", md: "fyvr119", lg: "fyvr11a", xl: "fyvr11b" }, defaultClass: "fyvr118" }, "14": { conditions: { sm: "fyvr11c", md: "fyvr11d", lg: "fyvr11e", xl: "fyvr11f" }, defaultClass: "fyvr11c" }, "16": { conditions: { sm: "fyvr11g", md: "fyvr11h", lg: "fyvr11i", xl: "fyvr11j" }, defaultClass: "fyvr11g" }, "18": { conditions: { sm: "fyvr11k", md: "fyvr11l", lg: "fyvr11m", xl: "fyvr11n" }, defaultClass: "fyvr11k" }, "20": { conditions: { sm: "fyvr11o", md: "fyvr11p", lg: "fyvr11q", xl: "fyvr11r" }, defaultClass: "fyvr11o" }, "0.25": { conditions: { sm: "fyvr11s", md: "fyvr11t", lg: "fyvr11u", xl: "fyvr11v" }, defaultClass: "fyvr11s" }, "0.5": { conditions: { sm: "fyvr11w", md: "fyvr11x", lg: "fyvr11y", xl: "fyvr11z" }, defaultClass: "fyvr11w" }, "1.5": { conditions: { sm: "fyvr120", md: "fyvr121", lg: "fyvr122", xl: "fyvr123" }, defaultClass: "fyvr120" }, none: { conditions: { sm: "fyvr124", md: "fyvr125", lg: "fyvr126", xl: "fyvr127" }, defaultClass: "fyvr124" }, px: { conditions: { sm: "fyvr128", md: "fyvr129", lg: "fyvr12a", xl: "fyvr12b" }, defaultClass: "fyvr128" }, auto: { conditions: { sm: "fyvr12c", md: "fyvr12d", lg: "fyvr12e", xl: "fyvr12f" }, defaultClass: "fyvr12c" }, full: { conditions: { sm: "fyvr12g", md: "fyvr12h", lg: "fyvr12i", xl: "fyvr12j" }, defaultClass: "fyvr12g" }, "1/2": { conditions: { sm: "fyvr12k", md: "fyvr12l", lg: "fyvr12m", xl: "fyvr12n" }, defaultClass: "fyvr12k" }, "1/3": { conditions: { sm: "fyvr12o", md: "fyvr12p", lg: "fyvr12q", xl: "fyvr12r" }, defaultClass: "fyvr12o" }, "2/3": { conditions: { sm: "fyvr12s", md: "fyvr12t", lg: "fyvr12u", xl: "fyvr12v" }, defaultClass: "fyvr12s" }, "1/4": { conditions: { sm: "fyvr12w", md: "fyvr12x", lg: "fyvr12y", xl: "fyvr12z" }, defaultClass: "fyvr12w" }, "3/4": { conditions: { sm: "fyvr130", md: "fyvr131", lg: "fyvr132", xl: "fyvr133" }, defaultClass: "fyvr130" }, fit: { conditions: { sm: "fyvr134", md: "fyvr135", lg: "fyvr136", xl: "fyvr137" }, defaultClass: "fyvr134" }, max: { conditions: { sm: "fyvr138", md: "fyvr139", lg: "fyvr13a", xl: "fyvr13b" }, defaultClass: "fyvr138" }, min: { conditions: { sm: "fyvr13c", md: "fyvr13d", lg: "fyvr13e", xl: "fyvr13f" }, defaultClass: "fyvr13c" }, vw: { conditions: { sm: "fyvr13g", md: "fyvr13h", lg: "fyvr13i", xl: "fyvr13j" }, defaultClass: "fyvr13g" }, vh: { conditions: { sm: "fyvr13k", md: "fyvr13l", lg: "fyvr13m", xl: "fyvr13n" }, defaultClass: "fyvr13k" } } }, height: { values: { "0": { conditions: { sm: "fyvr13o", md: "fyvr13p", lg: "fyvr13q", xl: "fyvr13r" }, defaultClass: "fyvr13o" }, "1": { conditions: { sm: "fyvr13s", md: "fyvr13t", lg: "fyvr13u", xl: "fyvr13v" }, defaultClass: "fyvr13s" }, "2": { conditions: { sm: "fyvr13w", md: "fyvr13x", lg: "fyvr13y", xl: "fyvr13z" }, defaultClass: "fyvr13w" }, "3": { conditions: { sm: "fyvr140", md: "fyvr141", lg: "fyvr142", xl: "fyvr143" }, defaultClass: "fyvr140" }, "4": { conditions: { sm: "fyvr144", md: "fyvr145", lg: "fyvr146", xl: "fyvr147" }, defaultClass: "fyvr144" }, "5": { conditions: { sm: "fyvr148", md: "fyvr149", lg: "fyvr14a", xl: "fyvr14b" }, defaultClass: "fyvr148" }, "6": { conditions: { sm: "fyvr14c", md: "fyvr14d", lg: "fyvr14e", xl: "fyvr14f" }, defaultClass: "fyvr14c" }, "7": { conditions: { sm: "fyvr14g", md: "fyvr14h", lg: "fyvr14i", xl: "fyvr14j" }, defaultClass: "fyvr14g" }, "8": { conditions: { sm: "fyvr14k", md: "fyvr14l", lg: "fyvr14m", xl: "fyvr14n" }, defaultClass: "fyvr14k" }, "9": { conditions: { sm: "fyvr14o", md: "fyvr14p", lg: "fyvr14q", xl: "fyvr14r" }, defaultClass: "fyvr14o" }, "10": { conditions: { sm: "fyvr14s", md: "fyvr14t", lg: "fyvr14u", xl: "fyvr14v" }, defaultClass: "fyvr14s" }, "12": { conditions: { sm: "fyvr14w", md: "fyvr14x", lg: "fyvr14y", xl: "fyvr14z" }, defaultClass: "fyvr14w" }, "14": { conditions: { sm: "fyvr150", md: "fyvr151", lg: "fyvr152", xl: "fyvr153" }, defaultClass: "fyvr150" }, "16": { conditions: { sm: "fyvr154", md: "fyvr155", lg: "fyvr156", xl: "fyvr157" }, defaultClass: "fyvr154" }, "18": { conditions: { sm: "fyvr158", md: "fyvr159", lg: "fyvr15a", xl: "fyvr15b" }, defaultClass: "fyvr158" }, "20": { conditions: { sm: "fyvr15c", md: "fyvr15d", lg: "fyvr15e", xl: "fyvr15f" }, defaultClass: "fyvr15c" }, "0.25": { conditions: { sm: "fyvr15g", md: "fyvr15h", lg: "fyvr15i", xl: "fyvr15j" }, defaultClass: "fyvr15g" }, "0.5": { conditions: { sm: "fyvr15k", md: "fyvr15l", lg: "fyvr15m", xl: "fyvr15n" }, defaultClass: "fyvr15k" }, "1.5": { conditions: { sm: "fyvr15o", md: "fyvr15p", lg: "fyvr15q", xl: "fyvr15r" }, defaultClass: "fyvr15o" }, none: { conditions: { sm: "fyvr15s", md: "fyvr15t", lg: "fyvr15u", xl: "fyvr15v" }, defaultClass: "fyvr15s" }, px: { conditions: { sm: "fyvr15w", md: "fyvr15x", lg: "fyvr15y", xl: "fyvr15z" }, defaultClass: "fyvr15w" }, auto: { conditions: { sm: "fyvr160", md: "fyvr161", lg: "fyvr162", xl: "fyvr163" }, defaultClass: "fyvr160" }, full: { conditions: { sm: "fyvr164", md: "fyvr165", lg: "fyvr166", xl: "fyvr167" }, defaultClass: "fyvr164" }, "1/2": { conditions: { sm: "fyvr168", md: "fyvr169", lg: "fyvr16a", xl: "fyvr16b" }, defaultClass: "fyvr168" }, "1/3": { conditions: { sm: "fyvr16c", md: "fyvr16d", lg: "fyvr16e", xl: "fyvr16f" }, defaultClass: "fyvr16c" }, "2/3": { conditions: { sm: "fyvr16g", md: "fyvr16h", lg: "fyvr16i", xl: "fyvr16j" }, defaultClass: "fyvr16g" }, "1/4": { conditions: { sm: "fyvr16k", md: "fyvr16l", lg: "fyvr16m", xl: "fyvr16n" }, defaultClass: "fyvr16k" }, "3/4": { conditions: { sm: "fyvr16o", md: "fyvr16p", lg: "fyvr16q", xl: "fyvr16r" }, defaultClass: "fyvr16o" }, fit: { conditions: { sm: "fyvr16s", md: "fyvr16t", lg: "fyvr16u", xl: "fyvr16v" }, defaultClass: "fyvr16s" }, max: { conditions: { sm: "fyvr16w", md: "fyvr16x", lg: "fyvr16y", xl: "fyvr16z" }, defaultClass: "fyvr16w" }, min: { conditions: { sm: "fyvr170", md: "fyvr171", lg: "fyvr172", xl: "fyvr173" }, defaultClass: "fyvr170" }, vw: { conditions: { sm: "fyvr174", md: "fyvr175", lg: "fyvr176", xl: "fyvr177" }, defaultClass: "fyvr174" }, vh: { conditions: { sm: "fyvr178", md: "fyvr179", lg: "fyvr17a", xl: "fyvr17b" }, defaultClass: "fyvr178" } } }, maxWidth: { values: { "0": { conditions: { sm: "fyvr17c", md: "fyvr17d", lg: "fyvr17e", xl: "fyvr17f" }, defaultClass: "fyvr17c" }, "1": { conditions: { sm: "fyvr17g", md: "fyvr17h", lg: "fyvr17i", xl: "fyvr17j" }, defaultClass: "fyvr17g" }, "2": { conditions: { sm: "fyvr17k", md: "fyvr17l", lg: "fyvr17m", xl: "fyvr17n" }, defaultClass: "fyvr17k" }, "3": { conditions: { sm: "fyvr17o", md: "fyvr17p", lg: "fyvr17q", xl: "fyvr17r" }, defaultClass: "fyvr17o" }, "4": { conditions: { sm: "fyvr17s", md: "fyvr17t", lg: "fyvr17u", xl: "fyvr17v" }, defaultClass: "fyvr17s" }, "5": { conditions: { sm: "fyvr17w", md: "fyvr17x", lg: "fyvr17y", xl: "fyvr17z" }, defaultClass: "fyvr17w" }, "6": { conditions: { sm: "fyvr180", md: "fyvr181", lg: "fyvr182", xl: "fyvr183" }, defaultClass: "fyvr180" }, "7": { conditions: { sm: "fyvr184", md: "fyvr185", lg: "fyvr186", xl: "fyvr187" }, defaultClass: "fyvr184" }, "8": { conditions: { sm: "fyvr188", md: "fyvr189", lg: "fyvr18a", xl: "fyvr18b" }, defaultClass: "fyvr188" }, "9": { conditions: { sm: "fyvr18c", md: "fyvr18d", lg: "fyvr18e", xl: "fyvr18f" }, defaultClass: "fyvr18c" }, "10": { conditions: { sm: "fyvr18g", md: "fyvr18h", lg: "fyvr18i", xl: "fyvr18j" }, defaultClass: "fyvr18g" }, "12": { conditions: { sm: "fyvr18k", md: "fyvr18l", lg: "fyvr18m", xl: "fyvr18n" }, defaultClass: "fyvr18k" }, "14": { conditions: { sm: "fyvr18o", md: "fyvr18p", lg: "fyvr18q", xl: "fyvr18r" }, defaultClass: "fyvr18o" }, "16": { conditions: { sm: "fyvr18s", md: "fyvr18t", lg: "fyvr18u", xl: "fyvr18v" }, defaultClass: "fyvr18s" }, "18": { conditions: { sm: "fyvr18w", md: "fyvr18x", lg: "fyvr18y", xl: "fyvr18z" }, defaultClass: "fyvr18w" }, "20": { conditions: { sm: "fyvr190", md: "fyvr191", lg: "fyvr192", xl: "fyvr193" }, defaultClass: "fyvr190" }, "0.25": { conditions: { sm: "fyvr194", md: "fyvr195", lg: "fyvr196", xl: "fyvr197" }, defaultClass: "fyvr194" }, "0.5": { conditions: { sm: "fyvr198", md: "fyvr199", lg: "fyvr19a", xl: "fyvr19b" }, defaultClass: "fyvr198" }, "1.5": { conditions: { sm: "fyvr19c", md: "fyvr19d", lg: "fyvr19e", xl: "fyvr19f" }, defaultClass: "fyvr19c" }, none: { conditions: { sm: "fyvr19g", md: "fyvr19h", lg: "fyvr19i", xl: "fyvr19j" }, defaultClass: "fyvr19g" }, px: { conditions: { sm: "fyvr19k", md: "fyvr19l", lg: "fyvr19m", xl: "fyvr19n" }, defaultClass: "fyvr19k" }, auto: { conditions: { sm: "fyvr19o", md: "fyvr19p", lg: "fyvr19q", xl: "fyvr19r" }, defaultClass: "fyvr19o" }, full: { conditions: { sm: "fyvr19s", md: "fyvr19t", lg: "fyvr19u", xl: "fyvr19v" }, defaultClass: "fyvr19s" }, "1/2": { conditions: { sm: "fyvr19w", md: "fyvr19x", lg: "fyvr19y", xl: "fyvr19z" }, defaultClass: "fyvr19w" }, "1/3": { conditions: { sm: "fyvr1a0", md: "fyvr1a1", lg: "fyvr1a2", xl: "fyvr1a3" }, defaultClass: "fyvr1a0" }, "2/3": { conditions: { sm: "fyvr1a4", md: "fyvr1a5", lg: "fyvr1a6", xl: "fyvr1a7" }, defaultClass: "fyvr1a4" }, "1/4": { conditions: { sm: "fyvr1a8", md: "fyvr1a9", lg: "fyvr1aa", xl: "fyvr1ab" }, defaultClass: "fyvr1a8" }, "3/4": { conditions: { sm: "fyvr1ac", md: "fyvr1ad", lg: "fyvr1ae", xl: "fyvr1af" }, defaultClass: "fyvr1ac" }, fit: { conditions: { sm: "fyvr1ag", md: "fyvr1ah", lg: "fyvr1ai", xl: "fyvr1aj" }, defaultClass: "fyvr1ag" }, max: { conditions: { sm: "fyvr1ak", md: "fyvr1al", lg: "fyvr1am", xl: "fyvr1an" }, defaultClass: "fyvr1ak" }, min: { conditions: { sm: "fyvr1ao", md: "fyvr1ap", lg: "fyvr1aq", xl: "fyvr1ar" }, defaultClass: "fyvr1ao" }, vw: { conditions: { sm: "fyvr1as", md: "fyvr1at", lg: "fyvr1au", xl: "fyvr1av" }, defaultClass: "fyvr1as" }, vh: { conditions: { sm: "fyvr1aw", md: "fyvr1ax", lg: "fyvr1ay", xl: "fyvr1az" }, defaultClass: "fyvr1aw" } } }, maxHeight: { values: { "0": { conditions: { sm: "fyvr1b0", md: "fyvr1b1", lg: "fyvr1b2", xl: "fyvr1b3" }, defaultClass: "fyvr1b0" }, "1": { conditions: { sm: "fyvr1b4", md: "fyvr1b5", lg: "fyvr1b6", xl: "fyvr1b7" }, defaultClass: "fyvr1b4" }, "2": { conditions: { sm: "fyvr1b8", md: "fyvr1b9", lg: "fyvr1ba", xl: "fyvr1bb" }, defaultClass: "fyvr1b8" }, "3": { conditions: { sm: "fyvr1bc", md: "fyvr1bd", lg: "fyvr1be", xl: "fyvr1bf" }, defaultClass: "fyvr1bc" }, "4": { conditions: { sm: "fyvr1bg", md: "fyvr1bh", lg: "fyvr1bi", xl: "fyvr1bj" }, defaultClass: "fyvr1bg" }, "5": { conditions: { sm: "fyvr1bk", md: "fyvr1bl", lg: "fyvr1bm", xl: "fyvr1bn" }, defaultClass: "fyvr1bk" }, "6": { conditions: { sm: "fyvr1bo", md: "fyvr1bp", lg: "fyvr1bq", xl: "fyvr1br" }, defaultClass: "fyvr1bo" }, "7": { conditions: { sm: "fyvr1bs", md: "fyvr1bt", lg: "fyvr1bu", xl: "fyvr1bv" }, defaultClass: "fyvr1bs" }, "8": { conditions: { sm: "fyvr1bw", md: "fyvr1bx", lg: "fyvr1by", xl: "fyvr1bz" }, defaultClass: "fyvr1bw" }, "9": { conditions: { sm: "fyvr1c0", md: "fyvr1c1", lg: "fyvr1c2", xl: "fyvr1c3" }, defaultClass: "fyvr1c0" }, "10": { conditions: { sm: "fyvr1c4", md: "fyvr1c5", lg: "fyvr1c6", xl: "fyvr1c7" }, defaultClass: "fyvr1c4" }, "12": { conditions: { sm: "fyvr1c8", md: "fyvr1c9", lg: "fyvr1ca", xl: "fyvr1cb" }, defaultClass: "fyvr1c8" }, "14": { conditions: { sm: "fyvr1cc", md: "fyvr1cd", lg: "fyvr1ce", xl: "fyvr1cf" }, defaultClass: "fyvr1cc" }, "16": { conditions: { sm: "fyvr1cg", md: "fyvr1ch", lg: "fyvr1ci", xl: "fyvr1cj" }, defaultClass: "fyvr1cg" }, "18": { conditions: { sm: "fyvr1ck", md: "fyvr1cl", lg: "fyvr1cm", xl: "fyvr1cn" }, defaultClass: "fyvr1ck" }, "20": { conditions: { sm: "fyvr1co", md: "fyvr1cp", lg: "fyvr1cq", xl: "fyvr1cr" }, defaultClass: "fyvr1co" }, "0.25": { conditions: { sm: "fyvr1cs", md: "fyvr1ct", lg: "fyvr1cu", xl: "fyvr1cv" }, defaultClass: "fyvr1cs" }, "0.5": { conditions: { sm: "fyvr1cw", md: "fyvr1cx", lg: "fyvr1cy", xl: "fyvr1cz" }, defaultClass: "fyvr1cw" }, "1.5": { conditions: { sm: "fyvr1d0", md: "fyvr1d1", lg: "fyvr1d2", xl: "fyvr1d3" }, defaultClass: "fyvr1d0" }, none: { conditions: { sm: "fyvr1d4", md: "fyvr1d5", lg: "fyvr1d6", xl: "fyvr1d7" }, defaultClass: "fyvr1d4" }, px: { conditions: { sm: "fyvr1d8", md: "fyvr1d9", lg: "fyvr1da", xl: "fyvr1db" }, defaultClass: "fyvr1d8" }, auto: { conditions: { sm: "fyvr1dc", md: "fyvr1dd", lg: "fyvr1de", xl: "fyvr1df" }, defaultClass: "fyvr1dc" }, full: { conditions: { sm: "fyvr1dg", md: "fyvr1dh", lg: "fyvr1di", xl: "fyvr1dj" }, defaultClass: "fyvr1dg" }, "1/2": { conditions: { sm: "fyvr1dk", md: "fyvr1dl", lg: "fyvr1dm", xl: "fyvr1dn" }, defaultClass: "fyvr1dk" }, "1/3": { conditions: { sm: "fyvr1do", md: "fyvr1dp", lg: "fyvr1dq", xl: "fyvr1dr" }, defaultClass: "fyvr1do" }, "2/3": { conditions: { sm: "fyvr1ds", md: "fyvr1dt", lg: "fyvr1du", xl: "fyvr1dv" }, defaultClass: "fyvr1ds" }, "1/4": { conditions: { sm: "fyvr1dw", md: "fyvr1dx", lg: "fyvr1dy", xl: "fyvr1dz" }, defaultClass: "fyvr1dw" }, "3/4": { conditions: { sm: "fyvr1e0", md: "fyvr1e1", lg: "fyvr1e2", xl: "fyvr1e3" }, defaultClass: "fyvr1e0" }, fit: { conditions: { sm: "fyvr1e4", md: "fyvr1e5", lg: "fyvr1e6", xl: "fyvr1e7" }, defaultClass: "fyvr1e4" }, max: { conditions: { sm: "fyvr1e8", md: "fyvr1e9", lg: "fyvr1ea", xl: "fyvr1eb" }, defaultClass: "fyvr1e8" }, min: { conditions: { sm: "fyvr1ec", md: "fyvr1ed", lg: "fyvr1ee", xl: "fyvr1ef" }, defaultClass: "fyvr1ec" }, vw: { conditions: { sm: "fyvr1eg", md: "fyvr1eh", lg: "fyvr1ei", xl: "fyvr1ej" }, defaultClass: "fyvr1eg" }, vh: { conditions: { sm: "fyvr1ek", md: "fyvr1el", lg: "fyvr1em", xl: "fyvr1en" }, defaultClass: "fyvr1ek" } } }, minWidth: { values: { "0": { conditions: { sm: "fyvr1eo", md: "fyvr1ep", lg: "fyvr1eq", xl: "fyvr1er" }, defaultClass: "fyvr1eo" }, "1": { conditions: { sm: "fyvr1es", md: "fyvr1et", lg: "fyvr1eu", xl: "fyvr1ev" }, defaultClass: "fyvr1es" }, "2": { conditions: { sm: "fyvr1ew", md: "fyvr1ex", lg: "fyvr1ey", xl: "fyvr1ez" }, defaultClass: "fyvr1ew" }, "3": { conditions: { sm: "fyvr1f0", md: "fyvr1f1", lg: "fyvr1f2", xl: "fyvr1f3" }, defaultClass: "fyvr1f0" }, "4": { conditions: { sm: "fyvr1f4", md: "fyvr1f5", lg: "fyvr1f6", xl: "fyvr1f7" }, defaultClass: "fyvr1f4" }, "5": { conditions: { sm: "fyvr1f8", md: "fyvr1f9", lg: "fyvr1fa", xl: "fyvr1fb" }, defaultClass: "fyvr1f8" }, "6": { conditions: { sm: "fyvr1fc", md: "fyvr1fd", lg: "fyvr1fe", xl: "fyvr1ff" }, defaultClass: "fyvr1fc" }, "7": { conditions: { sm: "fyvr1fg", md: "fyvr1fh", lg: "fyvr1fi", xl: "fyvr1fj" }, defaultClass: "fyvr1fg" }, "8": { conditions: { sm: "fyvr1fk", md: "fyvr1fl", lg: "fyvr1fm", xl: "fyvr1fn" }, defaultClass: "fyvr1fk" }, "9": { conditions: { sm: "fyvr1fo", md: "fyvr1fp", lg: "fyvr1fq", xl: "fyvr1fr" }, defaultClass: "fyvr1fo" }, "10": { conditions: { sm: "fyvr1fs", md: "fyvr1ft", lg: "fyvr1fu", xl: "fyvr1fv" }, defaultClass: "fyvr1fs" }, "12": { conditions: { sm: "fyvr1fw", md: "fyvr1fx", lg: "fyvr1fy", xl: "fyvr1fz" }, defaultClass: "fyvr1fw" }, "14": { conditions: { sm: "fyvr1g0", md: "fyvr1g1", lg: "fyvr1g2", xl: "fyvr1g3" }, defaultClass: "fyvr1g0" }, "16": { conditions: { sm: "fyvr1g4", md: "fyvr1g5", lg: "fyvr1g6", xl: "fyvr1g7" }, defaultClass: "fyvr1g4" }, "18": { conditions: { sm: "fyvr1g8", md: "fyvr1g9", lg: "fyvr1ga", xl: "fyvr1gb" }, defaultClass: "fyvr1g8" }, "20": { conditions: { sm: "fyvr1gc", md: "fyvr1gd", lg: "fyvr1ge", xl: "fyvr1gf" }, defaultClass: "fyvr1gc" }, "0.25": { conditions: { sm: "fyvr1gg", md: "fyvr1gh", lg: "fyvr1gi", xl: "fyvr1gj" }, defaultClass: "fyvr1gg" }, "0.5": { conditions: { sm: "fyvr1gk", md: "fyvr1gl", lg: "fyvr1gm", xl: "fyvr1gn" }, defaultClass: "fyvr1gk" }, "1.5": { conditions: { sm: "fyvr1go", md: "fyvr1gp", lg: "fyvr1gq", xl: "fyvr1gr" }, defaultClass: "fyvr1go" }, none: { conditions: { sm: "fyvr1gs", md: "fyvr1gt", lg: "fyvr1gu", xl: "fyvr1gv" }, defaultClass: "fyvr1gs" }, px: { conditions: { sm: "fyvr1gw", md: "fyvr1gx", lg: "fyvr1gy", xl: "fyvr1gz" }, defaultClass: "fyvr1gw" }, auto: { conditions: { sm: "fyvr1h0", md: "fyvr1h1", lg: "fyvr1h2", xl: "fyvr1h3" }, defaultClass: "fyvr1h0" }, full: { conditions: { sm: "fyvr1h4", md: "fyvr1h5", lg: "fyvr1h6", xl: "fyvr1h7" }, defaultClass: "fyvr1h4" }, "1/2": { conditions: { sm: "fyvr1h8", md: "fyvr1h9", lg: "fyvr1ha", xl: "fyvr1hb" }, defaultClass: "fyvr1h8" }, "1/3": { conditions: { sm: "fyvr1hc", md: "fyvr1hd", lg: "fyvr1he", xl: "fyvr1hf" }, defaultClass: "fyvr1hc" }, "2/3": { conditions: { sm: "fyvr1hg", md: "fyvr1hh", lg: "fyvr1hi", xl: "fyvr1hj" }, defaultClass: "fyvr1hg" }, "1/4": { conditions: { sm: "fyvr1hk", md: "fyvr1hl", lg: "fyvr1hm", xl: "fyvr1hn" }, defaultClass: "fyvr1hk" }, "3/4": { conditions: { sm: "fyvr1ho", md: "fyvr1hp", lg: "fyvr1hq", xl: "fyvr1hr" }, defaultClass: "fyvr1ho" }, fit: { conditions: { sm: "fyvr1hs", md: "fyvr1ht", lg: "fyvr1hu", xl: "fyvr1hv" }, defaultClass: "fyvr1hs" }, max: { conditions: { sm: "fyvr1hw", md: "fyvr1hx", lg: "fyvr1hy", xl: "fyvr1hz" }, defaultClass: "fyvr1hw" }, min: { conditions: { sm: "fyvr1i0", md: "fyvr1i1", lg: "fyvr1i2", xl: "fyvr1i3" }, defaultClass: "fyvr1i0" }, vw: { conditions: { sm: "fyvr1i4", md: "fyvr1i5", lg: "fyvr1i6", xl: "fyvr1i7" }, defaultClass: "fyvr1i4" }, vh: { conditions: { sm: "fyvr1i8", md: "fyvr1i9", lg: "fyvr1ia", xl: "fyvr1ib" }, defaultClass: "fyvr1i8" } } }, minHeight: { values: { "0": { conditions: { sm: "fyvr1ic", md: "fyvr1id", lg: "fyvr1ie", xl: "fyvr1if" }, defaultClass: "fyvr1ic" }, "1": { conditions: { sm: "fyvr1ig", md: "fyvr1ih", lg: "fyvr1ii", xl: "fyvr1ij" }, defaultClass: "fyvr1ig" }, "2": { conditions: { sm: "fyvr1ik", md: "fyvr1il", lg: "fyvr1im", xl: "fyvr1in" }, defaultClass: "fyvr1ik" }, "3": { conditions: { sm: "fyvr1io", md: "fyvr1ip", lg: "fyvr1iq", xl: "fyvr1ir" }, defaultClass: "fyvr1io" }, "4": { conditions: { sm: "fyvr1is", md: "fyvr1it", lg: "fyvr1iu", xl: "fyvr1iv" }, defaultClass: "fyvr1is" }, "5": { conditions: { sm: "fyvr1iw", md: "fyvr1ix", lg: "fyvr1iy", xl: "fyvr1iz" }, defaultClass: "fyvr1iw" }, "6": { conditions: { sm: "fyvr1j0", md: "fyvr1j1", lg: "fyvr1j2", xl: "fyvr1j3" }, defaultClass: "fyvr1j0" }, "7": { conditions: { sm: "fyvr1j4", md: "fyvr1j5", lg: "fyvr1j6", xl: "fyvr1j7" }, defaultClass: "fyvr1j4" }, "8": { conditions: { sm: "fyvr1j8", md: "fyvr1j9", lg: "fyvr1ja", xl: "fyvr1jb" }, defaultClass: "fyvr1j8" }, "9": { conditions: { sm: "fyvr1jc", md: "fyvr1jd", lg: "fyvr1je", xl: "fyvr1jf" }, defaultClass: "fyvr1jc" }, "10": { conditions: { sm: "fyvr1jg", md: "fyvr1jh", lg: "fyvr1ji", xl: "fyvr1jj" }, defaultClass: "fyvr1jg" }, "12": { conditions: { sm: "fyvr1jk", md: "fyvr1jl", lg: "fyvr1jm", xl: "fyvr1jn" }, defaultClass: "fyvr1jk" }, "14": { conditions: { sm: "fyvr1jo", md: "fyvr1jp", lg: "fyvr1jq", xl: "fyvr1jr" }, defaultClass: "fyvr1jo" }, "16": { conditions: { sm: "fyvr1js", md: "fyvr1jt", lg: "fyvr1ju", xl: "fyvr1jv" }, defaultClass: "fyvr1js" }, "18": { conditions: { sm: "fyvr1jw", md: "fyvr1jx", lg: "fyvr1jy", xl: "fyvr1jz" }, defaultClass: "fyvr1jw" }, "20": { conditions: { sm: "fyvr1k0", md: "fyvr1k1", lg: "fyvr1k2", xl: "fyvr1k3" }, defaultClass: "fyvr1k0" }, "0.25": { conditions: { sm: "fyvr1k4", md: "fyvr1k5", lg: "fyvr1k6", xl: "fyvr1k7" }, defaultClass: "fyvr1k4" }, "0.5": { conditions: { sm: "fyvr1k8", md: "fyvr1k9", lg: "fyvr1ka", xl: "fyvr1kb" }, defaultClass: "fyvr1k8" }, "1.5": { conditions: { sm: "fyvr1kc", md: "fyvr1kd", lg: "fyvr1ke", xl: "fyvr1kf" }, defaultClass: "fyvr1kc" }, none: { conditions: { sm: "fyvr1kg", md: "fyvr1kh", lg: "fyvr1ki", xl: "fyvr1kj" }, defaultClass: "fyvr1kg" }, px: { conditions: { sm: "fyvr1kk", md: "fyvr1kl", lg: "fyvr1km", xl: "fyvr1kn" }, defaultClass: "fyvr1kk" }, auto: { conditions: { sm: "fyvr1ko", md: "fyvr1kp", lg: "fyvr1kq", xl: "fyvr1kr" }, defaultClass: "fyvr1ko" }, full: { conditions: { sm: "fyvr1ks", md: "fyvr1kt", lg: "fyvr1ku", xl: "fyvr1kv" }, defaultClass: "fyvr1ks" }, "1/2": { conditions: { sm: "fyvr1kw", md: "fyvr1kx", lg: "fyvr1ky", xl: "fyvr1kz" }, defaultClass: "fyvr1kw" }, "1/3": { conditions: { sm: "fyvr1l0", md: "fyvr1l1", lg: "fyvr1l2", xl: "fyvr1l3" }, defaultClass: "fyvr1l0" }, "2/3": { conditions: { sm: "fyvr1l4", md: "fyvr1l5", lg: "fyvr1l6", xl: "fyvr1l7" }, defaultClass: "fyvr1l4" }, "1/4": { conditions: { sm: "fyvr1l8", md: "fyvr1l9", lg: "fyvr1la", xl: "fyvr1lb" }, defaultClass: "fyvr1l8" }, "3/4": { conditions: { sm: "fyvr1lc", md: "fyvr1ld", lg: "fyvr1le", xl: "fyvr1lf" }, defaultClass: "fyvr1lc" }, fit: { conditions: { sm: "fyvr1lg", md: "fyvr1lh", lg: "fyvr1li", xl: "fyvr1lj" }, defaultClass: "fyvr1lg" }, max: { conditions: { sm: "fyvr1lk", md: "fyvr1ll", lg: "fyvr1lm", xl: "fyvr1ln" }, defaultClass: "fyvr1lk" }, min: { conditions: { sm: "fyvr1lo", md: "fyvr1lp", lg: "fyvr1lq", xl: "fyvr1lr" }, defaultClass: "fyvr1lo" }, vw: { conditions: { sm: "fyvr1ls", md: "fyvr1lt", lg: "fyvr1lu", xl: "fyvr1lv" }, defaultClass: "fyvr1ls" }, vh: { conditions: { sm: "fyvr1lw", md: "fyvr1lx", lg: "fyvr1ly", xl: "fyvr1lz" }, defaultClass: "fyvr1lw" } } }, top: { values: { "0": { conditions: { sm: "fyvr1m0", md: "fyvr1m1", lg: "fyvr1m2", xl: "fyvr1m3" }, defaultClass: "fyvr1m0" }, "1": { conditions: { sm: "fyvr1m4", md: "fyvr1m5", lg: "fyvr1m6", xl: "fyvr1m7" }, defaultClass: "fyvr1m4" }, "2": { conditions: { sm: "fyvr1m8", md: "fyvr1m9", lg: "fyvr1ma", xl: "fyvr1mb" }, defaultClass: "fyvr1m8" }, "3": { conditions: { sm: "fyvr1mc", md: "fyvr1md", lg: "fyvr1me", xl: "fyvr1mf" }, defaultClass: "fyvr1mc" }, "4": { conditions: { sm: "fyvr1mg", md: "fyvr1mh", lg: "fyvr1mi", xl: "fyvr1mj" }, defaultClass: "fyvr1mg" }, "5": { conditions: { sm: "fyvr1mk", md: "fyvr1ml", lg: "fyvr1mm", xl: "fyvr1mn" }, defaultClass: "fyvr1mk" }, "6": { conditions: { sm: "fyvr1mo", md: "fyvr1mp", lg: "fyvr1mq", xl: "fyvr1mr" }, defaultClass: "fyvr1mo" }, "7": { conditions: { sm: "fyvr1ms", md: "fyvr1mt", lg: "fyvr1mu", xl: "fyvr1mv" }, defaultClass: "fyvr1ms" }, "8": { conditions: { sm: "fyvr1mw", md: "fyvr1mx", lg: "fyvr1my", xl: "fyvr1mz" }, defaultClass: "fyvr1mw" }, "9": { conditions: { sm: "fyvr1n0", md: "fyvr1n1", lg: "fyvr1n2", xl: "fyvr1n3" }, defaultClass: "fyvr1n0" }, "10": { conditions: { sm: "fyvr1n4", md: "fyvr1n5", lg: "fyvr1n6", xl: "fyvr1n7" }, defaultClass: "fyvr1n4" }, "12": { conditions: { sm: "fyvr1n8", md: "fyvr1n9", lg: "fyvr1na", xl: "fyvr1nb" }, defaultClass: "fyvr1n8" }, "14": { conditions: { sm: "fyvr1nc", md: "fyvr1nd", lg: "fyvr1ne", xl: "fyvr1nf" }, defaultClass: "fyvr1nc" }, "16": { conditions: { sm: "fyvr1ng", md: "fyvr1nh", lg: "fyvr1ni", xl: "fyvr1nj" }, defaultClass: "fyvr1ng" }, "18": { conditions: { sm: "fyvr1nk", md: "fyvr1nl", lg: "fyvr1nm", xl: "fyvr1nn" }, defaultClass: "fyvr1nk" }, "20": { conditions: { sm: "fyvr1no", md: "fyvr1np", lg: "fyvr1nq", xl: "fyvr1nr" }, defaultClass: "fyvr1no" }, "0.25": { conditions: { sm: "fyvr1ns", md: "fyvr1nt", lg: "fyvr1nu", xl: "fyvr1nv" }, defaultClass: "fyvr1ns" }, "0.5": { conditions: { sm: "fyvr1nw", md: "fyvr1nx", lg: "fyvr1ny", xl: "fyvr1nz" }, defaultClass: "fyvr1nw" }, "1.5": { conditions: { sm: "fyvr1o0", md: "fyvr1o1", lg: "fyvr1o2", xl: "fyvr1o3" }, defaultClass: "fyvr1o0" }, auto: { conditions: { sm: "fyvr1o4", md: "fyvr1o5", lg: "fyvr1o6", xl: "fyvr1o7" }, defaultClass: "fyvr1o4" } } }, bottom: { values: { "0": { conditions: { sm: "fyvr1o8", md: "fyvr1o9", lg: "fyvr1oa", xl: "fyvr1ob" }, defaultClass: "fyvr1o8" }, "1": { conditions: { sm: "fyvr1oc", md: "fyvr1od", lg: "fyvr1oe", xl: "fyvr1of" }, defaultClass: "fyvr1oc" }, "2": { conditions: { sm: "fyvr1og", md: "fyvr1oh", lg: "fyvr1oi", xl: "fyvr1oj" }, defaultClass: "fyvr1og" }, "3": { conditions: { sm: "fyvr1ok", md: "fyvr1ol", lg: "fyvr1om", xl: "fyvr1on" }, defaultClass: "fyvr1ok" }, "4": { conditions: { sm: "fyvr1oo", md: "fyvr1op", lg: "fyvr1oq", xl: "fyvr1or" }, defaultClass: "fyvr1oo" }, "5": { conditions: { sm: "fyvr1os", md: "fyvr1ot", lg: "fyvr1ou", xl: "fyvr1ov" }, defaultClass: "fyvr1os" }, "6": { conditions: { sm: "fyvr1ow", md: "fyvr1ox", lg: "fyvr1oy", xl: "fyvr1oz" }, defaultClass: "fyvr1ow" }, "7": { conditions: { sm: "fyvr1p0", md: "fyvr1p1", lg: "fyvr1p2", xl: "fyvr1p3" }, defaultClass: "fyvr1p0" }, "8": { conditions: { sm: "fyvr1p4", md: "fyvr1p5", lg: "fyvr1p6", xl: "fyvr1p7" }, defaultClass: "fyvr1p4" }, "9": { conditions: { sm: "fyvr1p8", md: "fyvr1p9", lg: "fyvr1pa", xl: "fyvr1pb" }, defaultClass: "fyvr1p8" }, "10": { conditions: { sm: "fyvr1pc", md: "fyvr1pd", lg: "fyvr1pe", xl: "fyvr1pf" }, defaultClass: "fyvr1pc" }, "12": { conditions: { sm: "fyvr1pg", md: "fyvr1ph", lg: "fyvr1pi", xl: "fyvr1pj" }, defaultClass: "fyvr1pg" }, "14": { conditions: { sm: "fyvr1pk", md: "fyvr1pl", lg: "fyvr1pm", xl: "fyvr1pn" }, defaultClass: "fyvr1pk" }, "16": { conditions: { sm: "fyvr1po", md: "fyvr1pp", lg: "fyvr1pq", xl: "fyvr1pr" }, defaultClass: "fyvr1po" }, "18": { conditions: { sm: "fyvr1ps", md: "fyvr1pt", lg: "fyvr1pu", xl: "fyvr1pv" }, defaultClass: "fyvr1ps" }, "20": { conditions: { sm: "fyvr1pw", md: "fyvr1px", lg: "fyvr1py", xl: "fyvr1pz" }, defaultClass: "fyvr1pw" }, "0.25": { conditions: { sm: "fyvr1q0", md: "fyvr1q1", lg: "fyvr1q2", xl: "fyvr1q3" }, defaultClass: "fyvr1q0" }, "0.5": { conditions: { sm: "fyvr1q4", md: "fyvr1q5", lg: "fyvr1q6", xl: "fyvr1q7" }, defaultClass: "fyvr1q4" }, "1.5": { conditions: { sm: "fyvr1q8", md: "fyvr1q9", lg: "fyvr1qa", xl: "fyvr1qb" }, defaultClass: "fyvr1q8" }, auto: { conditions: { sm: "fyvr1qc", md: "fyvr1qd", lg: "fyvr1qe", xl: "fyvr1qf" }, defaultClass: "fyvr1qc" } } }, left: { values: { "0": { conditions: { sm: "fyvr1qg", md: "fyvr1qh", lg: "fyvr1qi", xl: "fyvr1qj" }, defaultClass: "fyvr1qg" }, "1": { conditions: { sm: "fyvr1qk", md: "fyvr1ql", lg: "fyvr1qm", xl: "fyvr1qn" }, defaultClass: "fyvr1qk" }, "2": { conditions: { sm: "fyvr1qo", md: "fyvr1qp", lg: "fyvr1qq", xl: "fyvr1qr" }, defaultClass: "fyvr1qo" }, "3": { conditions: { sm: "fyvr1qs", md: "fyvr1qt", lg: "fyvr1qu", xl: "fyvr1qv" }, defaultClass: "fyvr1qs" }, "4": { conditions: { sm: "fyvr1qw", md: "fyvr1qx", lg: "fyvr1qy", xl: "fyvr1qz" }, defaultClass: "fyvr1qw" }, "5": { conditions: { sm: "fyvr1r0", md: "fyvr1r1", lg: "fyvr1r2", xl: "fyvr1r3" }, defaultClass: "fyvr1r0" }, "6": { conditions: { sm: "fyvr1r4", md: "fyvr1r5", lg: "fyvr1r6", xl: "fyvr1r7" }, defaultClass: "fyvr1r4" }, "7": { conditions: { sm: "fyvr1r8", md: "fyvr1r9", lg: "fyvr1ra", xl: "fyvr1rb" }, defaultClass: "fyvr1r8" }, "8": { conditions: { sm: "fyvr1rc", md: "fyvr1rd", lg: "fyvr1re", xl: "fyvr1rf" }, defaultClass: "fyvr1rc" }, "9": { conditions: { sm: "fyvr1rg", md: "fyvr1rh", lg: "fyvr1ri", xl: "fyvr1rj" }, defaultClass: "fyvr1rg" }, "10": { conditions: { sm: "fyvr1rk", md: "fyvr1rl", lg: "fyvr1rm", xl: "fyvr1rn" }, defaultClass: "fyvr1rk" }, "12": { conditions: { sm: "fyvr1ro", md: "fyvr1rp", lg: "fyvr1rq", xl: "fyvr1rr" }, defaultClass: "fyvr1ro" }, "14": { conditions: { sm: "fyvr1rs", md: "fyvr1rt", lg: "fyvr1ru", xl: "fyvr1rv" }, defaultClass: "fyvr1rs" }, "16": { conditions: { sm: "fyvr1rw", md: "fyvr1rx", lg: "fyvr1ry", xl: "fyvr1rz" }, defaultClass: "fyvr1rw" }, "18": { conditions: { sm: "fyvr1s0", md: "fyvr1s1", lg: "fyvr1s2", xl: "fyvr1s3" }, defaultClass: "fyvr1s0" }, "20": { conditions: { sm: "fyvr1s4", md: "fyvr1s5", lg: "fyvr1s6", xl: "fyvr1s7" }, defaultClass: "fyvr1s4" }, "0.25": { conditions: { sm: "fyvr1s8", md: "fyvr1s9", lg: "fyvr1sa", xl: "fyvr1sb" }, defaultClass: "fyvr1s8" }, "0.5": { conditions: { sm: "fyvr1sc", md: "fyvr1sd", lg: "fyvr1se", xl: "fyvr1sf" }, defaultClass: "fyvr1sc" }, "1.5": { conditions: { sm: "fyvr1sg", md: "fyvr1sh", lg: "fyvr1si", xl: "fyvr1sj" }, defaultClass: "fyvr1sg" }, auto: { conditions: { sm: "fyvr1sk", md: "fyvr1sl", lg: "fyvr1sm", xl: "fyvr1sn" }, defaultClass: "fyvr1sk" } } }, right: { values: { "0": { conditions: { sm: "fyvr1so", md: "fyvr1sp", lg: "fyvr1sq", xl: "fyvr1sr" }, defaultClass: "fyvr1so" }, "1": { conditions: { sm: "fyvr1ss", md: "fyvr1st", lg: "fyvr1su", xl: "fyvr1sv" }, defaultClass: "fyvr1ss" }, "2": { conditions: { sm: "fyvr1sw", md: "fyvr1sx", lg: "fyvr1sy", xl: "fyvr1sz" }, defaultClass: "fyvr1sw" }, "3": { conditions: { sm: "fyvr1t0", md: "fyvr1t1", lg: "fyvr1t2", xl: "fyvr1t3" }, defaultClass: "fyvr1t0" }, "4": { conditions: { sm: "fyvr1t4", md: "fyvr1t5", lg: "fyvr1t6", xl: "fyvr1t7" }, defaultClass: "fyvr1t4" }, "5": { conditions: { sm: "fyvr1t8", md: "fyvr1t9", lg: "fyvr1ta", xl: "fyvr1tb" }, defaultClass: "fyvr1t8" }, "6": { conditions: { sm: "fyvr1tc", md: "fyvr1td", lg: "fyvr1te", xl: "fyvr1tf" }, defaultClass: "fyvr1tc" }, "7": { conditions: { sm: "fyvr1tg", md: "fyvr1th", lg: "fyvr1ti", xl: "fyvr1tj" }, defaultClass: "fyvr1tg" }, "8": { conditions: { sm: "fyvr1tk", md: "fyvr1tl", lg: "fyvr1tm", xl: "fyvr1tn" }, defaultClass: "fyvr1tk" }, "9": { conditions: { sm: "fyvr1to", md: "fyvr1tp", lg: "fyvr1tq", xl: "fyvr1tr" }, defaultClass: "fyvr1to" }, "10": { conditions: { sm: "fyvr1ts", md: "fyvr1tt", lg: "fyvr1tu", xl: "fyvr1tv" }, defaultClass: "fyvr1ts" }, "12": { conditions: { sm: "fyvr1tw", md: "fyvr1tx", lg: "fyvr1ty", xl: "fyvr1tz" }, defaultClass: "fyvr1tw" }, "14": { conditions: { sm: "fyvr1u0", md: "fyvr1u1", lg: "fyvr1u2", xl: "fyvr1u3" }, defaultClass: "fyvr1u0" }, "16": { conditions: { sm: "fyvr1u4", md: "fyvr1u5", lg: "fyvr1u6", xl: "fyvr1u7" }, defaultClass: "fyvr1u4" }, "18": { conditions: { sm: "fyvr1u8", md: "fyvr1u9", lg: "fyvr1ua", xl: "fyvr1ub" }, defaultClass: "fyvr1u8" }, "20": { conditions: { sm: "fyvr1uc", md: "fyvr1ud", lg: "fyvr1ue", xl: "fyvr1uf" }, defaultClass: "fyvr1uc" }, "0.25": { conditions: { sm: "fyvr1ug", md: "fyvr1uh", lg: "fyvr1ui", xl: "fyvr1uj" }, defaultClass: "fyvr1ug" }, "0.5": { conditions: { sm: "fyvr1uk", md: "fyvr1ul", lg: "fyvr1um", xl: "fyvr1un" }, defaultClass: "fyvr1uk" }, "1.5": { conditions: { sm: "fyvr1uo", md: "fyvr1up", lg: "fyvr1uq", xl: "fyvr1ur" }, defaultClass: "fyvr1uo" }, auto: { conditions: { sm: "fyvr1us", md: "fyvr1ut", lg: "fyvr1uu", xl: "fyvr1uv" }, defaultClass: "fyvr1us" } } }, paddingTop: { values: { "0": { conditions: { sm: "fyvr1uw", md: "fyvr1ux", lg: "fyvr1uy", xl: "fyvr1uz" }, defaultClass: "fyvr1uw" }, "1": { conditions: { sm: "fyvr1v0", md: "fyvr1v1", lg: "fyvr1v2", xl: "fyvr1v3" }, defaultClass: "fyvr1v0" }, "2": { conditions: { sm: "fyvr1v4", md: "fyvr1v5", lg: "fyvr1v6", xl: "fyvr1v7" }, defaultClass: "fyvr1v4" }, "3": { conditions: { sm: "fyvr1v8", md: "fyvr1v9", lg: "fyvr1va", xl: "fyvr1vb" }, defaultClass: "fyvr1v8" }, "4": { conditions: { sm: "fyvr1vc", md: "fyvr1vd", lg: "fyvr1ve", xl: "fyvr1vf" }, defaultClass: "fyvr1vc" }, "5": { conditions: { sm: "fyvr1vg", md: "fyvr1vh", lg: "fyvr1vi", xl: "fyvr1vj" }, defaultClass: "fyvr1vg" }, "6": { conditions: { sm: "fyvr1vk", md: "fyvr1vl", lg: "fyvr1vm", xl: "fyvr1vn" }, defaultClass: "fyvr1vk" }, "7": { conditions: { sm: "fyvr1vo", md: "fyvr1vp", lg: "fyvr1vq", xl: "fyvr1vr" }, defaultClass: "fyvr1vo" }, "8": { conditions: { sm: "fyvr1vs", md: "fyvr1vt", lg: "fyvr1vu", xl: "fyvr1vv" }, defaultClass: "fyvr1vs" }, "9": { conditions: { sm: "fyvr1vw", md: "fyvr1vx", lg: "fyvr1vy", xl: "fyvr1vz" }, defaultClass: "fyvr1vw" }, "10": { conditions: { sm: "fyvr1w0", md: "fyvr1w1", lg: "fyvr1w2", xl: "fyvr1w3" }, defaultClass: "fyvr1w0" }, "12": { conditions: { sm: "fyvr1w4", md: "fyvr1w5", lg: "fyvr1w6", xl: "fyvr1w7" }, defaultClass: "fyvr1w4" }, "14": { conditions: { sm: "fyvr1w8", md: "fyvr1w9", lg: "fyvr1wa", xl: "fyvr1wb" }, defaultClass: "fyvr1w8" }, "16": { conditions: { sm: "fyvr1wc", md: "fyvr1wd", lg: "fyvr1we", xl: "fyvr1wf" }, defaultClass: "fyvr1wc" }, "18": { conditions: { sm: "fyvr1wg", md: "fyvr1wh", lg: "fyvr1wi", xl: "fyvr1wj" }, defaultClass: "fyvr1wg" }, "20": { conditions: { sm: "fyvr1wk", md: "fyvr1wl", lg: "fyvr1wm", xl: "fyvr1wn" }, defaultClass: "fyvr1wk" }, "0.25": { conditions: { sm: "fyvr1wo", md: "fyvr1wp", lg: "fyvr1wq", xl: "fyvr1wr" }, defaultClass: "fyvr1wo" }, "0.5": { conditions: { sm: "fyvr1ws", md: "fyvr1wt", lg: "fyvr1wu", xl: "fyvr1wv" }, defaultClass: "fyvr1ws" }, "1.5": { conditions: { sm: "fyvr1ww", md: "fyvr1wx", lg: "fyvr1wy", xl: "fyvr1wz" }, defaultClass: "fyvr1ww" } } }, paddingBottom: { values: { "0": { conditions: { sm: "fyvr1x0", md: "fyvr1x1", lg: "fyvr1x2", xl: "fyvr1x3" }, defaultClass: "fyvr1x0" }, "1": { conditions: { sm: "fyvr1x4", md: "fyvr1x5", lg: "fyvr1x6", xl: "fyvr1x7" }, defaultClass: "fyvr1x4" }, "2": { conditions: { sm: "fyvr1x8", md: "fyvr1x9", lg: "fyvr1xa", xl: "fyvr1xb" }, defaultClass: "fyvr1x8" }, "3": { conditions: { sm: "fyvr1xc", md: "fyvr1xd", lg: "fyvr1xe", xl: "fyvr1xf" }, defaultClass: "fyvr1xc" }, "4": { conditions: { sm: "fyvr1xg", md: "fyvr1xh", lg: "fyvr1xi", xl: "fyvr1xj" }, defaultClass: "fyvr1xg" }, "5": { conditions: { sm: "fyvr1xk", md: "fyvr1xl", lg: "fyvr1xm", xl: "fyvr1xn" }, defaultClass: "fyvr1xk" }, "6": { conditions: { sm: "fyvr1xo", md: "fyvr1xp", lg: "fyvr1xq", xl: "fyvr1xr" }, defaultClass: "fyvr1xo" }, "7": { conditions: { sm: "fyvr1xs", md: "fyvr1xt", lg: "fyvr1xu", xl: "fyvr1xv" }, defaultClass: "fyvr1xs" }, "8": { conditions: { sm: "fyvr1xw", md: "fyvr1xx", lg: "fyvr1xy", xl: "fyvr1xz" }, defaultClass: "fyvr1xw" }, "9": { conditions: { sm: "fyvr1y0", md: "fyvr1y1", lg: "fyvr1y2", xl: "fyvr1y3" }, defaultClass: "fyvr1y0" }, "10": { conditions: { sm: "fyvr1y4", md: "fyvr1y5", lg: "fyvr1y6", xl: "fyvr1y7" }, defaultClass: "fyvr1y4" }, "12": { conditions: { sm: "fyvr1y8", md: "fyvr1y9", lg: "fyvr1ya", xl: "fyvr1yb" }, defaultClass: "fyvr1y8" }, "14": { conditions: { sm: "fyvr1yc", md: "fyvr1yd", lg: "fyvr1ye", xl: "fyvr1yf" }, defaultClass: "fyvr1yc" }, "16": { conditions: { sm: "fyvr1yg", md: "fyvr1yh", lg: "fyvr1yi", xl: "fyvr1yj" }, defaultClass: "fyvr1yg" }, "18": { conditions: { sm: "fyvr1yk", md: "fyvr1yl", lg: "fyvr1ym", xl: "fyvr1yn" }, defaultClass: "fyvr1yk" }, "20": { conditions: { sm: "fyvr1yo", md: "fyvr1yp", lg: "fyvr1yq", xl: "fyvr1yr" }, defaultClass: "fyvr1yo" }, "0.25": { conditions: { sm: "fyvr1ys", md: "fyvr1yt", lg: "fyvr1yu", xl: "fyvr1yv" }, defaultClass: "fyvr1ys" }, "0.5": { conditions: { sm: "fyvr1yw", md: "fyvr1yx", lg: "fyvr1yy", xl: "fyvr1yz" }, defaultClass: "fyvr1yw" }, "1.5": { conditions: { sm: "fyvr1z0", md: "fyvr1z1", lg: "fyvr1z2", xl: "fyvr1z3" }, defaultClass: "fyvr1z0" } } }, paddingLeft: { values: { "0": { conditions: { sm: "fyvr1z4", md: "fyvr1z5", lg: "fyvr1z6", xl: "fyvr1z7" }, defaultClass: "fyvr1z4" }, "1": { conditions: { sm: "fyvr1z8", md: "fyvr1z9", lg: "fyvr1za", xl: "fyvr1zb" }, defaultClass: "fyvr1z8" }, "2": { conditions: { sm: "fyvr1zc", md: "fyvr1zd", lg: "fyvr1ze", xl: "fyvr1zf" }, defaultClass: "fyvr1zc" }, "3": { conditions: { sm: "fyvr1zg", md: "fyvr1zh", lg: "fyvr1zi", xl: "fyvr1zj" }, defaultClass: "fyvr1zg" }, "4": { conditions: { sm: "fyvr1zk", md: "fyvr1zl", lg: "fyvr1zm", xl: "fyvr1zn" }, defaultClass: "fyvr1zk" }, "5": { conditions: { sm: "fyvr1zo", md: "fyvr1zp", lg: "fyvr1zq", xl: "fyvr1zr" }, defaultClass: "fyvr1zo" }, "6": { conditions: { sm: "fyvr1zs", md: "fyvr1zt", lg: "fyvr1zu", xl: "fyvr1zv" }, defaultClass: "fyvr1zs" }, "7": { conditions: { sm: "fyvr1zw", md: "fyvr1zx", lg: "fyvr1zy", xl: "fyvr1zz" }, defaultClass: "fyvr1zw" }, "8": { conditions: { sm: "fyvr1100", md: "fyvr1101", lg: "fyvr1102", xl: "fyvr1103" }, defaultClass: "fyvr1100" }, "9": { conditions: { sm: "fyvr1104", md: "fyvr1105", lg: "fyvr1106", xl: "fyvr1107" }, defaultClass: "fyvr1104" }, "10": { conditions: { sm: "fyvr1108", md: "fyvr1109", lg: "fyvr110a", xl: "fyvr110b" }, defaultClass: "fyvr1108" }, "12": { conditions: { sm: "fyvr110c", md: "fyvr110d", lg: "fyvr110e", xl: "fyvr110f" }, defaultClass: "fyvr110c" }, "14": { conditions: { sm: "fyvr110g", md: "fyvr110h", lg: "fyvr110i", xl: "fyvr110j" }, defaultClass: "fyvr110g" }, "16": { conditions: { sm: "fyvr110k", md: "fyvr110l", lg: "fyvr110m", xl: "fyvr110n" }, defaultClass: "fyvr110k" }, "18": { conditions: { sm: "fyvr110o", md: "fyvr110p", lg: "fyvr110q", xl: "fyvr110r" }, defaultClass: "fyvr110o" }, "20": { conditions: { sm: "fyvr110s", md: "fyvr110t", lg: "fyvr110u", xl: "fyvr110v" }, defaultClass: "fyvr110s" }, "0.25": { conditions: { sm: "fyvr110w", md: "fyvr110x", lg: "fyvr110y", xl: "fyvr110z" }, defaultClass: "fyvr110w" }, "0.5": { conditions: { sm: "fyvr1110", md: "fyvr1111", lg: "fyvr1112", xl: "fyvr1113" }, defaultClass: "fyvr1110" }, "1.5": { conditions: { sm: "fyvr1114", md: "fyvr1115", lg: "fyvr1116", xl: "fyvr1117" }, defaultClass: "fyvr1114" } } }, paddingRight: { values: { "0": { conditions: { sm: "fyvr1118", md: "fyvr1119", lg: "fyvr111a", xl: "fyvr111b" }, defaultClass: "fyvr1118" }, "1": { conditions: { sm: "fyvr111c", md: "fyvr111d", lg: "fyvr111e", xl: "fyvr111f" }, defaultClass: "fyvr111c" }, "2": { conditions: { sm: "fyvr111g", md: "fyvr111h", lg: "fyvr111i", xl: "fyvr111j" }, defaultClass: "fyvr111g" }, "3": { conditions: { sm: "fyvr111k", md: "fyvr111l", lg: "fyvr111m", xl: "fyvr111n" }, defaultClass: "fyvr111k" }, "4": { conditions: { sm: "fyvr111o", md: "fyvr111p", lg: "fyvr111q", xl: "fyvr111r" }, defaultClass: "fyvr111o" }, "5": { conditions: { sm: "fyvr111s", md: "fyvr111t", lg: "fyvr111u", xl: "fyvr111v" }, defaultClass: "fyvr111s" }, "6": { conditions: { sm: "fyvr111w", md: "fyvr111x", lg: "fyvr111y", xl: "fyvr111z" }, defaultClass: "fyvr111w" }, "7": { conditions: { sm: "fyvr1120", md: "fyvr1121", lg: "fyvr1122", xl: "fyvr1123" }, defaultClass: "fyvr1120" }, "8": { conditions: { sm: "fyvr1124", md: "fyvr1125", lg: "fyvr1126", xl: "fyvr1127" }, defaultClass: "fyvr1124" }, "9": { conditions: { sm: "fyvr1128", md: "fyvr1129", lg: "fyvr112a", xl: "fyvr112b" }, defaultClass: "fyvr1128" }, "10": { conditions: { sm: "fyvr112c", md: "fyvr112d", lg: "fyvr112e", xl: "fyvr112f" }, defaultClass: "fyvr112c" }, "12": { conditions: { sm: "fyvr112g", md: "fyvr112h", lg: "fyvr112i", xl: "fyvr112j" }, defaultClass: "fyvr112g" }, "14": { conditions: { sm: "fyvr112k", md: "fyvr112l", lg: "fyvr112m", xl: "fyvr112n" }, defaultClass: "fyvr112k" }, "16": { conditions: { sm: "fyvr112o", md: "fyvr112p", lg: "fyvr112q", xl: "fyvr112r" }, defaultClass: "fyvr112o" }, "18": { conditions: { sm: "fyvr112s", md: "fyvr112t", lg: "fyvr112u", xl: "fyvr112v" }, defaultClass: "fyvr112s" }, "20": { conditions: { sm: "fyvr112w", md: "fyvr112x", lg: "fyvr112y", xl: "fyvr112z" }, defaultClass: "fyvr112w" }, "0.25": { conditions: { sm: "fyvr1130", md: "fyvr1131", lg: "fyvr1132", xl: "fyvr1133" }, defaultClass: "fyvr1130" }, "0.5": { conditions: { sm: "fyvr1134", md: "fyvr1135", lg: "fyvr1136", xl: "fyvr1137" }, defaultClass: "fyvr1134" }, "1.5": { conditions: { sm: "fyvr1138", md: "fyvr1139", lg: "fyvr113a", xl: "fyvr113b" }, defaultClass: "fyvr1138" } } }, marginTop: { values: { "0": { conditions: { sm: "fyvr113c", md: "fyvr113d", lg: "fyvr113e", xl: "fyvr113f" }, defaultClass: "fyvr113c" }, "1": { conditions: { sm: "fyvr113g", md: "fyvr113h", lg: "fyvr113i", xl: "fyvr113j" }, defaultClass: "fyvr113g" }, "2": { conditions: { sm: "fyvr113k", md: "fyvr113l", lg: "fyvr113m", xl: "fyvr113n" }, defaultClass: "fyvr113k" }, "3": { conditions: { sm: "fyvr113o", md: "fyvr113p", lg: "fyvr113q", xl: "fyvr113r" }, defaultClass: "fyvr113o" }, "4": { conditions: { sm: "fyvr113s", md: "fyvr113t", lg: "fyvr113u", xl: "fyvr113v" }, defaultClass: "fyvr113s" }, "5": { conditions: { sm: "fyvr113w", md: "fyvr113x", lg: "fyvr113y", xl: "fyvr113z" }, defaultClass: "fyvr113w" }, "6": { conditions: { sm: "fyvr1140", md: "fyvr1141", lg: "fyvr1142", xl: "fyvr1143" }, defaultClass: "fyvr1140" }, "7": { conditions: { sm: "fyvr1144", md: "fyvr1145", lg: "fyvr1146", xl: "fyvr1147" }, defaultClass: "fyvr1144" }, "8": { conditions: { sm: "fyvr1148", md: "fyvr1149", lg: "fyvr114a", xl: "fyvr114b" }, defaultClass: "fyvr1148" }, "9": { conditions: { sm: "fyvr114c", md: "fyvr114d", lg: "fyvr114e", xl: "fyvr114f" }, defaultClass: "fyvr114c" }, "10": { conditions: { sm: "fyvr114g", md: "fyvr114h", lg: "fyvr114i", xl: "fyvr114j" }, defaultClass: "fyvr114g" }, "12": { conditions: { sm: "fyvr114k", md: "fyvr114l", lg: "fyvr114m", xl: "fyvr114n" }, defaultClass: "fyvr114k" }, "14": { conditions: { sm: "fyvr114o", md: "fyvr114p", lg: "fyvr114q", xl: "fyvr114r" }, defaultClass: "fyvr114o" }, "16": { conditions: { sm: "fyvr114s", md: "fyvr114t", lg: "fyvr114u", xl: "fyvr114v" }, defaultClass: "fyvr114s" }, "18": { conditions: { sm: "fyvr114w", md: "fyvr114x", lg: "fyvr114y", xl: "fyvr114z" }, defaultClass: "fyvr114w" }, "20": { conditions: { sm: "fyvr1150", md: "fyvr1151", lg: "fyvr1152", xl: "fyvr1153" }, defaultClass: "fyvr1150" }, "0.25": { conditions: { sm: "fyvr1154", md: "fyvr1155", lg: "fyvr1156", xl: "fyvr1157" }, defaultClass: "fyvr1154" }, "0.5": { conditions: { sm: "fyvr1158", md: "fyvr1159", lg: "fyvr115a", xl: "fyvr115b" }, defaultClass: "fyvr1158" }, "1.5": { conditions: { sm: "fyvr115c", md: "fyvr115d", lg: "fyvr115e", xl: "fyvr115f" }, defaultClass: "fyvr115c" }, auto: { conditions: { sm: "fyvr115g", md: "fyvr115h", lg: "fyvr115i", xl: "fyvr115j" }, defaultClass: "fyvr115g" } } }, marginBottom: { values: { "0": { conditions: { sm: "fyvr115k", md: "fyvr115l", lg: "fyvr115m", xl: "fyvr115n" }, defaultClass: "fyvr115k" }, "1": { conditions: { sm: "fyvr115o", md: "fyvr115p", lg: "fyvr115q", xl: "fyvr115r" }, defaultClass: "fyvr115o" }, "2": { conditions: { sm: "fyvr115s", md: "fyvr115t", lg: "fyvr115u", xl: "fyvr115v" }, defaultClass: "fyvr115s" }, "3": { conditions: { sm: "fyvr115w", md: "fyvr115x", lg: "fyvr115y", xl: "fyvr115z" }, defaultClass: "fyvr115w" }, "4": { conditions: { sm: "fyvr1160", md: "fyvr1161", lg: "fyvr1162", xl: "fyvr1163" }, defaultClass: "fyvr1160" }, "5": { conditions: { sm: "fyvr1164", md: "fyvr1165", lg: "fyvr1166", xl: "fyvr1167" }, defaultClass: "fyvr1164" }, "6": { conditions: { sm: "fyvr1168", md: "fyvr1169", lg: "fyvr116a", xl: "fyvr116b" }, defaultClass: "fyvr1168" }, "7": { conditions: { sm: "fyvr116c", md: "fyvr116d", lg: "fyvr116e", xl: "fyvr116f" }, defaultClass: "fyvr116c" }, "8": { conditions: { sm: "fyvr116g", md: "fyvr116h", lg: "fyvr116i", xl: "fyvr116j" }, defaultClass: "fyvr116g" }, "9": { conditions: { sm: "fyvr116k", md: "fyvr116l", lg: "fyvr116m", xl: "fyvr116n" }, defaultClass: "fyvr116k" }, "10": { conditions: { sm: "fyvr116o", md: "fyvr116p", lg: "fyvr116q", xl: "fyvr116r" }, defaultClass: "fyvr116o" }, "12": { conditions: { sm: "fyvr116s", md: "fyvr116t", lg: "fyvr116u", xl: "fyvr116v" }, defaultClass: "fyvr116s" }, "14": { conditions: { sm: "fyvr116w", md: "fyvr116x", lg: "fyvr116y", xl: "fyvr116z" }, defaultClass: "fyvr116w" }, "16": { conditions: { sm: "fyvr1170", md: "fyvr1171", lg: "fyvr1172", xl: "fyvr1173" }, defaultClass: "fyvr1170" }, "18": { conditions: { sm: "fyvr1174", md: "fyvr1175", lg: "fyvr1176", xl: "fyvr1177" }, defaultClass: "fyvr1174" }, "20": { conditions: { sm: "fyvr1178", md: "fyvr1179", lg: "fyvr117a", xl: "fyvr117b" }, defaultClass: "fyvr1178" }, "0.25": { conditions: { sm: "fyvr117c", md: "fyvr117d", lg: "fyvr117e", xl: "fyvr117f" }, defaultClass: "fyvr117c" }, "0.5": { conditions: { sm: "fyvr117g", md: "fyvr117h", lg: "fyvr117i", xl: "fyvr117j" }, defaultClass: "fyvr117g" }, "1.5": { conditions: { sm: "fyvr117k", md: "fyvr117l", lg: "fyvr117m", xl: "fyvr117n" }, defaultClass: "fyvr117k" }, auto: { conditions: { sm: "fyvr117o", md: "fyvr117p", lg: "fyvr117q", xl: "fyvr117r" }, defaultClass: "fyvr117o" } } }, marginLeft: { values: { "0": { conditions: { sm: "fyvr117s", md: "fyvr117t", lg: "fyvr117u", xl: "fyvr117v" }, defaultClass: "fyvr117s" }, "1": { conditions: { sm: "fyvr117w", md: "fyvr117x", lg: "fyvr117y", xl: "fyvr117z" }, defaultClass: "fyvr117w" }, "2": { conditions: { sm: "fyvr1180", md: "fyvr1181", lg: "fyvr1182", xl: "fyvr1183" }, defaultClass: "fyvr1180" }, "3": { conditions: { sm: "fyvr1184", md: "fyvr1185", lg: "fyvr1186", xl: "fyvr1187" }, defaultClass: "fyvr1184" }, "4": { conditions: { sm: "fyvr1188", md: "fyvr1189", lg: "fyvr118a", xl: "fyvr118b" }, defaultClass: "fyvr1188" }, "5": { conditions: { sm: "fyvr118c", md: "fyvr118d", lg: "fyvr118e", xl: "fyvr118f" }, defaultClass: "fyvr118c" }, "6": { conditions: { sm: "fyvr118g", md: "fyvr118h", lg: "fyvr118i", xl: "fyvr118j" }, defaultClass: "fyvr118g" }, "7": { conditions: { sm: "fyvr118k", md: "fyvr118l", lg: "fyvr118m", xl: "fyvr118n" }, defaultClass: "fyvr118k" }, "8": { conditions: { sm: "fyvr118o", md: "fyvr118p", lg: "fyvr118q", xl: "fyvr118r" }, defaultClass: "fyvr118o" }, "9": { conditions: { sm: "fyvr118s", md: "fyvr118t", lg: "fyvr118u", xl: "fyvr118v" }, defaultClass: "fyvr118s" }, "10": { conditions: { sm: "fyvr118w", md: "fyvr118x", lg: "fyvr118y", xl: "fyvr118z" }, defaultClass: "fyvr118w" }, "12": { conditions: { sm: "fyvr1190", md: "fyvr1191", lg: "fyvr1192", xl: "fyvr1193" }, defaultClass: "fyvr1190" }, "14": { conditions: { sm: "fyvr1194", md: "fyvr1195", lg: "fyvr1196", xl: "fyvr1197" }, defaultClass: "fyvr1194" }, "16": { conditions: { sm: "fyvr1198", md: "fyvr1199", lg: "fyvr119a", xl: "fyvr119b" }, defaultClass: "fyvr1198" }, "18": { conditions: { sm: "fyvr119c", md: "fyvr119d", lg: "fyvr119e", xl: "fyvr119f" }, defaultClass: "fyvr119c" }, "20": { conditions: { sm: "fyvr119g", md: "fyvr119h", lg: "fyvr119i", xl: "fyvr119j" }, defaultClass: "fyvr119g" }, "0.25": { conditions: { sm: "fyvr119k", md: "fyvr119l", lg: "fyvr119m", xl: "fyvr119n" }, defaultClass: "fyvr119k" }, "0.5": { conditions: { sm: "fyvr119o", md: "fyvr119p", lg: "fyvr119q", xl: "fyvr119r" }, defaultClass: "fyvr119o" }, "1.5": { conditions: { sm: "fyvr119s", md: "fyvr119t", lg: "fyvr119u", xl: "fyvr119v" }, defaultClass: "fyvr119s" }, auto: { conditions: { sm: "fyvr119w", md: "fyvr119x", lg: "fyvr119y", xl: "fyvr119z" }, defaultClass: "fyvr119w" } } }, marginRight: { values: { "0": { conditions: { sm: "fyvr11a0", md: "fyvr11a1", lg: "fyvr11a2", xl: "fyvr11a3" }, defaultClass: "fyvr11a0" }, "1": { conditions: { sm: "fyvr11a4", md: "fyvr11a5", lg: "fyvr11a6", xl: "fyvr11a7" }, defaultClass: "fyvr11a4" }, "2": { conditions: { sm: "fyvr11a8", md: "fyvr11a9", lg: "fyvr11aa", xl: "fyvr11ab" }, defaultClass: "fyvr11a8" }, "3": { conditions: { sm: "fyvr11ac", md: "fyvr11ad", lg: "fyvr11ae", xl: "fyvr11af" }, defaultClass: "fyvr11ac" }, "4": { conditions: { sm: "fyvr11ag", md: "fyvr11ah", lg: "fyvr11ai", xl: "fyvr11aj" }, defaultClass: "fyvr11ag" }, "5": { conditions: { sm: "fyvr11ak", md: "fyvr11al", lg: "fyvr11am", xl: "fyvr11an" }, defaultClass: "fyvr11ak" }, "6": { conditions: { sm: "fyvr11ao", md: "fyvr11ap", lg: "fyvr11aq", xl: "fyvr11ar" }, defaultClass: "fyvr11ao" }, "7": { conditions: { sm: "fyvr11as", md: "fyvr11at", lg: "fyvr11au", xl: "fyvr11av" }, defaultClass: "fyvr11as" }, "8": { conditions: { sm: "fyvr11aw", md: "fyvr11ax", lg: "fyvr11ay", xl: "fyvr11az" }, defaultClass: "fyvr11aw" }, "9": { conditions: { sm: "fyvr11b0", md: "fyvr11b1", lg: "fyvr11b2", xl: "fyvr11b3" }, defaultClass: "fyvr11b0" }, "10": { conditions: { sm: "fyvr11b4", md: "fyvr11b5", lg: "fyvr11b6", xl: "fyvr11b7" }, defaultClass: "fyvr11b4" }, "12": { conditions: { sm: "fyvr11b8", md: "fyvr11b9", lg: "fyvr11ba", xl: "fyvr11bb" }, defaultClass: "fyvr11b8" }, "14": { conditions: { sm: "fyvr11bc", md: "fyvr11bd", lg: "fyvr11be", xl: "fyvr11bf" }, defaultClass: "fyvr11bc" }, "16": { conditions: { sm: "fyvr11bg", md: "fyvr11bh", lg: "fyvr11bi", xl: "fyvr11bj" }, defaultClass: "fyvr11bg" }, "18": { conditions: { sm: "fyvr11bk", md: "fyvr11bl", lg: "fyvr11bm", xl: "fyvr11bn" }, defaultClass: "fyvr11bk" }, "20": { conditions: { sm: "fyvr11bo", md: "fyvr11bp", lg: "fyvr11bq", xl: "fyvr11br" }, defaultClass: "fyvr11bo" }, "0.25": { conditions: { sm: "fyvr11bs", md: "fyvr11bt", lg: "fyvr11bu", xl: "fyvr11bv" }, defaultClass: "fyvr11bs" }, "0.5": { conditions: { sm: "fyvr11bw", md: "fyvr11bx", lg: "fyvr11by", xl: "fyvr11bz" }, defaultClass: "fyvr11bw" }, "1.5": { conditions: { sm: "fyvr11c0", md: "fyvr11c1", lg: "fyvr11c2", xl: "fyvr11c3" }, defaultClass: "fyvr11c0" }, auto: { conditions: { sm: "fyvr11c4", md: "fyvr11c5", lg: "fyvr11c6", xl: "fyvr11c7" }, defaultClass: "fyvr11c4" } } }, gap: { values: { "0": { conditions: { sm: "fyvr11c8", md: "fyvr11c9", lg: "fyvr11ca", xl: "fyvr11cb" }, defaultClass: "fyvr11c8" }, "1": { conditions: { sm: "fyvr11cc", md: "fyvr11cd", lg: "fyvr11ce", xl: "fyvr11cf" }, defaultClass: "fyvr11cc" }, "2": { conditions: { sm: "fyvr11cg", md: "fyvr11ch", lg: "fyvr11ci", xl: "fyvr11cj" }, defaultClass: "fyvr11cg" }, "3": { conditions: { sm: "fyvr11ck", md: "fyvr11cl", lg: "fyvr11cm", xl: "fyvr11cn" }, defaultClass: "fyvr11ck" }, "4": { conditions: { sm: "fyvr11co", md: "fyvr11cp", lg: "fyvr11cq", xl: "fyvr11cr" }, defaultClass: "fyvr11co" }, "5": { conditions: { sm: "fyvr11cs", md: "fyvr11ct", lg: "fyvr11cu", xl: "fyvr11cv" }, defaultClass: "fyvr11cs" }, "6": { conditions: { sm: "fyvr11cw", md: "fyvr11cx", lg: "fyvr11cy", xl: "fyvr11cz" }, defaultClass: "fyvr11cw" }, "7": { conditions: { sm: "fyvr11d0", md: "fyvr11d1", lg: "fyvr11d2", xl: "fyvr11d3" }, defaultClass: "fyvr11d0" }, "8": { conditions: { sm: "fyvr11d4", md: "fyvr11d5", lg: "fyvr11d6", xl: "fyvr11d7" }, defaultClass: "fyvr11d4" }, "9": { conditions: { sm: "fyvr11d8", md: "fyvr11d9", lg: "fyvr11da", xl: "fyvr11db" }, defaultClass: "fyvr11d8" }, "10": { conditions: { sm: "fyvr11dc", md: "fyvr11dd", lg: "fyvr11de", xl: "fyvr11df" }, defaultClass: "fyvr11dc" }, "12": { conditions: { sm: "fyvr11dg", md: "fyvr11dh", lg: "fyvr11di", xl: "fyvr11dj" }, defaultClass: "fyvr11dg" }, "14": { conditions: { sm: "fyvr11dk", md: "fyvr11dl", lg: "fyvr11dm", xl: "fyvr11dn" }, defaultClass: "fyvr11dk" }, "16": { conditions: { sm: "fyvr11do", md: "fyvr11dp", lg: "fyvr11dq", xl: "fyvr11dr" }, defaultClass: "fyvr11do" }, "18": { conditions: { sm: "fyvr11ds", md: "fyvr11dt", lg: "fyvr11du", xl: "fyvr11dv" }, defaultClass: "fyvr11ds" }, "20": { conditions: { sm: "fyvr11dw", md: "fyvr11dx", lg: "fyvr11dy", xl: "fyvr11dz" }, defaultClass: "fyvr11dw" }, "0.25": { conditions: { sm: "fyvr11e0", md: "fyvr11e1", lg: "fyvr11e2", xl: "fyvr11e3" }, defaultClass: "fyvr11e0" }, "0.5": { conditions: { sm: "fyvr11e4", md: "fyvr11e5", lg: "fyvr11e6", xl: "fyvr11e7" }, defaultClass: "fyvr11e4" }, "1.5": { conditions: { sm: "fyvr11e8", md: "fyvr11e9", lg: "fyvr11ea", xl: "fyvr11eb" }, defaultClass: "fyvr11e8" } } }, borderBottomWidth: { values: { none: { conditions: { sm: "fyvr11ec", md: "fyvr11ed", lg: "fyvr11ee", xl: "fyvr11ef" }, defaultClass: "fyvr11ec" }, thin: { conditions: { sm: "fyvr11eg", md: "fyvr11eh", lg: "fyvr11ei", xl: "fyvr11ej" }, defaultClass: "fyvr11eg" }, thick: { conditions: { sm: "fyvr11ek", md: "fyvr11el", lg: "fyvr11em", xl: "fyvr11en" }, defaultClass: "fyvr11ek" } } }, borderLeftWidth: { values: { none: { conditions: { sm: "fyvr11eo", md: "fyvr11ep", lg: "fyvr11eq", xl: "fyvr11er" }, defaultClass: "fyvr11eo" }, thin: { conditions: { sm: "fyvr11es", md: "fyvr11et", lg: "fyvr11eu", xl: "fyvr11ev" }, defaultClass: "fyvr11es" }, thick: { conditions: { sm: "fyvr11ew", md: "fyvr11ex", lg: "fyvr11ey", xl: "fyvr11ez" }, defaultClass: "fyvr11ew" } } }, borderRightWidth: { values: { none: { conditions: { sm: "fyvr11f0", md: "fyvr11f1", lg: "fyvr11f2", xl: "fyvr11f3" }, defaultClass: "fyvr11f0" }, thin: { conditions: { sm: "fyvr11f4", md: "fyvr11f5", lg: "fyvr11f6", xl: "fyvr11f7" }, defaultClass: "fyvr11f4" }, thick: { conditions: { sm: "fyvr11f8", md: "fyvr11f9", lg: "fyvr11fa", xl: "fyvr11fb" }, defaultClass: "fyvr11f8" } } }, borderTopWidth: { values: { none: { conditions: { sm: "fyvr11fc", md: "fyvr11fd", lg: "fyvr11fe", xl: "fyvr11ff" }, defaultClass: "fyvr11fc" }, thin: { conditions: { sm: "fyvr11fg", md: "fyvr11fh", lg: "fyvr11fi", xl: "fyvr11fj" }, defaultClass: "fyvr11fg" }, thick: { conditions: { sm: "fyvr11fk", md: "fyvr11fl", lg: "fyvr11fm", xl: "fyvr11fn" }, defaultClass: "fyvr11fk" } } }, borderBottomLeftRadius: { values: { none: { conditions: { sm: "fyvr11fo", md: "fyvr11fp", lg: "fyvr11fq", xl: "fyvr11fr" }, defaultClass: "fyvr11fo" }, xs: { conditions: { sm: "fyvr11fs", md: "fyvr11ft", lg: "fyvr11fu", xl: "fyvr11fv" }, defaultClass: "fyvr11fs" }, sm: { conditions: { sm: "fyvr11fw", md: "fyvr11fx", lg: "fyvr11fy", xl: "fyvr11fz" }, defaultClass: "fyvr11fw" }, md: { conditions: { sm: "fyvr11g0", md: "fyvr11g1", lg: "fyvr11g2", xl: "fyvr11g3" }, defaultClass: "fyvr11g0" }, lg: { conditions: { sm: "fyvr11g4", md: "fyvr11g5", lg: "fyvr11g6", xl: "fyvr11g7" }, defaultClass: "fyvr11g4" }, circle: { conditions: { sm: "fyvr11g8", md: "fyvr11g9", lg: "fyvr11ga", xl: "fyvr11gb" }, defaultClass: "fyvr11g8" } } }, borderBottomRightRadius: { values: { none: { conditions: { sm: "fyvr11gc", md: "fyvr11gd", lg: "fyvr11ge", xl: "fyvr11gf" }, defaultClass: "fyvr11gc" }, xs: { conditions: { sm: "fyvr11gg", md: "fyvr11gh", lg: "fyvr11gi", xl: "fyvr11gj" }, defaultClass: "fyvr11gg" }, sm: { conditions: { sm: "fyvr11gk", md: "fyvr11gl", lg: "fyvr11gm", xl: "fyvr11gn" }, defaultClass: "fyvr11gk" }, md: { conditions: { sm: "fyvr11go", md: "fyvr11gp", lg: "fyvr11gq", xl: "fyvr11gr" }, defaultClass: "fyvr11go" }, lg: { conditions: { sm: "fyvr11gs", md: "fyvr11gt", lg: "fyvr11gu", xl: "fyvr11gv" }, defaultClass: "fyvr11gs" }, circle: { conditions: { sm: "fyvr11gw", md: "fyvr11gx", lg: "fyvr11gy", xl: "fyvr11gz" }, defaultClass: "fyvr11gw" } } }, borderTopLeftRadius: { values: { none: { conditions: { sm: "fyvr11h0", md: "fyvr11h1", lg: "fyvr11h2", xl: "fyvr11h3" }, defaultClass: "fyvr11h0" }, xs: { conditions: { sm: "fyvr11h4", md: "fyvr11h5", lg: "fyvr11h6", xl: "fyvr11h7" }, defaultClass: "fyvr11h4" }, sm: { conditions: { sm: "fyvr11h8", md: "fyvr11h9", lg: "fyvr11ha", xl: "fyvr11hb" }, defaultClass: "fyvr11h8" }, md: { conditions: { sm: "fyvr11hc", md: "fyvr11hd", lg: "fyvr11he", xl: "fyvr11hf" }, defaultClass: "fyvr11hc" }, lg: { conditions: { sm: "fyvr11hg", md: "fyvr11hh", lg: "fyvr11hi", xl: "fyvr11hj" }, defaultClass: "fyvr11hg" }, circle: { conditions: { sm: "fyvr11hk", md: "fyvr11hl", lg: "fyvr11hm", xl: "fyvr11hn" }, defaultClass: "fyvr11hk" } } }, borderTopRightRadius: { values: { none: { conditions: { sm: "fyvr11ho", md: "fyvr11hp", lg: "fyvr11hq", xl: "fyvr11hr" }, defaultClass: "fyvr11ho" }, xs: { conditions: { sm: "fyvr11hs", md: "fyvr11ht", lg: "fyvr11hu", xl: "fyvr11hv" }, defaultClass: "fyvr11hs" }, sm: { conditions: { sm: "fyvr11hw", md: "fyvr11hx", lg: "fyvr11hy", xl: "fyvr11hz" }, defaultClass: "fyvr11hw" }, md: { conditions: { sm: "fyvr11i0", md: "fyvr11i1", lg: "fyvr11i2", xl: "fyvr11i3" }, defaultClass: "fyvr11i0" }, lg: { conditions: { sm: "fyvr11i4", md: "fyvr11i5", lg: "fyvr11i6", xl: "fyvr11i7" }, defaultClass: "fyvr11i4" }, circle: { conditions: { sm: "fyvr11i8", md: "fyvr11i9", lg: "fyvr11ia", xl: "fyvr11ib" }, defaultClass: "fyvr11i8" } } }, fontSize: { values: { inherit: { conditions: { sm: "fyvr11ic", md: "fyvr11id", lg: "fyvr11ie", xl: "fyvr11if" }, defaultClass: "fyvr11ic" }, xsmall: { conditions: { sm: "fyvr11ig", md: "fyvr11ih", lg: "fyvr11ii", xl: "fyvr11ij" }, defaultClass: "fyvr11ig" }, small: { conditions: { sm: "fyvr11ik", md: "fyvr11il", lg: "fyvr11im", xl: "fyvr11in" }, defaultClass: "fyvr11ik" }, normal: { conditions: { sm: "fyvr11io", md: "fyvr11ip", lg: "fyvr11iq", xl: "fyvr11ir" }, defaultClass: "fyvr11io" }, medium: { conditions: { sm: "fyvr11is", md: "fyvr11it", lg: "fyvr11iu", xl: "fyvr11iv" }, defaultClass: "fyvr11is" }, large: { conditions: { sm: "fyvr11iw", md: "fyvr11ix", lg: "fyvr11iy", xl: "fyvr11iz" }, defaultClass: "fyvr11iw" }, xlarge: { conditions: { sm: "fyvr11j0", md: "fyvr11j1", lg: "fyvr11j2", xl: "fyvr11j3" }, defaultClass: "fyvr11j0" } } }, fontWeight: { values: { inherit: { conditions: { sm: "fyvr11j4", md: "fyvr11j5", lg: "fyvr11j6", xl: "fyvr11j7" }, defaultClass: "fyvr11j4" }, normal: { conditions: { sm: "fyvr11j8", md: "fyvr11j9", lg: "fyvr11ja", xl: "fyvr11jb" }, defaultClass: "fyvr11j8" }, medium: { conditions: { sm: "fyvr11jc", md: "fyvr11jd", lg: "fyvr11je", xl: "fyvr11jf" }, defaultClass: "fyvr11jc" }, semibold: { conditions: { sm: "fyvr11jg", md: "fyvr11jh", lg: "fyvr11ji", xl: "fyvr11jj" }, defaultClass: "fyvr11jg" }, bold: { conditions: { sm: "fyvr11jk", md: "fyvr11jl", lg: "fyvr11jm", xl: "fyvr11jn" }, defaultClass: "fyvr11jk" } } }, letterSpacing: { values: { inherit: { conditions: { sm: "fyvr11jo", md: "fyvr11jp", lg: "fyvr11jq", xl: "fyvr11jr" }, defaultClass: "fyvr11jo" }, none: { conditions: { sm: "fyvr11js", md: "fyvr11jt", lg: "fyvr11ju", xl: "fyvr11jv" }, defaultClass: "fyvr11js" }, normal: { conditions: { sm: "fyvr11jw", md: "fyvr11jx", lg: "fyvr11jy", xl: "fyvr11jz" }, defaultClass: "fyvr11jw" }, wide: { conditions: { sm: "fyvr11k0", md: "fyvr11k1", lg: "fyvr11k2", xl: "fyvr11k3" }, defaultClass: "fyvr11k0" } } }, lineHeight: { values: { "4": { conditions: { sm: "fyvr11k4", md: "fyvr11k5", lg: "fyvr11k6", xl: "fyvr11k7" }, defaultClass: "fyvr11k4" }, "5": { conditions: { sm: "fyvr11k8", md: "fyvr11k9", lg: "fyvr11ka", xl: "fyvr11kb" }, defaultClass: "fyvr11k8" }, "6": { conditions: { sm: "fyvr11kc", md: "fyvr11kd", lg: "fyvr11ke", xl: "fyvr11kf" }, defaultClass: "fyvr11kc" }, "7": { conditions: { sm: "fyvr11kg", md: "fyvr11kh", lg: "fyvr11ki", xl: "fyvr11kj" }, defaultClass: "fyvr11kg" }, "9": { conditions: { sm: "fyvr11kk", md: "fyvr11kl", lg: "fyvr11km", xl: "fyvr11kn" }, defaultClass: "fyvr11kk" }, inherit: { conditions: { sm: "fyvr11ko", md: "fyvr11kp", lg: "fyvr11kq", xl: "fyvr11kr" }, defaultClass: "fyvr11ko" } } }, textAlign: { values: { center: { conditions: { sm: "fyvr11ks", md: "fyvr11kt", lg: "fyvr11ku", xl: "fyvr11kv" }, defaultClass: "fyvr11ks" }, left: { conditions: { sm: "fyvr11kw", md: "fyvr11kx", lg: "fyvr11ky", xl: "fyvr11kz" }, defaultClass: "fyvr11kw" }, right: { conditions: { sm: "fyvr11l0", md: "fyvr11l1", lg: "fyvr11l2", xl: "fyvr11l3" }, defaultClass: "fyvr11l0" } } }, display: { values: { block: { conditions: { sm: "fyvr11l4", md: "fyvr11l5", lg: "fyvr11l6", xl: "fyvr11l7" }, defaultClass: "fyvr11l4" }, flex: { conditions: { sm: "fyvr11l8", md: "fyvr11l9", lg: "fyvr11la", xl: "fyvr11lb" }, defaultClass: "fyvr11l8" }, grid: { conditions: { sm: "fyvr11lc", md: "fyvr11ld", lg: "fyvr11le", xl: "fyvr11lf" }, defaultClass: "fyvr11lc" }, "inline-block": { conditions: { sm: "fyvr11lg", md: "fyvr11lh", lg: "fyvr11li", xl: "fyvr11lj" }, defaultClass: "fyvr11lg" }, "inline-flex": { conditions: { sm: "fyvr11lk", md: "fyvr11ll", lg: "fyvr11lm", xl: "fyvr11ln" }, defaultClass: "fyvr11lk" }, none: { conditions: { sm: "fyvr11lo", md: "fyvr11lp", lg: "fyvr11lq", xl: "fyvr11lr" }, defaultClass: "fyvr11lo" }, contents: { conditions: { sm: "fyvr11ls", md: "fyvr11lt", lg: "fyvr11lu", xl: "fyvr11lv" }, defaultClass: "fyvr11ls" } } }, position: { values: { absolute: { conditions: { sm: "fyvr11lw", md: "fyvr11lx", lg: "fyvr11ly", xl: "fyvr11lz" }, defaultClass: "fyvr11lw" }, fixed: { conditions: { sm: "fyvr11m0", md: "fyvr11m1", lg: "fyvr11m2", xl: "fyvr11m3" }, defaultClass: "fyvr11m0" }, relative: { conditions: { sm: "fyvr11m4", md: "fyvr11m5", lg: "fyvr11m6", xl: "fyvr11m7" }, defaultClass: "fyvr11m4" }, sticky: { conditions: { sm: "fyvr11m8", md: "fyvr11m9", lg: "fyvr11ma", xl: "fyvr11mb" }, defaultClass: "fyvr11m8" } } }, flexDirection: { values: { column: { conditions: { sm: "fyvr11mc", md: "fyvr11md", lg: "fyvr11me", xl: "fyvr11mf" }, defaultClass: "fyvr11mc" }, "column-reverse": { conditions: { sm: "fyvr11mg", md: "fyvr11mh", lg: "fyvr11mi", xl: "fyvr11mj" }, defaultClass: "fyvr11mg" }, row: { conditions: { sm: "fyvr11mk", md: "fyvr11ml", lg: "fyvr11mm", xl: "fyvr11mn" }, defaultClass: "fyvr11mk" }, "row-reverse": { conditions: { sm: "fyvr11mo", md: "fyvr11mp", lg: "fyvr11mq", xl: "fyvr11mr" }, defaultClass: "fyvr11mo" } } }, flexShrink: { values: { "0": { conditions: { sm: "fyvr11ms", md: "fyvr11mt", lg: "fyvr11mu", xl: "fyvr11mv" }, defaultClass: "fyvr11ms" }, "1": { conditions: { sm: "fyvr11mw", md: "fyvr11mx", lg: "fyvr11my", xl: "fyvr11mz" }, defaultClass: "fyvr11mw" } } }, flexGrow: { values: { "0": { conditions: { sm: "fyvr11n0", md: "fyvr11n1", lg: "fyvr11n2", xl: "fyvr11n3" }, defaultClass: "fyvr11n0" }, "1": { conditions: { sm: "fyvr11n4", md: "fyvr11n5", lg: "fyvr11n6", xl: "fyvr11n7" }, defaultClass: "fyvr11n4" } } }, flexWrap: { values: { nowrap: { conditions: { sm: "fyvr11n8", md: "fyvr11n9", lg: "fyvr11na", xl: "fyvr11nb" }, defaultClass: "fyvr11n8" }, wrap: { conditions: { sm: "fyvr11nc", md: "fyvr11nd", lg: "fyvr11ne", xl: "fyvr11nf" }, defaultClass: "fyvr11nc" }, "wrap-reverse": { conditions: { sm: "fyvr11ng", md: "fyvr11nh", lg: "fyvr11ni", xl: "fyvr11nj" }, defaultClass: "fyvr11ng" } } }, justifyContent: { values: { "flex-start": { conditions: { sm: "fyvr11nk", md: "fyvr11nl", lg: "fyvr11nm", xl: "fyvr11nn" }, defaultClass: "fyvr11nk" }, center: { conditions: { sm: "fyvr11no", md: "fyvr11np", lg: "fyvr11nq", xl: "fyvr11nr" }, defaultClass: "fyvr11no" }, "flex-end": { conditions: { sm: "fyvr11ns", md: "fyvr11nt", lg: "fyvr11nu", xl: "fyvr11nv" }, defaultClass: "fyvr11ns" }, stretch: { conditions: { sm: "fyvr11nw", md: "fyvr11nx", lg: "fyvr11ny", xl: "fyvr11nz" }, defaultClass: "fyvr11nw" }, "space-around": { conditions: { sm: "fyvr11o0", md: "fyvr11o1", lg: "fyvr11o2", xl: "fyvr11o3" }, defaultClass: "fyvr11o0" }, "space-between": { conditions: { sm: "fyvr11o4", md: "fyvr11o5", lg: "fyvr11o6", xl: "fyvr11o7" }, defaultClass: "fyvr11o4" }, "space-evenly": { conditions: { sm: "fyvr11o8", md: "fyvr11o9", lg: "fyvr11oa", xl: "fyvr11ob" }, defaultClass: "fyvr11o8" } } }, justifySelf: { values: { "flex-start": { conditions: { sm: "fyvr11oc", md: "fyvr11od", lg: "fyvr11oe", xl: "fyvr11of" }, defaultClass: "fyvr11oc" }, center: { conditions: { sm: "fyvr11og", md: "fyvr11oh", lg: "fyvr11oi", xl: "fyvr11oj" }, defaultClass: "fyvr11og" }, "flex-end": { conditions: { sm: "fyvr11ok", md: "fyvr11ol", lg: "fyvr11om", xl: "fyvr11on" }, defaultClass: "fyvr11ok" }, stretch: { conditions: { sm: "fyvr11oo", md: "fyvr11op", lg: "fyvr11oq", xl: "fyvr11or" }, defaultClass: "fyvr11oo" } } }, alignItems: { values: { "flex-start": { conditions: { sm: "fyvr11os", md: "fyvr11ot", lg: "fyvr11ou", xl: "fyvr11ov" }, defaultClass: "fyvr11os" }, center: { conditions: { sm: "fyvr11ow", md: "fyvr11ox", lg: "fyvr11oy", xl: "fyvr11oz" }, defaultClass: "fyvr11ow" }, "flex-end": { conditions: { sm: "fyvr11p0", md: "fyvr11p1", lg: "fyvr11p2", xl: "fyvr11p3" }, defaultClass: "fyvr11p0" }, stretch: { conditions: { sm: "fyvr11p4", md: "fyvr11p5", lg: "fyvr11p6", xl: "fyvr11p7" }, defaultClass: "fyvr11p4" }, baseline: { conditions: { sm: "fyvr11p8", md: "fyvr11p9", lg: "fyvr11pa", xl: "fyvr11pb" }, defaultClass: "fyvr11p8" } } }, alignSelf: { values: { "flex-start": { conditions: { sm: "fyvr11pc", md: "fyvr11pd", lg: "fyvr11pe", xl: "fyvr11pf" }, defaultClass: "fyvr11pc" }, center: { conditions: { sm: "fyvr11pg", md: "fyvr11ph", lg: "fyvr11pi", xl: "fyvr11pj" }, defaultClass: "fyvr11pg" }, "flex-end": { conditions: { sm: "fyvr11pk", md: "fyvr11pl", lg: "fyvr11pm", xl: "fyvr11pn" }, defaultClass: "fyvr11pk" }, stretch: { conditions: { sm: "fyvr11po", md: "fyvr11pp", lg: "fyvr11pq", xl: "fyvr11pr" }, defaultClass: "fyvr11po" }, baseline: { conditions: { sm: "fyvr11ps", md: "fyvr11pt", lg: "fyvr11pu", xl: "fyvr11pv" }, defaultClass: "fyvr11ps" } } }, overflowX: { values: { auto: { conditions: { sm: "fyvr11pw", md: "fyvr11px", lg: "fyvr11py", xl: "fyvr11pz" }, defaultClass: "fyvr11pw" }, hidden: { conditions: { sm: "fyvr11q0", md: "fyvr11q1", lg: "fyvr11q2", xl: "fyvr11q3" }, defaultClass: "fyvr11q0" }, scroll: { conditions: { sm: "fyvr11q4", md: "fyvr11q5", lg: "fyvr11q6", xl: "fyvr11q7" }, defaultClass: "fyvr11q4" }, visible: { conditions: { sm: "fyvr11q8", md: "fyvr11q9", lg: "fyvr11qa", xl: "fyvr11qb" }, defaultClass: "fyvr11q8" } } }, overflowY: { values: { auto: { conditions: { sm: "fyvr11qc", md: "fyvr11qd", lg: "fyvr11qe", xl: "fyvr11qf" }, defaultClass: "fyvr11qc" }, hidden: { conditions: { sm: "fyvr11qg", md: "fyvr11qh", lg: "fyvr11qi", xl: "fyvr11qj" }, defaultClass: "fyvr11qg" }, scroll: { conditions: { sm: "fyvr11qk", md: "fyvr11ql", lg: "fyvr11qm", xl: "fyvr11qn" }, defaultClass: "fyvr11qk" }, visible: { conditions: { sm: "fyvr11qo", md: "fyvr11qp", lg: "fyvr11qq", xl: "fyvr11qr" }, defaultClass: "fyvr11qo" } } }, visibility: { values: { hidden: { conditions: { sm: "fyvr11qs", md: "fyvr11qt", lg: "fyvr11qu", xl: "fyvr11qv" }, defaultClass: "fyvr11qs" }, visible: { conditions: { sm: "fyvr11qw", md: "fyvr11qx", lg: "fyvr11qy", xl: "fyvr11qz" }, defaultClass: "fyvr11qw" } } } } }, { conditions: void 0, styles: { backdropFilter: { values: { blur: { defaultClass: "fyvr11r0" }, none: { defaultClass: "fyvr11r1" } } }, fontFamily: { values: { inherit: { defaultClass: "fyvr11r2" }, body: { defaultClass: "fyvr11r3" }, mono: { defaultClass: "fyvr11r4" } } }, textOverflow: { values: { ellipsis: { defaultClass: "fyvr11r5" }, clip: { defaultClass: "fyvr11r6" } } }, textTransform: { values: { capitalize: { defaultClass: "fyvr11r7" }, lowercase: { defaultClass: "fyvr11r8" }, uppercase: { defaultClass: "fyvr11r9" } } }, textDecoration: { values: { none: { defaultClass: "fyvr11ra" }, underline: { defaultClass: "fyvr11rb" } } }, userSelect: { values: { none: { defaultClass: "fyvr11rc" }, text: { defaultClass: "fyvr11rd" }, all: { defaultClass: "fyvr11re" }, auto: { defaultClass: "fyvr11rf" } } }, whiteSpace: { values: { normal: { defaultClass: "fyvr11rg" }, nowrap: { defaultClass: "fyvr11rh" }, initial: { defaultClass: "fyvr11ri" }, inherit: { defaultClass: "fyvr11rj" } } }, wordBreak: { values: { "break-word": { defaultClass: "fyvr11rk" } } }, wordWrap: { values: { normal: { defaultClass: "fyvr11rl" }, "break-word": { defaultClass: "fyvr11rm" }, initial: { defaultClass: "fyvr11rn" }, inherit: { defaultClass: "fyvr11ro" } } }, zIndex: { values: { "0": { defaultClass: "fyvr11rp" }, "1": { defaultClass: "fyvr11rq" }, "10": { defaultClass: "fyvr11rr" }, "20": { defaultClass: "fyvr11rs" }, "30": { defaultClass: "fyvr11rt" }, "40": { defaultClass: "fyvr11ru" }, "50": { defaultClass: "fyvr11rv" }, "-1": { defaultClass: "fyvr11rw" }, auto: { defaultClass: "fyvr11rx" } } }, aspectRatio: { values: { "1/1": { defaultClass: "fyvr11ry" }, "16/9": { defaultClass: "fyvr11rz" }, "4/3": { defaultClass: "fyvr11s0" }, "3/1": { defaultClass: "fyvr11s1" }, auto: { defaultClass: "fyvr11s2" } } } } }, { conditions: { defaultCondition: "base", conditionNames: ["base", "active", "disabled", "focus", "hover", "checked"], responsiveArray: void 0 }, styles: { borderColor: { mappings: ["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"] }, borderStyle: { mappings: ["borderTopStyle", "borderRightStyle", "borderBottomStyle", "borderLeftStyle"] }, focusRing: { mappings: ["boxShadow", "outline"] }, background: { values: { black: { conditions: { base: "fyvr11s3", active: "fyvr11s4", disabled: "fyvr11s5", focus: "fyvr11s6", hover: "fyvr11s7", checked: "fyvr11s8" }, defaultClass: "fyvr11s3" }, white: { conditions: { base: "fyvr11s9", active: "fyvr11sa", disabled: "fyvr11sb", focus: "fyvr11sc", hover: "fyvr11sd", checked: "fyvr11se" }, defaultClass: "fyvr11s9" }, inherit: { conditions: { base: "fyvr11sf", active: "fyvr11sg", disabled: "fyvr11sh", focus: "fyvr11si", hover: "fyvr11sj", checked: "fyvr11sk" }, defaultClass: "fyvr11sf" }, transparent: { conditions: { base: "fyvr11sl", active: "fyvr11sm", disabled: "fyvr11sn", focus: "fyvr11so", hover: "fyvr11sp", checked: "fyvr11sq" }, defaultClass: "fyvr11sl" }, positive: { conditions: { base: "fyvr11sr", active: "fyvr11ss", disabled: "fyvr11st", focus: "fyvr11su", hover: "fyvr11sv", checked: "fyvr11sw" }, defaultClass: "fyvr11sr" }, negative: { conditions: { base: "fyvr11sx", active: "fyvr11sy", disabled: "fyvr11sz", focus: "fyvr11t0", hover: "fyvr11t1", checked: "fyvr11t2" }, defaultClass: "fyvr11sx" }, info: { conditions: { base: "fyvr11t3", active: "fyvr11t4", disabled: "fyvr11t5", focus: "fyvr11t6", hover: "fyvr11t7", checked: "fyvr11t8" }, defaultClass: "fyvr11t3" }, warning: { conditions: { base: "fyvr11t9", active: "fyvr11ta", disabled: "fyvr11tb", focus: "fyvr11tc", hover: "fyvr11td", checked: "fyvr11te" }, defaultClass: "fyvr11t9" }, gradientBackdrop: { conditions: { base: "fyvr11tf", active: "fyvr11tg", disabled: "fyvr11th", focus: "fyvr11ti", hover: "fyvr11tj", checked: "fyvr11tk" }, defaultClass: "fyvr11tf" }, gradientPrimary: { conditions: { base: "fyvr11tl", active: "fyvr11tm", disabled: "fyvr11tn", focus: "fyvr11to", hover: "fyvr11tp", checked: "fyvr11tq" }, defaultClass: "fyvr11tl" }, gradientSecondary: { conditions: { base: "fyvr11tr", active: "fyvr11ts", disabled: "fyvr11tt", focus: "fyvr11tu", hover: "fyvr11tv", checked: "fyvr11tw" }, defaultClass: "fyvr11tr" }, arbitrumDark: { conditions: { base: "fyvr11tx", active: "fyvr11ty", disabled: "fyvr11tz", focus: "fyvr11u0", hover: "fyvr11u1", checked: "fyvr11u2" }, defaultClass: "fyvr11tx" }, arbitrumLight: { conditions: { base: "fyvr11u3", active: "fyvr11u4", disabled: "fyvr11u5", focus: "fyvr11u6", hover: "fyvr11u7", checked: "fyvr11u8" }, defaultClass: "fyvr11u3" }, avalanceDark: { conditions: { base: "fyvr11u9", active: "fyvr11ua", disabled: "fyvr11ub", focus: "fyvr11uc", hover: "fyvr11ud", checked: "fyvr11ue" }, defaultClass: "fyvr11u9" }, avalanceLight: { conditions: { base: "fyvr11uf", active: "fyvr11ug", disabled: "fyvr11uh", focus: "fyvr11ui", hover: "fyvr11uj", checked: "fyvr11uk" }, defaultClass: "fyvr11uf" }, bscDark: { conditions: { base: "fyvr11ul", active: "fyvr11um", disabled: "fyvr11un", focus: "fyvr11uo", hover: "fyvr11up", checked: "fyvr11uq" }, defaultClass: "fyvr11ul" }, bscLight: { conditions: { base: "fyvr11ur", active: "fyvr11us", disabled: "fyvr11ut", focus: "fyvr11uu", hover: "fyvr11uv", checked: "fyvr11uw" }, defaultClass: "fyvr11ur" }, ethereumDark: { conditions: { base: "fyvr11ux", active: "fyvr11uy", disabled: "fyvr11uz", focus: "fyvr11v0", hover: "fyvr11v1", checked: "fyvr11v2" }, defaultClass: "fyvr11ux" }, ethereumLight: { conditions: { base: "fyvr11v3", active: "fyvr11v4", disabled: "fyvr11v5", focus: "fyvr11v6", hover: "fyvr11v7", checked: "fyvr11v8" }, defaultClass: "fyvr11v3" }, gnosisDark: { conditions: { base: "fyvr11v9", active: "fyvr11va", disabled: "fyvr11vb", focus: "fyvr11vc", hover: "fyvr11vd", checked: "fyvr11ve" }, defaultClass: "fyvr11v9" }, gnosisLight: { conditions: { base: "fyvr11vf", active: "fyvr11vg", disabled: "fyvr11vh", focus: "fyvr11vi", hover: "fyvr11vj", checked: "fyvr11vk" }, defaultClass: "fyvr11vf" }, polygonDark: { conditions: { base: "fyvr11vl", active: "fyvr11vm", disabled: "fyvr11vn", focus: "fyvr11vo", hover: "fyvr11vp", checked: "fyvr11vq" }, defaultClass: "fyvr11vl" }, polygonLight: { conditions: { base: "fyvr11vr", active: "fyvr11vs", disabled: "fyvr11vt", focus: "fyvr11vu", hover: "fyvr11vv", checked: "fyvr11vw" }, defaultClass: "fyvr11vr" }, text100: { conditions: { base: "fyvr11vx", active: "fyvr11vy", disabled: "fyvr11vz", focus: "fyvr11w0", hover: "fyvr11w1", checked: "fyvr11w2" }, defaultClass: "fyvr11vx" }, text80: { conditions: { base: "fyvr11w3", active: "fyvr11w4", disabled: "fyvr11w5", focus: "fyvr11w6", hover: "fyvr11w7", checked: "fyvr11w8" }, defaultClass: "fyvr11w3" }, text50: { conditions: { base: "fyvr11w9", active: "fyvr11wa", disabled: "fyvr11wb", focus: "fyvr11wc", hover: "fyvr11wd", checked: "fyvr11we" }, defaultClass: "fyvr11w9" }, textInverse100: { conditions: { base: "fyvr11wf", active: "fyvr11wg", disabled: "fyvr11wh", focus: "fyvr11wi", hover: "fyvr11wj", checked: "fyvr11wk" }, defaultClass: "fyvr11wf" }, backgroundPrimary: { conditions: { base: "fyvr11wl", active: "fyvr11wm", disabled: "fyvr11wn", focus: "fyvr11wo", hover: "fyvr11wp", checked: "fyvr11wq" }, defaultClass: "fyvr11wl" }, backgroundSecondary: { conditions: { base: "fyvr11wr", active: "fyvr11ws", disabled: "fyvr11wt", focus: "fyvr11wu", hover: "fyvr11wv", checked: "fyvr11ww" }, defaultClass: "fyvr11wr" }, backgroundContrast: { conditions: { base: "fyvr11wx", active: "fyvr11wy", disabled: "fyvr11wz", focus: "fyvr11x0", hover: "fyvr11x1", checked: "fyvr11x2" }, defaultClass: "fyvr11wx" }, backgroundMuted: { conditions: { base: "fyvr11x3", active: "fyvr11x4", disabled: "fyvr11x5", focus: "fyvr11x6", hover: "fyvr11x7", checked: "fyvr11x8" }, defaultClass: "fyvr11x3" }, backgroundControl: { conditions: { base: "fyvr11x9", active: "fyvr11xa", disabled: "fyvr11xb", focus: "fyvr11xc", hover: "fyvr11xd", checked: "fyvr11xe" }, defaultClass: "fyvr11x9" }, backgroundInverse: { conditions: { base: "fyvr11xf", active: "fyvr11xg", disabled: "fyvr11xh", focus: "fyvr11xi", hover: "fyvr11xj", checked: "fyvr11xk" }, defaultClass: "fyvr11xf" }, backgroundBackdrop: { conditions: { base: "fyvr11xl", active: "fyvr11xm", disabled: "fyvr11xn", focus: "fyvr11xo", hover: "fyvr11xp", checked: "fyvr11xq" }, defaultClass: "fyvr11xl" }, backgroundOverlay: { conditions: { base: "fyvr11xr", active: "fyvr11xs", disabled: "fyvr11xt", focus: "fyvr11xu", hover: "fyvr11xv", checked: "fyvr11xw" }, defaultClass: "fyvr11xr" }, backgroundRaised: { conditions: { base: "fyvr11xx", active: "fyvr11xy", disabled: "fyvr11xz", focus: "fyvr11y0", hover: "fyvr11y1", checked: "fyvr11y2" }, defaultClass: "fyvr11xx" }, buttonGlass: { conditions: { base: "fyvr11y3", active: "fyvr11y4", disabled: "fyvr11y5", focus: "fyvr11y6", hover: "fyvr11y7", checked: "fyvr11y8" }, defaultClass: "fyvr11y3" }, buttonEmphasis: { conditions: { base: "fyvr11y9", active: "fyvr11ya", disabled: "fyvr11yb", focus: "fyvr11yc", hover: "fyvr11yd", checked: "fyvr11ye" }, defaultClass: "fyvr11y9" }, buttonInverse: { conditions: { base: "fyvr11yf", active: "fyvr11yg", disabled: "fyvr11yh", focus: "fyvr11yi", hover: "fyvr11yj", checked: "fyvr11yk" }, defaultClass: "fyvr11yf" }, borderNormal: { conditions: { base: "fyvr11yl", active: "fyvr11ym", disabled: "fyvr11yn", focus: "fyvr11yo", hover: "fyvr11yp", checked: "fyvr11yq" }, defaultClass: "fyvr11yl" }, borderFocus: { conditions: { base: "fyvr11yr", active: "fyvr11ys", disabled: "fyvr11yt", focus: "fyvr11yu", hover: "fyvr11yv", checked: "fyvr11yw" }, defaultClass: "fyvr11yr" } } }, borderBottomColor: { values: { black: { conditions: { base: "fyvr11yx", active: "fyvr11yy", disabled: "fyvr11yz", focus: "fyvr11z0", hover: "fyvr11z1", checked: "fyvr11z2" }, defaultClass: "fyvr11yx" }, white: { conditions: { base: "fyvr11z3", active: "fyvr11z4", disabled: "fyvr11z5", focus: "fyvr11z6", hover: "fyvr11z7", checked: "fyvr11z8" }, defaultClass: "fyvr11z3" }, inherit: { conditions: { base: "fyvr11z9", active: "fyvr11za", disabled: "fyvr11zb", focus: "fyvr11zc", hover: "fyvr11zd", checked: "fyvr11ze" }, defaultClass: "fyvr11z9" }, transparent: { conditions: { base: "fyvr11zf", active: "fyvr11zg", disabled: "fyvr11zh", focus: "fyvr11zi", hover: "fyvr11zj", checked: "fyvr11zk" }, defaultClass: "fyvr11zf" }, positive: { conditions: { base: "fyvr11zl", active: "fyvr11zm", disabled: "fyvr11zn", focus: "fyvr11zo", hover: "fyvr11zp", checked: "fyvr11zq" }, defaultClass: "fyvr11zl" }, negative: { conditions: { base: "fyvr11zr", active: "fyvr11zs", disabled: "fyvr11zt", focus: "fyvr11zu", hover: "fyvr11zv", checked: "fyvr11zw" }, defaultClass: "fyvr11zr" }, info: { conditions: { base: "fyvr11zx", active: "fyvr11zy", disabled: "fyvr11zz", focus: "fyvr1200", hover: "fyvr1201", checked: "fyvr1202" }, defaultClass: "fyvr11zx" }, warning: { conditions: { base: "fyvr1203", active: "fyvr1204", disabled: "fyvr1205", focus: "fyvr1206", hover: "fyvr1207", checked: "fyvr1208" }, defaultClass: "fyvr1203" }, gradientBackdrop: { conditions: { base: "fyvr1209", active: "fyvr120a", disabled: "fyvr120b", focus: "fyvr120c", hover: "fyvr120d", checked: "fyvr120e" }, defaultClass: "fyvr1209" }, gradientPrimary: { conditions: { base: "fyvr120f", active: "fyvr120g", disabled: "fyvr120h", focus: "fyvr120i", hover: "fyvr120j", checked: "fyvr120k" }, defaultClass: "fyvr120f" }, gradientSecondary: { conditions: { base: "fyvr120l", active: "fyvr120m", disabled: "fyvr120n", focus: "fyvr120o", hover: "fyvr120p", checked: "fyvr120q" }, defaultClass: "fyvr120l" }, arbitrumDark: { conditions: { base: "fyvr120r", active: "fyvr120s", disabled: "fyvr120t", focus: "fyvr120u", hover: "fyvr120v", checked: "fyvr120w" }, defaultClass: "fyvr120r" }, arbitrumLight: { conditions: { base: "fyvr120x", active: "fyvr120y", disabled: "fyvr120z", focus: "fyvr1210", hover: "fyvr1211", checked: "fyvr1212" }, defaultClass: "fyvr120x" }, avalanceDark: { conditions: { base: "fyvr1213", active: "fyvr1214", disabled: "fyvr1215", focus: "fyvr1216", hover: "fyvr1217", checked: "fyvr1218" }, defaultClass: "fyvr1213" }, avalanceLight: { conditions: { base: "fyvr1219", active: "fyvr121a", disabled: "fyvr121b", focus: "fyvr121c", hover: "fyvr121d", checked: "fyvr121e" }, defaultClass: "fyvr1219" }, bscDark: { conditions: { base: "fyvr121f", active: "fyvr121g", disabled: "fyvr121h", focus: "fyvr121i", hover: "fyvr121j", checked: "fyvr121k" }, defaultClass: "fyvr121f" }, bscLight: { conditions: { base: "fyvr121l", active: "fyvr121m", disabled: "fyvr121n", focus: "fyvr121o", hover: "fyvr121p", checked: "fyvr121q" }, defaultClass: "fyvr121l" }, ethereumDark: { conditions: { base: "fyvr121r", active: "fyvr121s", disabled: "fyvr121t", focus: "fyvr121u", hover: "fyvr121v", checked: "fyvr121w" }, defaultClass: "fyvr121r" }, ethereumLight: { conditions: { base: "fyvr121x", active: "fyvr121y", disabled: "fyvr121z", focus: "fyvr1220", hover: "fyvr1221", checked: "fyvr1222" }, defaultClass: "fyvr121x" }, gnosisDark: { conditions: { base: "fyvr1223", active: "fyvr1224", disabled: "fyvr1225", focus: "fyvr1226", hover: "fyvr1227", checked: "fyvr1228" }, defaultClass: "fyvr1223" }, gnosisLight: { conditions: { base: "fyvr1229", active: "fyvr122a", disabled: "fyvr122b", focus: "fyvr122c", hover: "fyvr122d", checked: "fyvr122e" }, defaultClass: "fyvr1229" }, polygonDark: { conditions: { base: "fyvr122f", active: "fyvr122g", disabled: "fyvr122h", focus: "fyvr122i", hover: "fyvr122j", checked: "fyvr122k" }, defaultClass: "fyvr122f" }, polygonLight: { conditions: { base: "fyvr122l", active: "fyvr122m", disabled: "fyvr122n", focus: "fyvr122o", hover: "fyvr122p", checked: "fyvr122q" }, defaultClass: "fyvr122l" }, text100: { conditions: { base: "fyvr122r", active: "fyvr122s", disabled: "fyvr122t", focus: "fyvr122u", hover: "fyvr122v", checked: "fyvr122w" }, defaultClass: "fyvr122r" }, text80: { conditions: { base: "fyvr122x", active: "fyvr122y", disabled: "fyvr122z", focus: "fyvr1230", hover: "fyvr1231", checked: "fyvr1232" }, defaultClass: "fyvr122x" }, text50: { conditions: { base: "fyvr1233", active: "fyvr1234", disabled: "fyvr1235", focus: "fyvr1236", hover: "fyvr1237", checked: "fyvr1238" }, defaultClass: "fyvr1233" }, textInverse100: { conditions: { base: "fyvr1239", active: "fyvr123a", disabled: "fyvr123b", focus: "fyvr123c", hover: "fyvr123d", checked: "fyvr123e" }, defaultClass: "fyvr1239" }, backgroundPrimary: { conditions: { base: "fyvr123f", active: "fyvr123g", disabled: "fyvr123h", focus: "fyvr123i", hover: "fyvr123j", checked: "fyvr123k" }, defaultClass: "fyvr123f" }, backgroundSecondary: { conditions: { base: "fyvr123l", active: "fyvr123m", disabled: "fyvr123n", focus: "fyvr123o", hover: "fyvr123p", checked: "fyvr123q" }, defaultClass: "fyvr123l" }, backgroundContrast: { conditions: { base: "fyvr123r", active: "fyvr123s", disabled: "fyvr123t", focus: "fyvr123u", hover: "fyvr123v", checked: "fyvr123w" }, defaultClass: "fyvr123r" }, backgroundMuted: { conditions: { base: "fyvr123x", active: "fyvr123y", disabled: "fyvr123z", focus: "fyvr1240", hover: "fyvr1241", checked: "fyvr1242" }, defaultClass: "fyvr123x" }, backgroundControl: { conditions: { base: "fyvr1243", active: "fyvr1244", disabled: "fyvr1245", focus: "fyvr1246", hover: "fyvr1247", checked: "fyvr1248" }, defaultClass: "fyvr1243" }, backgroundInverse: { conditions: { base: "fyvr1249", active: "fyvr124a", disabled: "fyvr124b", focus: "fyvr124c", hover: "fyvr124d", checked: "fyvr124e" }, defaultClass: "fyvr1249" }, backgroundBackdrop: { conditions: { base: "fyvr124f", active: "fyvr124g", disabled: "fyvr124h", focus: "fyvr124i", hover: "fyvr124j", checked: "fyvr124k" }, defaultClass: "fyvr124f" }, backgroundOverlay: { conditions: { base: "fyvr124l", active: "fyvr124m", disabled: "fyvr124n", focus: "fyvr124o", hover: "fyvr124p", checked: "fyvr124q" }, defaultClass: "fyvr124l" }, backgroundRaised: { conditions: { base: "fyvr124r", active: "fyvr124s", disabled: "fyvr124t", focus: "fyvr124u", hover: "fyvr124v", checked: "fyvr124w" }, defaultClass: "fyvr124r" }, buttonGlass: { conditions: { base: "fyvr124x", active: "fyvr124y", disabled: "fyvr124z", focus: "fyvr1250", hover: "fyvr1251", checked: "fyvr1252" }, defaultClass: "fyvr124x" }, buttonEmphasis: { conditions: { base: "fyvr1253", active: "fyvr1254", disabled: "fyvr1255", focus: "fyvr1256", hover: "fyvr1257", checked: "fyvr1258" }, defaultClass: "fyvr1253" }, buttonInverse: { conditions: { base: "fyvr1259", active: "fyvr125a", disabled: "fyvr125b", focus: "fyvr125c", hover: "fyvr125d", checked: "fyvr125e" }, defaultClass: "fyvr1259" }, borderNormal: { conditions: { base: "fyvr125f", active: "fyvr125g", disabled: "fyvr125h", focus: "fyvr125i", hover: "fyvr125j", checked: "fyvr125k" }, defaultClass: "fyvr125f" }, borderFocus: { conditions: { base: "fyvr125l", active: "fyvr125m", disabled: "fyvr125n", focus: "fyvr125o", hover: "fyvr125p", checked: "fyvr125q" }, defaultClass: "fyvr125l" } } }, borderBottomStyle: { values: { solid: { conditions: { base: "fyvr125r", active: "fyvr125s", disabled: "fyvr125t", focus: "fyvr125u", hover: "fyvr125v", checked: "fyvr125w" }, defaultClass: "fyvr125r" }, dashed: { conditions: { base: "fyvr125x", active: "fyvr125y", disabled: "fyvr125z", focus: "fyvr1260", hover: "fyvr1261", checked: "fyvr1262" }, defaultClass: "fyvr125x" }, dotted: { conditions: { base: "fyvr1263", active: "fyvr1264", disabled: "fyvr1265", focus: "fyvr1266", hover: "fyvr1267", checked: "fyvr1268" }, defaultClass: "fyvr1263" } } }, borderLeftColor: { values: { black: { conditions: { base: "fyvr1269", active: "fyvr126a", disabled: "fyvr126b", focus: "fyvr126c", hover: "fyvr126d", checked: "fyvr126e" }, defaultClass: "fyvr1269" }, white: { conditions: { base: "fyvr126f", active: "fyvr126g", disabled: "fyvr126h", focus: "fyvr126i", hover: "fyvr126j", checked: "fyvr126k" }, defaultClass: "fyvr126f" }, inherit: { conditions: { base: "fyvr126l", active: "fyvr126m", disabled: "fyvr126n", focus: "fyvr126o", hover: "fyvr126p", checked: "fyvr126q" }, defaultClass: "fyvr126l" }, transparent: { conditions: { base: "fyvr126r", active: "fyvr126s", disabled: "fyvr126t", focus: "fyvr126u", hover: "fyvr126v", checked: "fyvr126w" }, defaultClass: "fyvr126r" }, positive: { conditions: { base: "fyvr126x", active: "fyvr126y", disabled: "fyvr126z", focus: "fyvr1270", hover: "fyvr1271", checked: "fyvr1272" }, defaultClass: "fyvr126x" }, negative: { conditions: { base: "fyvr1273", active: "fyvr1274", disabled: "fyvr1275", focus: "fyvr1276", hover: "fyvr1277", checked: "fyvr1278" }, defaultClass: "fyvr1273" }, info: { conditions: { base: "fyvr1279", active: "fyvr127a", disabled: "fyvr127b", focus: "fyvr127c", hover: "fyvr127d", checked: "fyvr127e" }, defaultClass: "fyvr1279" }, warning: { conditions: { base: "fyvr127f", active: "fyvr127g", disabled: "fyvr127h", focus: "fyvr127i", hover: "fyvr127j", checked: "fyvr127k" }, defaultClass: "fyvr127f" }, gradientBackdrop: { conditions: { base: "fyvr127l", active: "fyvr127m", disabled: "fyvr127n", focus: "fyvr127o", hover: "fyvr127p", checked: "fyvr127q" }, defaultClass: "fyvr127l" }, gradientPrimary: { conditions: { base: "fyvr127r", active: "fyvr127s", disabled: "fyvr127t", focus: "fyvr127u", hover: "fyvr127v", checked: "fyvr127w" }, defaultClass: "fyvr127r" }, gradientSecondary: { conditions: { base: "fyvr127x", active: "fyvr127y", disabled: "fyvr127z", focus: "fyvr1280", hover: "fyvr1281", checked: "fyvr1282" }, defaultClass: "fyvr127x" }, arbitrumDark: { conditions: { base: "fyvr1283", active: "fyvr1284", disabled: "fyvr1285", focus: "fyvr1286", hover: "fyvr1287", checked: "fyvr1288" }, defaultClass: "fyvr1283" }, arbitrumLight: { conditions: { base: "fyvr1289", active: "fyvr128a", disabled: "fyvr128b", focus: "fyvr128c", hover: "fyvr128d", checked: "fyvr128e" }, defaultClass: "fyvr1289" }, avalanceDark: { conditions: { base: "fyvr128f", active: "fyvr128g", disabled: "fyvr128h", focus: "fyvr128i", hover: "fyvr128j", checked: "fyvr128k" }, defaultClass: "fyvr128f" }, avalanceLight: { conditions: { base: "fyvr128l", active: "fyvr128m", disabled: "fyvr128n", focus: "fyvr128o", hover: "fyvr128p", checked: "fyvr128q" }, defaultClass: "fyvr128l" }, bscDark: { conditions: { base: "fyvr128r", active: "fyvr128s", disabled: "fyvr128t", focus: "fyvr128u", hover: "fyvr128v", checked: "fyvr128w" }, defaultClass: "fyvr128r" }, bscLight: { conditions: { base: "fyvr128x", active: "fyvr128y", disabled: "fyvr128z", focus: "fyvr1290", hover: "fyvr1291", checked: "fyvr1292" }, defaultClass: "fyvr128x" }, ethereumDark: { conditions: { base: "fyvr1293", active: "fyvr1294", disabled: "fyvr1295", focus: "fyvr1296", hover: "fyvr1297", checked: "fyvr1298" }, defaultClass: "fyvr1293" }, ethereumLight: { conditions: { base: "fyvr1299", active: "fyvr129a", disabled: "fyvr129b", focus: "fyvr129c", hover: "fyvr129d", checked: "fyvr129e" }, defaultClass: "fyvr1299" }, gnosisDark: { conditions: { base: "fyvr129f", active: "fyvr129g", disabled: "fyvr129h", focus: "fyvr129i", hover: "fyvr129j", checked: "fyvr129k" }, defaultClass: "fyvr129f" }, gnosisLight: { conditions: { base: "fyvr129l", active: "fyvr129m", disabled: "fyvr129n", focus: "fyvr129o", hover: "fyvr129p", checked: "fyvr129q" }, defaultClass: "fyvr129l" }, polygonDark: { conditions: { base: "fyvr129r", active: "fyvr129s", disabled: "fyvr129t", focus: "fyvr129u", hover: "fyvr129v", checked: "fyvr129w" }, defaultClass: "fyvr129r" }, polygonLight: { conditions: { base: "fyvr129x", active: "fyvr129y", disabled: "fyvr129z", focus: "fyvr12a0", hover: "fyvr12a1", checked: "fyvr12a2" }, defaultClass: "fyvr129x" }, text100: { conditions: { base: "fyvr12a3", active: "fyvr12a4", disabled: "fyvr12a5", focus: "fyvr12a6", hover: "fyvr12a7", checked: "fyvr12a8" }, defaultClass: "fyvr12a3" }, text80: { conditions: { base: "fyvr12a9", active: "fyvr12aa", disabled: "fyvr12ab", focus: "fyvr12ac", hover: "fyvr12ad", checked: "fyvr12ae" }, defaultClass: "fyvr12a9" }, text50: { conditions: { base: "fyvr12af", active: "fyvr12ag", disabled: "fyvr12ah", focus: "fyvr12ai", hover: "fyvr12aj", checked: "fyvr12ak" }, defaultClass: "fyvr12af" }, textInverse100: { conditions: { base: "fyvr12al", active: "fyvr12am", disabled: "fyvr12an", focus: "fyvr12ao", hover: "fyvr12ap", checked: "fyvr12aq" }, defaultClass: "fyvr12al" }, backgroundPrimary: { conditions: { base: "fyvr12ar", active: "fyvr12as", disabled: "fyvr12at", focus: "fyvr12au", hover: "fyvr12av", checked: "fyvr12aw" }, defaultClass: "fyvr12ar" }, backgroundSecondary: { conditions: { base: "fyvr12ax", active: "fyvr12ay", disabled: "fyvr12az", focus: "fyvr12b0", hover: "fyvr12b1", checked: "fyvr12b2" }, defaultClass: "fyvr12ax" }, backgroundContrast: { conditions: { base: "fyvr12b3", active: "fyvr12b4", disabled: "fyvr12b5", focus: "fyvr12b6", hover: "fyvr12b7", checked: "fyvr12b8" }, defaultClass: "fyvr12b3" }, backgroundMuted: { conditions: { base: "fyvr12b9", active: "fyvr12ba", disabled: "fyvr12bb", focus: "fyvr12bc", hover: "fyvr12bd", checked: "fyvr12be" }, defaultClass: "fyvr12b9" }, backgroundControl: { conditions: { base: "fyvr12bf", active: "fyvr12bg", disabled: "fyvr12bh", focus: "fyvr12bi", hover: "fyvr12bj", checked: "fyvr12bk" }, defaultClass: "fyvr12bf" }, backgroundInverse: { conditions: { base: "fyvr12bl", active: "fyvr12bm", disabled: "fyvr12bn", focus: "fyvr12bo", hover: "fyvr12bp", checked: "fyvr12bq" }, defaultClass: "fyvr12bl" }, backgroundBackdrop: { conditions: { base: "fyvr12br", active: "fyvr12bs", disabled: "fyvr12bt", focus: "fyvr12bu", hover: "fyvr12bv", checked: "fyvr12bw" }, defaultClass: "fyvr12br" }, backgroundOverlay: { conditions: { base: "fyvr12bx", active: "fyvr12by", disabled: "fyvr12bz", focus: "fyvr12c0", hover: "fyvr12c1", checked: "fyvr12c2" }, defaultClass: "fyvr12bx" }, backgroundRaised: { conditions: { base: "fyvr12c3", active: "fyvr12c4", disabled: "fyvr12c5", focus: "fyvr12c6", hover: "fyvr12c7", checked: "fyvr12c8" }, defaultClass: "fyvr12c3" }, buttonGlass: { conditions: { base: "fyvr12c9", active: "fyvr12ca", disabled: "fyvr12cb", focus: "fyvr12cc", hover: "fyvr12cd", checked: "fyvr12ce" }, defaultClass: "fyvr12c9" }, buttonEmphasis: { conditions: { base: "fyvr12cf", active: "fyvr12cg", disabled: "fyvr12ch", focus: "fyvr12ci", hover: "fyvr12cj", checked: "fyvr12ck" }, defaultClass: "fyvr12cf" }, buttonInverse: { conditions: { base: "fyvr12cl", active: "fyvr12cm", disabled: "fyvr12cn", focus: "fyvr12co", hover: "fyvr12cp", checked: "fyvr12cq" }, defaultClass: "fyvr12cl" }, borderNormal: { conditions: { base: "fyvr12cr", active: "fyvr12cs", disabled: "fyvr12ct", focus: "fyvr12cu", hover: "fyvr12cv", checked: "fyvr12cw" }, defaultClass: "fyvr12cr" }, borderFocus: { conditions: { base: "fyvr12cx", active: "fyvr12cy", disabled: "fyvr12cz", focus: "fyvr12d0", hover: "fyvr12d1", checked: "fyvr12d2" }, defaultClass: "fyvr12cx" } } }, borderLeftStyle: { values: { solid: { conditions: { base: "fyvr12d3", active: "fyvr12d4", disabled: "fyvr12d5", focus: "fyvr12d6", hover: "fyvr12d7", checked: "fyvr12d8" }, defaultClass: "fyvr12d3" }, dashed: { conditions: { base: "fyvr12d9", active: "fyvr12da", disabled: "fyvr12db", focus: "fyvr12dc", hover: "fyvr12dd", checked: "fyvr12de" }, defaultClass: "fyvr12d9" }, dotted: { conditions: { base: "fyvr12df", active: "fyvr12dg", disabled: "fyvr12dh", focus: "fyvr12di", hover: "fyvr12dj", checked: "fyvr12dk" }, defaultClass: "fyvr12df" } } }, borderRightColor: { values: { black: { conditions: { base: "fyvr12dl", active: "fyvr12dm", disabled: "fyvr12dn", focus: "fyvr12do", hover: "fyvr12dp", checked: "fyvr12dq" }, defaultClass: "fyvr12dl" }, white: { conditions: { base: "fyvr12dr", active: "fyvr12ds", disabled: "fyvr12dt", focus: "fyvr12du", hover: "fyvr12dv", checked: "fyvr12dw" }, defaultClass: "fyvr12dr" }, inherit: { conditions: { base: "fyvr12dx", active: "fyvr12dy", disabled: "fyvr12dz", focus: "fyvr12e0", hover: "fyvr12e1", checked: "fyvr12e2" }, defaultClass: "fyvr12dx" }, transparent: { conditions: { base: "fyvr12e3", active: "fyvr12e4", disabled: "fyvr12e5", focus: "fyvr12e6", hover: "fyvr12e7", checked: "fyvr12e8" }, defaultClass: "fyvr12e3" }, positive: { conditions: { base: "fyvr12e9", active: "fyvr12ea", disabled: "fyvr12eb", focus: "fyvr12ec", hover: "fyvr12ed", checked: "fyvr12ee" }, defaultClass: "fyvr12e9" }, negative: { conditions: { base: "fyvr12ef", active: "fyvr12eg", disabled: "fyvr12eh", focus: "fyvr12ei", hover: "fyvr12ej", checked: "fyvr12ek" }, defaultClass: "fyvr12ef" }, info: { conditions: { base: "fyvr12el", active: "fyvr12em", disabled: "fyvr12en", focus: "fyvr12eo", hover: "fyvr12ep", checked: "fyvr12eq" }, defaultClass: "fyvr12el" }, warning: { conditions: { base: "fyvr12er", active: "fyvr12es", disabled: "fyvr12et", focus: "fyvr12eu", hover: "fyvr12ev", checked: "fyvr12ew" }, defaultClass: "fyvr12er" }, gradientBackdrop: { conditions: { base: "fyvr12ex", active: "fyvr12ey", disabled: "fyvr12ez", focus: "fyvr12f0", hover: "fyvr12f1", checked: "fyvr12f2" }, defaultClass: "fyvr12ex" }, gradientPrimary: { conditions: { base: "fyvr12f3", active: "fyvr12f4", disabled: "fyvr12f5", focus: "fyvr12f6", hover: "fyvr12f7", checked: "fyvr12f8" }, defaultClass: "fyvr12f3" }, gradientSecondary: { conditions: { base: "fyvr12f9", active: "fyvr12fa", disabled: "fyvr12fb", focus: "fyvr12fc", hover: "fyvr12fd", checked: "fyvr12fe" }, defaultClass: "fyvr12f9" }, arbitrumDark: { conditions: { base: "fyvr12ff", active: "fyvr12fg", disabled: "fyvr12fh", focus: "fyvr12fi", hover: "fyvr12fj", checked: "fyvr12fk" }, defaultClass: "fyvr12ff" }, arbitrumLight: { conditions: { base: "fyvr12fl", active: "fyvr12fm", disabled: "fyvr12fn", focus: "fyvr12fo", hover: "fyvr12fp", checked: "fyvr12fq" }, defaultClass: "fyvr12fl" }, avalanceDark: { conditions: { base: "fyvr12fr", active: "fyvr12fs", disabled: "fyvr12ft", focus: "fyvr12fu", hover: "fyvr12fv", checked: "fyvr12fw" }, defaultClass: "fyvr12fr" }, avalanceLight: { conditions: { base: "fyvr12fx", active: "fyvr12fy", disabled: "fyvr12fz", focus: "fyvr12g0", hover: "fyvr12g1", checked: "fyvr12g2" }, defaultClass: "fyvr12fx" }, bscDark: { conditions: { base: "fyvr12g3", active: "fyvr12g4", disabled: "fyvr12g5", focus: "fyvr12g6", hover: "fyvr12g7", checked: "fyvr12g8" }, defaultClass: "fyvr12g3" }, bscLight: { conditions: { base: "fyvr12g9", active: "fyvr12ga", disabled: "fyvr12gb", focus: "fyvr12gc", hover: "fyvr12gd", checked: "fyvr12ge" }, defaultClass: "fyvr12g9" }, ethereumDark: { conditions: { base: "fyvr12gf", active: "fyvr12gg", disabled: "fyvr12gh", focus: "fyvr12gi", hover: "fyvr12gj", checked: "fyvr12gk" }, defaultClass: "fyvr12gf" }, ethereumLight: { conditions: { base: "fyvr12gl", active: "fyvr12gm", disabled: "fyvr12gn", focus: "fyvr12go", hover: "fyvr12gp", checked: "fyvr12gq" }, defaultClass: "fyvr12gl" }, gnosisDark: { conditions: { base: "fyvr12gr", active: "fyvr12gs", disabled: "fyvr12gt", focus: "fyvr12gu", hover: "fyvr12gv", checked: "fyvr12gw" }, defaultClass: "fyvr12gr" }, gnosisLight: { conditions: { base: "fyvr12gx", active: "fyvr12gy", disabled: "fyvr12gz", focus: "fyvr12h0", hover: "fyvr12h1", checked: "fyvr12h2" }, defaultClass: "fyvr12gx" }, polygonDark: { conditions: { base: "fyvr12h3", active: "fyvr12h4", disabled: "fyvr12h5", focus: "fyvr12h6", hover: "fyvr12h7", checked: "fyvr12h8" }, defaultClass: "fyvr12h3" }, polygonLight: { conditions: { base: "fyvr12h9", active: "fyvr12ha", disabled: "fyvr12hb", focus: "fyvr12hc", hover: "fyvr12hd", checked: "fyvr12he" }, defaultClass: "fyvr12h9" }, text100: { conditions: { base: "fyvr12hf", active: "fyvr12hg", disabled: "fyvr12hh", focus: "fyvr12hi", hover: "fyvr12hj", checked: "fyvr12hk" }, defaultClass: "fyvr12hf" }, text80: { conditions: { base: "fyvr12hl", active: "fyvr12hm", disabled: "fyvr12hn", focus: "fyvr12ho", hover: "fyvr12hp", checked: "fyvr12hq" }, defaultClass: "fyvr12hl" }, text50: { conditions: { base: "fyvr12hr", active: "fyvr12hs", disabled: "fyvr12ht", focus: "fyvr12hu", hover: "fyvr12hv", checked: "fyvr12hw" }, defaultClass: "fyvr12hr" }, textInverse100: { conditions: { base: "fyvr12hx", active: "fyvr12hy", disabled: "fyvr12hz", focus: "fyvr12i0", hover: "fyvr12i1", checked: "fyvr12i2" }, defaultClass: "fyvr12hx" }, backgroundPrimary: { conditions: { base: "fyvr12i3", active: "fyvr12i4", disabled: "fyvr12i5", focus: "fyvr12i6", hover: "fyvr12i7", checked: "fyvr12i8" }, defaultClass: "fyvr12i3" }, backgroundSecondary: { conditions: { base: "fyvr12i9", active: "fyvr12ia", disabled: "fyvr12ib", focus: "fyvr12ic", hover: "fyvr12id", checked: "fyvr12ie" }, defaultClass: "fyvr12i9" }, backgroundContrast: { conditions: { base: "fyvr12if", active: "fyvr12ig", disabled: "fyvr12ih", focus: "fyvr12ii", hover: "fyvr12ij", checked: "fyvr12ik" }, defaultClass: "fyvr12if" }, backgroundMuted: { conditions: { base: "fyvr12il", active: "fyvr12im", disabled: "fyvr12in", focus: "fyvr12io", hover: "fyvr12ip", checked: "fyvr12iq" }, defaultClass: "fyvr12il" }, backgroundControl: { conditions: { base: "fyvr12ir", active: "fyvr12is", disabled: "fyvr12it", focus: "fyvr12iu", hover: "fyvr12iv", checked: "fyvr12iw" }, defaultClass: "fyvr12ir" }, backgroundInverse: { conditions: { base: "fyvr12ix", active: "fyvr12iy", disabled: "fyvr12iz", focus: "fyvr12j0", hover: "fyvr12j1", checked: "fyvr12j2" }, defaultClass: "fyvr12ix" }, backgroundBackdrop: { conditions: { base: "fyvr12j3", active: "fyvr12j4", disabled: "fyvr12j5", focus: "fyvr12j6", hover: "fyvr12j7", checked: "fyvr12j8" }, defaultClass: "fyvr12j3" }, backgroundOverlay: { conditions: { base: "fyvr12j9", active: "fyvr12ja", disabled: "fyvr12jb", focus: "fyvr12jc", hover: "fyvr12jd", checked: "fyvr12je" }, defaultClass: "fyvr12j9" }, backgroundRaised: { conditions: { base: "fyvr12jf", active: "fyvr12jg", disabled: "fyvr12jh", focus: "fyvr12ji", hover: "fyvr12jj", checked: "fyvr12jk" }, defaultClass: "fyvr12jf" }, buttonGlass: { conditions: { base: "fyvr12jl", active: "fyvr12jm", disabled: "fyvr12jn", focus: "fyvr12jo", hover: "fyvr12jp", checked: "fyvr12jq" }, defaultClass: "fyvr12jl" }, buttonEmphasis: { conditions: { base: "fyvr12jr", active: "fyvr12js", disabled: "fyvr12jt", focus: "fyvr12ju", hover: "fyvr12jv", checked: "fyvr12jw" }, defaultClass: "fyvr12jr" }, buttonInverse: { conditions: { base: "fyvr12jx", active: "fyvr12jy", disabled: "fyvr12jz", focus: "fyvr12k0", hover: "fyvr12k1", checked: "fyvr12k2" }, defaultClass: "fyvr12jx" }, borderNormal: { conditions: { base: "fyvr12k3", active: "fyvr12k4", disabled: "fyvr12k5", focus: "fyvr12k6", hover: "fyvr12k7", checked: "fyvr12k8" }, defaultClass: "fyvr12k3" }, borderFocus: { conditions: { base: "fyvr12k9", active: "fyvr12ka", disabled: "fyvr12kb", focus: "fyvr12kc", hover: "fyvr12kd", checked: "fyvr12ke" }, defaultClass: "fyvr12k9" } } }, borderRightStyle: { values: { solid: { conditions: { base: "fyvr12kf", active: "fyvr12kg", disabled: "fyvr12kh", focus: "fyvr12ki", hover: "fyvr12kj", checked: "fyvr12kk" }, defaultClass: "fyvr12kf" }, dashed: { conditions: { base: "fyvr12kl", active: "fyvr12km", disabled: "fyvr12kn", focus: "fyvr12ko", hover: "fyvr12kp", checked: "fyvr12kq" }, defaultClass: "fyvr12kl" }, dotted: { conditions: { base: "fyvr12kr", active: "fyvr12ks", disabled: "fyvr12kt", focus: "fyvr12ku", hover: "fyvr12kv", checked: "fyvr12kw" }, defaultClass: "fyvr12kr" } } }, borderTopColor: { values: { black: { conditions: { base: "fyvr12kx", active: "fyvr12ky", disabled: "fyvr12kz", focus: "fyvr12l0", hover: "fyvr12l1", checked: "fyvr12l2" }, defaultClass: "fyvr12kx" }, white: { conditions: { base: "fyvr12l3", active: "fyvr12l4", disabled: "fyvr12l5", focus: "fyvr12l6", hover: "fyvr12l7", checked: "fyvr12l8" }, defaultClass: "fyvr12l3" }, inherit: { conditions: { base: "fyvr12l9", active: "fyvr12la", disabled: "fyvr12lb", focus: "fyvr12lc", hover: "fyvr12ld", checked: "fyvr12le" }, defaultClass: "fyvr12l9" }, transparent: { conditions: { base: "fyvr12lf", active: "fyvr12lg", disabled: "fyvr12lh", focus: "fyvr12li", hover: "fyvr12lj", checked: "fyvr12lk" }, defaultClass: "fyvr12lf" }, positive: { conditions: { base: "fyvr12ll", active: "fyvr12lm", disabled: "fyvr12ln", focus: "fyvr12lo", hover: "fyvr12lp", checked: "fyvr12lq" }, defaultClass: "fyvr12ll" }, negative: { conditions: { base: "fyvr12lr", active: "fyvr12ls", disabled: "fyvr12lt", focus: "fyvr12lu", hover: "fyvr12lv", checked: "fyvr12lw" }, defaultClass: "fyvr12lr" }, info: { conditions: { base: "fyvr12lx", active: "fyvr12ly", disabled: "fyvr12lz", focus: "fyvr12m0", hover: "fyvr12m1", checked: "fyvr12m2" }, defaultClass: "fyvr12lx" }, warning: { conditions: { base: "fyvr12m3", active: "fyvr12m4", disabled: "fyvr12m5", focus: "fyvr12m6", hover: "fyvr12m7", checked: "fyvr12m8" }, defaultClass: "fyvr12m3" }, gradientBackdrop: { conditions: { base: "fyvr12m9", active: "fyvr12ma", disabled: "fyvr12mb", focus: "fyvr12mc", hover: "fyvr12md", checked: "fyvr12me" }, defaultClass: "fyvr12m9" }, gradientPrimary: { conditions: { base: "fyvr12mf", active: "fyvr12mg", disabled: "fyvr12mh", focus: "fyvr12mi", hover: "fyvr12mj", checked: "fyvr12mk" }, defaultClass: "fyvr12mf" }, gradientSecondary: { conditions: { base: "fyvr12ml", active: "fyvr12mm", disabled: "fyvr12mn", focus: "fyvr12mo", hover: "fyvr12mp", checked: "fyvr12mq" }, defaultClass: "fyvr12ml" }, arbitrumDark: { conditions: { base: "fyvr12mr", active: "fyvr12ms", disabled: "fyvr12mt", focus: "fyvr12mu", hover: "fyvr12mv", checked: "fyvr12mw" }, defaultClass: "fyvr12mr" }, arbitrumLight: { conditions: { base: "fyvr12mx", active: "fyvr12my", disabled: "fyvr12mz", focus: "fyvr12n0", hover: "fyvr12n1", checked: "fyvr12n2" }, defaultClass: "fyvr12mx" }, avalanceDark: { conditions: { base: "fyvr12n3", active: "fyvr12n4", disabled: "fyvr12n5", focus: "fyvr12n6", hover: "fyvr12n7", checked: "fyvr12n8" }, defaultClass: "fyvr12n3" }, avalanceLight: { conditions: { base: "fyvr12n9", active: "fyvr12na", disabled: "fyvr12nb", focus: "fyvr12nc", hover: "fyvr12nd", checked: "fyvr12ne" }, defaultClass: "fyvr12n9" }, bscDark: { conditions: { base: "fyvr12nf", active: "fyvr12ng", disabled: "fyvr12nh", focus: "fyvr12ni", hover: "fyvr12nj", checked: "fyvr12nk" }, defaultClass: "fyvr12nf" }, bscLight: { conditions: { base: "fyvr12nl", active: "fyvr12nm", disabled: "fyvr12nn", focus: "fyvr12no", hover: "fyvr12np", checked: "fyvr12nq" }, defaultClass: "fyvr12nl" }, ethereumDark: { conditions: { base: "fyvr12nr", active: "fyvr12ns", disabled: "fyvr12nt", focus: "fyvr12nu", hover: "fyvr12nv", checked: "fyvr12nw" }, defaultClass: "fyvr12nr" }, ethereumLight: { conditions: { base: "fyvr12nx", active: "fyvr12ny", disabled: "fyvr12nz", focus: "fyvr12o0", hover: "fyvr12o1", checked: "fyvr12o2" }, defaultClass: "fyvr12nx" }, gnosisDark: { conditions: { base: "fyvr12o3", active: "fyvr12o4", disabled: "fyvr12o5", focus: "fyvr12o6", hover: "fyvr12o7", checked: "fyvr12o8" }, defaultClass: "fyvr12o3" }, gnosisLight: { conditions: { base: "fyvr12o9", active: "fyvr12oa", disabled: "fyvr12ob", focus: "fyvr12oc", hover: "fyvr12od", checked: "fyvr12oe" }, defaultClass: "fyvr12o9" }, polygonDark: { conditions: { base: "fyvr12of", active: "fyvr12og", disabled: "fyvr12oh", focus: "fyvr12oi", hover: "fyvr12oj", checked: "fyvr12ok" }, defaultClass: "fyvr12of" }, polygonLight: { conditions: { base: "fyvr12ol", active: "fyvr12om", disabled: "fyvr12on", focus: "fyvr12oo", hover: "fyvr12op", checked: "fyvr12oq" }, defaultClass: "fyvr12ol" }, text100: { conditions: { base: "fyvr12or", active: "fyvr12os", disabled: "fyvr12ot", focus: "fyvr12ou", hover: "fyvr12ov", checked: "fyvr12ow" }, defaultClass: "fyvr12or" }, text80: { conditions: { base: "fyvr12ox", active: "fyvr12oy", disabled: "fyvr12oz", focus: "fyvr12p0", hover: "fyvr12p1", checked: "fyvr12p2" }, defaultClass: "fyvr12ox" }, text50: { conditions: { base: "fyvr12p3", active: "fyvr12p4", disabled: "fyvr12p5", focus: "fyvr12p6", hover: "fyvr12p7", checked: "fyvr12p8" }, defaultClass: "fyvr12p3" }, textInverse100: { conditions: { base: "fyvr12p9", active: "fyvr12pa", disabled: "fyvr12pb", focus: "fyvr12pc", hover: "fyvr12pd", checked: "fyvr12pe" }, defaultClass: "fyvr12p9" }, backgroundPrimary: { conditions: { base: "fyvr12pf", active: "fyvr12pg", disabled: "fyvr12ph", focus: "fyvr12pi", hover: "fyvr12pj", checked: "fyvr12pk" }, defaultClass: "fyvr12pf" }, backgroundSecondary: { conditions: { base: "fyvr12pl", active: "fyvr12pm", disabled: "fyvr12pn", focus: "fyvr12po", hover: "fyvr12pp", checked: "fyvr12pq" }, defaultClass: "fyvr12pl" }, backgroundContrast: { conditions: { base: "fyvr12pr", active: "fyvr12ps", disabled: "fyvr12pt", focus: "fyvr12pu", hover: "fyvr12pv", checked: "fyvr12pw" }, defaultClass: "fyvr12pr" }, backgroundMuted: { conditions: { base: "fyvr12px", active: "fyvr12py", disabled: "fyvr12pz", focus: "fyvr12q0", hover: "fyvr12q1", checked: "fyvr12q2" }, defaultClass: "fyvr12px" }, backgroundControl: { conditions: { base: "fyvr12q3", active: "fyvr12q4", disabled: "fyvr12q5", focus: "fyvr12q6", hover: "fyvr12q7", checked: "fyvr12q8" }, defaultClass: "fyvr12q3" }, backgroundInverse: { conditions: { base: "fyvr12q9", active: "fyvr12qa", disabled: "fyvr12qb", focus: "fyvr12qc", hover: "fyvr12qd", checked: "fyvr12qe" }, defaultClass: "fyvr12q9" }, backgroundBackdrop: { conditions: { base: "fyvr12qf", active: "fyvr12qg", disabled: "fyvr12qh", focus: "fyvr12qi", hover: "fyvr12qj", checked: "fyvr12qk" }, defaultClass: "fyvr12qf" }, backgroundOverlay: { conditions: { base: "fyvr12ql", active: "fyvr12qm", disabled: "fyvr12qn", focus: "fyvr12qo", hover: "fyvr12qp", checked: "fyvr12qq" }, defaultClass: "fyvr12ql" }, backgroundRaised: { conditions: { base: "fyvr12qr", active: "fyvr12qs", disabled: "fyvr12qt", focus: "fyvr12qu", hover: "fyvr12qv", checked: "fyvr12qw" }, defaultClass: "fyvr12qr" }, buttonGlass: { conditions: { base: "fyvr12qx", active: "fyvr12qy", disabled: "fyvr12qz", focus: "fyvr12r0", hover: "fyvr12r1", checked: "fyvr12r2" }, defaultClass: "fyvr12qx" }, buttonEmphasis: { conditions: { base: "fyvr12r3", active: "fyvr12r4", disabled: "fyvr12r5", focus: "fyvr12r6", hover: "fyvr12r7", checked: "fyvr12r8" }, defaultClass: "fyvr12r3" }, buttonInverse: { conditions: { base: "fyvr12r9", active: "fyvr12ra", disabled: "fyvr12rb", focus: "fyvr12rc", hover: "fyvr12rd", checked: "fyvr12re" }, defaultClass: "fyvr12r9" }, borderNormal: { conditions: { base: "fyvr12rf", active: "fyvr12rg", disabled: "fyvr12rh", focus: "fyvr12ri", hover: "fyvr12rj", checked: "fyvr12rk" }, defaultClass: "fyvr12rf" }, borderFocus: { conditions: { base: "fyvr12rl", active: "fyvr12rm", disabled: "fyvr12rn", focus: "fyvr12ro", hover: "fyvr12rp", checked: "fyvr12rq" }, defaultClass: "fyvr12rl" } } }, borderTopStyle: { values: { solid: { conditions: { base: "fyvr12rr", active: "fyvr12rs", disabled: "fyvr12rt", focus: "fyvr12ru", hover: "fyvr12rv", checked: "fyvr12rw" }, defaultClass: "fyvr12rr" }, dashed: { conditions: { base: "fyvr12rx", active: "fyvr12ry", disabled: "fyvr12rz", focus: "fyvr12s0", hover: "fyvr12s1", checked: "fyvr12s2" }, defaultClass: "fyvr12rx" }, dotted: { conditions: { base: "fyvr12s3", active: "fyvr12s4", disabled: "fyvr12s5", focus: "fyvr12s6", hover: "fyvr12s7", checked: "fyvr12s8" }, defaultClass: "fyvr12s3" } } }, border: { values: { none: { conditions: { base: "fyvr12s9", active: "fyvr12sa", disabled: "fyvr12sb", focus: "fyvr12sc", hover: "fyvr12sd", checked: "fyvr12se" }, defaultClass: "fyvr12s9" } } }, color: { values: { black: { conditions: { base: "fyvr12sf", active: "fyvr12sg", disabled: "fyvr12sh", focus: "fyvr12si", hover: "fyvr12sj", checked: "fyvr12sk" }, defaultClass: "fyvr12sf" }, white: { conditions: { base: "fyvr12sl", active: "fyvr12sm", disabled: "fyvr12sn", focus: "fyvr12so", hover: "fyvr12sp", checked: "fyvr12sq" }, defaultClass: "fyvr12sl" }, inherit: { conditions: { base: "fyvr12sr", active: "fyvr12ss", disabled: "fyvr12st", focus: "fyvr12su", hover: "fyvr12sv", checked: "fyvr12sw" }, defaultClass: "fyvr12sr" }, transparent: { conditions: { base: "fyvr12sx", active: "fyvr12sy", disabled: "fyvr12sz", focus: "fyvr12t0", hover: "fyvr12t1", checked: "fyvr12t2" }, defaultClass: "fyvr12sx" }, positive: { conditions: { base: "fyvr12t3", active: "fyvr12t4", disabled: "fyvr12t5", focus: "fyvr12t6", hover: "fyvr12t7", checked: "fyvr12t8" }, defaultClass: "fyvr12t3" }, negative: { conditions: { base: "fyvr12t9", active: "fyvr12ta", disabled: "fyvr12tb", focus: "fyvr12tc", hover: "fyvr12td", checked: "fyvr12te" }, defaultClass: "fyvr12t9" }, info: { conditions: { base: "fyvr12tf", active: "fyvr12tg", disabled: "fyvr12th", focus: "fyvr12ti", hover: "fyvr12tj", checked: "fyvr12tk" }, defaultClass: "fyvr12tf" }, warning: { conditions: { base: "fyvr12tl", active: "fyvr12tm", disabled: "fyvr12tn", focus: "fyvr12to", hover: "fyvr12tp", checked: "fyvr12tq" }, defaultClass: "fyvr12tl" }, gradientBackdrop: { conditions: { base: "fyvr12tr", active: "fyvr12ts", disabled: "fyvr12tt", focus: "fyvr12tu", hover: "fyvr12tv", checked: "fyvr12tw" }, defaultClass: "fyvr12tr" }, gradientPrimary: { conditions: { base: "fyvr12tx", active: "fyvr12ty", disabled: "fyvr12tz", focus: "fyvr12u0", hover: "fyvr12u1", checked: "fyvr12u2" }, defaultClass: "fyvr12tx" }, gradientSecondary: { conditions: { base: "fyvr12u3", active: "fyvr12u4", disabled: "fyvr12u5", focus: "fyvr12u6", hover: "fyvr12u7", checked: "fyvr12u8" }, defaultClass: "fyvr12u3" }, arbitrumDark: { conditions: { base: "fyvr12u9", active: "fyvr12ua", disabled: "fyvr12ub", focus: "fyvr12uc", hover: "fyvr12ud", checked: "fyvr12ue" }, defaultClass: "fyvr12u9" }, arbitrumLight: { conditions: { base: "fyvr12uf", active: "fyvr12ug", disabled: "fyvr12uh", focus: "fyvr12ui", hover: "fyvr12uj", checked: "fyvr12uk" }, defaultClass: "fyvr12uf" }, avalanceDark: { conditions: { base: "fyvr12ul", active: "fyvr12um", disabled: "fyvr12un", focus: "fyvr12uo", hover: "fyvr12up", checked: "fyvr12uq" }, defaultClass: "fyvr12ul" }, avalanceLight: { conditions: { base: "fyvr12ur", active: "fyvr12us", disabled: "fyvr12ut", focus: "fyvr12uu", hover: "fyvr12uv", checked: "fyvr12uw" }, defaultClass: "fyvr12ur" }, bscDark: { conditions: { base: "fyvr12ux", active: "fyvr12uy", disabled: "fyvr12uz", focus: "fyvr12v0", hover: "fyvr12v1", checked: "fyvr12v2" }, defaultClass: "fyvr12ux" }, bscLight: { conditions: { base: "fyvr12v3", active: "fyvr12v4", disabled: "fyvr12v5", focus: "fyvr12v6", hover: "fyvr12v7", checked: "fyvr12v8" }, defaultClass: "fyvr12v3" }, ethereumDark: { conditions: { base: "fyvr12v9", active: "fyvr12va", disabled: "fyvr12vb", focus: "fyvr12vc", hover: "fyvr12vd", checked: "fyvr12ve" }, defaultClass: "fyvr12v9" }, ethereumLight: { conditions: { base: "fyvr12vf", active: "fyvr12vg", disabled: "fyvr12vh", focus: "fyvr12vi", hover: "fyvr12vj", checked: "fyvr12vk" }, defaultClass: "fyvr12vf" }, gnosisDark: { conditions: { base: "fyvr12vl", active: "fyvr12vm", disabled: "fyvr12vn", focus: "fyvr12vo", hover: "fyvr12vp", checked: "fyvr12vq" }, defaultClass: "fyvr12vl" }, gnosisLight: { conditions: { base: "fyvr12vr", active: "fyvr12vs", disabled: "fyvr12vt", focus: "fyvr12vu", hover: "fyvr12vv", checked: "fyvr12vw" }, defaultClass: "fyvr12vr" }, polygonDark: { conditions: { base: "fyvr12vx", active: "fyvr12vy", disabled: "fyvr12vz", focus: "fyvr12w0", hover: "fyvr12w1", checked: "fyvr12w2" }, defaultClass: "fyvr12vx" }, polygonLight: { conditions: { base: "fyvr12w3", active: "fyvr12w4", disabled: "fyvr12w5", focus: "fyvr12w6", hover: "fyvr12w7", checked: "fyvr12w8" }, defaultClass: "fyvr12w3" }, text100: { conditions: { base: "fyvr12w9", active: "fyvr12wa", disabled: "fyvr12wb", focus: "fyvr12wc", hover: "fyvr12wd", checked: "fyvr12we" }, defaultClass: "fyvr12w9" }, text80: { conditions: { base: "fyvr12wf", active: "fyvr12wg", disabled: "fyvr12wh", focus: "fyvr12wi", hover: "fyvr12wj", checked: "fyvr12wk" }, defaultClass: "fyvr12wf" }, text50: { conditions: { base: "fyvr12wl", active: "fyvr12wm", disabled: "fyvr12wn", focus: "fyvr12wo", hover: "fyvr12wp", checked: "fyvr12wq" }, defaultClass: "fyvr12wl" }, textInverse100: { conditions: { base: "fyvr12wr", active: "fyvr12ws", disabled: "fyvr12wt", focus: "fyvr12wu", hover: "fyvr12wv", checked: "fyvr12ww" }, defaultClass: "fyvr12wr" }, backgroundPrimary: { conditions: { base: "fyvr12wx", active: "fyvr12wy", disabled: "fyvr12wz", focus: "fyvr12x0", hover: "fyvr12x1", checked: "fyvr12x2" }, defaultClass: "fyvr12wx" }, backgroundSecondary: { conditions: { base: "fyvr12x3", active: "fyvr12x4", disabled: "fyvr12x5", focus: "fyvr12x6", hover: "fyvr12x7", checked: "fyvr12x8" }, defaultClass: "fyvr12x3" }, backgroundContrast: { conditions: { base: "fyvr12x9", active: "fyvr12xa", disabled: "fyvr12xb", focus: "fyvr12xc", hover: "fyvr12xd", checked: "fyvr12xe" }, defaultClass: "fyvr12x9" }, backgroundMuted: { conditions: { base: "fyvr12xf", active: "fyvr12xg", disabled: "fyvr12xh", focus: "fyvr12xi", hover: "fyvr12xj", checked: "fyvr12xk" }, defaultClass: "fyvr12xf" }, backgroundControl: { conditions: { base: "fyvr12xl", active: "fyvr12xm", disabled: "fyvr12xn", focus: "fyvr12xo", hover: "fyvr12xp", checked: "fyvr12xq" }, defaultClass: "fyvr12xl" }, backgroundInverse: { conditions: { base: "fyvr12xr", active: "fyvr12xs", disabled: "fyvr12xt", focus: "fyvr12xu", hover: "fyvr12xv", checked: "fyvr12xw" }, defaultClass: "fyvr12xr" }, backgroundBackdrop: { conditions: { base: "fyvr12xx", active: "fyvr12xy", disabled: "fyvr12xz", focus: "fyvr12y0", hover: "fyvr12y1", checked: "fyvr12y2" }, defaultClass: "fyvr12xx" }, backgroundOverlay: { conditions: { base: "fyvr12y3", active: "fyvr12y4", disabled: "fyvr12y5", focus: "fyvr12y6", hover: "fyvr12y7", checked: "fyvr12y8" }, defaultClass: "fyvr12y3" }, backgroundRaised: { conditions: { base: "fyvr12y9", active: "fyvr12ya", disabled: "fyvr12yb", focus: "fyvr12yc", hover: "fyvr12yd", checked: "fyvr12ye" }, defaultClass: "fyvr12y9" }, buttonGlass: { conditions: { base: "fyvr12yf", active: "fyvr12yg", disabled: "fyvr12yh", focus: "fyvr12yi", hover: "fyvr12yj", checked: "fyvr12yk" }, defaultClass: "fyvr12yf" }, buttonEmphasis: { conditions: { base: "fyvr12yl", active: "fyvr12ym", disabled: "fyvr12yn", focus: "fyvr12yo", hover: "fyvr12yp", checked: "fyvr12yq" }, defaultClass: "fyvr12yl" }, buttonInverse: { conditions: { base: "fyvr12yr", active: "fyvr12ys", disabled: "fyvr12yt", focus: "fyvr12yu", hover: "fyvr12yv", checked: "fyvr12yw" }, defaultClass: "fyvr12yr" }, borderNormal: { conditions: { base: "fyvr12yx", active: "fyvr12yy", disabled: "fyvr12yz", focus: "fyvr12z0", hover: "fyvr12z1", checked: "fyvr12z2" }, defaultClass: "fyvr12yx" }, borderFocus: { conditions: { base: "fyvr12z3", active: "fyvr12z4", disabled: "fyvr12z5", focus: "fyvr12z6", hover: "fyvr12z7", checked: "fyvr12z8" }, defaultClass: "fyvr12z3" } } }, cursor: { values: { "default": { conditions: { base: "fyvr12z9", active: "fyvr12za", disabled: "fyvr12zb", focus: "fyvr12zc", hover: "fyvr12zd", checked: "fyvr12ze" }, defaultClass: "fyvr12z9" }, pointer: { conditions: { base: "fyvr12zf", active: "fyvr12zg", disabled: "fyvr12zh", focus: "fyvr12zi", hover: "fyvr12zj", checked: "fyvr12zk" }, defaultClass: "fyvr12zf" }, text: { conditions: { base: "fyvr12zl", active: "fyvr12zm", disabled: "fyvr12zn", focus: "fyvr12zo", hover: "fyvr12zp", checked: "fyvr12zq" }, defaultClass: "fyvr12zl" } } }, opacity: { values: { "0": { conditions: { base: "fyvr12zr", active: "fyvr12zs", disabled: "fyvr12zt", focus: "fyvr12zu", hover: "fyvr12zv", checked: "fyvr12zw" }, defaultClass: "fyvr12zr" }, "50": { conditions: { base: "fyvr12zx", active: "fyvr12zy", disabled: "fyvr12zz", focus: "fyvr1300", hover: "fyvr1301", checked: "fyvr1302" }, defaultClass: "fyvr12zx" }, "80": { conditions: { base: "fyvr1303", active: "fyvr1304", disabled: "fyvr1305", focus: "fyvr1306", hover: "fyvr1307", checked: "fyvr1308" }, defaultClass: "fyvr1303" }, "100": { conditions: { base: "fyvr1309", active: "fyvr130a", disabled: "fyvr130b", focus: "fyvr130c", hover: "fyvr130d", checked: "fyvr130e" }, defaultClass: "fyvr1309" } } }, pointerEvents: { values: { none: { conditions: { base: "fyvr130f", active: "fyvr130g", disabled: "fyvr130h", focus: "fyvr130i", hover: "fyvr130j", checked: "fyvr130k" }, defaultClass: "fyvr130f" }, auto: { conditions: { base: "fyvr130l", active: "fyvr130m", disabled: "fyvr130n", focus: "fyvr130o", hover: "fyvr130p", checked: "fyvr130q" }, defaultClass: "fyvr130l" } } }, outline: { values: { none: { conditions: { base: "fyvr130r", active: "fyvr130s", disabled: "fyvr130t", focus: "fyvr130u", hover: "fyvr130v", checked: "fyvr130w" }, defaultClass: "fyvr130r" } } }, boxShadow: { values: { none: { conditions: { base: "fyvr130x", active: "fyvr130y", disabled: "fyvr130z", focus: "fyvr1310", hover: "fyvr1311", checked: "fyvr1312" }, defaultClass: "fyvr130x" } } } } });
const FLEX_PROPS = [
  "alignItems",
  "alignSelf",
  "flexDirection",
  "gap",
  "justifyContent",
  "justifySelf",
  "placeItems"
];
const atoms = (props) => {
  props.display || (props.display = Object.keys(props).some((prop) => FLEX_PROPS.includes(prop)) ? "flex" : void 0);
  return sprinkles(props);
};
atoms.properties = sprinkles.properties;
const truncateAddress = (address, minPrefix = 20, minSuffix = 3) => {
  if (minPrefix + minSuffix >= 40) {
    return address;
  } else {
    return `${address.substring(0, 2 + minPrefix)}${address.substring(address.length - minSuffix)}`;
  }
};
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const SEQUENCE_ASSETS_URL_PREFIX = "https://assets.sequence.info/";
const VERSION$3 = 5;
const sizes = {
  xs: "small",
  sm: "small",
  md: "medium",
  lg: "large",
  xl: "large"
};
const getSize = (size2) => size2 ? sizes[size2] || size2 : "medium";
const replaceSize = (url, size2) => {
  return url.replace(/\/(small|medium|large)\//, `/${getSize(size2)}/`);
};
const tokenImageUrl = (chainId, contractAddress, size2) => {
  return SEQUENCE_ASSETS_URL_PREFIX + `images/tokens/${getSize(
    size2
  )}/${chainId}/${contractAddress.toLowerCase()}.webp?v${VERSION$3}`;
};
const nativeTokenImageUrl = (chainId, size2) => tokenImageUrl(chainId, ZERO_ADDRESS, size2);
const networkImageUrl = (chainId, size2) => {
  return SEQUENCE_ASSETS_URL_PREFIX + `images/networks/${getSize(size2)}/${chainId}.webp?v${VERSION$3}`;
};
function r$3(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$3(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$3(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const Box = reactExports.forwardRef(
  (props, ref) => {
    const { as = "div", sx = {}, className, ...restProps } = props;
    const atomProps = {};
    const nativeProps = {};
    for (const key in restProps) {
      if (atoms.properties.has(key)) {
        atomProps[key] = restProps[key];
      } else {
        nativeProps[key] = restProps[key];
      }
    }
    const atomicClasses = atoms({
      ...atomProps,
      ...sx
    });
    return reactExports.createElement(as, {
      className: clsx(atomicClasses, className),
      ...nativeProps,
      ref
    });
  }
);
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = React, k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q2(c2, a2, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
{
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
}
var jsxRuntimeExports = jsxRuntime.exports;
function toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty$2(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function mapValues(input2, fn) {
  var result = {};
  for (var _key in input2) {
    result[_key] = fn(input2[_key], _key);
  }
  return result;
}
var shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {
  for (var key of Object.keys(compoundCheck)) {
    var _selections$key;
    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {
      return false;
    }
  }
  return true;
};
var createRuntimeFn = (config2) => {
  var runtimeFn = (options) => {
    var className = config2.defaultClassName;
    var selections = _objectSpread2(_objectSpread2({}, config2.defaultVariants), options);
    for (var variantName in selections) {
      var _selections$variantNa;
      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config2.defaultVariants[variantName];
      if (variantSelection != null) {
        var selection = variantSelection;
        if (typeof selection === "boolean") {
          selection = selection === true ? "true" : "false";
        }
        var selectionClassName = (
          // @ts-expect-error
          config2.variantClassNames[variantName][selection]
        );
        if (selectionClassName) {
          className += " " + selectionClassName;
        }
      }
    }
    for (var [compoundCheck, compoundClassName] of config2.compoundVariants) {
      if (shouldApplyCompound(compoundCheck, selections, config2.defaultVariants)) {
        className += " " + compoundClassName;
      }
    }
    return className;
  };
  runtimeFn.variants = () => Object.keys(config2.variantClassNames);
  runtimeFn.classNames = {
    get base() {
      return config2.defaultClassName.split(" ")[0];
    },
    get variants() {
      return mapValues(config2.variantClassNames, (classNames) => mapValues(classNames, (className) => className.split(" ")[0]));
    }
  };
  return runtimeFn;
};
createRuntimeFn({ defaultClassName: "_2q9vfj7", variantClassNames: { variant: { info: "_2q9vfj8 _2q9vfj0 fyvr11t3", warning: "_2q9vfj9 _2q9vfj1 fyvr11t9", success: "_2q9vfja _2q9vfj2 fyvr11sr", error: "_2q9vfjb _2q9vfj3 fyvr11sx" }, size: { sm: "_2q9vfjc _1qxj1ib9 _1qxj1ibf _1qxj1ib5 fyvr11r3 fyvr11ik fyvr11k4 fyvr11k0 fyvr11jc _2q9vfj4 fyvr1zc fyvr111g fyvr144 fyvr1f4", md: "_2q9vfjd _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _2q9vfj5 fyvr1zg fyvr111k fyvr148 fyvr1f8", lg: "_2q9vfje _1qxj1ib9 _1qxj1ibd _1qxj1ib3 fyvr11r3 fyvr11is fyvr11kc fyvr11jw fyvr11jk _2q9vfj6 fyvr1zk fyvr111o fyvr14c fyvr1fc" } }, defaultVariants: {}, compoundVariants: [] });
const Divider = (props) => {
  const { color: color2 = "borderNormal", marginY = "4", ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: "hr",
      marginY,
      background: color2,
      height: "px",
      borderWidth: "none",
      ...rest
    }
  );
};
var textVariants = createRuntimeFn({ defaultClassName: "_1qxj1ib9", variantClassNames: { variant: { inherit: "_1qxj1iba _1qxj1ib0 fyvr11r2 fyvr11ic fyvr11ko fyvr11jo fyvr11j4", xlarge: "_1qxj1ibb _1qxj1ib1 fyvr11r3 fyvr11j0 fyvr11kk fyvr11js fyvr11jk", large: "_1qxj1ibc _1qxj1ib2 fyvr11r3 fyvr11iw fyvr11kg fyvr11jw fyvr11jg", medium: "_1qxj1ibd _1qxj1ib3 fyvr11r3 fyvr11is fyvr11kc fyvr11jw fyvr11jk", normal: "_1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8", small: "_1qxj1ibf _1qxj1ib5 fyvr11r3 fyvr11ik fyvr11k4 fyvr11k0 fyvr11jc", xsmall: "_1qxj1ibg _1qxj1ib6 fyvr11r3 fyvr11ig fyvr11k4 fyvr11k0 fyvr11jk", code: "_1qxj1ibh _1qxj1ib7 fyvr11r4 fyvr11io fyvr11k8 fyvr11js fyvr11j8" }, ellipsis: { true: "_1qxj1ibi _1qxj1ib8 fyvr11q0 fyvr11qg fyvr11rh fyvr11r5" }, italic: { true: "_1qxj1ibj" }, underline: { true: "_1qxj1ibk" }, uppercase: { true: "_1qxj1ibl" }, capitalize: { true: "_1qxj1ibm" }, hidden: { true: "_1qxj1ibn" } }, defaultVariants: {}, compoundVariants: [] });
const Text = reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "span",
      variant = "inherit",
      className,
      hidden,
      italic,
      underline,
      children,
      ellipsis,
      uppercase,
      capitalize: capitalize2,
      ...boxProps
    } = props;
    const textVariantProps = text[variant];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as,
        className: clsx(
          className,
          textVariants({
            hidden,
            ellipsis,
            italic,
            underline,
            uppercase,
            capitalize: capitalize2
          })
        ),
        ref,
        ...textVariantProps,
        ...boxProps,
        children
      }
    );
  }
);
var buttonVariants = createRuntimeFn({ defaultClassName: "_140wn8ni _140wn8n0 fyvr11q0 fyvr11qg fyvr11rh fyvr11ow fyvr12s9 fyvr11ra fyvr11l8 _4efw240", variantClassNames: { variant: { base: "_140wn8nj _140wn8n1 fyvr11sl fyvr12w9", ghost: "_140wn8nk _140wn8n2 fyvr11sl fyvr12w9", feature: "_140wn8nl _140wn8n3 fyvr11tr fyvr12sl", primary: "_140wn8nm _140wn8n4 fyvr11tl fyvr12sl", glass: "_140wn8nn _140wn8n5 fyvr11y3 fyvr12w9", emphasis: "_140wn8no _140wn8n6 fyvr11y9 fyvr12w9", raised: "_140wn8np _140wn8n7 fyvr11xx fyvr12w9", danger: "_140wn8nq _140wn8n8 fyvr11sx fyvr12sl", text: "_140wn8nr _1qxj1ib9 _1qxj1ibf _1qxj1ib5 fyvr11r3 fyvr11ik fyvr11k4 fyvr11k0 fyvr11jc _140wn8n9 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr11sl fyvr12wl" }, shape: { circle: "_140wn8ns _140wn8na fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw", square: "_140wn8nt _140wn8nb fyvr11h8 fyvr11hw fyvr11fw fyvr11gk" }, disabled: { true: "_140wn8nu _140wn8nc fyvr12z9 fyvr12zx", false: "_140wn8nv _140wn8nd fyvr12zf fyvr1309 fyvr1307" }, size: { xs: "_140wn8nw _1qxj1ib9 _1qxj1ibg _1qxj1ib6 fyvr11r3 fyvr11ig fyvr11k4 fyvr11k0 fyvr11jk _140wn8ne fyvr1zg fyvr111k", sm: "_140wn8nx _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _140wn8nf fyvr1zk fyvr111o", md: "_140wn8ny _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _140wn8ng fyvr1zo fyvr111s", lg: "_140wn8nz _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _140wn8nh fyvr1zo fyvr111s" }, iconOnly: { true: "_140wn8n10" }, hasLeftIcon: { true: "_140wn8n11" }, hasRightIcon: { true: "_140wn8n12" }, activeOutline: { light: "_140wn8n13", bold: "_140wn8n14" } }, defaultVariants: {}, compoundVariants: [[{ iconOnly: true, size: "xs" }, "_140wn8n15"], [{ iconOnly: true, size: "sm" }, "_140wn8n16"], [{ iconOnly: true, size: "md" }, "_140wn8n17"], [{ iconOnly: true, size: "lg" }, "_140wn8n18"], [{ iconOnly: false, hasLeftIcon: true, size: "xs" }, "_140wn8n19"], [{ iconOnly: false, hasLeftIcon: true, size: "sm" }, "_140wn8n1a"], [{ iconOnly: false, hasLeftIcon: true, size: "md" }, "_140wn8n1b"], [{ iconOnly: false, hasRightIcon: true, size: "xs" }, "_140wn8n1c"], [{ iconOnly: false, hasRightIcon: true, size: "sm" }, "_140wn8n1d"], [{ iconOnly: false, hasRightIcon: true, size: "md" }, "_140wn8n1e"]] });
const Button = reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "button",
      activeOutline,
      className,
      disabled = false,
      display = "inline-flex",
      fontWeight = "bold",
      pending = false,
      label,
      leftIcon: LeftIcon,
      rightIcon: RightIcon,
      size: size2 = "md",
      variant = "glass",
      width = "fit",
      shape = "circle",
      type = "button",
      ...restProps
    } = props;
    const hasLeftIcon = LeftIcon !== void 0 && label !== void 0;
    const hasRightIcon = RightIcon !== void 0 && label !== void 0;
    const iconOnly = LeftIcon !== void 0 && label === void 0;
    const iconSize = size2 === "xs" ? "xs" : "sm";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as,
        className: clsx(
          className,
          buttonVariants({
            activeOutline,
            disabled: disabled || pending,
            hasLeftIcon,
            hasRightIcon,
            iconOnly,
            size: variant === "text" ? void 0 : size2,
            shape: variant === "text" ? void 0 : shape,
            variant
          })
        ),
        disabled: disabled || pending,
        display,
        fontWeight,
        ref,
        type,
        width,
        ...restProps,
        children: iconOnly ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: iconSize }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            width: "full",
            height: "full",
            justifyContent: "space-between",
            alignItems: "center",
            gap: size2 === "xs" ? "1" : "2",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box,
                {
                  justifyContent: "flex-start",
                  alignItems: "center",
                  gap: size2 === "xs" ? "1" : "2",
                  children: [
                    LeftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: iconSize }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: label })
                  ]
                }
              ),
              RightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(RightIcon, { size: iconSize })
            ]
          }
        )
      }
    );
  }
);
var cardVariants = createRuntimeFn({ defaultClassName: "rhmai63", variantClassNames: { clickable: { true: "rhmai64 rhmai60 fyvr11ec fyvr11eo fyvr11f0 fyvr11fc fyvr1307 fyvr12zf _4efw240" }, disabled: { true: "rhmai65" }, outlined: { true: "rhmai66 rhmai61 fyvr11eg fyvr11es fyvr11f4 fyvr11fg fyvr12rf fyvr12k3 fyvr125f fyvr12cr fyvr12rr fyvr12kf fyvr125r fyvr12d3" }, blur: { true: "rhmai67 rhmai62 fyvr11r0" } }, defaultVariants: {}, compoundVariants: [] });
const Card = reactExports.forwardRef(
  (props, ref) => {
    const {
      className,
      children,
      clickable,
      outlined,
      disabled,
      blur: blur2,
      width = "full",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: clsx(
          className,
          cardVariants({ clickable, outlined, disabled, blur: blur2 })
        ),
        background: outlined ? "transparent" : "backgroundSecondary",
        overflow: "hidden",
        borderRadius: "md",
        padding: "4",
        width,
        ref,
        ...rest,
        children
      }
    );
  }
);
function setRef$1(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs$1(...refs) {
  return (node) => refs.forEach((ref) => setRef$1(ref, node));
}
function useComposedRefs$1(...refs) {
  return reactExports.useCallback(composeRefs$1(...refs), refs);
}
function createContext2(rootComponentName, defaultContext) {
  const Context = reactExports.createContext(defaultContext);
  function Provider2(props) {
    const { children, ...context2 } = props;
    const value = reactExports.useMemo(() => context2, Object.values(context2));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
  }
  function useContext2(consumerName) {
    const context2 = reactExports.useContext(Context);
    if (context2) return context2;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider2.displayName = rootComponentName + "Provider";
  return [Provider2, useContext2];
}
function createContextScope$1(scopeName, createContextScopeDeps = []) {
  let defaultContexts2 = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts2.length;
    defaultContexts2 = [...defaultContexts2, defaultContext];
    function Provider2(props) {
      const { scope, children, ...context2 } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(() => context2, Object.values(context2));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context2 = reactExports.useContext(Context);
      if (context2) return context2;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope2 = () => {
    const scopeContexts = defaultContexts2.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope2.scopeName = scopeName;
  return [createContext3, composeContextScopes$1(createScope2, ...createContextScopeDeps)];
}
function composeContextScopes$1(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope2 = () => {
    const scopeHooks = scopes.map((createScope22) => ({
      useScope: createScope22(),
      scopeName: createScope22.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope2.scopeName = baseScope.scopeName;
  return createScope2;
}
function composeEventHandlers$1(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function useCallbackRef$1$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useControllableState$1({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState$1({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1$1(onChange);
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState$1({
  defaultProp,
  onChange
}) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = useCallbackRef$1$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
function usePrevious(value) {
  const ref = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var useLayoutEffect2$1 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
function useSize$1(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2$1(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
function useStateMachine$1(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence$1 = (props) => {
  const { present, children } = props;
  const presence = usePresence$1(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs$1(presence.ref, getElementRef$1$1(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence$1.displayName = "Presence";
function usePresence$1(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine$1(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName$1(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2$1(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName$1(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2$1(() => {
    if (node) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName$1(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          reactDomExports.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName$1(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName$1(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef$1$1(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var Slot$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable$1);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone$1, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone$1, { ...slotProps, ref: forwardedRef, children });
});
Slot$1.displayName = "Slot";
var SlotClone$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (reactExports.isValidElement(children)) {
    const childrenRef = getElementRef$2(children);
    return reactExports.cloneElement(children, {
      ...mergeProps$1(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs$1(forwardedRef, childrenRef) : childrenRef
    });
  }
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
SlotClone$1.displayName = "SlotClone";
var Slottable$1 = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable$1(child) {
  return reactExports.isValidElement(child) && child.type === Slottable$1;
}
function mergeProps$1(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$2(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES$1 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive$2 = NODES$1.reduce((primitive, node) => {
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot$1 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent$1(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope$1(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name: name2,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      ...checkboxProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    const [checked = false, setChecked] = useControllableState$1({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    const initialCheckedStateRef = reactExports.useRef(checked);
    reactExports.useEffect(() => {
      const form = button == null ? void 0 : button.form;
      if (form) {
        const reset2 = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset2);
        return () => form.removeEventListener("reset", reset2);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$2.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate$1(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState$4(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
            if (event.key === "Enter") event.preventDefault();
          }),
          onClick: composeEventHandlers$1(props.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate$1(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$2,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME$3 = "CheckboxIndicator";
var CheckboxIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context2 = useCheckboxContext(INDICATOR_NAME$3, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || isIndeterminate$1(context2.state) || context2.state === true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.span,
      {
        "data-state": getState$4(context2.state),
        "data-disabled": context2.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef,
        style: { pointerEvents: "none", ...props.style }
      }
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME$3;
var BubbleInput$2 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize$1(control);
  reactExports.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input2.indeterminate = isIndeterminate$1(checked);
      setChecked.call(input2, isIndeterminate$1(checked) ? false : checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: isIndeterminate$1(checked) ? false : checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function isIndeterminate$1(checked) {
  return checked === "indeterminate";
}
function getState$4(checked) {
  return isIndeterminate$1(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root$8 = Checkbox$1;
var Indicator$2 = CheckboxIndicator;
var labelVariants = createRuntimeFn({ defaultClassName: "_43lu9r4", variantClassNames: { labelLocation: { top: "_43lu9r5 _43lu9r0 fyvr11p4 fyvr11mc fyvr11ck fyvr11l8", left: "_43lu9r6 _43lu9r1 fyvr11ow fyvr11mk fyvr11ck fyvr11l8", right: "_43lu9r7 _43lu9r2 fyvr11ow fyvr11mk fyvr11ck fyvr11l8", hidden: "_43lu9r8 _43lu9r3 fyvr11c8 fyvr11l8" } }, defaultVariants: {}, compoundVariants: [] });
const Field$2 = (props) => {
  const {
    id: id2,
    label,
    description: description2,
    labelLocation = "top",
    children,
    ...rest
  } = props;
  const renderLabel = () => label || description2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flexDirection: "column", gap: "0.5", children: [
    label && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        variant: "small",
        color: "text100",
        hidden: labelLocation === "hidden",
        children: label
      }
    ),
    description2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        variant: "small",
        color: "text50",
        hidden: labelLocation === "hidden",
        children: description2
      }
    )
  ] }) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      as: "label",
      className: labelVariants({ labelLocation }),
      htmlFor: id2,
      ...rest,
      children: [
        ["left", "top", "hidden"].includes(labelLocation) && renderLabel(),
        children,
        labelLocation === "right" && renderLabel()
      ]
    }
  );
};
var iconVariants = createRuntimeFn({ defaultClassName: "_1dizidw0", variantClassNames: { size: { xs: "_1dizidw1", sm: "_1dizidw2", md: "_1dizidw3", lg: "_1dizidw4", xl: "_1dizidw5" } }, defaultVariants: {}, compoundVariants: [] });
const Svg$17 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M11.168 9.25V2.929h-1.5V9.25h-6.32v1.5h6.32v6.321h1.5V10.75h6.321v-1.5h-6.32Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgAddIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$17,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$13 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m10.888 14.47 1.06 1.06L17.48 10l-5.53-5.53-1.06 1.06 3.719 3.72H4.418v1.5h10.19l-3.72 3.72Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgArrowRightIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$13,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$11 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        stroke: "currentColor",
        strokeWidth: 1.5,
        d: "m4.304 10.232 4.263 4.79 7.13-11.238"
      }
    )
  }
);
const SvgCheckmarkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$11,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$10 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m3.888 7.53 1.06-1.06 5.47 5.47 5.47-5.47 1.06 1.06-6.53 6.53-6.53-6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronDownIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$10,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$$ = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m12.888 3.47 1.06 1.06L8.48 10l5.47 5.47-1.061 1.06L6.358 10l6.53-6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronLeftIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$$,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$_ = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m7.949 16.53-1.061-1.06 5.47-5.47-5.47-5.47 1.06-1.06L14.48 10l-6.53 6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronRightIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$_,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$Y = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m10.418 11.06 4.47 4.47 1.06-1.06L11.48 10l4.47-4.47-1.06-1.06-4.47 4.47-4.47-4.47-1.06 1.06L9.357 10l-4.47 4.47 1.06 1.06 4.47-4.47Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCloseIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$Y,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$U = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M14.918 4.5h-6V6h4.5v6.5h1.5v-8Zm-1.5 9.5v3h-9V6h3V3h9v11h-3Zm-7.5 1.5v-8h6v8h-6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCopyIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$U,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$T = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M5 6.714 3.618 3.547H2.5L4.158 7.02H2.98v.69h1.494v.663H2.981v.69h1.494v1.484h1.036V9.063h1.46v-.69h-1.46v-.66l.001-.003h1.46v-.69h-1.13L7.5 3.547H6.383L5 6.714Zm4.747 8.232v-.788a2.887 2.887 0 0 1-1.04-.249 2.04 2.04 0 0 1-.863-.727 2.213 2.213 0 0 1-.344-1.125h1.017c.02.26.098.476.236.65.14.171.319.299.535.383.144.054.297.09.46.109V10.81l-.319-.093c-.538-.157-.964-.388-1.28-.693-.312-.304-.469-.707-.469-1.209 0-.415.105-.777.315-1.086.21-.31.495-.55.853-.72.273-.133.573-.215.9-.246v-.817h.537v.81c.365.023.692.106.981.249.35.17.626.406.827.706.201.298.306.64.315 1.027h-.978a1.04 1.04 0 0 0-.433-.774 1.47 1.47 0 0 0-.712-.264v2.253l.283.079c.214.056.434.132.659.228a2.6 2.6 0 0 1 .627.38c.192.157.347.351.466.583.12.232.18.51.18.834 0 .407-.098.77-.295 1.086a2.006 2.006 0 0 1-.85.749c-.304.15-.66.239-1.07.265v.79h-.538Zm1.024-1.877c-.148.064-.31.106-.486.128v-2.23c.216.064.41.136.584.218.193.089.345.201.457.337.113.136.17.31.17.524 0 .234-.065.44-.194.615-.129.174-.306.31-.531.408ZM9.747 7.706v2.095a4.605 4.605 0 0 1-.246-.086 2.195 2.195 0 0 1-.4-.207 1.038 1.038 0 0 1-.299-.313.847.847 0 0 1-.111-.443.94.94 0 0 1 .164-.545c.112-.162.268-.288.47-.38.126-.059.267-.099.422-.12Zm7.677 10.086h-4.9v-.897h.34a.342.342 0 0 0 .29-.186c.068-.117.114-.254.137-.411.023-.16.032-.304.028-.432l-.027-.779H12.5v-.896h.76l-.043-1.262c-.018-.472.073-.866.273-1.183.203-.317.473-.555.809-.715.335-.16.697-.24 1.084-.24.346 0 .656.056.931.166.278.11.511.26.7.452.191.188.328.404.41.647.081.243.097.498.048.766l-1.01-.156c.023-.22-.014-.403-.11-.55a.891.891 0 0 0-.395-.33 1.31 1.31 0 0 0-1.102.024c-.177.09-.322.227-.434.411-.11.185-.164.42-.164.708l.048 1.261h1.649v.897H14.34l.029.752c.014.29-.025.55-.116.78-.04.1-.096.193-.166.276h3.337v.897Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCurrencyIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$T,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$K = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M15.01 6.1H4.99L10 9.68 15.01 6.1ZM3.5 6.88v7.22h13V6.88L10 11.521 3.5 6.88ZM2 15.6v-11h16v11H2Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgEmailIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$K,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$C = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.918 10a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0Zm1.5 0a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-9 1.469v.133h1.48v-.133c.003-.255.036-.47.098-.645a1.3 1.3 0 0 1 .293-.46c.133-.134.303-.261.508-.384.245-.145.457-.308.637-.488.18-.182.319-.39.418-.625.101-.237.152-.508.152-.812 0-.456-.113-.845-.34-1.168a2.131 2.131 0 0 0-.937-.739c-.399-.171-.857-.257-1.375-.257-.471 0-.902.084-1.293.254-.39.166-.704.42-.941.761-.237.339-.362.768-.375 1.29h1.593c.008-.214.06-.393.157-.536a.917.917 0 0 1 .37-.328 1.06 1.06 0 0 1 .481-.113c.175 0 .333.036.477.11a.858.858 0 0 1 .347.312.863.863 0 0 1 .13.472c0 .17-.039.323-.114.461-.076.136-.177.26-.305.371a3.69 3.69 0 0 1-.433.325 2.69 2.69 0 0 0-.555.453c-.154.166-.27.385-.352.656-.078.27-.118.634-.12 1.09Zm.106 2.36a.917.917 0 0 0 .668.273c.166 0 .32-.042.46-.125.141-.086.255-.2.34-.34a.897.897 0 0 0-.149-1.129.907.907 0 0 0-.651-.274.917.917 0 0 0-.668.274.882.882 0 0 0-.27.656.899.899 0 0 0 .27.664Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgHelpIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$C,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$x = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeWidth: 1.5,
          d: "M10.906 8.966c1.459 1.316 1.459 3.45 0 4.765l-2.53 2.282c-1.459 1.316-3.824 1.316-5.282 0-1.459-1.315-1.459-3.449 0-4.764l1.265-1.142"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeWidth: 1.5,
          d: "M8.094 11c-1.459-1.316-1.459-3.449 0-4.765l2.53-2.282c1.459-1.316 3.823-1.316 5.282 0s1.459 3.449 0 4.765l-1.265 1.14"
        }
      )
    ]
  }
);
const SvgLinkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$x,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$r = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M13.283 6.175a4.643 4.643 0 1 0-6.566 6.567l-.708.707a5.644 5.644 0 1 1 7.982 0l-.708-.707a4.644 4.644 0 0 0 0-6.567Zm-5.097 1.47a2.565 2.565 0 0 1 3.628 3.627l.707.707a3.565 3.565 0 1 0-5.042 0l.707-.707a2.565 2.565 0 0 1 0-3.627ZM10 10.959a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm0 .667-1.5 6h3l-1.5-6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgNetworkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$r,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$p = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.899 5.261a1 1 0 0 1 1 1v.729H2.102v2.055h15.797v4.694a1 1 0 0 1-1 1H3.102a1 1 0 0 1-1-1V6.261a1 1 0 0 1 1-1h13.797Zm-7.13 7.284h7v1h-7v-1Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgPaymentsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$p,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$m = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M6.418 3.6h-2.5v2.5h2.5V3.6Zm0-1.5h1.5v5.5h-5.5V2.1h4Zm0 12h-2.5v2.5h2.5v-2.5Zm0-1.5h1.5v5.5h-5.5v-5.5h4Zm8-9h2.5v2.5h-2.5V3.6Zm4-1.5h-5.5v5.5h5.5V2.1Zm-1.5 12h-2.5v2.5h2.5v-2.5Zm0-1.5h1.5v5.5h-5.5v-5.5h4ZM9.668 2.1v7.25h-7.25v1.5h8.75V2.1h-1.5Zm1.5 10.5v5.5h-1.5v-5.5h1.5Zm1.75-1.75h5.5v-1.5h-5.5v1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgQrCodeIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$m,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$h = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M13.918 9.5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-.677 4.383a5.5 5.5 0 1 1 1.06-1.06l2.648 2.647-1.061 1.06-2.647-2.647Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSearchIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$h,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$g = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M11.529 15.925 9.419 11 4.493 8.89 2.418 8l2.142-.714 11.08-3.693L17.418 3l-.593 1.779-3.693 11.08L12.418 18l-.89-2.075Zm-1.71-6.386L6.635 8.175l6.82-2.273-3.638 3.637Zm1.06 1.061 1.364 3.183 2.273-6.82L10.88 10.6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSendIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$g,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$e = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M12.775 5.204a5.465 5.465 0 0 0-1.341-.537L11 2.5H9l-.443 2.214c-.444.128-.866.31-1.257.54L5.404 3.99 3.99 5.404l1.283 1.925c-.212.38-.38.787-.497 1.216L2.5 9v2l2.276.455c.118.429.285.836.497 1.216L3.99 14.596l1.414 1.414L7.3 14.746c.391.23.813.412 1.257.54L9 17.5h2l.434-2.167c.474-.12.925-.302 1.341-.537l1.821 1.214 1.414-1.414-1.195-1.793c.253-.427.45-.891.581-1.382L17.5 11V9l-2.104-.42a5.467 5.467 0 0 0-.581-1.383l1.195-1.793-1.414-1.414-1.82 1.214Zm-.59 2.692a2.976 2.976 0 1 0-4.208 4.208 2.976 2.976 0 0 0 4.209-4.208Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSettingsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$e,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$d = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M4 6.234a.5.5 0 0 0-.5.5v8a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5V10.5L14 9v5.734a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h5.769l-1.516 1.5H4Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: 1.25, d: "M11 3h5v5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: 1.5, d: "m16 3-8 8" })
    ]
  }
);
const SvgShareIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$d,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$b = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M9.418 3.25h-5.75v13.5h5.75v-1.5h-4.25V4.75h4.25v-1.5Zm4.53 11.28-1.06-1.06 2.72-2.72h-8.19v-1.5h8.19l-2.72-2.72 1.06-1.06L18.48 10l-4.53 4.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSignoutIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$b,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$a = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.539 10.75H4.298v-1.5h12.24v1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSubtractIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$a,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$7 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m12.28 2.856-6.71 8.887h4.134l-1.424 6.2 6.887-8.71h-4.322l1.435-6.377Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgTransactionIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$7,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
var checkboxVariants = createRuntimeFn({ defaultClassName: "_1c9x66f1 _1c9x66f0 fyvr11eg fyvr11es fyvr11f4 fyvr11fg fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr12rl fyvr12k9 fyvr125l fyvr12cx fyvr12rr fyvr12kf fyvr125r fyvr12d3 fyvr11l8 fyvr11ow fyvr11no fyvr11sl fyvr1309 fyvr1307 fyvr12zz fyvr12zf fyvr12zb _4efw240", variantClassNames: { size: { sm: "_1c9x66f2", lg: "_1c9x66f3" } }, defaultVariants: {}, compoundVariants: [] });
var indicator$1 = "_1c9x66f4 fyvr12w9 fyvr11l8 fyvr11ow fyvr11no fyvr12g fyvr164";
const Indicator$1 = ({ size: size2 = "sm" }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator$2, { className: indicator$1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckmarkIcon, { size: size2 === "lg" ? "sm" : "xs" }) });
reactExports.forwardRef(
  (props, ref) => {
    const {
      disabled = false,
      id: id2,
      name: name2,
      label = "",
      labelLocation = "left",
      size: size2 = "sm",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$2,
      {
        disabled,
        display: "flex",
        id: id2 ?? name2,
        label,
        labelLocation,
        whiteSpace: "nowrap",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$8,
          {
            className: checkboxVariants({ size: size2 }),
            disabled,
            id: id2 ?? name2,
            name: name2,
            ref,
            ...rest,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator$1, { size: size2 })
          }
        )
      }
    );
  }
);
React.createContext(null);
var useReactId$1 = React$1["useId".toString()] || (() => void 0);
var count$1$1 = 0;
function useId$1(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId$1());
  useLayoutEffect2$1(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count$1$1++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope$1(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open = false, setOpen] = useControllableState$1({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId$1(),
        open,
        onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$2.div,
          {
            "data-state": getState$3(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible$1.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME$5 = "CollapsibleTrigger";
var CollapsibleTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context2 = useCollapsibleContext(TRIGGER_NAME$5, __scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.button,
      {
        type: "button",
        "aria-controls": context2.contentId,
        "aria-expanded": context2.open || false,
        "data-state": getState$3(context2.open),
        "data-disabled": context2.disabled ? "" : void 0,
        disabled: context2.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers$1(props.onClick, context2.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME$5;
var CONTENT_NAME$7 = "CollapsibleContent";
var CollapsibleContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context2 = useCollapsibleContext(CONTENT_NAME$7, props.__scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME$7;
var CollapsibleContentImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context2 = useCollapsibleContext(CONTENT_NAME$7, __scopeCollapsible);
  const [isPresent, setIsPresent] = reactExports.useState(present);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs$1(forwardedRef, ref);
  const heightRef = reactExports.useRef(0);
  const height = heightRef.current;
  const widthRef = reactExports.useRef(0);
  const width = widthRef.current;
  const isOpen = context2.open || isPresent;
  const isMountAnimationPreventedRef = reactExports.useRef(isOpen);
  const originalStylesRef = reactExports.useRef();
  reactExports.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect2$1(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context2.open, present]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$2.div,
    {
      "data-state": getState$3(context2.open),
      "data-disabled": context2.disabled ? "" : void 0,
      id: context2.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState$3(open) {
  return open ? "open" : "closed";
}
var Root$7 = Collapsible$1;
var Trigger$5 = CollapsibleTrigger;
var Content$3 = CollapsibleContent;
var COLLAPSED_HEIGHT = "64px";
var root$4 = "_4j62fl0";
var trigger$1 = "_4j62fl2 _4j62fl1 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr11l8 fyvr11ow fyvr11sl fyvr12g fyvr12zf fyvr11rc _4efw240";
var content$3 = "_4j62fl4 _4j62fl3 fyvr1zk fyvr111o fyvr1uw fyvr1xg fyvr12g";
var icon = "_4j62fl5";
const Collapsible = (props) => {
  const {
    className,
    children,
    defaultOpen,
    open,
    onOpenChange,
    label,
    ...rest
  } = props;
  const [expanded, toggleExpanded] = reactExports.useState(defaultOpen);
  const isOpen = open ?? expanded;
  const handleSetExpanded = (isExpanded) => {
    if (open !== void 0) {
      return;
    }
    toggleExpanded(isExpanded);
  };
  const handleOpenChange = (isOpen2) => {
    handleSetExpanded(isOpen2);
    onOpenChange == null ? void 0 : onOpenChange(isOpen2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root$7,
    {
      open: isOpen,
      defaultOpen,
      onOpenChange: handleOpenChange,
      asChild: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          as: motion.div,
          className: clsx(className, root$4),
          initial: { height: isOpen ? "auto" : COLLAPSED_HEIGHT },
          animate: { height: isOpen ? "auto" : COLLAPSED_HEIGHT },
          transition: { ease: "easeOut", duration: 0.3 },
          borderRadius: "md",
          background: "backgroundSecondary",
          position: "relative",
          overflow: "hidden",
          width: "full",
          ...rest,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Trigger$5, { className: trigger$1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "div", variant: "normal", fontWeight: "bold", color: "text80", children: label }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  as: motion.div,
                  position: "absolute",
                  right: "0",
                  marginRight: "4",
                  initial: { rotate: isOpen ? 180 : 0 },
                  animate: { rotate: isOpen ? 180 : 0 },
                  transition: { ease: "linear", duration: 0.1 },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgChevronDownIcon, { className: icon, color: "text50" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content$3,
              {
                className: content$3,
                asChild: true,
                forceMount: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.div,
                  {
                    initial: { opacity: isOpen ? 1 : 0 },
                    animate: { opacity: 1 },
                    exit: { opacity: 0 },
                    transition: { ease: "easeOut", duration: 0.3 },
                    children
                  }
                )
              }
            ) })
          ]
        }
      )
    }
  );
};
function createCollection(name2) {
  const PROVIDER_NAME2 = name2 + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope$1(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name2 + "CollectionSlot";
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context2 = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs$1(forwardedRef, context2.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot$1, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name2 + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs$1(forwardedRef, ref);
      const context2 = useCollectionContext(ITEM_SLOT_NAME, scope);
      React.useEffect(() => {
        context2.itemMap.set(ref, { ref, ...itemData });
        return () => void context2.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot$1, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context2 = useCollectionContext(name2 + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context2.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context2.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context2.collectionRef, context2.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
function useEscapeKeydown$1(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME$1 = "DismissableLayer";
var CONTEXT_UPDATE$1 = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE$1 = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE$1 = "dismissableLayer.focusOutside";
var originalBodyPointerEvents$1;
var DismissableLayerContext$1 = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context2 = reactExports.useContext(DismissableLayerContext$1);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context2.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context2.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context2.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside$1((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context2.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside$1((event) => {
      const target = event.target;
      const isFocusInBranch = [...context2.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown$1((event) => {
      const isHighestLayer = index2 === context2.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context2.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents$1 = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context2.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context2.layers.add(node);
      dispatchUpdate$1();
      return () => {
        if (disableOutsidePointerEvents && context2.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents$1;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context2]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context2.layers.delete(node);
        context2.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate$1();
      };
    }, [node, context2]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE$1, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE$1, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers$1(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers$1(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers$1(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer$1.displayName = DISMISSABLE_LAYER_NAME$1;
var BRANCH_NAME$1 = "DismissableLayerBranch";
var DismissableLayerBranch$1 = reactExports.forwardRef((props, forwardedRef) => {
  const context2 = reactExports.useContext(DismissableLayerContext$1);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs$1(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context2.branches.add(node);
      return () => {
        context2.branches.delete(node);
      };
    }
  }, [context2.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch$1.displayName = BRANCH_NAME$1;
function usePointerDownOutside$1(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE$1,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside$1(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE$1, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate$1() {
  const event = new CustomEvent(CONTEXT_UPDATE$1);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name2, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent$1(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root$6 = DismissableLayer$1;
var Branch = DismissableLayerBranch$1;
var count$2 = 0;
function useFocusGuards$1() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard$1());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard$1());
    count$2++;
    return () => {
      if (count$2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$2--;
    };
  }, []);
}
function createFocusGuard$1() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
var AUTOFOCUS_ON_MOUNT$1 = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT$1 = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME$1 = "FocusScope";
var FocusScope$1 = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs$1(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus$1(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus$1(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus$1(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack$1.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT$1, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT$1, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$3(removeLinks$1(getTabbableCandidates$1(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus$1(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT$1, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT$1, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT$1, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus$1(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT$1, onUnmountAutoFocus);
          focusScopesStack$1.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges$1(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus$1(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus$1(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope$1.displayName = FOCUS_SCOPE_NAME$1;
function focusFirst$3(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus$1(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges$1(container) {
  const candidates = getTabbableCandidates$1(container);
  const first = findVisible$1(candidates, container);
  const last = findVisible$1(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible$1(elements, container) {
  for (const element of elements) {
    if (!isHidden$1(element, { upTo: container })) return element;
  }
}
function isHidden$1(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput$1(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus$1(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput$1(element) && select)
      element.select();
  }
}
var focusScopesStack$1 = createFocusScopesStack$1();
function createFocusScopesStack$1() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove$1(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a2;
      stack = arrayRemove$1(stack, focusScope);
      (_a2 = stack[0]) == null ? void 0 : _a2.resume();
    }
  };
}
function arrayRemove$1(array, item2) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item2);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks$1(items) {
  return items.filter((item2) => item2.tagName !== "A");
}
const sides$1 = ["top", "right", "bottom", "left"];
const min$1 = Math.min;
const max$1 = Math.max;
const round$1 = Math.round;
const floor$1 = Math.floor;
const createCoords$1 = (v3) => ({
  x: v3,
  y: v3
});
const oppositeSideMap$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap$1 = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max$1(start, min$1(value, end));
}
function evaluate$1(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide$1(placement) {
  return placement.split("-")[0];
}
function getAlignment$1(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis$1(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength$1(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis$1(placement) {
  return ["top", "bottom"].includes(getSide$1(placement)) ? "y" : "x";
}
function getAlignmentAxis$1(placement) {
  return getOppositeAxis$1(getSideAxis$1(placement));
}
function getAlignmentSides$1(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment$1(placement);
  const alignmentAxis = getAlignmentAxis$1(placement);
  const length = getAxisLength$1(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement$1(mainAlignmentSide)];
}
function getExpandedPlacements$1(placement) {
  const oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeAlignmentPlacement$1(placement), oppositePlacement, getOppositeAlignmentPlacement$1(oppositePlacement)];
}
function getOppositeAlignmentPlacement$1(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap$1[alignment]);
}
function getSideList$1(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements$1(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment$1(placement);
  let list2 = getSideList$1(getSide$1(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement$1));
    }
  }
  return list2;
}
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap$1[side]);
}
function expandPaddingObject$1(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getPaddingObject$1(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject$1(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect$1(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement$1(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis$1(placement);
  const alignmentAxis = getAlignmentAxis$1(placement);
  const alignLength = getAxisLength$1(alignmentAxis);
  const side = getSide$1(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment$1(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement$1(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement$1(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate$1(options, state);
  const paddingObject = getPaddingObject$1(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect$1(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect$1(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$4 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding: padding2 = 0
    } = evaluate$1(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject$1(padding2);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis$1(placement);
    const length = getAxisLength$1(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);
    const min$1$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment$1(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide$1(placement);
      const initialSideAxis = getSideAxis$1(initialPlacement);
      const isBasePlacement = getSide$1(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements$1(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements$1(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides$1(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis$1(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets$1(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped$1(overflow) {
  return sides$1.some((side) => overflow[side] >= 0);
}
const hide$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets$1(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped$1(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets$1(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped$1(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords$1(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide$1(placement);
  const alignment = getAlignment$1(placement);
  const isVertical = getSideAxis$1(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate$1(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords$1(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x22,
              y: y22
            } = _ref;
            return {
              x: x22,
              y: y22
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const crossAxis = getSideAxis$1(getSide$1(placement));
      const mainAxis = getOppositeAxis$1(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
const limitShift$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate$1(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis$1(placement);
      const mainAxis = getOppositeAxis$1(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate$1(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide$1(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const side = getSide$1(placement);
      const alignment = getAlignment$1(placement);
      const isYAxis = getSideAxis$1(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min$1(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min$1(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min$1(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max$1(overflow.left, 0);
        const xMax = max$1(overflow.right, 0);
        const yMin = max$1(overflow.top, 0);
        const yMax = max$1(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getNodeName$1(node) {
  if (isNode$3(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement$1(node) {
  var _ref;
  return (_ref = (isNode$3(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode$3(value) {
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement$1(value) {
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement$1(value) {
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot$1(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
function isOverflowElement$1(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].includes(getNodeName$1(element));
}
function isTopLayer$1(element) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element.matches(selector2);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock$1(element) {
  const webkit = isWebKit$1();
  const css = getComputedStyle$1$1(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock$1(element) {
  let currentNode = getParentNode$1(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode$1(currentNode)) {
    if (isTopLayer$1(currentNode)) {
      return null;
    }
    if (isContainingBlock$1(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode$1(currentNode);
  }
  return null;
}
function isWebKit$1() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode$1(node) {
  return ["html", "body", "#document"].includes(getNodeName$1(node));
}
function getComputedStyle$1$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll$1(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode$1(node) {
  if (getNodeName$1(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot$1(node) && node.host || // Fallback.
    getDocumentElement$1(node)
  );
  return isShadowRoot$1(result) ? result.host : result;
}
function getNearestOverflowAncestor$1(node) {
  const parentNode = getParentNode$1(node);
  if (isLastTraversableNode$1(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement$1(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor$1(parentNode);
}
function getOverflowAncestors$1(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor$1(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement$1(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors$1(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors$1(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions$1(element) {
  const css = getComputedStyle$1$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round$1(width) !== offsetWidth || round$1(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement$1(element) {
  return !isElement$1(element) ? element.contextElement : element;
}
function getScale$1(element) {
  const domElement = unwrapElement$1(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords$1(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions$1(domElement);
  let x2 = ($ ? round$1(rect.width) : rect.width) / width;
  let y2 = ($ ? round$1(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets$1 = /* @__PURE__ */ createCoords$1(0);
function getVisualOffsets$1(element) {
  const win = getWindow$1(element);
  if (!isWebKit$1() || !win.visualViewport) {
    return noOffsets$1;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets$1(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect$1(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement$1(element);
  let scale2 = createCoords$1(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale2 = getScale$1(offsetParent);
      }
    } else {
      scale2 = getScale$1(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets$1(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets$1(domElement) : createCoords$1(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale$1(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow$1(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect$1({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect$1(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement$1(offsetParent);
  const topLayer = elements ? isTopLayer$1(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords$1(1);
  const offsets = createCoords$1(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || isOverflowElement$1(documentElement)) {
      scroll2 = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent);
      scale2 = getScale$1(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll2.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll2.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects$1(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getNodeScroll$1(element).scrollLeft;
}
function getDocumentRect$1(element) {
  const html = getDocumentElement$1(element);
  const scroll2 = getNodeScroll$1(element);
  const body = element.ownerDocument.body;
  const width = max$1(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max$1(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll2.scrollLeft + getWindowScrollBarX$1(element);
  const y2 = -scroll2.scrollTop;
  if (getComputedStyle$1$1(body).direction === "rtl") {
    x2 += max$1(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect$1(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement$1(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit$1();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect$1(element, strategy) {
  const clientRect = getBoundingClientRect$1(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement$1(element) ? getScale$1(element) : createCoords$1(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x2 = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect$1(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect$1(getDocumentElement$1(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect$1(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets$1(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect$1(rect);
}
function hasFixedPositionAncestor$1(element, stopNode) {
  const parentNode = getParentNode$1(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode$1(parentNode)) {
    return false;
  }
  return getComputedStyle$1$1(parentNode).position === "fixed" || hasFixedPositionAncestor$1(parentNode, stopNode);
}
function getClippingElementAncestors$1(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors$1(element, [], false).filter((el2) => isElement$1(el2) && getNodeName$1(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode$1(element) : element;
  while (isElement$1(currentNode) && !isLastTraversableNode$1(currentNode)) {
    const computedStyle = getComputedStyle$1$1(currentNode);
    const currentNodeIsContaining = isContainingBlock$1(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement$1(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor$1(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode$1(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect$1(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer$1(element) ? [] : getClippingElementAncestors$1(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor$1(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions$1(element) {
  const {
    width,
    height
  } = getCssDimensions$1(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent$1(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect$1(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords$1(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || isOverflowElement$1(documentElement)) {
      scroll2 = getNodeScroll$1(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  const x2 = rect.left + scroll2.scrollLeft - offsets.x;
  const y2 = rect.top + scroll2.scrollTop - offsets.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned$1(element) {
  return getComputedStyle$1$1(element).position === "static";
}
function getTrueOffsetParent$1(element, polyfill2) {
  if (!isHTMLElement$1(element) || getComputedStyle$1$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  return element.offsetParent;
}
function getOffsetParent$1(element, polyfill2) {
  const win = getWindow$1(element);
  if (isTopLayer$1(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode$1(element);
    while (svgOffsetParent && !isLastTraversableNode$1(svgOffsetParent)) {
      if (isElement$1(svgOffsetParent) && !isStaticPositioned$1(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode$1(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent$1(element, polyfill2);
  while (offsetParent && isTableElement$1(offsetParent) && isStaticPositioned$1(offsetParent)) {
    offsetParent = getTrueOffsetParent$1(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode$1(offsetParent) && isStaticPositioned$1(offsetParent) && !isContainingBlock$1(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock$1(element) || win;
}
const getElementRects$1 = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent$1;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent$1(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL$1(element) {
  return getComputedStyle$1$1(element).direction === "rtl";
}
const platform$1 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect$1,
  getDocumentElement: getDocumentElement$1,
  getClippingRect: getClippingRect$1,
  getOffsetParent: getOffsetParent$1,
  getElementRects: getElementRects$1,
  getClientRects: getClientRects$1,
  getDimensions: getDimensions$1,
  getScale: getScale$1,
  isElement: isElement$1,
  isRTL: isRTL$1
};
function observeMove$1(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement$1(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor$1(top);
    const insetRight = floor$1(root2.clientWidth - (left + width));
    const insetBottom = floor$1(root2.clientHeight - (top + height));
    const insetLeft = floor$1(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate$1(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement$1(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors$1(referenceEl) : [], ...getOverflowAncestors$1(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove$1(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect$1(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect$1(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1$1 = offset$2$1;
const shift$1$1 = shift$2$1;
const flip$1$1 = flip$2$1;
const size$1$1 = size$2$1;
const hide$1$1 = hide$2$1;
const arrow$3$1 = arrow$4;
const limitShift$1$1 = limitShift$2$1;
const computePosition$2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform: platform$1,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$4$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$2(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual$2(a2[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual$2(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR$1(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR$1(element, value) {
  const dpr = getDPR$1(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = reactExports.useRef(value);
  index$4$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual$2(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const platformRef = useLatestRef$1(platform2);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition$2(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual$2(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$4$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$4$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$4$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR$1(elements.floating, data.x);
    const y2 = roundByDPR$1(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR$1(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding: padding2
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$3$1({
            element: element.current,
            padding: padding2
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$3$1({
          element,
          padding: padding2
        }).fn(state);
      }
      return {};
    }
  };
};
const offset$3 = (options, deps) => ({
  ...offset$1$1(options),
  options: [options, deps]
});
const shift$3 = (options, deps) => ({
  ...shift$1$1(options),
  options: [options, deps]
});
const limitShift$3 = (options, deps) => ({
  ...limitShift$1$1(options),
  options: [options, deps]
});
const flip$3 = (options, deps) => ({
  ...flip$1$1(options),
  options: [options, deps]
});
const size$6 = (options, deps) => ({
  ...size$1$1(options),
  options: [options, deps]
});
const hide$3 = (options, deps) => ({
  ...hide$1$1(options),
  options: [options, deps]
});
const arrow$2$1 = (options, deps) => ({
  ...arrow$1$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$2.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1$1.displayName = NAME$1;
var Root$5 = Arrow$1$1;
var POPPER_NAME$1 = "Popper";
var [createPopperContext$1, createPopperScope$1] = createContextScope$1(POPPER_NAME$1);
var [PopperProvider$1, usePopperContext$1] = createPopperContext$1(POPPER_NAME$1);
var Popper$1 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider$1, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper$1.displayName = POPPER_NAME$1;
var ANCHOR_NAME$1$1 = "PopperAnchor";
var PopperAnchor$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context2 = usePopperContext$1(ANCHOR_NAME$1$1, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    reactExports.useEffect(() => {
      context2.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor$1.displayName = ANCHOR_NAME$1$1;
var CONTENT_NAME$6 = "PopperContent";
var [PopperContentProvider$1, useContentContext$1] = createPopperContext$1(CONTENT_NAME$6);
var PopperContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context2 = usePopperContext$1(CONTENT_NAME$6, __scopePopper);
    const [content2, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node) => setContent(node));
    const [arrow2, setArrow] = reactExports.useState(null);
    const arrowSize = useSize$1(arrow2);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull$1),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating$1({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate$1(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context2.anchor
      },
      middleware: [
        offset$3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift$3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift$3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip$3({ ...detectOverflowOptions }),
        size$6({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle2 = elements.floating.style;
            contentStyle2.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle2.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle2.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle2.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow2 && arrow$2$1({ element: arrow2, padding: arrowPadding }),
        transformOrigin$1({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide$3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement$1(placement);
    const handlePlaced = useCallbackRef$1$1(onPlaced);
    useLayoutEffect2$1(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
    const arrowY = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2$1(() => {
      if (content2) setContentZIndex(window.getComputedStyle(content2).zIndex);
    }, [content2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d2 = middlewareData.transformOrigin) == null ? void 0 : _d2.x,
            (_e2 = middlewareData.transformOrigin) == null ? void 0 : _e2.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f2 = middlewareData.hide) == null ? void 0 : _f2.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider$1,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$2.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent$1.displayName = CONTENT_NAME$6;
var ARROW_NAME$4 = "PopperArrow";
var OPPOSITE_SIDE$1 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow$1 = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext$1(ARROW_NAME$4, __scopePopper);
  const baseSide = OPPOSITE_SIDE$1[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$5,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow$1.displayName = ARROW_NAME$4;
function isNotNull$1(value) {
  return value !== null;
}
var transformOrigin$1 = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a2, _b2, _c2;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement$1(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y: y2 } };
  }
});
function getSideAndAlignFromPlacement$1(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$5 = Popper$1;
var Anchor$1 = PopperAnchor$1;
var Content$2 = PopperContent$1;
var Arrow$2 = PopperArrow$1;
var PORTAL_NAME$4 = "Portal";
var Portal$3 = reactExports.forwardRef((props, forwardedRef) => {
  var _a2;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2$1(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$3.displayName = PORTAL_NAME$4;
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS$2 = { bubbles: false, cancelable: true };
var GROUP_NAME$3 = "RovingFocusGroup";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(GROUP_NAME$3);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope$1(
  GROUP_NAME$3,
  [createCollectionScope$3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
var RovingFocusGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs$1(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState$1({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = useCallbackRef$1$1(onEntryFocus);
  const getItems = useCollection$3(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: reactExports.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$2.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers$1(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers$1(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS$2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item2) => item2.focusable);
                const activeItem = items.find((item2) => item2.active);
                const currentItem = items.find((item2) => item2.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item2) => item2.ref.current);
                focusFirst$2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers$1(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$4 = "RovingFocusGroupItem";
var RovingFocusGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      ...itemProps
    } = props;
    const autoId = useId$1();
    const id2 = tabStopId || autoId;
    const context2 = useRovingFocusContext(ITEM_NAME$4, __scopeRovingFocusGroup);
    const isCurrentTabStop = context2.currentTabStopId === id2;
    const getItems = useCollection$3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context2;
    reactExports.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$2.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context2.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers$1(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context2.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers$1(props.onFocus, () => context2.onItemFocus(id2)),
            onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context2.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context2.orientation, context2.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item2) => item2.focusable);
                let candidateNodes = items.map((item2) => item2.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context2.loop ? wrapArray$2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$2(candidateNodes));
              }
            })
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$4;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$2(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root$4 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
var getDefaultParent$1 = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap$1 = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes$1 = /* @__PURE__ */ new WeakMap();
var markerMap$1 = {};
var lockCount$1 = 0;
var unwrapHost$1 = function(node) {
  return node && (node.host || unwrapHost$1(node.parentNode));
};
var correctTargets$1 = function(parent2, targets) {
  return targets.map(function(target) {
    if (parent2.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost$1(target);
    if (correctedTarget && parent2.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent2, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers$1 = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets$1(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap$1[markerName]) {
    markerMap$1[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap$1[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent2) {
    if (!parent2 || elementsToStop.has(parent2)) {
      return;
    }
    Array.prototype.forEach.call(parent2.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap$1.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap$1.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes$1.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount$1++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap$1.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap$1.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes$1.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes$1.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount$1--;
    if (!lockCount$1) {
      counterMap$1 = /* @__PURE__ */ new WeakMap();
      counterMap$1 = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes$1 = /* @__PURE__ */ new WeakMap();
      markerMap$1 = {};
    }
  };
};
var hideOthers$1 = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent$1(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers$1(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __spreadArray(to, from, pack2) {
  for (var i = 0, l2 = from.length, ar; i < l2; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var zeroRightClassName$1 = "right-scroll-bar-position";
var fullWidthClassName$1 = "width-before-scroll-bar";
var noScrollbarsClassName$1 = "with-scroll-bars-hidden";
var removedBarSizeVariable$1 = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef$2(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues$1 = /* @__PURE__ */ new WeakMap();
function useMergeRefs$1(refs, defaultValue) {
  var callbackRef = useCallbackRef$2(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues$1.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef$1(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef$1(ref, current_1);
        }
      });
    }
    currentValues$1.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI$1(a2) {
  return a2;
}
function innerCreateMedium$1(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI$1;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item2 = middleware(data, assigned);
      buffer2.push(item2);
      return function() {
        buffer2 = buffer2.filter(function(x2) {
          return x2 !== item2;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
      }
      buffer2 = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium$1(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium$1(null);
  medium.options = __assign$1({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign$1({}, rest));
};
SideCar$1$1.isSideCarExport = true;
function exportSidecar$1(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1$1;
}
var effectCar$1 = createSidecarMedium$1();
var nothing$1 = function() {
  return;
};
var RemoveScroll$1 = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing$1,
    onWheelCapture: nothing$1,
    onTouchMoveCapture: nothing$1
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs$1([ref, parentRef]);
  var containerProps = __assign$1(__assign$1({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar$1, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$1(__assign$1({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign$1({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName$1,
  zeroRight: zeroRightClassName$1
};
var getNonce$1 = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag$1() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce$1();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles$1(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag$1(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton$1 = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag$1()) {
          injectStyles$1(stylesheet, style);
          insertStyleTag$1(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton$1 = function() {
  var sheet = stylesheetSingleton$1();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton$1 = function() {
  var useStyle2 = styleHookSingleton$1();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle2(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap$1 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$2 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset$1 = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$2(left), parse$2(top), parse$2(right)];
};
var getGapWidth$1 = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap$1;
  }
  var offsets = getOffset$1(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style$1 = styleSingleton$1();
var lockAttribute$1 = "data-scroll-locked";
var getStyles$1 = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName$1, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute$1, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName$1, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName$1, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName$1, " .").concat(zeroRightClassName$1, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName$1, " .").concat(fullWidthClassName$1, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute$1, "] {\n    ").concat(removedBarSizeVariable$1, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter$1 = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute$1) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute$1 = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute$1, (getCurrentUseCounter$1() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter$1() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute$1);
      } else {
        document.body.setAttribute(lockAttribute$1, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar$1 = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute$1();
  var gap = reactExports.useMemo(function() {
    return getGapWidth$1(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style$1, { styles: getStyles$1(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported$1 = false;
if (typeof window !== "undefined") {
  try {
    var options$1 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported$1 = true;
        return true;
      }
    });
    window.addEventListener("test", options$1, options$1);
    window.removeEventListener("test", options$1, options$1);
  } catch (err) {
    passiveSupported$1 = false;
  }
}
var nonPassive$1 = passiveSupported$1 ? { passive: false } : false;
var alwaysContainsScroll$1 = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled$1 = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll$1(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled$1 = function(node) {
  return elementCanBeScrolled$1(node, "overflowY");
};
var elementCouldBeHScrolled$1 = function(node) {
  return elementCanBeScrolled$1(node, "overflowX");
};
var locationCouldBeScrolled$1 = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled$1(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables$1(axis, current), s2 = _a2[1], d2 = _a2[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables$1 = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables$1 = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled$1 = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled$1(node) : elementCouldBeHScrolled$1(node);
};
var getScrollVariables$1 = function(axis, node) {
  return axis === "v" ? getVScrollVariables$1(node) : getHScrollVariables$1(node);
};
var getDirectionFactor$1 = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll$1 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor$1(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables$1(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled$1(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY$1 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY$1 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef$1 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare$1 = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle$1 = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter$1 = 0;
var lockStack$1 = [];
function RemoveScrollSideCar$1(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter$1++)[0];
  var Style2 = reactExports.useState(styleSingleton$1)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef$1)).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent2) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY$1(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll$1(cancelingAxis, parent2, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event2) {
    var event = _event2;
    if (!lockStack$1.length || lockStack$1[lockStack$1.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY$1(event) : getTouchXY$1(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare$1(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef$1).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should, shadowParent: getOutermostShadowParent$1(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY$1(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack$1.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive$1);
    document.addEventListener("touchmove", shouldPrevent, nonPassive$1);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive$1);
    return function() {
      lockStack$1 = lockStack$1.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive$1);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle$1(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar$1, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent$1(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar$2 = exportSidecar$1(effectCar$1, RemoveScrollSideCar$1);
var ReactRemoveScroll$1 = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll$1, __assign$1({}, props, { ref, sideCar: SideCar$2 }));
});
ReactRemoveScroll$1.classNames = RemoveScroll$1.classNames;
var SELECTION_KEYS$1 = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS$1, "ArrowRight"],
  rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope$1(MENU_NAME, [
  createCollectionScope$2,
  createPopperScope$1,
  createRovingFocusGroupScope
]);
var usePopperScope$2 = createPopperScope$1();
var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$2(__scopeMenu);
  const [content2, setContent] = reactExports.useState(null);
  const isUsingKeyboardRef = reactExports.useRef(false);
  const handleOpenChange = useCallbackRef$1$1(onOpenChange);
  const direction = useDirection(dir);
  reactExports.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content: content2,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: reactExports.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME$2 = "MenuAnchor";
var MenuAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor$1, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME$2;
var PORTAL_NAME$3 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context2 = useMenuContext(PORTAL_NAME$3, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$3;
var CONTENT_NAME$5 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$5);
var MenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    reactExports.useEffect(() => {
      const content2 = ref.current;
      if (content2) return hideOthers$1(content2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context2.open,
        disableOutsidePointerEvents: context2.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers$1(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context2.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = reactExports.forwardRef((props, forwardedRef) => {
  const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context2.onOpenChange(false)
    }
  );
});
var MenuContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context2 = useMenuContext(CONTENT_NAME$5, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, __scopeMenu);
    const popperScope = usePopperScope$2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const getItems = useCollection$2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = reactExports.useState(null);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, contentRef, context2.onContentChange);
    const timerRef = reactExports.useRef(0);
    const searchRef = reactExports.useRef("");
    const pointerGraceTimerRef = reactExports.useRef(0);
    const pointerGraceIntentRef = reactExports.useRef(null);
    const pointerDirRef = reactExports.useRef("right");
    const lastPointerXRef = reactExports.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll$1 : reactExports.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot$1, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a2, _b2;
      const search2 = searchRef.current + key;
      const items = getItems().filter((item2) => !item2.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a2 = items.find((item2) => item2.ref.current === currentItem)) == null ? void 0 : _a2.textValue;
      const values = items.map((item2) => item2.textValue);
      const nextMatch = getNextMatch(values, search2, currentMatch);
      const newItem = (_b2 = items.find((item2) => item2.textValue === nextMatch)) == null ? void 0 : _b2.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search2);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    reactExports.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards$1();
    const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
      var _a2, _b2;
      const isMovingTowards = pointerDirRef.current === ((_a2 = pointerGraceIntentRef.current) == null ? void 0 : _a2.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b2 = pointerGraceIntentRef.current) == null ? void 0 : _b2.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: reactExports.useCallback(
          (event) => {
            var _a2;
            if (isPointerMovingToSubmenu(event)) return;
            (_a2 = contentRef.current) == null ? void 0 : _a2.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: reactExports.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope$1,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers$1(onOpenAutoFocus, (event) => {
              var _a2;
              event.preventDefault();
              (_a2 = contentRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer$1,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$4,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers$1(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content$2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context2.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers$1(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content2 = contentRef.current;
                          if (event.target !== content2) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item2) => !item2.disabled);
                          const candidateNodes = items.map((item2) => item2.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst$1(candidateNodes);
                        }),
                        onBlur: composeEventHandlers$1(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers$1(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$5;
var GROUP_NAME$2 = "MenuGroup";
var MenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel";
var MenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = reactExports.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$3, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$3, props.__scopeMenu);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    const isPointerDownRef = reactExports.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent$1(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers$1(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a2;
          (_a2 = props.onPointerDown) == null ? void 0 : _a2.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers$1(props.onPointerUp, (event) => {
          var _a2;
          if (!isPointerDownRef.current) (_a2 = event.currentTarget) == null ? void 0 : _a2.click();
        }),
        onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS$1.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$3;
var MenuItemImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$3, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const [textContent, setTextContent] = reactExports.useState("");
    reactExports.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$2.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers$1(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item2 = event.currentTarget;
                    item2.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers$1(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers$1(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers$1(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem";
var MenuCheckboxItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers$1(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$2 = "MenuRadioGroup";
var [RadioGroupProvider$1, useRadioGroupContext$1] = createMenuContext(
  RADIO_GROUP_NAME$2,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider$1, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
var RADIO_ITEM_NAME$1 = "MenuRadioItem";
var MenuRadioItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context2 = useRadioGroupContext$1(RADIO_ITEM_NAME$1, props.__scopeMenu);
    const checked = value === context2.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers$1(
          radioItemProps.onSelect,
          () => {
            var _a2;
            return (_a2 = context2.onValueChange) == null ? void 0 : _a2.call(context2, value);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME$1,
  { checked: false }
);
var MenuItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence$1,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$2.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "MenuSeparator";
var MenuSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$3 = "MenuArrow";
var MenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow$2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var SUB_TRIGGER_NAME$1 = "MenuSubTrigger";
var MenuSubTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useMenuContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const openTimerRef = reactExports.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = reactExports.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    reactExports.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    reactExports.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context2.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context2.open),
        ...props,
        ref: composeRefs$1(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a2;
          (_a2 = props.onClick) == null ? void 0 : _a2.call(props, event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context2.open) context2.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers$1(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context2.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context2.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers$1(
          props.onPointerLeave,
          whenMouse((event) => {
            var _a2, _b2;
            clearOpenTimer();
            const contentRect = (_a2 = context2.content) == null ? void 0 : _a2.getBoundingClientRect();
            if (contentRect) {
              const side = (_b2 = context2.content) == null ? void 0 : _b2.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
          var _a2;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context2.onOpenChange(true);
            (_a2 = context2.content) == null ? void 0 : _a2.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent";
var MenuSubContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$1, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a2;
          if (rootContext.isUsingKeyboardRef.current) (_a2 = ref.current) == null ? void 0 : _a2.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers$1(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context2.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers$1(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
          var _a2;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context2.onOpenChange(false);
            (_a2 = subContext.trigger) == null ? void 0 : _a2.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$1(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search2, currentMatch) {
  const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
  const normalizedSearch = isRepeated ? search2[0] : search2;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray$1(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v3) => v3 !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi2 = polygon[i].x;
    const yi2 = polygon[i].y;
    const xj2 = polygon[j2].x;
    const yj2 = polygon[j2].y;
    const intersect = yi2 > y2 !== yj2 > y2 && x2 < (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$1 = Menu;
var Anchor2$1 = MenuAnchor;
var Portal$2 = MenuPortal;
var Content2$3 = MenuContent;
var Group$1 = MenuGroup;
var Label = MenuLabel;
var Item2$2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup$2 = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow2$2 = MenuArrow;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope$1(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = reactExports.useRef(null);
  const [open = false, setOpen] = useControllableState$1({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId$1(),
      triggerRef,
      contentId: useId$1(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$1, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$4 = "DropdownMenuTrigger";
var DropdownMenuTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context2 = useDropdownMenuContext(TRIGGER_NAME$4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2$1, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.button,
      {
        type: "button",
        id: context2.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context2.open,
        "aria-controls": context2.open ? context2.contentId : void 0,
        "data-state": context2.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs$1(forwardedRef, context2.triggerRef),
        onPointerDown: composeEventHandlers$1(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context2.onOpenToggle();
            if (!context2.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context2.onOpenToggle();
          if (event.key === "ArrowDown") context2.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger$1.displayName = TRIGGER_NAME$4;
var PORTAL_NAME$2 = "DropdownMenuPortal";
var DropdownMenuPortal$1 = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { ...menuScope, ...portalProps });
};
DropdownMenuPortal$1.displayName = PORTAL_NAME$2;
var CONTENT_NAME$4 = "DropdownMenuContent";
var DropdownMenuContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context2 = useDropdownMenuContext(CONTENT_NAME$4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$3,
      {
        id: context2.contentId,
        "aria-labelledby": context2.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers$1(props.onCloseAutoFocus, (event) => {
          var _a2;
          if (!hasInteractedOutsideRef.current) (_a2 = context2.triggerRef.current) == null ? void 0 : _a2.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers$1(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context2.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent$1.displayName = CONTENT_NAME$4;
var GROUP_NAME$1 = "DropdownMenuGroup";
var DropdownMenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group$1, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "DropdownMenuLabel";
var DropdownMenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$2 = "DropdownMenuItem";
var DropdownMenuItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem$1.displayName = ITEM_NAME$2;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME$1 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup$2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup$1.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME$2 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator$1.displayName = INDICATOR_NAME$2;
var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
var DropdownMenuSeparator$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator$1.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$2 = "DropdownMenuArrow";
var DropdownMenuArrow$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow$1.displayName = ARROW_NAME$2;
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME;
var CheckboxItem2 = DropdownMenuCheckboxItem$1;
var RadioItem2 = DropdownMenuRadioItem$1;
var ItemIndicator2 = DropdownMenuItemIndicator$1;
var item = "_1k2mbvi4 _1k2mbvi3 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr1zs fyvr111g fyvr1v0 fyvr1x4 fyvr1310 fyvr130u fyvr11l8 fyvr11ow fyvr11o4 fyvr12zf fyvr11rc fyvr11m4 fyvr12wf";
var indicator = "_1k2mbvi5";
const DropdownMenuItemIndicator = ({
  children
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { className: indicator, children });
reactExports.forwardRef(({ className, children, ...rest }, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CheckboxItem2,
    {
      className: clsx(item, className),
      ...rest,
      ref: forwardedRef,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckmarkIcon, { size: "xs" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", children })
      ]
    }
  );
});
reactExports.forwardRef(({ className, children, ...rest }, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    RadioItem2,
    {
      className: clsx(item, className),
      ...rest,
      ref: forwardedRef,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { className: indicator, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", children })
      ]
    }
  );
});
const IconButton = reactExports.forwardRef(
  (props, ref) => {
    const { icon: icon2, size: size2 = "md", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        leftIcon: icon2,
        size: size2,
        flexShrink: "0",
        ref,
        ...rest
      }
    );
  }
);
const useCombinedRefs = (...refs) => (element) => refs.forEach((ref) => {
  if (!ref) {
    return;
  }
  if (typeof ref === "function") {
    ref(element);
  } else {
    ref.current = element;
  }
});
var wrap$1 = "_1hq71vk1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _1hq71vk0 fyvr11eg fyvr11es fyvr11f4 fyvr11fg fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr12rf fyvr12k3 fyvr125f fyvr12cr fyvr12rx fyvr12kl fyvr125x fyvr12d9 fyvr11ow fyvr11lk fyvr11mk fyvr11nk fyvr1h4 fyvr11m4";
var wrapVariants$1 = createRuntimeFn({ defaultClassName: "_1hq71vk5", variantClassNames: { borderRadius: { xs: "_1hq71vk6 _1hq71vk2 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg", sm: "_1hq71vk7 _1hq71vk3 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk", md: "_1hq71vk8 _1hq71vk4 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go" } }, defaultVariants: {}, compoundVariants: [] });
var input$1 = "_1hq71vka _1hq71vk9 fyvr130x fyvr130r fyvr11lw fyvr12zr fyvr1m0 fyvr1qg fyvr1o8 fyvr1so";
const MIME_TYPES = {
  png: ".png,image/png",
  jpeg: ".jpeg,image/jpeg",
  jpg: ".jpg,image/jpg",
  images: "image/*, video/*",
  pdf: ".pdf,application/pdf",
  mp4: ".mp4,video/mp4",
  csv: ".csv,text/csv",
  json: ".json,application/json"
};
reactExports.forwardRef(
  (props, ref) => {
    const {
      borderRadius = "md",
      description: description2,
      disabled = false,
      id: id2,
      label = "",
      labelLocation = "hidden",
      name: name2,
      onValueChange,
      placeholder = "Upload a file",
      validExtensions,
      ...rest
    } = props;
    const inputRef = reactExports.useRef(null);
    const combinedRef = useCombinedRefs(inputRef, ref);
    const [fileData, setFileData] = reactExports.useState(null);
    const handleChange = (e2) => {
      const filelist = e2.currentTarget.files;
      if (!filelist || !filelist[0]) {
        return;
      }
      const file = filelist[0];
      const filename = file.name;
      const filesize = file.size / 1e3;
      setFileData({
        name: filename,
        size: filesize,
        extension: filename.split(".").pop() ?? ""
      });
      onValueChange == null ? void 0 : onValueChange(file);
    };
    const accept = validExtensions.map((ext) => MIME_TYPES[ext]).join(",");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$2,
      {
        description: description2,
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            width: "full",
            minWidth: "0",
            justifyContent: fileData ? "space-between" : "flex-start",
            gap: "2",
            color: fileData ? "text100" : "text50",
            className: clsx(wrap$1, wrapVariants$1({ borderRadius })),
            children: [
              fileData ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flexDirection: "row", gap: "2", alignItems: "center", minWidth: "0", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ellipsis: true, children: fileData.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { color: "text50", variant: "xsmall", whiteSpace: "nowrap", children: [
                  fileData.size.toFixed(2),
                  " kb"
                ] })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ellipsis: true, children: placeholder }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  accept,
                  as: "input",
                  className: input$1,
                  cursor: "pointer",
                  disabled,
                  id: id2 ?? name2,
                  name: name2,
                  onChange: handleChange,
                  ref: combinedRef,
                  type: "file",
                  ...rest
                }
              ),
              fileData && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  cursor: "pointer",
                  icon: SvgCloseIcon,
                  size: "xs",
                  onClick: (ev) => {
                    var _a2;
                    ev.preventDefault();
                    ev.stopPropagation();
                    ((_a2 = inputRef.current) == null ? void 0 : _a2.value) && (inputRef.current.value = "");
                    onValueChange == null ? void 0 : onValueChange(null);
                    setFileData(null);
                  },
                  zIndex: "10"
                }
              )
            ]
          }
        )
      }
    );
  }
);
var avatar = createRuntimeFn({ defaultClassName: "_1bhyzin0", variantClassNames: { size: { xs: "_1bhyzin1", sm: "_1bhyzin2", md: "_1bhyzin3", lg: "_1bhyzin4", xl: "_1bhyzin5" } }, defaultVariants: {}, compoundVariants: [] });
const MOD = 1e3;
const SIZE = 64;
const RADIUS = SIZE / 2;
const scaledMod = (value, mod2 = MOD) => {
  return value % mod2 / (MOD / SIZE);
};
const cyrb53 = (str, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch2; i < str.length; i++) {
    ch2 = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch2, 2654435761);
    h2 = Math.imul(h2 ^ ch2, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
const createGradient = (a2, b2, c2) => {
  const hueA = a2 % 360;
  const hueB = (a2 + 120) % 360;
  const hueC = c2 % 360;
  return {
    a: `hsl(${hueA}deg 100% 40%)`,
    b: `hsl(${hueB}deg 100% 50%)`,
    c: `hsl(${hueC}deg 100% 50%)`
  };
};
const createGradients = (address, complexity) => {
  const hashes = [];
  for (let i = 0; i < complexity; i++) {
    const offset2 = i * 6;
    hashes.push({
      a: cyrb53(address + "a", offset2),
      b: cyrb53(address + "b", offset2 + 1),
      c: cyrb53(address + "c", offset2 + 2),
      x: cyrb53(address + "d", offset2 + 3),
      y: cyrb53(address + "e", offset2 + 4),
      r: cyrb53(address + "f", offset2 + 5)
    });
  }
  return hashes.map((hash2, idx) => {
    const r2 = SIZE / 10 + scaledMod(hash2.r, MOD * 1.5 / (idx + 1));
    return {
      ...createGradient(hash2.a, hash2.b, hash2.c),
      x: scaledMod(hash2.x),
      //clampGradientPosition(hash.x % SIZE, -r / 3),
      y: scaledMod(hash2.y),
      //clampGradientPosition(hash.y % SIZE, -r / 3),
      r: r2
    };
  });
};
const GradientAvatar = reactExports.memo((props) => {
  const { className, address, size: size2 = "md", complexity = 1, ...rest } = props;
  const gradients = createGradients(address, complexity);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      as: "svg",
      className: clsx(className, avatar({ size: size2 })),
      viewBox: `0 0 ${SIZE} ${SIZE}`,
      version: "1.1",
      flexShrink: "0",
      borderRadius: "circle",
      overflow: "hidden",
      xmlns: "http://www.w3.org/2000/svg",
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "circle-clip", children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: RADIUS, cy: RADIUS, r: RADIUS }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "filter",
            {
              id: "blur",
              x: "-10%",
              y: "-10%",
              width: "120%",
              height: "120%",
              filterUnits: "userSpaceOnUse",
              colorInterpolationFilters: "sRGB",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "feBlend",
                  {
                    mode: "normal",
                    in: "SourceGraphic",
                    in2: "BackgroundImageFix",
                    result: "shape"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "feGaussianBlur",
                  {
                    stdDeviation: SIZE / 10,
                    result: "effect1_foregroundBlur"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "linearGradient",
            {
              id: `gradient-background-${address}`,
              x1: "0",
              y1: "0",
              x2: "1",
              y2: "1",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradients[0].c }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradients[0].a })
              ]
            }
          ),
          gradients.map((gradient, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: `gradient-primary-${address}-${idx}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradient.a }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradient.b })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: `gradient-secondary-${address}-${idx}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradient.c }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradient.b })
            ] })
          ] }, idx))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#circle-clip)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              width: "100%",
              height: "100%",
              fill: `url(#gradient-background-${address})`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { filter: "url(#blur)", children: gradients.map((gradient, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                fill: `url(#gradient-primary-${address}-${idx})`,
                cx: gradient.x,
                cy: gradient.y,
                r: gradient.r
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                fill: `url(#gradient-secondary-${address}-${idx})`,
                cx: gradient.y,
                cy: gradient.x,
                r: gradient.r / 2
              }
            )
          ] }, idx)) })
        ] })
      ]
    }
  );
});
const Image$1 = (props) => {
  const { disableAnimation = false, onLoad, ...rest } = props;
  const [isImageLoaded, setImageLoaded] = reactExports.useState(false);
  const handleLoad = (ev) => {
    setImageLoaded(true);
    onLoad == null ? void 0 : onLoad(ev);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: motion.img,
      initial: disableAnimation ? void 0 : { opacity: 0 },
      animate: disableAnimation ? void 0 : { opacity: isImageLoaded ? 1 : 0 },
      transition: { duration: 0.2 },
      onLoad: disableAnimation ? void 0 : handleLoad,
      ...rest
    }
  );
};
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope$1(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open = false, setOpen] = useControllableState$1({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId$1(),
      titleId: useId$1(),
      descriptionId: useId$1(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$3 = "DialogTrigger";
var DialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context2 = useDialogContext(TRIGGER_NAME$3, __scopeDialog);
    const composedTriggerRef = useComposedRefs$1(forwardedRef, context2.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context2.open,
        "aria-controls": context2.contentId,
        "data-state": getState$2(context2.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers$1(props.onClick, context2.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$1$1 = "DialogPortal";
var [PortalProvider$1, usePortalContext$1] = createDialogContext(PORTAL_NAME$1$1, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context2 = useDialogContext(PORTAL_NAME$1$1, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME$1$1;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context2 = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context2 = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll$1, { as: Slot$1, allowPinchZoom: true, shards: [context2.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$2.div,
        {
          "data-state": getState$2(context2.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$3 = "DialogContent";
var DialogContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context2 = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME$3;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, context2.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content2 = contentRef.current;
      if (content2) return hideOthers$1(content2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context2.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers$1(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          (_a2 = context2.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers$1(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers$1(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b2 = context2.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context2.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context2 = useDialogContext(CONTENT_NAME$3, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, contentRef);
    useFocusGuards$1();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope$1,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer$1,
            {
              role: "dialog",
              id: context2.contentId,
              "aria-describedby": context2.descriptionId,
              "aria-labelledby": context2.titleId,
              "data-state": getState$2(context2.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context2.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context2.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context2.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$1 = "DialogTitle";
var DialogTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context2 = useDialogContext(TITLE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.h2, { id: context2.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "DialogDescription";
var DialogDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context2 = useDialogContext(DESCRIPTION_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.p, { id: context2.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME$1;
var CLOSE_NAME$1 = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context2 = useDialogContext(CLOSE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers$1(props.onClick, () => context2.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$1;
function getState$2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$3,
  titleName: TITLE_NAME$1,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    var _a2;
    const describedById = (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$3 = Dialog;
var Trigger$3 = DialogTrigger;
var Portal$1$1 = DialogPortal;
var Overlay = DialogOverlay;
var Content$1 = DialogContent;
var Title$1 = DialogTitle;
var Description$1 = DialogDescription;
var Close$1 = DialogClose;
const index$2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Close: Close$1,
  Content: Content$1,
  Description: Description$1,
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
  Overlay,
  Portal: Portal$1$1,
  Root: Root$3,
  Title: Title$1,
  Trigger: Trigger$3,
  WarningProvider,
  createDialogScope
}, Symbol.toStringTag, { value: "Module" }));
var scroll = createRuntimeFn({ defaultClassName: "_1vqx0w91 _1vqx0w90 fyvr12g fyvr164", variantClassNames: { direction: { vertical: "_1vqx0w92", horizontal: "_1vqx0w93" } }, defaultVariants: {}, compoundVariants: [] });
var overlay$1 = createRuntimeFn({ defaultClassName: "_1vqx0w94", variantClassNames: { shadows: { true: "_1vqx0w95", false: "_1vqx0w96" }, direction: { vertical: "_1vqx0w97", horizontal: "_1vqx0w98" } }, defaultVariants: {}, compoundVariants: [] });
const Scroll = (props) => {
  const {
    children,
    shadows = true,
    direction = "vertical",
    contentProps,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: overlay$1({ direction, shadows }),
      position: "relative",
      width: "full",
      height: "full",
      ...rest,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          className: scroll({ direction }),
          background: "backgroundPrimary",
          ...contentProps,
          children
        }
      )
    }
  );
};
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  if (matches) {
    return matches[1];
  }
  return variable;
}
function get$1(obj, path) {
  var result = obj;
  for (var key of path) {
    if (!(key in result)) {
      throw new Error("Path ".concat(path.join(" -> "), " does not exist in object"));
    }
    result = result[key];
  }
  return result;
}
function walkObject(obj, fn) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var clone = {};
  for (var key in obj) {
    var _value2 = obj[key];
    var currentPath = [...path, key];
    if (typeof _value2 === "string" || typeof _value2 === "number" || _value2 == null) {
      clone[key] = fn(_value2, currentPath);
    } else if (typeof _value2 === "object" && !Array.isArray(_value2)) {
      clone[key] = walkObject(_value2, fn, currentPath);
    } else {
      console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value2) ? "Array" : typeof _value2, '"'));
    }
  }
  return clone;
}
function setVar(element, variable, value) {
  element.style.setProperty(getVarName(variable), value);
}
function setElementVars(element, varsOrContract, tokens2) {
  if (typeof tokens2 === "object") {
    var _contract = varsOrContract;
    walkObject(tokens2, (value2, path) => {
      if (value2 == null) {
        return;
      }
      setVar(element, get$1(_contract, path), String(value2));
    });
  } else {
    var _vars = varsOrContract;
    for (var varName in _vars) {
      var value = _vars[varName];
      if (value == null) {
        continue;
      }
      setVar(element, varName, _vars[varName]);
    }
  }
}
const THEMES = ["dark", "light"];
const DEFAULT_THEME = "dark";
const THEME_ATTR = "data-theme";
const STORAGE_KEY = "@sequence.theme";
const isTheme = (theme) => THEMES.includes(theme);
const isThemeOverrides = (theme) => typeof theme === "object" && theme !== null && !Array.isArray(theme);
const getStorageKey = (scope) => scope ? `${STORAGE_KEY}.${scope}` : STORAGE_KEY;
const getTheme = (scope) => {
  const persistedTheme = localStorage.getItem(
    getStorageKey(scope)
  );
  if (persistedTheme && THEMES.includes(persistedTheme)) {
    return persistedTheme;
  }
  return DEFAULT_THEME;
};
const ThemeContext = reactExports.createContext(null);
const ThemeProvider = (props) => {
  const [theme, setTheme] = reactExports.useState(
    props.theme || DEFAULT_THEME
  );
  reactExports.useEffect(() => {
    /Mac/.test(window.navigator.userAgent) && window.document.documentElement.classList.add("is-apple");
  }, []);
  reactExports.useEffect(() => {
    if (!props.theme) {
      setTheme(getTheme(props.scope));
    }
  }, [props.theme, props.scope]);
  reactExports.useEffect(() => {
    if (props.theme) {
      setTheme(props.theme);
    }
  }, [props.theme]);
  reactExports.useEffect(() => {
    const rootEl = document.querySelector(props.root || ":root");
    if (rootEl) {
      if (isTheme(theme)) {
        rootEl.setAttribute(THEME_ATTR, theme);
        setElementVars(rootEl, colorSchemeVars, {
          colors: colors[theme]
        });
      } else if (isThemeOverrides(theme)) {
        setElementVars(rootEl, colorSchemeVars, {
          colors: theme
        });
      }
      if (props.root) {
        rootEl.classList.add("seq-root");
      }
    }
  }, [theme, props.root]);
  const value = reactExports.useMemo(() => {
    return {
      theme,
      root: props.root,
      setTheme: (mode) => {
        if (THEMES.includes(mode)) {
          localStorage.setItem(getStorageKey(props.scope), mode);
          setTheme(mode);
        }
      }
    };
  }, [theme, props.root, props.scope]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, { value, children: props.children });
};
const useTheme$1 = () => {
  const context2 = reactExports.useContext(ThemeContext);
  if (!context2) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context2;
};
var root$3 = "_5b32m91 _5b32m90 fyvr11no fyvr11ow fyvr11l8 fyvr11m0 fyvr11rs fyvr1m0 fyvr1qg fyvr1so fyvr1o8";
var overlay = "_5b32m93 _5b32m92 fyvr11m0 fyvr1m0 fyvr1qg fyvr1so fyvr1o8";
var contentVariants = createRuntimeFn({ defaultClassName: "_5b32m95 _5b32m94 fyvr11hg fyvr11i4 fyvr11fo fyvr11g6 fyvr11gc fyvr11gu fyvr11q0 fyvr11qg fyvr1310 fyvr130u fyvr11l8 fyvr11mc fyvr11m0 fyvr11wl fyvr1o8 fyvr1qe", variantClassNames: { size: { sm: "_5b32m96", lg: "_5b32m97" }, autoHeight: { true: "_5b32m98" } }, defaultVariants: {}, compoundVariants: [[{ autoHeight: true, size: "lg" }, "_5b32m99"]] });
var close = "_5b32m9b _5b32m9a fyvr113s fyvr1160 fyvr1188 fyvr11ag fyvr11lw fyvr1so fyvr1m0 fyvr11rs";
const Modal = (props) => {
  const {
    autoHeight = false,
    backdropColor = "backgroundBackdrop",
    // gradientBackdrop for onboarding or special modals
    children,
    disableAnimation = false,
    isDismissible = true,
    onClose,
    scroll: scroll2 = true,
    size: size2 = "lg",
    overlayProps,
    contentProps,
    rootProps = {}
  } = props;
  const { root: root2 } = useTheme$1();
  const [container, setContainer] = reactExports.useState(null);
  reactExports.useEffect(() => {
    setContainer(document.querySelector(root2 || "body"));
  }, [root2]);
  return container ? /* @__PURE__ */ jsxRuntimeExports.jsx(Root$3, { modal: true, defaultOpen: true, onOpenChange: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1$1, { forceMount: true, container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      ...rootProps,
      className: clsx("seq-root", root$3, rootProps == null ? void 0 : rootProps.className),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            as: Overlay,
            asChild: true,
            background: backdropColor,
            className: overlay,
            forceMount: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: disableAnimation ? false : { opacity: 0 },
                animate: disableAnimation ? false : { opacity: 1 },
                exit: disableAnimation ? void 0 : { opacity: 0 },
                transition: {
                  type: "tween",
                  ease: "linear"
                },
                ...overlayProps
              },
              "modal-overlay"
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Content$1,
          {
            asChild: true,
            className: contentVariants({ autoHeight, size: size2 }),
            forceMount: true,
            onEscapeKeyDown: (ev) => {
              if (isDismissible) {
                onClose == null ? void 0 : onClose();
              } else {
                ev.preventDefault();
              }
            },
            onInteractOutside: (ev) => {
              if (!isDismissible) {
                ev.preventDefault();
              }
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                initial: disableAnimation ? false : { y: "100%", opacity: size2 === "sm" ? 0 : 1 },
                animate: disableAnimation ? false : { y: 0, opacity: size2 === "sm" ? 1 : 1 },
                exit: disableAnimation ? void 0 : { y: "100%", opacity: size2 === "sm" ? 0 : 1 },
                transition: { type: "tween", ease: "easeOut" },
                ...contentProps,
                children: [
                  scroll2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Scroll, { children }) : children,
                  isDismissible && /* @__PURE__ */ jsxRuntimeExports.jsx(Close$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IconButton,
                    {
                      icon: SvgCloseIcon,
                      backdropFilter: "blur",
                      size: "xs",
                      className: close,
                      "aria-label": "Close"
                    }
                  ) })
                ]
              },
              "modal-content"
            )
          }
        )
      ]
    }
  ) }) }) : null;
};
var wrap$2 = "_1acm19y1 _1acm19y0 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr1zk fyvr111o fyvr11lk fyvr11ow fyvr11sl fyvr12w9 fyvr1h4 fyvr11cg";
var wrapVariants = createRuntimeFn({ defaultClassName: "_1acm19y5", variantClassNames: { borderRadius: { xs: "_1acm19y6 _1acm19y2 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg", sm: "_1acm19y7 _1acm19y3 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk", md: "_1acm19y8 _1acm19y4 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go" } }, defaultVariants: {}, compoundVariants: [] });
var input = createRuntimeFn({ defaultClassName: "_1acm19ya _1acm19y9 fyvr1z4 fyvr1118 fyvr1vc fyvr1xg fyvr130x fyvr130r fyvr11l4 fyvr11sl fyvr12w9 fyvr12s9 fyvr12g fyvr164", variantClassNames: { numeric: { false: "_1acm19yb _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8", true: "_1acm19yc _1qxj1ib9 _1qxj1ibc _1qxj1ib2 fyvr11r3 fyvr11iw fyvr11kg fyvr11jw fyvr11jg" } }, defaultVariants: {}, compoundVariants: [] });
const TextInput = reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "input",
      autoComplete = "off",
      borderRadius = "md",
      description: description2,
      disabled = false,
      id: id2,
      label = "",
      labelLocation = "hidden",
      leftIcon: LeftIcon,
      rightIcon: RightIcon,
      name: name2,
      controls,
      type = "text",
      numeric = false,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$2,
      {
        description: description2,
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { width: "full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            className: clsx(
              wrap$2,
              wrapVariants({ borderRadius })
            ),
            children: [
              LeftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: "sm" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  as,
                  autoComplete,
                  spellCheck: "false",
                  className: input({ numeric }),
                  disabled,
                  id: id2 ?? name2,
                  name: name2,
                  ref,
                  type,
                  ...rest
                }
              ),
              RightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(RightIcon, { size: "sm" }),
              controls
            ]
          }
        ) })
      }
    );
  }
);
const inputRegex = RegExp(`^\\d*(?:\\\\[.])?\\d*$`);
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const NumericInput = reactExports.forwardRef(
  (props, ref) => {
    const { name: name2 = "amount", placeholder, onChange, onBlur, ...rest } = props;
    const handleChange = (ev) => {
      let { value } = ev.target;
      value = value.replace(/,/g, ".");
      if (value.startsWith(".")) {
        value = "0" + value;
      }
      if (value.startsWith("0")) {
        value = value.replace(/^0+(?=\d)/, "");
      }
      if (value === "" || inputRegex.test(escapeRegExp(value))) {
        onChange == null ? void 0 : onChange({ ...ev, target: { ...ev.target, value } });
      }
    };
    const handleBlur = (ev) => {
      const { value } = ev.target;
      let v3 = value;
      if (v3.endsWith(".")) {
        v3 = v3.slice(0, -1);
      }
      if (v3.endsWith(".0")) {
        v3 = v3.slice(0, -2);
      }
      if (v3 === "0") {
        v3 = "";
      }
      onBlur == null ? void 0 : onBlur(ev);
      if (v3 !== value) {
        onChange == null ? void 0 : onChange({ ...ev, target: { ...ev.target, value: v3 } });
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        name: name2,
        onChange: handleChange,
        onBlur: handleBlur,
        inputMode: "decimal",
        autoComplete: "off",
        autoCorrect: "off",
        type: "text",
        pattern: "^[0-9]*[.,]?[0-9]*$",
        placeholder: placeholder || "0",
        minLength: 1,
        maxLength: 79,
        spellCheck: "false",
        numeric: true,
        ref,
        ...rest
      }
    );
  }
);
var digitInput = "y5zf971 _1qxj1ib9 _1qxj1ibc _1qxj1ib2 fyvr11r3 fyvr11iw fyvr11kg fyvr11jw fyvr11jg _4efw240";
const PINCodeInput = (props) => {
  const {
    value,
    digits = 6,
    group,
    onChange,
    onConfirm,
    disabled = false
  } = props;
  const inputRefs = reactExports.useMemo(() => {
    return range(0, digits).map(() => reactExports.createRef());
  }, [digits]);
  reactExports.useEffect(() => {
    var _a2, _b2;
    (_b2 = (_a2 = inputRefs[0]) == null ? void 0 : _a2.current) == null ? void 0 : _b2.focus();
  }, [inputRefs]);
  const handleChange = (idx, character) => {
    var _a2, _b2;
    if (!/^\d$/.test(character)) {
      character = "";
    }
    const curr = [...value];
    curr[idx] = character;
    if (character !== "") {
      (_b2 = (_a2 = inputRefs[idx + 1]) == null ? void 0 : _a2.current) == null ? void 0 : _b2.focus();
    }
    onChange(curr);
  };
  const isValid2 = () => value.join("").length === digits;
  const handleKeyDown = (idx, ev) => {
    var _a2, _b2;
    const currentRef = inputRefs[idx].current;
    const prevRef = (_a2 = inputRefs[idx - 1]) == null ? void 0 : _a2.current;
    const nextRef = (_b2 = inputRefs[idx + 1]) == null ? void 0 : _b2.current;
    switch (ev.key) {
      case "Backspace":
        ev.preventDefault();
        if (currentRef) {
          currentRef.value = "";
          handleChange(idx, "");
        }
        prevRef == null ? void 0 : prevRef.focus();
        break;
      case "ArrowLeft":
        ev.preventDefault();
        prevRef == null ? void 0 : prevRef.focus();
        break;
      case "ArrowRight":
        ev.preventDefault();
        nextRef == null ? void 0 : nextRef.focus();
        break;
      case "Enter":
        ev.preventDefault();
        if (isValid2()) {
          onConfirm == null ? void 0 : onConfirm();
        }
        break;
      default:
        if ((currentRef == null ? void 0 : currentRef.value) === ev.key) {
          ev.preventDefault();
          handleChange(idx, ev.key);
        }
    }
  };
  const handlePaste = (idx, ev) => {
    var _a2, _b2;
    const pasted = ev.clipboardData.getData("text/plain");
    const filtered = pasted.replace(/\D/g, "");
    const re2 = new RegExp(`^\\d{${digits}}$`);
    if (re2.test(filtered)) {
      (_b2 = (_a2 = inputRefs[0]) == null ? void 0 : _a2.current) == null ? void 0 : _b2.focus();
      onChange(filtered.split(""));
      setTimeout(() => {
        var _a22, _b22;
        (_b22 = (_a22 = inputRefs[inputRefs.length - 1]) == null ? void 0 : _a22.current) == null ? void 0 : _b22.focus();
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { gap: "2", children: range(0, digits).map((idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    !!group && idx > 0 && idx % group === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as: "input",
        className: digitInput,
        value: value[idx] || "",
        ref: inputRefs[idx],
        type: "text",
        inputMode: "numeric",
        maxLength: 1,
        disabled,
        onFocus: (ev) => ev.target.select(),
        onPaste: (ev) => handlePaste(idx, ev),
        onChange: (ev) => handleChange(idx, ev.target.value),
        onKeyDown: (ev) => {
          handleKeyDown(idx, ev);
        }
      }
    )
  ] }, idx)) });
};
const range = (start, end) => Array.from({ length: end - start }, (v3, k2) => k2 + start);
var skeleton = createRuntimeFn({ defaultClassName: "_1jujggt1", variantClassNames: { size: { sm: "_1jujggt2", normal: "_1jujggt3", md: "_1jujggt4", lg: "_1jujggt5", xl: "_1jujggt6" } }, defaultVariants: {}, compoundVariants: [] });
const Skeleton = (props) => {
  const { size: size2, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: motion.div,
      className: skeleton({ size: size2 }),
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      borderRadius: "sm",
      ...rest
    }
  );
};
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope$1(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeProgress,
      value: valueProp = null,
      max: maxProp,
      getValueLabel = defaultGetValueLabel,
      ...progressProps
    } = props;
    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
      console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
    }
    const max2 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
    if (valueProp !== null && !isValidValueNumber(valueProp, max2)) {
      console.error(getInvalidValueError(`${valueProp}`, "Progress"));
    }
    const value = isValidValueNumber(valueProp, max2) ? valueProp : null;
    const valueLabel = isNumber$1(value) ? getValueLabel(value, max2) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressProvider, { scope: __scopeProgress, value, max: max2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.div,
      {
        "aria-valuemax": max2,
        "aria-valuemin": 0,
        "aria-valuenow": isNumber$1(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": getProgressState(value, max2),
        "data-value": value ?? void 0,
        "data-max": max2,
        ...progressProps,
        ref: forwardedRef
      }
    ) });
  }
);
Progress$1.displayName = PROGRESS_NAME;
var INDICATOR_NAME$1 = "ProgressIndicator";
var ProgressIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeProgress, ...indicatorProps } = props;
    const context2 = useProgressContext(INDICATOR_NAME$1, __scopeProgress);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.div,
      {
        "data-state": getProgressState(context2.value, context2.max),
        "data-value": context2.value ?? void 0,
        "data-max": context2.max,
        ...indicatorProps,
        ref: forwardedRef
      }
    );
  }
);
ProgressIndicator.displayName = INDICATOR_NAME$1;
function defaultGetValueLabel(value, max2) {
  return `${Math.round(value / max2 * 100)}%`;
}
function getProgressState(value, maxValue2) {
  return value == null ? "indeterminate" : value === maxValue2 ? "complete" : "loading";
}
function isNumber$1(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max2) {
  return isNumber$1(max2) && !isNaN(max2) && max2 > 0;
}
function isValidValueNumber(value, max2) {
  return isNumber$1(value) && !isNaN(value) && value <= max2 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope$1(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name: name2,
      checked = false,
      required,
      disabled,
      value = "on",
      onCheck,
      ...radioProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$2.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState$1(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers$1(props.onClick, (event) => {
            if (!checked) onCheck == null ? void 0 : onCheck();
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$1,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME = "RadioIndicator";
var RadioIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context2 = useRadioContext(INDICATOR_NAME, __scopeRadio);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.span,
      {
        "data-state": getState$1(context2.checked),
        "data-disabled": context2.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME;
var BubbleInput$1 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize$1(control);
  reactExports.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input2, checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "radio",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState$1(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope$1(RADIO_GROUP_NAME, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
var RadioGroup$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name: name2,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState$1({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioGroupProvider,
      {
        scope: __scopeRadioGroup,
        name: name2,
        required,
        disabled,
        value,
        onValueChange: setValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$4,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$2.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup$1.displayName = RADIO_GROUP_NAME;
var ITEM_NAME$1 = "RadioGroupItem";
var RadioGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context2 = useRadioGroupContext(ITEM_NAME$1, __scopeRadioGroup);
    const isDisabled = context2.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    const checked = context2.value === itemProps.value;
    const isArrowKeyPressedRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        if (ARROW_KEYS.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Radio,
          {
            disabled: isDisabled,
            required: context2.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context2.name,
            ref: composedRefs,
            onCheck: () => context2.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers$1((event) => {
              if (event.key === "Enter") event.preventDefault();
            }),
            onFocus: composeEventHandlers$1(itemProps.onFocus, () => {
              var _a2;
              if (isArrowKeyPressedRef.current) (_a2 = ref.current) == null ? void 0 : _a2.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem.displayName = ITEM_NAME$1;
var INDICATOR_NAME2 = "RadioGroupIndicator";
var RadioGroupIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME2;
var Root2$3 = RadioGroup$1;
var Item2 = RadioGroupItem;
var Indicator = RadioGroupIndicator;
var radioItemVariants = createRuntimeFn({ defaultClassName: "io59uy3 io59uy0 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr1uw fyvr1x0 fyvr1z4 fyvr1118 fyvr12rl fyvr12k9 fyvr125l fyvr12cx fyvr12rr fyvr12kf fyvr125r fyvr12d3 fyvr11sl fyvr12zf fyvr12zb fyvr1307 fyvr12zz _4efw240", variantClassNames: { size: { sm: "io59uy4 io59uy1 fyvr11eg fyvr11es fyvr11f4 fyvr11fg", lg: "io59uy5 io59uy2 fyvr11ek fyvr11ew fyvr11f8 fyvr11fk" } }, defaultVariants: {}, compoundVariants: [] });
var indicatorVariants = createRuntimeFn({ defaultClassName: "io59uy8 io59uy7 io59uy6 fyvr11l8 fyvr11ow fyvr11no fyvr11m4 fyvr12g fyvr164 fyvr12w9", variantClassNames: { size: { sm: "io59uy9", lg: "io59uya" } }, defaultVariants: {}, compoundVariants: [] });
const RadioOption = (props) => {
  const { id: id2, label, size: size2 = "sm", value, disabled } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field$2,
    {
      disabled,
      display: "flex",
      id: id2,
      label,
      labelLocation: "right",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Item2,
        {
          className: radioItemVariants({ size: size2 }),
          value,
          id: id2,
          disabled,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, { className: indicatorVariants({ size: size2 }) })
        }
      )
    }
  ) });
};
reactExports.forwardRef(
  (props, ref) => {
    const {
      flexDirection = "column",
      disabled = false,
      gap = "2",
      name: name2,
      options,
      size: size2 = "sm",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$3, { disabled, name: name2, ref, ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { flexDirection, gap, children: options.map(({ label, value, disabled: disabled2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioOption,
      {
        id: `${name2}-${value}`,
        label,
        size: size2,
        value,
        disabled: disabled2
      },
      value
    )) }) });
  }
);
function clamp$2(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
var NAME$2 = "VisuallyHidden";
var VisuallyHidden$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden$1.displayName = NAME$2;
var Root$1 = VisuallyHidden$1;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope$1(SELECT_NAME, [
  createCollectionScope$1,
  createPopperScope$1
]);
var usePopperScope$1 = createPopperScope$1();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name: name2,
    autoComplete,
    disabled,
    required
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const [valueNode, setValueNode] = reactExports.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = reactExports.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState$1({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState$1({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = reactExports.useRef(null);
  const isFormControl = trigger2 ? Boolean(trigger2.closest("form")) : true;
  const [nativeOptionsSet, setNativeOptionsSet] = reactExports.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId$1(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name: name2,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$2 = "SelectTrigger";
var SelectTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context2 = useSelectContext(TRIGGER_NAME$2, __scopeSelect);
    const isDisabled = context2.disabled || disabled;
    const composedRefs = useComposedRefs$1(forwardedRef, context2.onTriggerChange);
    const getItems = useCollection$1(__scopeSelect);
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search2) => {
      const enabledItems = getItems().filter((item2) => !item2.disabled);
      const currentItem = enabledItems.find((item2) => item2.value === context2.value);
      const nextItem = findNextItem(enabledItems, search2, currentItem);
      if (nextItem !== void 0) {
        context2.onValueChange(nextItem.value);
      }
    });
    const handleOpen = () => {
      if (!isDisabled) {
        context2.onOpenChange(true);
        resetTypeahead();
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor$1, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context2.contentId,
        "aria-expanded": context2.open,
        "aria-required": context2.required,
        "aria-autocomplete": "none",
        dir: context2.dir,
        "data-state": context2.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context2.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers$1(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
        }),
        onPointerDown: composeEventHandlers$1(triggerProps.onPointerDown, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false) {
            handleOpen();
            context2.triggerPointerDownPosRef.current = {
              x: Math.round(event.pageX),
              y: Math.round(event.pageY)
            };
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers$1(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME$2;
var VALUE_NAME = "SelectValue";
var SelectValue = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context2 = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context2;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs$1(forwardedRef, context2.onValueNodeChange);
    useLayoutEffect2$1(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context2.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
  }
);
SelectIcon.displayName = ICON_NAME;
var CONTENT_NAME$2 = "SelectContent";
var SelectContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useSelectContext(CONTENT_NAME$2, props.__scopeSelect);
    const [fragment, setFragment] = reactExports.useState();
    useLayoutEffect2$1(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context2.open) {
      const frag = fragment;
      return frag ? reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME$2;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$2);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context2 = useSelectContext(CONTENT_NAME$2, __scopeSelect);
    const [content2, setContent] = reactExports.useState(null);
    const [viewport2, setViewport] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = reactExports.useState(null);
    const [selectedItemText, setSelectedItemText] = reactExports.useState(
      null
    );
    const getItems = useCollection$1(__scopeSelect);
    const [isPositioned, setIsPositioned] = reactExports.useState(false);
    const firstValidItemFoundRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (content2) return hideOthers$1(content2);
    }, [content2]);
    useFocusGuards$1();
    const focusFirst2 = reactExports.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item2) => item2.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport2) viewport2.scrollTop = 0;
          if (candidate === lastItem && viewport2) viewport2.scrollTop = viewport2.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport2]
    );
    const focusSelectedItem = reactExports.useCallback(
      () => focusFirst2([selectedItem, content2]),
      [focusFirst2, selectedItem, content2]
    );
    reactExports.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context2;
    reactExports.useEffect(() => {
      if (content2) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a2, _b2;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a2 = triggerPointerDownPosRef.current) == null ? void 0 : _a2.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b2 = triggerPointerDownPosRef.current) == null ? void 0 : _b2.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content2.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content2, onOpenChange, triggerPointerDownPosRef]);
    reactExports.useEffect(() => {
      const close2 = () => onOpenChange(false);
      window.addEventListener("blur", close2);
      window.addEventListener("resize", close2);
      return () => {
        window.removeEventListener("blur", close2);
        window.removeEventListener("resize", close2);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search2) => {
      const enabledItems = getItems().filter((item2) => !item2.disabled);
      const currentItem = enabledItems.find((item2) => item2.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search2, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context2.value !== void 0 && context2.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context2.value]
    );
    const handleItemLeave = reactExports.useCallback(() => content2 == null ? void 0 : content2.focus(), [content2]);
    const itemTextRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context2.value !== void 0 && context2.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context2.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content: content2,
        viewport: viewport2,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll$1, { as: Slot$1, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope$1,
          {
            asChild: true,
            trapped: context2.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers$1(onCloseAutoFocus, (event) => {
              var _a2;
              (_a2 = context2.trigger) == null ? void 0 : _a2.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer$1,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context2.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context2.contentId,
                    "data-state": context2.open ? "open" : "closed",
                    dir: context2.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers$1(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item2) => !item2.disabled);
                        let candidateNodes = items.map((item2) => item2.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context2 = useSelectContext(CONTENT_NAME$2, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$2, __scopeSelect);
  const [contentWrapper, setContentWrapper] = reactExports.useState(null);
  const [content2, setContent] = reactExports.useState(null);
  const composedRefs = useComposedRefs$1(forwardedRef, (node) => setContent(node));
  const getItems = useCollection$1(__scopeSelect);
  const shouldExpandOnScrollRef = reactExports.useRef(false);
  const shouldRepositionRef = reactExports.useRef(true);
  const { viewport: viewport2, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = reactExports.useCallback(() => {
    if (context2.trigger && context2.valueNode && contentWrapper && content2 && viewport2 && selectedItem && selectedItemText) {
      const triggerRect = context2.trigger.getBoundingClientRect();
      const contentRect = content2.getBoundingClientRect();
      const valueNodeRect = context2.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context2.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp$2(left, [CONTENT_MARGIN, rightEdge - contentWidth]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp$2(right, [CONTENT_MARGIN, leftEdge - contentWidth]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport2.scrollHeight;
      const contentStyles = window.getComputedStyle(content2);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport2);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content2.clientHeight - viewport2.offsetTop - viewport2.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport2.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport2.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport2.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context2.trigger,
    context2.valueNode,
    contentWrapper,
    content2,
    viewport2,
    selectedItem,
    selectedItemText,
    context2.dir,
    onPlaced
  ]);
  useLayoutEffect2$1(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  useLayoutEffect2$1(() => {
    if (content2) setContentZIndex(window.getComputedStyle(content2).zIndex);
  }, [content2]);
  const handleScrollButtonChange = reactExports.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive$2.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content$2,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$2, {});
var VIEWPORT_NAME$1 = "SelectViewport";
var SelectViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME$1, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME$1, __scopeSelect);
    const composedRefs = useComposedRefs$1(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = reactExports.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$2.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers$1(viewportProps.onScroll, (event) => {
            const viewport2 = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport2.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport2.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport2.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME$1;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId$1();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context2 = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context2.value === value;
    const [textValue, setTextValue] = reactExports.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const composedRefs = useComposedRefs$1(
      forwardedRef,
      (node) => {
        var _a2;
        return (_a2 = contentContext.itemRefCallback) == null ? void 0 : _a2.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId$1();
    const handleSelect = () => {
      if (!disabled) {
        context2.onValueChange(value);
        context2.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: reactExports.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection$1.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$2.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers$1(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers$1(itemProps.onBlur, () => setIsFocused(false)),
                onPointerUp: composeEventHandlers$1(itemProps.onPointerUp, handleSelect),
                onPointerMove: composeEventHandlers$1(itemProps.onPointerMove, (event) => {
                  var _a2;
                  if (disabled) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  } else {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers$1(itemProps.onPointerLeave, (event) => {
                  var _a2;
                  if (event.currentTarget === document.activeElement) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers$1(itemProps.onKeyDown, (event) => {
                  var _a2;
                  const isTypingAhead = ((_a2 = contentContext.searchRef) == null ? void 0 : _a2.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context2 = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a2;
        return (_a2 = contentContext.itemTextRefCallback) == null ? void 0 : _a2.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = reactExports.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2$1(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context2.valueNode && !context2.valueNodeHasChildren ? reactDomExports.createPortal(itemTextProps.children, context2.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = reactExports.useState(false);
  const composedRefs = useComposedRefs$1(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2$1(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport2.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport2 = contentContext.viewport;
      handleScroll2();
      viewport2.addEventListener("scroll", handleScroll2);
      return () => viewport2.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = reactExports.useState(false);
  const composedRefs = useComposedRefs$1(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2$1(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport2.scrollHeight - viewport2.clientHeight;
        const canScrollDown2 = Math.ceil(viewport2.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport2 = contentContext.viewport;
      handleScroll2();
      viewport2.addEventListener("scroll", handleScroll2);
      return () => viewport2.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = reactExports.useRef(null);
  const getItems = useCollection$1(__scopeSelect);
  const clearAutoScrollTimer = reactExports.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  reactExports.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2$1(() => {
    var _a2;
    const activeItem = getItems().find((item2) => item2.ref.current === document.activeElement);
    (_a2 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a2.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$2.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers$1(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers$1(scrollIndicatorProps.onPointerMove, () => {
        var _a2;
        (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers$1(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME$1$1 = "SelectArrow";
var SelectArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context2 = useSelectContext(ARROW_NAME$1$1, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME$1$1, __scopeSelect);
    return context2.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow$2, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME$1$1;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref);
    const prevValue = usePrevious(value);
    reactExports.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1$1(onSearchChange);
  const searchRef = reactExports.useRef("");
  const timerRef = reactExports.useRef(0);
  const handleTypeaheadSearch = reactExports.useCallback(
    (key) => {
      const search2 = searchRef.current + key;
      handleSearchChange(search2);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search2);
    },
    [handleSearchChange]
  );
  const resetTypeahead = reactExports.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search2, currentItem) {
  const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
  const normalizedSearch = isRepeated ? search2[0] : search2;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v3) => v3 !== currentItem);
  const nextItem = wrappedItems.find(
    (item2) => item2.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root2$2 = Select$1;
var Trigger$2 = SelectTrigger;
var Value = SelectValue;
var Icon = SelectIcon;
var Content2$1 = SelectContent;
var Viewport$1 = SelectViewport;
var Group = SelectGroup;
var Item$2 = SelectItem$1;
var ItemText = SelectItemText;
var triggerStyle = "gohwum1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 gohwum0 fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr11ow fyvr11sl fyvr11lk fyvr11jc fyvr12w9 fyvr11cc fyvr11o4 fyvr11rc fyvr12zf fyvr12s9";
var triggerVariants = createRuntimeFn({ defaultClassName: "gohwum5", variantClassNames: { borderRadius: { xs: "gohwum6 gohwum2 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg", sm: "gohwum7 gohwum3 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk", md: "gohwum8 gohwum4 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go" } }, defaultVariants: {}, compoundVariants: [] });
var contentStyle = "gohwuma gohwum9 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr11q0 fyvr11qg fyvr11r0 fyvr11y3 fyvr12w9 fyvr11rt";
var optionStyle = "gohwume _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 gohwumd fyvr1zk fyvr111o fyvr1v8 fyvr1xc fyvr1310 fyvr1311 fyvr130u fyvr130v fyvr11l8 fyvr11o4 fyvr11ow fyvr12zf fyvr12zb fyvr12w9 fyvr1309 fyvr12zz";
const SelectItem = reactExports.forwardRef(
  ({ children, className, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$2,
      {
        className: clsx(optionStyle, className),
        ...props,
        ref,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
      }
    );
  }
);
const Select = reactExports.forwardRef(
  (props, ref) => {
    const {
      borderRadius = "md",
      disabled = false,
      id: id2,
      label = "",
      description: description2,
      labelLocation = "hidden",
      name: name2,
      options,
      placeholder,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$2,
      {
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        description: description2,
        whiteSpace: "nowrap",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$2, { disabled, name: name2, ...rest, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Trigger$2,
            {
              id: id2 ?? name2,
              className: clsx(triggerStyle, triggerVariants({ borderRadius })),
              ref,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Value, { placeholder }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: Icon, display: "inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgChevronDownIcon, {}) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Content2$1, { className: contentStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { children: options.map(({ value, label: label2, ...rest2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value, ...rest2, children: label2 }, value)) }) }) })
        ] })
      }
    );
  }
);
reactExports.forwardRef(
  (props, ref) => {
    const {
      controls,
      onChange,
      placeholder = "Search",
      name: name2 = "search",
      value,
      ...rest
    } = props;
    const defaultClearButton = value ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        icon: SvgCloseIcon,
        size: "xs",
        onClick: () => onChange == null ? void 0 : onChange({
          target: { value: "" }
        })
      }
    ) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        ref,
        name: name2,
        leftIcon: SvgSearchIcon,
        controls: controls || defaultClearButton,
        placeholder,
        value,
        onChange: (ev) => onChange == null ? void 0 : onChange(ev),
        ...rest
      }
    );
  }
);
var variants = createRuntimeFn({ defaultClassName: "en4abt1", variantClassNames: { size: { sm: "en4abt2", md: "en4abt3", lg: "en4abt4" } }, defaultVariants: {}, compoundVariants: [] });
const Spinner = reactExports.forwardRef(
  (props, ref) => {
    const { size: size2 = "md", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: variants({ size: size2 }),
        color: "text50",
        ref,
        ...rest,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg",
            stroke: "currentColor",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: "12",
                  cy: "12",
                  fill: "none",
                  r: "10.5",
                  strokeDasharray: "42",
                  strokeLinecap: "round"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: "12",
                  cy: "12",
                  fill: "none",
                  opacity: "0.25",
                  r: "10.5",
                  strokeLinecap: "round"
                }
              )
            ]
          }
        )
      }
    );
  }
);
reactExports.forwardRef(
  ({ children }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ref,
      width: "fit",
      height: "fit",
      onClick: (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      },
      onKeyDown: (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          ev.stopPropagation();
        }
      },
      children
    }
  )
);
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope$1(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name: name2,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      ...switchProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    const [checked = false, setChecked] = useControllableState$1({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$2.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState$5(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers$1(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch$1.displayName = SWITCH_NAME;
var THUMB_NAME = "SwitchThumb";
var SwitchThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context2 = useSwitchContext(THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.span,
      {
        "data-state": getState$5(context2.checked),
        "data-disabled": context2.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME;
var BubbleInput = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize$1(control);
  reactExports.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input2, checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState$5(checked) {
  return checked ? "checked" : "unchecked";
}
var Root$2 = Switch$1;
var Thumb = SwitchThumb;
var root$2 = "_1lp2u8e1 _1lp2u8e0 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr1v0 fyvr1x4 fyvr1z8 fyvr111c fyvr11x9 fyvr11m4 fyvr12zf fyvr12s9 _4efw240";
var thumb = "_1lp2u8e3 _1lp2u8e2 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr11lw fyvr1m0 fyvr1qg fyvr1k fyvr148 fyvr11s9";
const Switch = (props) => {
  const {
    disabled,
    label,
    labelLocation = "left",
    description: description2,
    id: id2,
    name: name2,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field$2,
    {
      disabled,
      display: "flex",
      id: id2 ?? name2,
      label,
      labelLocation,
      description: description2,
      whiteSpace: "nowrap",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root$2,
        {
          className: root$2,
          disabled,
          ...rest,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { position: "relative", width: "full", height: "full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: thumb }) })
        }
      )
    }
  );
};
createRuntimeFn({ defaultClassName: "nwwh3z8", variantClassNames: { variant: { pill: "nwwh3z9", line: "nwwh3za nwwh3z1 fyvr11k8" }, active: { true: "nwwh3zb nwwh3z2 fyvr130d", false: "nwwh3zc" }, disabled: { true: "nwwh3zd nwwh3z3 fyvr12zx" } }, defaultVariants: {}, compoundVariants: [[{ active: true, variant: "pill" }, "nwwh3z4 fyvr11yf fyvr12wr"], [{ active: false, variant: "pill" }, "nwwh3z5 fyvr11sl fyvr12wf"], [{ active: true, variant: "line" }, "nwwh3z6 fyvr12w9"], [{ active: false, variant: "line" }, "nwwh3z7 fyvr12wf"]] });
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope$1(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState$1({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId$1(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$2.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context2 = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$4,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context2.orientation,
        dir: context2.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$2.div,
          {
            role: "tablist",
            "aria-orientation": context2.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$1 = "TabsTrigger";
var TabsTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context2 = useTabsContext(TRIGGER_NAME$1, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context2.baseId, value);
    const contentId = makeContentId(context2.baseId, value);
    const isSelected = value === context2.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive$2.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers$1(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context2.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context2.onValueChange(value);
            }),
            onFocus: composeEventHandlers$1(props.onFocus, () => {
              const isAutomaticActivation = context2.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context2.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$1;
var CONTENT_NAME$1$1 = "TabsContent";
var TabsContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context2 = useTabsContext(CONTENT_NAME$1$1, __scopeTabs);
    const triggerId = makeTriggerId(context2.baseId, value);
    const contentId = makeContentId(context2.baseId, value);
    const isSelected = value === context2.value;
    const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
    reactExports.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context2.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$1$1;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2$1$1 = Tabs$1;
var List = TabsList$1;
var Trigger$1 = TabsTrigger$1;
var list = "_10c8o0n1 _10c8o0n0 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr11l8 fyvr11m4 fyvr12g fyvr11wr fyvr14w";
var trigger = "_10c8o0n3 _10c8o0n2 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr130x fyvr130r fyvr12g fyvr164 fyvr12zf fyvr11m4 fyvr11sl fyvr11rc fyvr12wf";
var selector = "_10c8o0n5 _10c8o0n4 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr11lw fyvr1m0 fyvr1qg fyvr14k fyvr11y3 fyvr130f";
const TabsHeader = (props) => {
  const { tabs, value } = props;
  if (!tabs.length) {
    return null;
  }
  const selectorWidth = 100 / tabs.length;
  const selectedIdx = tabs.findIndex((tab) => tab.value === value);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(List, { className: list, style: { outline: void 0 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { display: "flex", position: "absolute", inset: "2", height: "8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: selector,
        style: {
          width: `${selectorWidth}%`,
          transform: `translateX(${selectedIdx * 100}%)`
        }
      }
    ) }),
    tabs.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trigger$1,
      {
        className: trigger,
        value: tab.value,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "normal", fontWeight: "bold", children: tab.label })
      },
      tab.value
    ))
  ] });
};
const TabsRoot = Root2$1$1;
const TabsContent = TabsContent$1;
var tagStyle = "_1ppqbnx1 _1qxj1ib9 _1qxj1ibg _1qxj1ib6 fyvr11r3 fyvr11ig fyvr11k4 fyvr11k0 fyvr11jk _1ppqbnx0 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr1zc fyvr111g fyvr1v0 fyvr1x4 fyvr11lk fyvr11cc fyvr11rh";
reactExports.forwardRef(
  (props, ref) => {
    const { icon: Icon2, label, ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        className: tagStyle,
        ref,
        background: "buttonGlass",
        color: "text80",
        ...rest,
        children: [
          Icon2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: "xs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: label })
        ]
      }
    );
  }
);
var PROVIDER_NAME$1 = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope$1("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME$1);
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context2 = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref, context2.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context2.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        var _a2;
        const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) (_a2 = ref.current) == null ? void 0 : _a2.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport2 = ref.current;
      if (hasToasts && wrapper && viewport2) {
        const handlePause = () => {
          if (!context2.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport2.dispatchEvent(pauseEvent);
            context2.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context2.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport2.dispatchEvent(resumeEvent);
            context2.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context2.isClosePausedRef]);
    const getSortedTabbableCandidates = reactExports.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates$2(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    reactExports.useEffect(() => {
      const viewport2 = ref.current;
      if (viewport2) {
        const handleKeyDown = (event) => {
          var _a2, _b2, _c2;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport2;
            if (targetIsViewport && isTabbingBackwards) {
              (_a2 = headFocusProxyRef.current) == null ? void 0 : _a2.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst$4(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b2 = headFocusProxyRef.current) == null ? void 0 : _b2.focus() : (_c2 = tailFocusProxyRef.current) == null ? void 0 : _c2.focus();
            }
          }
        };
        viewport2.addEventListener("keydown", handleKeyDown);
        return () => viewport2.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst$4(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst$4(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport$1.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context2 = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden$1,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a2;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a2 = context2.viewport) == null ? void 0 : _a2.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open = true, setOpen] = useControllableState$1({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1$1(props.onPause),
        onResume: useCallbackRef$1$1(props.onResume),
        onSwipeStart: composeEventHandlers$1(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers$1(props.onSwipeMove, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
        }),
        onSwipeCancel: composeEventHandlers$1(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers$1(props.onSwipeEnd, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast$1.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context2 = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs$1(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration = durationProp || context2.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context2;
    const handleClose = useCallbackRef$1$1(() => {
      var _a2;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast) (_a2 = context2.viewport) == null ? void 0 : _a2.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    reactExports.useEffect(() => {
      const viewport2 = context2.viewport;
      if (viewport2) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport2.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport2.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport2.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport2.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context2.viewport, duration, onPause, onResume, startTimer]);
    reactExports.useEffect(() => {
      if (open && !context2.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context2.isClosePausedRef, startTimer]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context2.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$6,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers$1(onEscapeKeyDown, () => {
              if (!context2.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context2.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$2.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context2.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers$1(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context2.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers$1(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers$1(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x2 = event.clientX - pointerStartRef.current.x;
                  const y2 = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context2.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context2.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x2) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y2) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent$2(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context2.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent$2(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x2) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers$1(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context2.swipeDirection, context2.swipeThreshold)) {
                      handleAndDispatchCustomEvent$2(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent$2(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context2.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context2 = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
  const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  reactExports.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden$1, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context2.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME;
var CLOSE_NAME$2 = "ToastClose";
var ToastClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME$2, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers$1(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME$2;
var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$2.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement$2(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent$2(name2, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name2, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent$1(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef$1$1(callback);
  useLayoutEffect2$1(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement$2(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates$2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst$4(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
createRuntimeFn({ defaultClassName: "_6wut8v3", variantClassNames: { variant: { normal: "_6wut8v4", success: "_6wut8v5", error: "_6wut8v6" } }, defaultVariants: {}, compoundVariants: [] });
reactExports.createContext(null);
var textarea = "_15pztn1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _15pztn0 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr11ow fyvr11sl fyvr12w9 fyvr12s9 fyvr130r fyvr12g fyvr11l8";
var resize = "_15pztn2";
reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "textarea",
      autoComplete = "off",
      borderRadius = "md",
      description: description2,
      disabled = false,
      id: id2,
      label = "",
      labelLocation = "hidden",
      name: name2,
      rows,
      resize: resize$1 = false,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$2,
      {
        description: description2,
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            as,
            autoComplete,
            spellCheck: "false",
            className: clsx(textarea, resize$1 && resize),
            disabled,
            id: id2 ?? name2,
            name: name2,
            ref,
            rows,
            borderRadius,
            ...rest
          }
        )
      }
    );
  }
);
var root$1 = createRuntimeFn({ defaultClassName: "_18h918k5 _18h918k0 fyvr11q0 fyvr11qg fyvr11no fyvr11ow fyvr11l8", variantClassNames: { size: { xs: "_18h918k6", sm: "_18h918k7", md: "_18h918k8", lg: "_18h918k9", xl: "_18h918ka" }, borderRadius: { circle: "_18h918kb _18h918k1 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw", lg: "_18h918kc _18h918k2 fyvr11hg fyvr11i4 fyvr11g4 fyvr11gs", md: "_18h918kd _18h918k3 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go", sm: "_18h918ke _18h918k4 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk" } }, defaultVariants: {}, compoundVariants: [] });
var img$1 = "_18h918kf";
const NetworkImage = reactExports.memo((props) => {
  const {
    chainId,
    borderRadius = "circle",
    className,
    disableAnimation = false,
    style,
    src,
    size: size2 = "md",
    ...boxProps
  } = props;
  const logoURI = src || replaceSize(networkImageUrl(chainId), size2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: clsx(className, root$1({ borderRadius, size: size2 })),
      style,
      flexShrink: "0",
      ...boxProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Image$1,
        {
          className: img$1,
          disableAnimation,
          src: logoURI
        }
      )
    }
  );
});
var root$5 = createRuntimeFn({ defaultClassName: "bnrreb1 bnrreb0 fyvr11no fyvr11ow fyvr11m4 fyvr11l8", variantClassNames: { size: { xs: "bnrreb2", sm: "bnrreb3", md: "bnrreb4", lg: "bnrreb5", xl: "bnrreb6" } }, defaultVariants: {}, compoundVariants: [] });
var img = "bnrreb7";
var fallback = "bnrreb9 bnrreb8 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr11q0 fyvr11qg fyvr11no fyvr11ow fyvr11wr fyvr12g fyvr164 fyvr11l8";
var cutout = "bnrreba";
const NETWORK_IMAGE_SIZE = "40%";
const NETWORK_IMAGE_OFFSET = "-2%";
const TokenImage = reactExports.memo((props) => {
  const {
    borderRadius = "circle",
    className,
    disableAnimation = false,
    style,
    src,
    symbol,
    size: size2 = "md",
    withNetwork,
    ...boxProps
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className: clsx(className, root$5({ size: size2 })),
      style,
      flexShrink: "0",
      ...boxProps,
      children: [
        src ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Image$1,
          {
            className: clsx(img, withNetwork && cutout),
            disableAnimation,
            borderRadius,
            overflow: "hidden",
            src
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Text,
          {
            className: clsx(fallback, withNetwork && cutout),
            variant: "normal",
            fontWeight: "medium",
            color: "text50",
            borderRadius,
            overflow: "hidden",
            uppercase: true,
            children: symbol == null ? void 0 : symbol.replace(/\s/, "").slice(0, 4)
          }
        ),
        withNetwork && /* @__PURE__ */ jsxRuntimeExports.jsx(
          NetworkImage,
          {
            chainId: withNetwork,
            position: "absolute",
            zIndex: "1",
            disableAnimation,
            style: {
              width: NETWORK_IMAGE_SIZE,
              height: NETWORK_IMAGE_SIZE,
              right: NETWORK_IMAGE_OFFSET,
              bottom: NETWORK_IMAGE_OFFSET
            }
          }
        )
      ]
    }
  );
});
var [createTooltipContext, createTooltipScope] = createContextScope$1("Tooltip", [
  createPopperScope$1
]);
var usePopperScope$3 = createPopperScope$1();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = reactExports.useState(true);
  const isPointerInTransitRef = reactExports.useRef(false);
  const skipDelayTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: reactExports.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip$1 = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope$3(__scopeTooltip);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const contentId = useId$1();
  const openTimerRef = reactExports.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = reactExports.useRef(false);
  const [open = false, setOpen] = useControllableState$1({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    }
  });
  const stateAttribute = reactExports.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
    }, delayDuration);
  }, [delayDuration, setOpen]);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(openTimerRef.current);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: reactExports.useCallback(() => {
        if (providerContext.isOpenDelayed) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: reactExports.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME$6 = "TooltipTrigger";
var TooltipTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context2 = useTooltipContext(TRIGGER_NAME$6, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME$6, __scopeTooltip);
    const popperScope = usePopperScope$3(__scopeTooltip);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs$1(forwardedRef, ref, context2.onTriggerChange);
    const isPointerDownRef = reactExports.useRef(false);
    const hasPointerMoveOpenedRef = reactExports.useRef(false);
    const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
    reactExports.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor$1, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$2.button,
      {
        "aria-describedby": context2.open ? context2.contentId : void 0,
        "data-state": context2.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers$1(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context2.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers$1(props.onPointerLeave, () => {
          context2.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers$1(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers$1(props.onFocus, () => {
          if (!isPointerDownRef.current) context2.onOpen();
        }),
        onBlur: composeEventHandlers$1(props.onBlur, context2.onClose),
        onClick: composeEventHandlers$1(props.onClick, context2.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME$6;
var PORTAL_NAME$5 = "TooltipPortal";
var [PortalProvider$3, usePortalContext$3] = createTooltipContext(PORTAL_NAME$5, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context2 = useTooltipContext(PORTAL_NAME$5, __scopeTooltip);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$3, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME$5;
var CONTENT_NAME$8 = "TooltipContent";
var TooltipContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$3(CONTENT_NAME$8, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context2 = useTooltipContext(CONTENT_NAME$8, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence$1, { present: forceMount || context2.open, children: context2.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
  const context2 = useTooltipContext(CONTENT_NAME$8, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME$8, props.__scopeTooltip);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs$1(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger: trigger2, onClose } = context2;
  const content2 = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = reactExports.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (trigger2 && content2) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content2);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content2.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content2.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content2, handleCreateGraceArea, handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger2 == null ? void 0 : trigger2.contains(target)) || (content2 == null ? void 0 : content2.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content2, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context2 = useTooltipContext(CONTENT_NAME$8, __scopeTooltip);
    const popperScope = usePopperScope$3(__scopeTooltip);
    const { onClose } = context2;
    reactExports.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    reactExports.useEffect(() => {
      if (context2.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context2.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context2.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer$1,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$2,
          {
            "data-state": context2.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable$1, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, { id: context2.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME$8;
var ARROW_NAME$5 = "TooltipArrow";
var TooltipArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope$3(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME$5,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow$2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME$5;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding2 = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y + padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y + padding2 }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y - padding2 }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y + padding2 }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x - padding2, y: exitPoint.y + padding2 }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x: x2, y: y2 } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi2 = polygon[i].x;
    const yi2 = polygon[i].y;
    const xj2 = polygon[j2].x;
    const yj2 = polygon[j2].y;
    const intersect = yi2 > y2 !== yj2 > y2 && x2 < (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b2) => {
    if (a2.x < b2.x) return -1;
    else if (a2.x > b2.x) return 1;
    else if (a2.y < b2.y) return -1;
    else if (a2.y > b2.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root3 = Tooltip$1;
var Trigger$4 = TooltipTrigger;
var Content2$2 = TooltipContent;
var Arrow2 = TooltipArrow;
var content = "q888p21 q888p20 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr1zk fyvr111o fyvr11r0 fyvr11xx fyvr1xc fyvr1v4";
const Tooltip = (props) => {
  const {
    align = "center",
    children,
    delayDuration = 0,
    disabled = false,
    hOffset = 0,
    message,
    side = "top",
    vOffset = 0
  } = props;
  return disabled ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root3, { delayDuration, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$4, { asChild: true, children }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Content2$2,
      {
        className: content,
        side,
        align,
        sideOffset: vOffset,
        alignOffset: hOffset,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", fontWeight: "medium", color: "text80", children: message }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { offset: 12, width: 10, height: 5 })
        ]
      }
    )
  ] }) });
};
const useMediaQuery = (queryInput, options = {}) => {
  const bp = (/* @__PURE__ */ new Map()).set("isMobile", `@media screen and (max-width: ${breakpoints.lg - 1}px)`).set("isDesktop", `@media screen and (min-width: ${breakpoints.lg}px)`);
  if (!queryInput.startsWith("@media")) {
    const bpQuery = bp.get(queryInput);
    if (!bpQuery || bpQuery === "") {
      throw new Error(
        `useMediaQuery failed to get breakpoint from theme for: ${queryInput}`
      );
    }
    queryInput = bpQuery;
  }
  const query = queryInput.replace(/^@media( ?)/m, "");
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const { defaultMatches = false } = options;
  const [match, setMatch] = reactExports.useState(() => {
    if (supportMatchMedia) {
      return window.matchMedia(query).matches;
    }
    return defaultMatches;
  });
  reactExports.useEffect(() => {
    let active = true;
    if (!supportMatchMedia) {
      return void 0;
    }
    const queryList = window.matchMedia(query);
    const updateMatch = () => {
      if (active) {
        setMatch(queryList.matches);
      }
    };
    updateMatch();
    queryList.addListener(updateMatch);
    return () => {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, supportMatchMedia]);
  return match;
};
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$2() {
  return void 0;
}
function functionalUpdate(updater, input2) {
  return typeof updater === "function" ? updater(input2) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn2 = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn2(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject$2(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialMatchKey(a2[key], b2[key]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (array || isPlainObject$2(a2) && isPlainObject$2(b2)) {
    const aItems = array ? a2 : Object.keys(a2);
    const aSize = aItems.length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      if ((!array && aItems.includes(key) || array) && a2[key] === void 0 && b2[key] === void 0) {
        copy2[key] = void 0;
        equalItems++;
      } else {
        copy2[key] = replaceEqualDeep(a2[key], b2[key]);
        if (copy2[key] === a2[key] && a2[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (!b2 || Object.keys(a2).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key in a2) {
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$2(o2) {
  if (!hasObjectPrototype$1(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype$1(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o2) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype$1(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function sleep$1(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item2, max2 = 0) {
  const newItems = [...items, item2];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item2, max2 = 0) {
  const newItems = [item2, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup, setup);
    (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a2;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();
var OnlineManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup2, setup);
    (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    var _a2;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a2 = config2.abort) == null ? void 0 : _a2.call(config2);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onSuccess) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onError) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a2;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a2 = config2.onPause) == null ? void 0 : _a2.call(config2);
    }).then(() => {
      var _a2;
      continueFn = void 0;
      if (!isResolved) {
        (_a2 = config2.onContinue) == null ? void 0 : _a2.call(config2);
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a2;
      if (isResolved) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry2 = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry2) {
        reject(error);
        return;
      }
      failureCount++;
      (_a2 = config2.onFail) == null ? void 0 : _a2.call(config2, failureCount, error);
      sleep$1(delay2).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return promise;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return promise;
    }
  };
}
function createNotifyManager() {
  let queue2 = [];
  let transactions2 = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb2) => setTimeout(cb2, 0);
  const schedule = (callback) => {
    if (transactions2) {
      queue2.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue2;
    queue2 = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions2++;
      try {
        result = callback();
      } finally {
        transactions2--;
        if (!transactions2) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();
var Removable = (_c = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _c);
var Query = (_d = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _cache, config2.cache);
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, getDefaultState$1(this.options));
    this.state = config2.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a2;
    return (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a2, _b2;
    const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
    return promise ? promise.then(noop$2).catch(noop$2) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  onOnline() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a2, _b2, _c2;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object2) => {
      Object.defineProperty(object2, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context2 = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context2);
    (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(
      context2,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context2.fetchOptions) == null ? void 0 : _b2.meta)) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context2.fetchOptions) == null ? void 0 : _c2.meta });
    }
    const onError = (error) => {
      var _a3, _b3, _c3, _d2;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
          _a3,
          error,
          this
        );
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          this.state.data,
          error,
          this
        );
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context2.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _a3, _b3, _c3, _d2;
        if (data === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data, this);
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          data,
          this.state.error,
          this
        );
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context2.options.retry,
      retryDelay: context2.options.retryDelay,
      networkMode: context2.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _d);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryCache = (_e = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client2, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _e);
var Mutation = (_f = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a2;
    return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n, _o, _p, _q, _r2, _s2, _t;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
          _a2,
          variables,
          this
        ));
        const context2 = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
        if (context2 !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context: context2,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
        _e2,
        data,
        variables,
        this.state.context,
        this
      ));
      await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data, variables, this.state.context));
      await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
        _i2,
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l2 = (_k2 = this.options).onSettled) == null ? void 0 : _l2.call(_k2, data, null, variables, this.state.context));
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_n = (_m2 = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m2,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r2 = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r2.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t = (_s2 = this.options).onSettled) == null ? void 0 : _t.call(
          _s2,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _mutationId);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client2, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client2.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    var _a2;
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = (_a2 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a2.filter((x2) => x2 !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    var _a2;
    const firstPendingMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    var _a2;
    const foundMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
    return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$2))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  var _a2;
  return ((_a2 = mutation.options.scope) == null ? void 0 : _a2.id) ?? String(mutation.mutationId);
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context2, query) => {
      var _a2, _b2, _c2, _d2, _e2;
      const options = context2.options;
      const direction = (_c2 = (_b2 = (_a2 = context2.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
      const oldPages = ((_d2 = context2.state.data) == null ? void 0 : _d2.pages) || [];
      const oldPageParams = ((_e2 = context2.state.data) == null ? void 0 : _e2.pageParams) || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object2) => {
          Object.defineProperty(object2, "signal", {
            enumerable: true,
            get: () => {
              if (context2.signal.aborted) {
                cancelled = true;
              } else {
                context2.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context2.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context2.options, context2.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context2.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context2.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context2.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context2.options.persister) {
        context2.fetchFn = () => {
          var _a3, _b3;
          return (_b3 = (_a3 = context2.options).persister) == null ? void 0 : _b3.call(
            _a3,
            fetchFn,
            {
              queryKey: context2.queryKey,
              meta: context2.options.meta,
              signal: context2.signal
            },
            query
          );
        };
      } else {
        context2.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a2;
  return pages.length > 0 ? (_a2 = options.getPreviousPageParam) == null ? void 0 : _a2.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}
function hasNextPage(options, data) {
  if (!data)
    return false;
  return getNextPageParam(options, data) != null;
}
function hasPreviousPage(options, data) {
  if (!data || !options.getPreviousPageParam)
    return false;
  return getPreviousPageParam(options, data) != null;
}
var QueryClient = (_h = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a2, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    if (cachedData === void 0)
      return this.fetchQuery(options);
    else {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$2).catch(noop$2);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: filters.refetchType ?? filters.type ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    const fetchOptions = {
      ...options,
      cancelRefetch: (options == null ? void 0 : options.cancelRefetch) ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$2);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$2);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$2).catch(noop$2);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$2).catch(noop$2);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults2 = [...__privateGet(this, _queryDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
var QueryObserver = (_i = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client, client2);
    __privateSet(this, _selectError, null);
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult(notifyOptions);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key);
          onPropTracked == null ? void 0 : onPropTracked(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a2;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data = options.select(newState.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          __privateSet(this, _selectResult, data);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    } else {
      data = newState.data;
    }
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a2.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError2 = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError: isError2,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError2 && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError2 && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop$2);
  }
  return promise;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time2 = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time2 + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _i);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
var InfiniteQueryObserver = class extends QueryObserver {
  constructor(client2, options) {
    super(client2, options);
  }
  bindMethods() {
    super.bindMethods();
    this.fetchNextPage = this.fetchNextPage.bind(this);
    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(options, notifyOptions) {
    super.setOptions(
      {
        ...options,
        behavior: infiniteQueryBehavior()
      },
      notifyOptions
    );
  }
  getOptimisticResult(options) {
    options.behavior = infiniteQueryBehavior();
    return super.getOptimisticResult(options);
  }
  fetchNextPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(query, options) {
    var _a2, _b2;
    const { state } = query;
    const parentResult = super.createResult(query, options);
    const { isFetching, isRefetching, isError: isError2, isRefetchError } = parentResult;
    const fetchDirection = (_b2 = (_a2 = state.fetchMeta) == null ? void 0 : _a2.fetchMore) == null ? void 0 : _b2.direction;
    const isFetchNextPageError = isError2 && fetchDirection === "forward";
    const isFetchingNextPage = isFetching && fetchDirection === "forward";
    const isFetchPreviousPageError = isError2 && fetchDirection === "backward";
    const isFetchingPreviousPage = isFetching && fetchDirection === "backward";
    const result = {
      ...parentResult,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hasNextPage(options, state.data),
      hasPreviousPage: hasPreviousPage(options, state.data),
      isFetchNextPageError,
      isFetchingNextPage,
      isFetchPreviousPageError,
      isFetchingPreviousPage,
      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,
      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
    };
    return result;
  }
};
var MutationObserver$1 = (_j = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client2, client2);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a2;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client2).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a2;
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a2;
    __privateSet(this, _mutateOptions, options);
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client2).getMutationCache().build(__privateGet(this, _client2), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client2 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a2;
  const state = ((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state) ?? getDefaultState();
  __privateSet(this, _currentResult2, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context2 = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b2 = (_a2 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b2.call(_a2, action.data, variables, context2);
        (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context2);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f2 = (_e2 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e2, action.error, variables, context2);
        (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
          _g2,
          void 0,
          action.error,
          variables,
          context2
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _j);
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client2 = reactExports.useContext(QueryClientContext);
  if (!client2) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client2;
};
var QueryClientProvider = ({
  client: client2,
  children
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(QueryClientContext.Provider, { value: client2, children });
};
var IsRestoringContext = reactExports.createContext(false);
var useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue());
var useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(throwError2, params) {
  if (typeof throwError2 === "function") {
    return throwError2(...params);
  }
  return !!throwError2;
}
function noop$1() {
}
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);
};
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});
function useBaseQuery(options, Observer, queryClient) {
  var _a2, _b2, _c2, _d2;
  const client2 = useQueryClient();
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client2.defaultQueryOptions(options);
  (_b2 = (_a2 = client2.getDefaultOptions().queries) == null ? void 0 : _a2._experimental_beforeQuery) == null ? void 0 : _b2.call(
    _a2,
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(
    () => new Observer(
      client2,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
        observer.updateResult();
        return unsubscribe;
      },
      [observer, isRestoring]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client2.getQueryCache().get(defaultedOptions.queryHash)
  })) {
    throw result.error;
  }
  (_d2 = (_c2 = client2.getDefaultOptions().queries) == null ? void 0 : _c2._experimental_afterQuery) == null ? void 0 : _d2.call(
    _c2,
    defaultedOptions,
    result
  );
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery$1(options, queryClient) {
  return useBaseQuery(options, QueryObserver);
}
function useMutation(options, queryClient) {
  const client2 = useQueryClient();
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client2,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$1);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
function useInfiniteQuery(options, queryClient) {
  return useBaseQuery(
    options,
    InfiniteQueryObserver
  );
}
const version$9 = "2.21.10";
let errorConfig = {
  getDocsUrl: ({ docsBaseUrl, docsPath: docsPath2 = "", docsSlug }) => docsPath2 ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath2}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
  version: version$9
};
let BaseError$3 = class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    var _a2;
    const details = (() => {
      var _a3;
      if (args.cause instanceof BaseError)
        return args.cause.details;
      if ((_a3 = args.cause) == null ? void 0 : _a3.message)
        return args.cause.message;
      return args.details;
    })();
    const docsPath2 = (() => {
      if (args.cause instanceof BaseError)
        return args.cause.docsPath || args.docsPath;
      return args.docsPath;
    })();
    const docsUrl = (_a2 = errorConfig.getDocsUrl) == null ? void 0 : _a2.call(errorConfig, { ...args, docsPath: docsPath2 });
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsUrl ? [`Docs: ${docsUrl}`] : [],
      ...details ? [`Details: ${details}`] : [],
      ...[`Version: ${errorConfig.version}`]
    ].join("\n");
    super(message, args.cause ? { cause: args.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.name = args.name ?? this.name;
    this.shortMessage = shortMessage;
    this.version = version$9;
  }
  walk(fn) {
    return walk(this, fn);
  }
};
function walk(err, fn) {
  if (fn == null ? void 0 : fn(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn);
  return fn ? null : err;
}
class IntegerOutOfRangeError extends BaseError$3 {
  constructor({ max: max2, min: min2, signed: signed2, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed2 ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min2} to ${max2})` : `(above ${min2})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class InvalidBytesBooleanError extends BaseError$3 {
  constructor(bytes2) {
    super(`Bytes value "${bytes2}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class SizeOverflowError extends BaseError$3 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
  }
}
class SliceOffsetOutOfBoundsError extends BaseError$3 {
  constructor({ offset: offset2, position, size: size2 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset2}" is out-of-bounds (size: ${size2}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class SizeExceedsPaddingSizeError extends BaseError$3 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class InvalidBytesLengthError extends BaseError$3 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`, { name: "InvalidBytesLengthError" });
  }
}
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex2 = hex_.replace("0x", "");
  if (hex2.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex2.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes2;
  if (bytes2.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes2.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0; i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes2[padEnd ? i : bytes2.length - i - 1];
  }
  return paddedBytes;
}
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size$5(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function toBytes$3(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes$2(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { size: opts.size });
  }
  return bytes2;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes$2(hex_, opts = {}) {
  let hex2 = hex_;
  if (opts.size) {
    assertSize(hex2, { size: opts.size });
    hex2 = pad(hex2, { dir: "right", size: opts.size });
  }
  let hexString = hex2.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes2 = new Uint8Array(length);
  for (let index2 = 0, j2 = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError$3(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function numberToBytes(value, opts) {
  const hex2 = numberToHex(value, opts);
  return hexToBytes$2(hex2);
}
function stringToBytes(value, opts = {}) {
  const bytes2 = encoder$1.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}
function assertSize(hexOrBytes, { size: size2 }) {
  if (size$5(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size$5(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex2, opts = {}) {
  const { signed: signed2 } = opts;
  if (opts.size)
    assertSize(hex2, { size: opts.size });
  const value = BigInt(hex2);
  if (!signed2)
    return value;
  const size2 = (hex2.length - 2) / 2;
  const max2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max2)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToNumber$2(hex2, opts = {}) {
  return Number(hexToBigInt(hex2, opts));
}
const hexes$3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v2, i) => i.toString(16).padStart(2, "0"));
function toHex$1(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex$3(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex2 = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad(hex2, { size: opts.size });
  }
  return hex2;
}
function bytesToHex$3(value, opts = {}) {
  let string = "";
  for (let i = 0; i < value.length; i++) {
    string += hexes$3[value[i]];
  }
  const hex2 = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad(hex2, { dir: "right", size: opts.size });
  }
  return hex2;
}
function numberToHex(value_, opts = {}) {
  const { signed: signed2, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue2;
  if (size2) {
    if (signed2)
      maxValue2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue2 = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue2 = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue2 === "bigint" && signed2 ? -maxValue2 - 1n : 0;
  if (maxValue2 && value > maxValue2 || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue2 ? `${maxValue2}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex2 = `0x${(signed2 && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex2, { size: size2 });
  return hex2;
}
const encoder = /* @__PURE__ */ new TextEncoder();
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex$3(value, opts);
}
async function addChain(client2, { chain }) {
  const { id: id2, name: name2, nativeCurrency, rpcUrls, blockExplorers } = chain;
  await client2.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id2),
        chainName: name2,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  }, { dedupe: true, retryCount: 0 });
}
function formatAbiItem$1(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
class AbiConstructorNotFoundError extends BaseError$3 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError$3 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError$3 {
  constructor({ data, params, size: size2 }) {
    super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data} (${size2} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data;
    this.params = params;
    this.size = size2;
  }
}
class AbiDecodingZeroDataError extends BaseError$3 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$3 {
  constructor({ expectedLength, givenLength, type }) {
    super([
      `ABI encoding array length mismatch for type ${type}.`,
      `Expected length: ${expectedLength}`,
      `Given length: ${givenLength}`
    ].join("\n"), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$3 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size$5(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class AbiEncodingLengthMismatchError extends BaseError$3 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"), { name: "AbiEncodingLengthMismatchError" });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError$3 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded error signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiErrorSignatureNotFoundError"
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.signature = signature2;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError$3 {
  constructor({ docsPath: docsPath2 }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: docsPath2,
      name: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError$3 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded event signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError$3 {
  constructor(eventName, { docsPath: docsPath2 } = {}) {
    super([
      `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError$3 {
  constructor(functionName, { docsPath: docsPath2 } = {}) {
    super([
      `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError$3 {
  constructor(functionName, { docsPath: docsPath2 }) {
    super([
      `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError$3 {
  constructor(x2, y2) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${x2.type}\` in \`${formatAbiItem$1(x2.abiItem)}\`, and`,
        `\`${y2.type}\` in \`${formatAbiItem$1(y2.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError$3 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError$3 {
  constructor({ abiItem, data, params, size: size2 }) {
    super([
      `Data size of ${size2} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data} (${size2} bytes)`
      ],
      name: "DecodeLogDataMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
    this.data = data;
    this.params = params;
    this.size = size2;
  }
}
class DecodeLogTopicsMismatch extends BaseError$3 {
  constructor({ abiItem, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem$1(abiItem, { includeName: true })}".`
    ].join("\n"), { name: "DecodeLogTopicsMismatch" });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
  }
}
class InvalidAbiEncodingTypeError extends BaseError$3 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2, name: "InvalidAbiEncodingType" });
  }
}
class InvalidAbiDecodingTypeError extends BaseError$3 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2, name: "InvalidAbiDecodingType" });
  }
}
class InvalidArrayError extends BaseError$3 {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"), {
      name: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError$3 {
  constructor(type) {
    super([
      `"${type}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join("\n"), { name: "InvalidDefinitionTypeError" });
  }
}
function concat$1(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes$4(values);
}
function concatBytes$4(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset2 = 0;
  for (const arr of values) {
    result.set(arr, offset2);
    offset2 += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
class InvalidAddressError extends BaseError$3 {
  constructor({ address }) {
    super(`Address "${address}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class LruMap extends Map {
  constructor(size2) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size2;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
}
function number$1(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`positive integer expected, not ${n2}`);
}
function isBytes$2(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function bytes$2(b2, ...lengths) {
  if (!isBytes$2(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function hash$2(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(h2.outputLen);
  number$1(h2.blockLen);
}
function exists$2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$2(out, instance) {
  bytes$2(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
const U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64$1), l: Number(n2 >> _32n$1 & U32_MASK64$1) };
  return { h: Number(n2 >> _32n$1 & U32_MASK64$1) | 0, l: Number(n2 & U32_MASK64$1) | 0 };
}
function split$2(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l: l2 } = fromBig$1(lst[i], le2);
    [Ah2[i], Al[i]] = [h2, l2];
  }
  return [Ah2, Al];
}
const rotlSH$1 = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
const rotlSL$1 = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
const rotlBH$1 = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
const rotlBL$1 = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
const crypto$3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$1 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView$2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$2 = (word, shift2) => word << 32 - shift2 | word >>> shift2;
const isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
const byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
function utf8ToBytes$4(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$2(data) {
  if (typeof data === "string")
    data = utf8ToBytes$4(data);
  bytes$2(data);
  return data;
}
function concatBytes$3(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a2 = arrays[i];
    bytes$2(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a2 = arrays[i];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
let Hash$2 = class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$3(bytesLength = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues === "function") {
    return crypto$3.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
const SHA3_PI$1 = [];
const SHA3_ROTL$1 = [];
const _SHA3_IOTA$1 = [];
const _0n$9 = /* @__PURE__ */ BigInt(0);
const _1n$b = /* @__PURE__ */ BigInt(1);
const _2n$7 = /* @__PURE__ */ BigInt(2);
const _7n$1 = /* @__PURE__ */ BigInt(7);
const _256n$1 = /* @__PURE__ */ BigInt(256);
const _0x71n$1 = /* @__PURE__ */ BigInt(113);
for (let round2 = 0, R2 = _1n$b, x2 = 1, y2 = 0; round2 < 24; round2++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI$1.push(2 * (5 * y2 + x2));
  SHA3_ROTL$1.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n$9;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n$b ^ (R2 >> _7n$1) * _0x71n$1) % _256n$1;
    if (R2 & _2n$7)
      t2 ^= _1n$b << (_1n$b << /* @__PURE__ */ BigInt(j2)) - _1n$b;
  }
  _SHA3_IOTA$1.push(t2);
}
const [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = /* @__PURE__ */ split$2(_SHA3_IOTA$1, true);
const rotlH$1 = (h2, l2, s2) => s2 > 32 ? rotlBH$1(h2, l2, s2) : rotlSH$1(h2, l2, s2);
const rotlL$1 = (h2, l2, s2) => s2 > 32 ? rotlBL$1(h2, l2, s2) : rotlSL$1(h2, l2, s2);
function keccakP$1(s2, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH$1(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL$1(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x2 + y2] ^= Th2;
        s2[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift2 = SHA3_ROTL$1[t2];
      const Th2 = rotlH$1(curH, curL, shift2);
      const Tl = rotlL$1(curH, curL, shift2);
      const PI = SHA3_PI$1[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th2;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s2[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H$1[round2];
    s2[1] ^= SHA3_IOTA_L$1[round2];
  }
  B2.fill(0);
}
let Keccak$1 = class Keccak extends Hash$2 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number$1(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32$1(this.state);
  }
  keccak() {
    if (!isLE$1)
      byteSwap32(this.state32);
    keccakP$1(this.state32, this.rounds);
    if (!isLE$1)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists$2(this);
    const { blockLen, state } = this;
    data = toBytes$2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists$2(this, false);
    bytes$2(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number$1(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output$2(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
const gen$1 = (suffix, blockLen, outputLen) => wrapConstructor$2(() => new Keccak$1(blockLen, suffix, outputLen));
const keccak_256$1 = /* @__PURE__ */ gen$1(1, 136, 256 / 8);
function keccak256$1(value, to_) {
  const to = to_ || "hex";
  const bytes2 = keccak_256$1(isHex(value, { strict: false }) ? toBytes$3(value) : value);
  if (to === "bytes")
    return bytes2;
  return toHex$1(bytes2);
}
const checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = address_.substring(2).toLowerCase();
  const hash2 = keccak256$1(stringToBytes(hexAddress), "bytes");
  const address = hexAddress.split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function getAddress$1(address, chainId) {
  if (!isAddress$1(address, { strict: false }))
    throw new InvalidAddressError({ address });
  return checksumAddress(address, chainId);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
const isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress$1(address, options) {
  const { strict = true } = options ?? {};
  const cacheKey2 = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey2))
    return isAddressCache.get(cacheKey2);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey2, result);
  return result;
}
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size$5(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size$5(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size$5(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size$5(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed2 = param.type.startsWith("int");
    return encodeNumber(value, { signed: signed2 });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes$1(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size$5(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size$5(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat$1([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress$1(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat$1([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat$1(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes$1(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size$5(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat$1([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  if (typeof value !== "boolean")
    throw new BaseError$3(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed: signed2 }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed: signed2
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size$5(hexValue) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat$1([
      padHex(numberToHex(size$5(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index2 = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index2]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat$1(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
const docsPath$4 = "/docs/contract/encodeDeployData";
function encodeDeployData(parameters) {
  const { abi: abi2, args, bytecode } = parameters;
  if (!args || args.length === 0)
    return bytecode;
  const description2 = abi2.find((x2) => "type" in x2 && x2.type === "constructor");
  if (!description2)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath$4 });
  if (!("inputs" in description2))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath$4 });
  if (!description2.inputs || description2.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath$4 });
  const data = encodeAbiParameters(description2.inputs, args);
  return concatHex([bytecode, data]);
}
function parseAccount(account2) {
  if (typeof account2 === "string")
    return { address: account2, type: "json-rpc" };
  return account2;
}
class AccountNotFoundError extends BaseError$3 {
  constructor({ docsPath: docsPath2 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath: docsPath2,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class AccountTypeNotSupportedError extends BaseError$3 {
  constructor({ docsPath: docsPath2, metaMessages, type }) {
    super(`Account type "${type}" is not supported.`, {
      docsPath: docsPath2,
      metaMessages,
      name: "AccountTypeNotSupportedError"
    });
  }
}
function publicKeyToAddress(publicKey) {
  const address = keccak256$1(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i = links.length - 1; i >= 0; i--) {
            const link2 = links[i];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item2 of res || []) {
      if (item2.status !== "rejected") continue;
      handlePreloadError(item2.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
async function recoverPublicKey({ hash: hash2, signature: signature2 }) {
  const hashHex = isHex(hash2) ? hash2 : toHex$1(hash2);
  const { secp256k1: secp256k12 } = await __vitePreload(async () => {
    const { secp256k1: secp256k13 } = await Promise.resolve().then(() => secp256k1$2);
    return { secp256k1: secp256k13 };
  }, true ? void 0 : void 0, import.meta.url);
  const signature_ = (() => {
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2) {
      const { r: r2, s: s2, v: v3, yParity } = signature2;
      const yParityOrV2 = Number(yParity ?? v3);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r2), hexToBigInt(s2)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature2) ? signature2 : toHex$1(signature2);
    const yParityOrV = hexToNumber$2(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function recoverAddress$1({ hash: hash2, signature: signature2 }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature: signature2 }));
}
class NegativeOffsetError extends BaseError$3 {
  constructor({ offset: offset2 }) {
    super(`Offset \`${offset2}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError$3 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class RecursiveReadLimitExceededError extends BaseError$3 {
  constructor({ count: count2, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count2}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset2) {
    if (offset2 < 0)
      throw new NegativeOffsetError({ offset: offset2 });
    const position = this.position - offset2;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset2) {
    if (offset2 < 0)
      throw new NegativeOffsetError({ offset: offset2 });
    const position = this.position + offset2;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes2) {
    this.assertPosition(this.position + bytes2.length - 1);
    this.bytes.set(bytes2, this.position);
    this.position += bytes2.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size2) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size2 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count2 = this.getReadCount();
    this.positionReadCount.set(this.position, count2 + 1);
    if (count2 > 0)
      this.recursiveReadCount++;
  }
};
function createCursor(bytes2, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes2;
  cursor.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
function toRlp(bytes2, to = "hex") {
  const encodable = getEncodable(bytes2);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === "hex")
    return bytesToHex$3(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes2) {
  if (Array.isArray(bytes2))
    return getEncodableList(bytes2.map((x2) => getEncodable(x2)));
  return getEncodableBytes(bytes2);
}
function getEncodableList(list2) {
  const bodyLength = list2.reduce((acc, x2) => acc + x2.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode2 } of list2) {
        encode2(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes2 = typeof bytesOrHex === "string" ? hexToBytes$2(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes2.length);
  const length = (() => {
    if (bytes2.length === 1 && bytes2[0] < 128)
      return 1;
    if (bytes2.length <= 55)
      return 1 + bytes2.length;
    return 1 + sizeOfBytesLength + bytes2.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes2.length === 1 && bytes2[0] < 128) {
        cursor.pushBytes(bytes2);
      } else if (bytes2.length <= 55) {
        cursor.pushByte(128 + bytes2.length);
        cursor.pushBytes(bytes2);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes2.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes2.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes2.length);
        else
          cursor.pushUint32(bytes2.length);
        cursor.pushBytes(bytes2);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError$3("Length is too large.");
}
function hashAuthorization(parameters) {
  const { chainId, contractAddress, nonce, to } = parameters;
  const hash2 = keccak256$1(concatHex([
    "0x05",
    toRlp([
      numberToHex(chainId),
      contractAddress,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to === "bytes")
    return hexToBytes$2(hash2);
  return hash2;
}
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature: signature2 } = parameters;
  return recoverAddress$1({
    hash: hashAuthorization(authorization),
    signature: signature2 ?? authorization
  });
}
class ChainDoesNotSupportContract extends BaseError$3 {
  constructor({ blockNumber, chain, contract }) {
    super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
          `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
        ] : [
          `- The chain does not have the contract "${contract.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError$3 {
  constructor({ chain, currentChainId }) {
    super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${currentChainId}`,
        `Expected Chain ID: ${chain.id}  ${chain.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
let ChainNotFoundError$1 = class ChainNotFoundError extends BaseError$3 {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join("\n"), {
      name: "ChainNotFoundError"
    });
  }
};
class ClientChainNotConfiguredError extends BaseError$3 {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError$1();
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}
const etherUnits = {
  gwei: 9,
  wei: 18
};
const gweiUnits = {
  ether: -9,
  wei: 9
};
function formatUnits$2(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatGwei(wei, unit = "wei") {
  return formatUnits$2(wei, gweiUnits[unit]);
}
class ExecutionRevertedError extends BaseError$3 {
  constructor({ cause, message } = {}) {
    var _a2;
    const reason = (_a2 = message == null ? void 0 : message.replace("execution reverted: ", "")) == null ? void 0 : _a2.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError$3 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError$3 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError$3 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError$3 {
  constructor({ cause, nonce } = {}) {
    super([
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join("\n"), { cause, name: "NonceTooLowError" });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError$3 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError$3 {
  constructor({ cause } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join("\n"), {
      cause,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class IntrinsicGasTooHighError extends BaseError$3 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError$3 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError$3 {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError$3 {
  constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"), {
      cause,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError$3 {
  constructor({ cause }) {
    super(`An error occurred while executing: ${cause == null ? void 0 : cause.shortMessage}`, {
      cause,
      name: "UnknownNodeError"
    });
  }
}
function formatEther$2(wei, unit = "wei") {
  return formatUnits$2(wei, etherUnits[unit]);
}
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
class FeeConflictError extends BaseError$3 {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join("\n"), { name: "FeeConflictError" });
  }
}
class InvalidSerializableTransactionError extends BaseError$3 {
  constructor({ transaction: transaction2 }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(transaction2),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class TransactionExecutionError extends BaseError$3 {
  constructor(cause, { account: account2, docsPath: docsPath2, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    var _a2;
    const prettyArgs = prettyPrint({
      chain: chain && `${chain == null ? void 0 : chain.name} (id: ${chain == null ? void 0 : chain.id})`,
      from: account2 == null ? void 0 : account2.address,
      to,
      value: typeof value !== "undefined" && `${formatEther$2(value)} ${((_a2 = chain == null ? void 0 : chain.nativeCurrency) == null ? void 0 : _a2.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "TransactionExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
}
class TransactionNotFoundError extends BaseError$3 {
  constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {
    let identifier = "Transaction";
    if (blockTag && index2 !== void 0)
      identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
    if (blockHash && index2 !== void 0)
      identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
    if (blockNumber && index2 !== void 0)
      identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
    if (hash2)
      identifier = `Transaction with hash "${hash2}"`;
    super(`${identifier} could not be found.`, {
      name: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError$3 {
  constructor({ hash: hash2 }) {
    super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`, {
      name: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError$3 {
  constructor({ hash: hash2 }) {
    super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
  }
}
const stringify$3 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return value2;
}, space);
const getContractAddress = (address) => address;
const getUrl = (url) => url;
class HttpRequestError extends BaseError$3 {
  constructor({ body, cause, details, headers, status, url }) {
    super("HTTP request failed.", {
      cause,
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body && `Request body: ${stringify$3(body)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}
class RpcRequestError extends BaseError$3 {
  constructor({ body, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$3(body)}`],
      name: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
  }
}
let TimeoutError$2 = class TimeoutError extends BaseError$3 {
  constructor({ body, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$3(body)}`],
      name: "TimeoutError"
    });
  }
};
const unknownErrorCode = -1;
class RpcError extends BaseError$3 {
  constructor(cause, { code: code2, docsPath: docsPath2, metaMessages, name: name2, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: metaMessages || (cause == null ? void 0 : cause.metaMessages),
      name: name2 || "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name2 || cause.name;
    this.code = cause instanceof RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${method ? ` "${method}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err instanceof BaseError$3 ? err.walk((e2) => e2.code === ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof BaseError$3)
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args == null ? void 0 : args.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args == null ? void 0 : args.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args == null ? void 0 : args.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args == null ? void 0 : args.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args == null ? void 0 : args.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args == null ? void 0 : args.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args == null ? void 0 : args.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args == null ? void 0 : args.maxFeePerGas,
      maxPriorityFeePerGas: args == null ? void 0 : args.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
function getTransactionError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
function extract(value_, { format: format2 }) {
  if (!format2)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key of keys) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format2(value_ || {});
  extract_(formatted);
  return value;
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.authorizationList !== "undefined")
    rpcRequest.authorizationList = formatAuthorizationList$1(request.authorizationList);
  if (typeof request.accessList !== "undefined")
    rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== "undefined")
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined") {
    if (typeof request.blobs[0] !== "string")
      rpcRequest.blobs = request.blobs.map((x2) => bytesToHex$3(x2));
    else
      rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== "undefined")
    rpcRequest.data = request.data;
  if (typeof request.from !== "undefined")
    rpcRequest.from = request.from;
  if (typeof request.gas !== "undefined")
    rpcRequest.gas = numberToHex(request.gas);
  if (typeof request.gasPrice !== "undefined")
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request.nonce);
  if (typeof request.to !== "undefined")
    rpcRequest.to = request.to;
  if (typeof request.type !== "undefined")
    rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== "undefined")
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
function formatAuthorizationList$1(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.contractAddress,
    r: authorization.r,
    s: authorization.s,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    ...typeof authorization.yParity !== "undefined" ? { yParity: numberToHex(authorization.yParity) } : {},
    ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: numberToHex(authorization.v) } : {}
  }));
}
function getAction$1(client2, actionFn, name2) {
  const action_implicit = client2[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client2[name2];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client2, params);
}
const maxUint256 = 2n ** 256n - 1n;
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account2 = account_ ? parseAccount(account_) : void 0;
  if (account2 && !isAddress$1(account2.address))
    throw new InvalidAddressError({ address: account2.address });
  if (to && !isAddress$1(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
async function getChainId$2(client2) {
  const chainIdHex = await client2.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber$2(chainIdHex);
}
class BaseFeeScalarError extends BaseError$3 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError$3 {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError$3 {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class BlockNotFoundError extends BaseError$3 {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction2) {
  const transaction_ = {
    ...transaction2,
    blockHash: transaction2.blockHash ? transaction2.blockHash : null,
    blockNumber: transaction2.blockNumber ? BigInt(transaction2.blockNumber) : null,
    chainId: transaction2.chainId ? hexToNumber$2(transaction2.chainId) : void 0,
    gas: transaction2.gas ? BigInt(transaction2.gas) : void 0,
    gasPrice: transaction2.gasPrice ? BigInt(transaction2.gasPrice) : void 0,
    maxFeePerBlobGas: transaction2.maxFeePerBlobGas ? BigInt(transaction2.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction2.maxFeePerGas ? BigInt(transaction2.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction2.maxPriorityFeePerGas ? BigInt(transaction2.maxPriorityFeePerGas) : void 0,
    nonce: transaction2.nonce ? hexToNumber$2(transaction2.nonce) : void 0,
    to: transaction2.to ? transaction2.to : null,
    transactionIndex: transaction2.transactionIndex ? Number(transaction2.transactionIndex) : null,
    type: transaction2.type ? transactionType[transaction2.type] : void 0,
    typeHex: transaction2.type ? transaction2.type : void 0,
    value: transaction2.value ? BigInt(transaction2.value) : void 0,
    v: transaction2.v ? BigInt(transaction2.v) : void 0
  };
  if (transaction2.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction2.authorizationList);
  transaction_.yParity = (() => {
    if (transaction2.yParity)
      return Number(transaction2.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    r: authorization.r,
    s: authorization.s,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    ...typeof authorization.yParity !== "undefined" ? { yParity: Number(authorization.yParity) } : {},
    ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: Number(authorization.v) } : {}
  }));
}
function formatBlock$1(block) {
  var _a2;
  const transactions2 = (_a2 = block.transactions) == null ? void 0 : _a2.map((transaction2) => {
    if (typeof transaction2 === "string")
      return transaction2;
    return formatTransaction(transaction2);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions: transactions2,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
async function getBlock(client2, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  var _a2, _b2, _c2;
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client2.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true });
  } else {
    block = await client2.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.block) == null ? void 0 : _c2.format) || formatBlock$1;
  return format2(block);
}
async function getGasPrice(client2) {
  const gasPrice = await client2.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}
async function estimateMaxPriorityFeePerGas(client2, args) {
  return internal_estimateMaxPriorityFeePerGas(client2, args);
}
async function internal_estimateMaxPriorityFeePerGas(client2, args) {
  var _a2, _b2;
  const { block: block_, chain = client2.chain, request } = args || {};
  try {
    const maxPriorityFeePerGas = ((_a2 = chain == null ? void 0 : chain.fees) == null ? void 0 : _a2.maxPriorityFeePerGas) ?? ((_b2 = chain == null ? void 0 : chain.fees) == null ? void 0 : _b2.defaultPriorityFee);
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction$1(client2, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client: client2,
        request
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error();
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== "undefined")
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client2.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction$1(client2, getBlock, "getBlock")({}),
      getAction$1(client2, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}
async function estimateFeesPerGas(client2, args) {
  return internal_estimateFeesPerGas(client2, args);
}
async function internal_estimateFeesPerGas(client2, args) {
  var _a2, _b2;
  const { block: block_, chain = client2.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    var _a3, _b3;
    if (typeof ((_a3 = chain == null ? void 0 : chain.fees) == null ? void 0 : _a3.baseFeeMultiplier) === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client: client2,
        request
      });
    return ((_b3 = chain == null ? void 0 : chain.fees) == null ? void 0 : _b3.baseFeeMultiplier) ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = ((_a2 = baseFeeMultiplier.toString().split(".")[1]) == null ? void 0 : _a2.length) ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction$1(client2, getBlock, "getBlock")({});
  if (typeof ((_b2 = chain == null ? void 0 : chain.fees) == null ? void 0 : _b2.estimateFeesPerGas) === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client: client2,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof (request == null ? void 0 : request.maxPriorityFeePerGas) === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client2, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = (request == null ? void 0 : request.maxFeePerGas) ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = (request == null ? void 0 : request.gasPrice) ?? multiply(await getAction$1(client2, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}
class EstimateGasExecutionError extends BaseError$3 {
  constructor(cause, { account: account2, docsPath: docsPath2, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    var _a2;
    const prettyArgs = prettyPrint({
      from: account2 == null ? void 0 : account2.address,
      to,
      value: typeof value !== "undefined" && `${formatEther$2(value)} ${((_a2 = chain == null ? void 0 : chain.nativeCurrency) == null ? void 0 : _a2.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
}
function getEstimateGasError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
class AccountStateConflictError extends BaseError$3 {
  constructor({ address }) {
    super(`State for account "${address}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class StateAssignmentConflictError extends BaseError$3 {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}
`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state }) => {
    let val = `${pretty}    ${address}:
`;
    if (state.nonce)
      val += `      nonce: ${state.nonce}
`;
    if (state.balance)
      val += `      balance: ${state.balance}
`;
    if (state.code)
      val += `      code: ${state.code}
`;
    if (state.state) {
      val += "      state:\n";
      val += prettyStateMapping(state.state);
    }
    if (state.stateDiff) {
      val += "      stateDiff:\n";
      val += prettyStateMapping(state.stateDiff);
    }
    return val;
  }, "  State Override:\n").slice(0, -1);
}
function serializeStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0)
    return void 0;
  return stateMapping.reduce((acc, { slot, value }) => {
    if (slot.length !== 66)
      throw new InvalidBytesLengthError({
        size: slot.length,
        targetSize: 66,
        type: "hex"
      });
    if (value.length !== 66)
      throw new InvalidBytesLengthError({
        size: value.length,
        targetSize: 66,
        type: "hex"
      });
    acc[slot] = value;
    return acc;
  }, {});
}
function serializeAccountStateOverride(parameters) {
  const { balance, nonce, state, stateDiff, code: code2 } = parameters;
  const rpcAccountStateOverride = {};
  if (code2 !== void 0)
    rpcAccountStateOverride.code = code2;
  if (balance !== void 0)
    rpcAccountStateOverride.balance = numberToHex(balance);
  if (nonce !== void 0)
    rpcAccountStateOverride.nonce = numberToHex(nonce);
  if (state !== void 0)
    rpcAccountStateOverride.state = serializeStateMapping(state);
  if (stateDiff !== void 0) {
    if (rpcAccountStateOverride.state)
      throw new StateAssignmentConflictError();
    rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
  if (!parameters)
    return void 0;
  const rpcStateOverride = {};
  for (const { address, ...accountState } of parameters) {
    if (!isAddress$1(address, { strict: false }))
      throw new InvalidAddressError({ address });
    if (rpcStateOverride[address])
      throw new AccountStateConflictError({ address });
    rpcStateOverride[address] = serializeAccountStateOverride(accountState);
  }
  return rpcStateOverride;
}
async function getBalance(client2, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client2.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}
async function estimateGas(client2, args) {
  var _a2, _b2, _c2;
  const account_ = args.account ?? client2.account;
  const account2 = account_ ? parseAccount(account_) : void 0;
  try {
    let estimateGas_rpc = function(parameters) {
      const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client2.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [request2, block2 ?? "latest", rpcStateOverride2] : block2 ? [request2, block2] : [request2]
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client2, {
      ...args,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (account2 == null ? void 0 : account2.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    });
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError$3("`to` is required. Could not infer from `authorizationList`");
        });
      return void 0;
    })();
    assertRequest(args);
    const chainFormat = (_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.transactionRequest) == null ? void 0 : _c2.format;
    const format2 = chainFormat || formatTransactionRequest;
    const request = format2({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account2 == null ? void 0 : account2.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
    if (authorizationList) {
      const value2 = await getBalance(client2, { address: request.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { contractAddress } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: void 0,
            data,
            from: account2 == null ? void 0 : account2.address,
            to: contractAddress,
            value: numberToHex(value2)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account: account2,
      chain: client2.chain
    });
  }
}
async function getTransactionCount(client2, { address, blockTag = "latest", blockNumber }) {
  const count2 = await client2.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber$2(count2);
}
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x2) => hexToBytes$2(x2)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x2) => bytesToHex$3(x2));
}
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x2) => hexToBytes$2(x2)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x2) => hexToBytes$2(x2)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x2) => bytesToHex$3(x2));
}
function setBigUint64$2(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi$2 = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj$2 = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
let HashMD$1 = class HashMD extends Hash$2 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$2(this.buffer);
  }
  update(data) {
    exists$2(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes$2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$2(this);
    output$2(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64$2(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};
const SHA256_K$2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$2 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$2 = class SHA256 extends HashMD$1 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV$1[0] | 0;
    this.B = SHA256_IV$1[1] | 0;
    this.C = SHA256_IV$1[2] | 0;
    this.D = SHA256_IV$1[3] | 0;
    this.E = SHA256_IV$1[4] | 0;
    this.F = SHA256_IV$1[5] | 0;
    this.G = SHA256_IV$1[6] | 0;
    this.H = SHA256_IV$1[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W$2[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$2[i - 15];
      const W2 = SHA256_W$2[i - 2];
      const s0 = rotr$2(W15, 7) ^ rotr$2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$2(W2, 17) ^ rotr$2(W2, 19) ^ W2 >>> 10;
      SHA256_W$2[i] = s1 + SHA256_W$2[i - 7] + s0 + SHA256_W$2[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$2(E2, 6) ^ rotr$2(E2, 11) ^ rotr$2(E2, 25);
      const T12 = H2 + sigma1 + Chi$2(E2, F2, G2) + SHA256_K$2[i] + SHA256_W$2[i] | 0;
      const sigma0 = rotr$2(A2, 2) ^ rotr$2(A2, 13) ^ rotr$2(A2, 22);
      const T22 = sigma0 + Maj$2(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T12 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$4 = /* @__PURE__ */ wrapConstructor$2(() => new SHA256$2());
function sha256$3(value, to_) {
  const bytes2 = sha256$4(isHex(value, { strict: false }) ? toBytes$3(value) : value);
  return bytes2;
}
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version2 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha256$3(commitment);
  versionedHash.set([version2], 0);
  return to === "bytes" ? versionedHash : bytesToHex$3(versionedHash);
}
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version2 } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version2
    }));
  }
  return hashes;
}
const blobsPerTransaction = 6;
const bytesPerFieldElement = 32;
const fieldElementsPerBlob = 4096;
const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;
class BlobSizeTooLargeError extends BaseError$3 {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class EmptyBlobError extends BaseError$3 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes$2(parameters.data) : parameters.data;
  const size_ = size$5(data);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes2 = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes2);
      if (bytes2.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === "bytes" ? blobs.map((x2) => x2.bytes) : blobs.map((x2) => bytesToHex$3(x2.bytes));
}
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}
function getTransactionType(transaction2) {
  if (transaction2.type)
    return transaction2.type;
  if (typeof transaction2.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction2.blobs !== "undefined" || typeof transaction2.blobVersionedHashes !== "undefined" || typeof transaction2.maxFeePerBlobGas !== "undefined" || typeof transaction2.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction2.maxFeePerGas !== "undefined" || typeof transaction2.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction2.gasPrice !== "undefined") {
    if (typeof transaction2.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction: transaction2 });
}
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(client2, args) {
  const { account: account_ = client2.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type } = args;
  const account2 = account_ ? parseAccount(account_) : void 0;
  const request = { ...args, ...account2 ? { from: account2 == null ? void 0 : account2.address } : {} };
  let block;
  async function getBlock$1() {
    if (block)
      return block;
    block = await getAction$1(client2, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain)
      return chain.id;
    if (typeof args.chainId !== "undefined")
      return args.chainId;
    const chainId_ = await getAction$1(client2, getChainId$2, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request.chainId = await getChainId2();
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account2) {
    if (nonceManager) {
      const chainId2 = await getChainId2();
      request.nonce = await nonceManager.consume({
        address: account2.address,
        chainId: chainId2,
        client: client2
      });
    } else {
      request.nonce = await getAction$1(client2, getTransactionCount, "getTransactionCount")({
        address: account2.address,
        blockTag: "pending"
      });
    }
  }
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      const block2 = await getBlock$1();
      request.type = typeof (block2 == null ? void 0 : block2.baseFeePerGas) === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock$1();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client2, {
          block: block2,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError();
      const block2 = await getBlock$1();
      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client2, {
        block: block2,
        chain,
        request,
        type: "legacy"
      });
      request.gasPrice = gasPrice_;
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction$1(client2, estimateGas, "estimateGas")({
      ...request,
      account: account2 ? { address: account2.address, type: "json-rpc" } : void 0
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}
async function sendRawTransaction(client2, { serializedTransaction }) {
  return client2.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}
async function sendTransaction$1(client2, parameters) {
  var _a2, _b2, _c2, _d2;
  const { account: account_ = client2.account, chain = client2.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, ...rest } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account2 = parseAccount(account_);
  try {
    assertRequest(parameters);
    const to = await (async () => {
      if (parameters.to)
        return parameters.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError$3("`to` is required. Could not infer from `authorizationList`.");
        });
      return void 0;
    })();
    if (account2.type === "json-rpc") {
      let chainId;
      if (chain !== null) {
        chainId = await getAction$1(client2, getChainId$2, "getChainId")({});
        assertCurrentChain({
          currentChainId: chainId,
          chain
        });
      }
      const chainFormat = (_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.transactionRequest) == null ? void 0 : _c2.format;
      const format2 = chainFormat || formatTransactionRequest;
      const request = format2({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data,
        from: account2.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      return await client2.request({
        method: "eth_sendTransaction",
        params: [request]
      }, { retryCount: 0 });
    }
    if (account2.type === "local") {
      const request = await getAction$1(client2, prepareTransactionRequest, "prepareTransactionRequest")({
        account: account2,
        accessList,
        authorizationList,
        blobs,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account2.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        value,
        ...rest,
        to
      });
      const serializer = (_d2 = chain == null ? void 0 : chain.serializers) == null ? void 0 : _d2.transaction;
      const serializedTransaction = await account2.signTransaction(request, {
        serializer
      });
      return await getAction$1(client2, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    if (account2.type === "smart")
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          "Consider using the `sendUserOperation` Action instead."
        ],
        docsPath: "/docs/actions/bundler/sendUserOperation",
        type: "smart"
      });
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: account2.type
    });
  } catch (err) {
    if (err instanceof AccountTypeNotSupportedError)
      throw err;
    throw getTransactionError(err, {
      ...parameters,
      account: account2,
      chain: parameters.chain || void 0
    });
  }
}
function deployContract(walletClient, parameters) {
  const { abi: abi2, args, bytecode, ...request } = parameters;
  const calldata = encodeDeployData({ abi: abi2, args, bytecode });
  return sendTransaction$1(walletClient, {
    ...request,
    data: calldata
  });
}
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
];
const universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
];
const universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
];
const textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
];
const addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
];
const universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        name: "_signer",
        type: "address"
      },
      {
        name: "_hash",
        type: "bytes32"
      },
      {
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
function bytesToBigInt(bytes2, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes2, { size: opts.size });
  const hex2 = bytesToHex$3(bytes2, opts);
  return hexToBigInt(hex2, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes2 = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes2, { size: opts.size });
    bytes2 = trim(bytes2);
  }
  if (bytes2.length > 1 || bytes2[0] > 1)
    throw new InvalidBytesBooleanError(bytes2);
  return Boolean(bytes2[0]);
}
function bytesToNumber(bytes2, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes2, { size: opts.size });
  const hex2 = bytesToHex$3(bytes2, opts);
  return hexToNumber$2(hex2, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes2 = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes2, { size: opts.size });
    bytes2 = trim(bytes2, { dir: "right" });
  }
  return new TextDecoder().decode(bytes2);
}
function decodeAbiParameters(params, data) {
  const bytes2 = typeof data === "string" ? hexToBytes$2(data) : data;
  const cursor = createCursor(bytes2);
  if (size$5(bytes2) === 0 && params.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$5(data) && size$5(data) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof data === "string" ? data : bytesToHex$3(data),
      params,
      size: size$5(data)
    });
  let consumed = 0;
  const values = [];
  for (let i = 0; i < params.length; ++i) {
    const param = params[i];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, param, {
      staticPosition: 0
    });
    consumed += consumed_;
    values.push(data2);
  }
  return values;
}
function decodeParameter(cursor, param, { staticPosition }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(cursor, { ...param, type }, { length, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, { staticPosition });
  if (param.type === "address")
    return decodeAddress(cursor);
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const sizeOfLength = 32;
const sizeOfOffset = 32;
function decodeAddress(cursor) {
  const value = cursor.readBytes(32);
  return [checksumAddress(bytesToHex$3(sliceBytes(value, -20))), 32];
}
function decodeArray(cursor, param, { length, staticPosition }) {
  if (!length) {
    const offset2 = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset2;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value2 = [];
    for (let i = 0; i < length2; ++i) {
      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(param)) {
    const offset2 = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset2;
    const value2 = [];
    for (let i = 0; i < length; ++i) {
      cursor.setPosition(start + i * 32);
      const [data] = decodeParameter(cursor, param, {
        staticPosition: start
      });
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let i = 0; i < length; ++i) {
    const [data, consumed_] = decodeParameter(cursor, param, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data);
  }
  return [value, consumed];
}
function decodeBool(cursor) {
  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
  const [_, size2] = param.type.split("bytes");
  if (!size2) {
    const offset2 = bytesToNumber(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset2);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [bytesToHex$3(data), 32];
  }
  const value = bytesToHex$3(cursor.readBytes(Number.parseInt(size2), 32));
  return [value, 32];
}
function decodeNumber(cursor, param) {
  const signed2 = param.type.startsWith("int");
  const size2 = Number.parseInt(param.type.split("int")[1] || "256");
  const value = cursor.readBytes(32);
  return [
    size2 > 48 ? bytesToBigInt(value, { signed: signed2 }) : bytesToNumber(value, { signed: signed2 }),
    32
  ];
}
function decodeTuple(cursor, param, { staticPosition }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name: name2 }) => !name2);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset2 = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset2;
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition: start
      });
      consumed += consumed_;
      value[hasUnnamedChild ? i : component == null ? void 0 : component.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let i = 0; i < param.components.length; ++i) {
    const component = param.components[i];
    const [data, consumed_] = decodeParameter(cursor, component, {
      staticPosition
    });
    value[hasUnnamedChild ? i : component == null ? void 0 : component.name] = data;
    consumed += consumed_;
  }
  return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset2 = bytesToNumber(cursor.readBytes(32));
  const start = staticPosition + offset2;
  cursor.setPosition(start);
  const length = bytesToNumber(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value = bytesToString(trim(data));
  cursor.setPosition(staticPosition + 32);
  return [value, 32];
}
function hasDynamicChild(param) {
  var _a2;
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return (_a2 = param.components) == null ? void 0 : _a2.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
const hash$1 = (value) => keccak256$1(toBytes$3(value));
function hashSignature(sig) {
  return hash$1(sig);
}
const version$8 = "1.0.5";
let BaseError$2 = class BaseError2 extends Error {
  constructor(shortMessage, args = {}) {
    var _a2;
    const details = args.cause instanceof BaseError2 ? args.cause.details : ((_a2 = args.cause) == null ? void 0 : _a2.message) ? args.cause.message : args.details;
    const docsPath2 = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath2 ? [`Docs: https://abitype.dev${docsPath2}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: abitype@${version$8}`
    ].join("\n");
    super(message);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiTypeError"
    });
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
};
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match == null ? void 0 : match.groups;
}
const bytesRegex$1 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex$1 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const isTupleRegex = /^\(.+?\).*?$/;
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let i = 0; i < length; i++) {
      const component = abiParameter.components[i];
      type += formatAbiParameter(component);
      if (i < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${(result == null ? void 0 : result.array) ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0; i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature2) {
  return errorSignatureRegex.test(signature2);
}
function execErrorSignature(signature2) {
  return execTyped(errorSignatureRegex, signature2);
}
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature2) {
  return eventSignatureRegex.test(signature2);
}
function execEventSignature(signature2) {
  return execTyped(eventSignatureRegex, signature2);
}
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature2) {
  return functionSignatureRegex.test(signature2);
}
function execFunctionSignature(signature2) {
  return execTyped(functionSignatureRegex, signature2);
}
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature2) {
  return structSignatureRegex.test(signature2);
}
function execStructSignature(signature2) {
  return execTyped(structSignatureRegex, signature2);
}
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature2) {
  return constructorSignatureRegex.test(signature2);
}
function execConstructorSignature(signature2) {
  return execTyped(constructorSignatureRegex, signature2);
}
const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(signature2) {
  return fallbackSignatureRegex.test(signature2);
}
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature2) {
  return receiveSignatureRegex.test(signature2);
}
const eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
const functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class UnknownTypeError extends BaseError$2 {
  constructor({ type }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownTypeError"
    });
  }
}
class UnknownSolidityTypeError extends BaseError$2 {
  constructor({ type }) {
    super("Unknown type.", {
      metaMessages: [`Type "${type}" is not a valid ABI type.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSolidityTypeError"
    });
  }
}
class InvalidParameterError extends BaseError$2 {
  constructor({ param }) {
    super("Invalid ABI parameter.", {
      details: param
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParameterError"
    });
  }
}
class SolidityProtectedKeywordError extends BaseError$2 {
  constructor({ param, name: name2 }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `"${name2}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class InvalidModifierError extends BaseError$2 {
  constructor({ param, type, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidModifierError"
    });
  }
}
class InvalidFunctionModifierError extends BaseError$2 {
  constructor({ param, type, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidFunctionModifierError"
    });
  }
}
class InvalidAbiTypeParameterError extends BaseError$2 {
  constructor({ abiParameter }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(abiParameter, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class InvalidSignatureError extends BaseError$2 {
  constructor({ signature: signature2, type }) {
    super(`Invalid ${type} signature.`, {
      details: signature2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSignatureError"
    });
  }
}
class UnknownSignatureError extends BaseError$2 {
  constructor({ signature: signature2 }) {
    super("Unknown signature.", {
      details: signature2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSignatureError"
    });
  }
}
class InvalidStructSignatureError extends BaseError$2 {
  constructor({ signature: signature2 }) {
    super("Invalid struct signature.", {
      details: signature2,
      metaMessages: ["No properties exist."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidStructSignatureError"
    });
  }
}
class CircularReferenceError extends BaseError$2 {
  constructor({ type }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${type}" is a circular reference.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CircularReferenceError"
    });
  }
}
class InvalidParenthesisError extends BaseError$2 {
  constructor({ current, depth }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${depth}"`
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParenthesisError"
    });
  }
}
function getParameterCacheKey(param, type) {
  if (type)
    return `${type}:${param}`;
  return param;
}
const parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: true }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: true }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ]
]);
function parseSignature(signature2, structs = {}) {
  if (isFunctionSignature(signature2)) {
    const match = execFunctionSignature(signature2);
    if (!match)
      throw new InvalidSignatureError({ signature: signature2, type: "function" });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for (let i = 0; i < inputLength; i++) {
      inputs.push(parseAbiParameter(inputParams[i], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
    const outputs = [];
    if (match.returns) {
      const outputParams = splitParameters(match.returns);
      const outputLength = outputParams.length;
      for (let i = 0; i < outputLength; i++) {
        outputs.push(parseAbiParameter(outputParams[i], {
          modifiers: functionModifiers,
          structs,
          type: "function"
        }));
      }
    }
    return {
      name: match.name,
      type: "function",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs,
      outputs
    };
  }
  if (isEventSignature(signature2)) {
    const match = execEventSignature(signature2);
    if (!match)
      throw new InvalidSignatureError({ signature: signature2, type: "event" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++) {
      abiParameters.push(parseAbiParameter(params[i], {
        modifiers: eventModifiers,
        structs,
        type: "event"
      }));
    }
    return { name: match.name, type: "event", inputs: abiParameters };
  }
  if (isErrorSignature(signature2)) {
    const match = execErrorSignature(signature2);
    if (!match)
      throw new InvalidSignatureError({ signature: signature2, type: "error" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++) {
      abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
    }
    return { name: match.name, type: "error", inputs: abiParameters };
  }
  if (isConstructorSignature(signature2)) {
    const match = execConstructorSignature(signature2);
    if (!match)
      throw new InvalidSignatureError({ signature: signature2, type: "constructor" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++) {
      abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
    }
    return {
      type: "constructor",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs: abiParameters
    };
  }
  if (isFallbackSignature(signature2))
    return { type: "fallback" };
  if (isReceiveSignature(signature2))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature: signature2 });
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
  var _a2, _b2;
  const parameterCacheKey = getParameterCacheKey(param, options == null ? void 0 : options.type);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
  if (!match)
    throw new InvalidParameterError({ param });
  if (match.name && isSolidityKeyword(match.name))
    throw new SolidityProtectedKeywordError({ param, name: match.name });
  const name2 = match.name ? { name: match.name } : {};
  const indexed = match.modifier === "indexed" ? { indexed: true } : {};
  const structs = (options == null ? void 0 : options.structs) ?? {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const params = splitParameters(match.type);
    const components_ = [];
    const length = params.length;
    for (let i = 0; i < length; i++) {
      components_.push(parseAbiParameter(params[i], { structs }));
    }
    components = { components: components_ };
  } else if (match.type in structs) {
    type = "tuple";
    components = { components: structs[match.type] };
  } else if (dynamicIntegerRegex.test(match.type)) {
    type = `${match.type}256`;
  } else {
    type = match.type;
    if (!((options == null ? void 0 : options.type) === "struct") && !isSolidityType(type))
      throw new UnknownSolidityTypeError({ type });
  }
  if (match.modifier) {
    if (!((_b2 = (_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.has) == null ? void 0 : _b2.call(_a2, match.modifier)))
      throw new InvalidModifierError({
        param,
        type: options == null ? void 0 : options.type,
        modifier: match.modifier
      });
    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
      throw new InvalidFunctionModifierError({
        param,
        type: options == null ? void 0 : options.type,
        modifier: match.modifier
      });
  }
  const abiParameter = {
    type: `${type}${match.array ?? ""}`,
    ...name2,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(params, result = [], current = "", depth = 0) {
  const length = params.trim().length;
  for (let i = 0; i < length; i++) {
    const char = params[i];
    const tail = params.slice(i + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char}`, depth);
    }
  }
  if (current === "")
    return result;
  if (depth !== 0)
    throw new InvalidParenthesisError({ current, depth });
  result.push(current.trim());
  return result;
}
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex$1.test(type) || integerRegex$1.test(type);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name2) {
  return name2 === "address" || name2 === "bool" || name2 === "function" || name2 === "string" || name2 === "tuple" || bytesRegex$1.test(name2) || integerRegex$1.test(name2) || protectedKeywordsRegex.test(name2);
}
function isValidDataLocation(type, isArray2) {
  return isArray2 || type === "bytes" || type === "string" || type === "tuple";
}
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i = 0; i < signaturesLength; i++) {
    const signature2 = signatures[i];
    if (!isStructSignature(signature2))
      continue;
    const match = execStructSignature(signature2);
    if (!match)
      throw new InvalidSignatureError({ signature: signature2, type: "struct" });
    const properties = match.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k2 = 0; k2 < propertiesLength; k2++) {
      const property = properties[k2];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new InvalidStructSignatureError({ signature: signature2 });
    shallowStructs[match.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i = 0; i < entriesLength; i++) {
    const [name2, parameters] = entries[i];
    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
  const components = [];
  const length = abiParameters.length;
  for (let i = 0; i < length; i++) {
    const abiParameter = abiParameters[i];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
      if (!(match == null ? void 0 : match.type))
        throw new InvalidAbiTypeParameterError({ abiParameter });
      const { array, type } = match;
      if (type in structs) {
        if (ancestors.has(type))
          throw new CircularReferenceError({ type });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
        });
      } else {
        if (isSolidityType(type))
          components.push(abiParameter);
        else
          throw new UnknownTypeError({ type });
      }
    }
  }
  return components;
}
function parseAbi(signatures) {
  const structs = parseStructs(signatures);
  const abi2 = [];
  const length = signatures.length;
  for (let i = 0; i < length; i++) {
    const signature2 = signatures[i];
    if (isStructSignature(signature2))
      continue;
    abi2.push(parseSignature(signature2, structs));
  }
  return abi2;
}
function normalizeSignature(signature2) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0; i < signature2.length; i++) {
    const char = signature2[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature2[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError$3("Unable to normalize signature.");
  return result;
}
const toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem(def);
  })();
  return normalizeSignature(def_);
};
function toSignatureHash(fn) {
  return hashSignature(toSignature(fn));
}
const toEventSelector = toSignatureHash;
const toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
function getAbiItem(parameters) {
  const { abi: abi2, args = [], name: name2 } = parameters;
  const isSelector = isHex(name2, { strict: false });
  const abiItems = abi2.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name2;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name2;
      return false;
    }
    return "name" in abiItem && abiItem.name === name2;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = void 0;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress$1(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgOfType(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x2) => isArgOfType(x2, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return isAddress$1(args[parameterIndex], { strict: false });
      if (types2.includes("address") && types2.includes("bytes"))
        return isAddress$1(args[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}
const docsPath$3 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(parameters) {
  const { abi: abi2, args, functionName, data } = parameters;
  let abiItem = abi2[0];
  if (functionName) {
    const item2 = getAbiItem({ abi: abi2, args, name: functionName });
    if (!item2)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$3 });
    abiItem = item2;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$3 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$3 });
  const values = decodeAbiParameters(abiItem.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return void 0;
}
const docsPath$2 = "/docs/contract/encodeFunctionData";
function prepareEncodeFunctionData(parameters) {
  const { abi: abi2, args, functionName } = parameters;
  let abiItem = abi2[0];
  if (functionName) {
    const item2 = getAbiItem({
      abi: abi2,
      args,
      name: functionName
    });
    if (!item2)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$2 });
    abiItem = item2;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$2 });
  return {
    abi: [abiItem],
    functionName: toFunctionSelector(formatAbiItem$1(abiItem))
  };
}
function encodeFunctionData(parameters) {
  const { args } = parameters;
  const { abi: abi2, functionName } = (() => {
    var _a2;
    if (parameters.abi.length === 1 && ((_a2 = parameters.functionName) == null ? void 0 : _a2.startsWith("0x")))
      return parameters;
    return prepareEncodeFunctionData(parameters);
  })();
  const abiItem = abi2[0];
  const signature2 = functionName;
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
  return concatHex([signature2, data ?? "0x"]);
}
function getChainContractAddress({ blockNumber, chain, contract: name2 }) {
  var _a2;
  const contract = (_a2 = chain == null ? void 0 : chain.contracts) == null ? void 0 : _a2[name2];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name: name2 }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name: name2,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
const solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
};
const solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function decodeErrorResult(parameters) {
  const { abi: abi2, data } = parameters;
  const signature2 = slice(data, 0, 4);
  if (signature2 === "0x")
    throw new AbiDecodingZeroDataError();
  const abi_ = [...abi2 || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x2) => x2.type === "error" && signature2 === toFunctionSelector(formatAbiItem$1(x2)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,
    errorName: abiItem.name
  };
}
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input2, i) => `${includeName && input2.name ? `${input2.name}: ` : ""}${typeof args[i] === "object" ? stringify$3(args[i]) : args[i]}`).join(", ")})`;
}
class CallExecutionError extends BaseError$3 {
  constructor(cause, { account: account_, docsPath: docsPath2, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
    var _a2;
    const account2 = account_ ? parseAccount(account_) : void 0;
    let prettyArgs = prettyPrint({
      from: account2 == null ? void 0 : account2.address,
      to,
      value: typeof value !== "undefined" && `${formatEther$2(value)} ${((_a2 = chain == null ? void 0 : chain.nativeCurrency) == null ? void 0 : _a2.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    if (stateOverride) {
      prettyArgs += `
${prettyStateOverride(stateOverride)}`;
    }
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "CallExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
}
class ContractFunctionExecutionError extends BaseError$3 {
  constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath2, functionName, sender }) {
    const abiItem = getAbiItem({ abi: abi2, args, name: functionName });
    const formattedArgs = abiItem ? formatAbiItemWithArgs({
      abiItem,
      args,
      includeFunctionName: false,
      includeName: false
    }) : void 0;
    const functionWithParams = abiItem ? formatAbiItem$1(abiItem, { includeName: true }) : void 0;
    const prettyArgs = prettyPrint({
      address: contractAddress && getContractAddress(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array((functionName == null ? void 0 : functionName.length) ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        prettyArgs && "Contract Call:",
        prettyArgs
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    });
    Object.defineProperty(this, "abi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "args", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "formattedArgs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "functionName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sender", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abi = abi2;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
}
class ContractFunctionRevertedError extends BaseError$3 {
  constructor({ abi: abi2, data, functionName, message }) {
    let cause;
    let decodedData = void 0;
    let metaMessages;
    let reason;
    if (data && data !== "0x") {
      try {
        decodedData = decodeErrorResult({ abi: abi2, data });
        const { abiItem, errorName, args: errorArgs } = decodedData;
        if (errorName === "Error") {
          reason = errorArgs[0];
        } else if (errorName === "Panic") {
          const [firstArg] = errorArgs;
          reason = panicReasons[firstArg];
        } else {
          const errorWithParams = abiItem ? formatAbiItem$1(abiItem, { includeName: true }) : void 0;
          const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
            abiItem,
            args: errorArgs,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : "",
            formattedArgs && formattedArgs !== "()" ? `       ${[...Array((errorName == null ? void 0 : errorName.length) ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
          ];
        }
      } catch (err) {
        cause = err;
      }
    } else if (message)
      reason = message;
    let signature2;
    if (cause instanceof AbiErrorSignatureNotFoundError) {
      signature2 = cause.signature;
      metaMessages = [
        `Unable to decode signature "${signature2}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ];
    }
    super(reason && reason !== "execution reverted" || signature2 ? [
      `The contract function "${functionName}" reverted with the following ${signature2 ? "signature" : "reason"}:`,
      reason || signature2
    ].join("\n") : `The contract function "${functionName}" reverted.`, {
      cause,
      metaMessages,
      name: "ContractFunctionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reason", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = decodedData;
    this.reason = reason;
    this.signature = signature2;
  }
}
class ContractFunctionZeroDataError extends BaseError$3 {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class CounterfactualDeploymentFailedError extends BaseError$3 {
  constructor({ factory: factory2 }) {
    super(`Deployment for counterfactual contract call failed${factory2 ? ` for factory "${factory2}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class RawContractError extends BaseError$3 {
  constructor({ data, message }) {
    super(message || "", { name: "RawContractError" });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data;
  }
}
function isNullUniversalResolverError(err, callType) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  if (!(err instanceof BaseError$3))
    return false;
  const cause = err.walk((e2) => e2 instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (((_a2 = cause.data) == null ? void 0 : _a2.errorName) === "ResolverNotFound")
    return true;
  if (((_b2 = cause.data) == null ? void 0 : _b2.errorName) === "ResolverWildcardNotSupported")
    return true;
  if (((_c2 = cause.data) == null ? void 0 : _c2.errorName) === "ResolverNotContract")
    return true;
  if (((_d2 = cause.data) == null ? void 0 : _d2.errorName) === "ResolverError")
    return true;
  if (((_e2 = cause.data) == null ? void 0 : _e2.errorName) === "HttpError")
    return true;
  if ((_f2 = cause.reason) == null ? void 0 : _f2.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}
function namehash$1(name2) {
  let result = new Uint8Array(32).fill(0);
  if (!name2)
    return bytesToHex$3(result);
  const labels = name2.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes$3(hashFromEncodedLabel) : keccak256$1(stringToBytes(labels[i]), "bytes");
    result = keccak256$1(concat$1([result, hashed]), "bytes");
  }
  return bytesToHex$3(result);
}
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex$3(result);
  return encodedLabelToLabelhash(label) || keccak256$1(stringToBytes(label));
}
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes2 = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset2 = 0;
  const list2 = value.split(".");
  for (let i = 0; i < list2.length; i++) {
    let encoded = stringToBytes(list2[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list2[i])));
    bytes2[offset2] = encoded.length;
    bytes2.set(encoded, offset2 + 1);
    offset2 += encoded.length + 1;
  }
  if (bytes2.byteLength !== offset2 + 1)
    return bytes2.slice(0, offset2 + 1);
  return bytes2;
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi: abi2, address, args, docsPath: docsPath2, functionName, sender }) {
  const { code: code2, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError$3 ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code2) && (data || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi: abi2,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi: abi2,
    args,
    contractAddress: address,
    docsPath: docsPath2,
    functionName,
    sender
  });
}
const aggregate3Signature = "0x82ad56cb";
const deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe";
const deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe";
const universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
function getCallError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn, id: id2, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler2 = getScheduler();
    flush();
    const args = scheduler2.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data) => {
      var _a2;
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (let i = 0; i < scheduler2.length; i++) {
        const { pendingPromise } = scheduler2[i];
        (_a2 = pendingPromise.resolve) == null ? void 0 : _a2.call(pendingPromise, [data[i], data]);
      }
    }).catch((err) => {
      var _a2;
      for (let i = 0; i < scheduler2.length; i++) {
        const { pendingPromise } = scheduler2[i];
        (_a2 = pendingPromise.reject) == null ? void 0 : _a2.call(pendingPromise, err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id2);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id2) || [];
  const setScheduler = (item2) => schedulerCache.set(id2, [...getScheduler(), item2]);
  return {
    flush,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve, reject) => {
        pendingPromise.resolve = resolve;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch == null ? void 0 : shouldSplitBatch([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
async function call(client2, args) {
  var _a2, _b2, _c2, _d2;
  const { account: account_ = client2.account, batch = Boolean((_a2 = client2.batch) == null ? void 0 : _a2.multicall), blockNumber, blockTag = "latest", accessList, blobs, code: code2, data: data_, factory: factory2, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
  const account2 = account_ ? parseAccount(account_) : void 0;
  if (code2 && (factory2 || factoryData))
    throw new BaseError$3("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (code2 && to)
    throw new BaseError$3("Cannot provide both `code` & `to` as parameters.");
  const deploylessCallViaBytecode = code2 && data_;
  const deploylessCallViaFactory = factory2 && factoryData && to && data_;
  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
  const data = (() => {
    if (deploylessCallViaBytecode)
      return toDeploylessCallViaBytecodeData({
        code: code2,
        data: data_
      });
    if (deploylessCallViaFactory)
      return toDeploylessCallViaFactoryData({
        data: data_,
        factory: factory2,
        factoryData,
        to
      });
    return data_;
  })();
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const chainFormat = (_d2 = (_c2 = (_b2 = client2.chain) == null ? void 0 : _b2.formatters) == null ? void 0 : _c2.transactionRequest) == null ? void 0 : _d2.format;
    const format2 = chainFormat || formatTransactionRequest;
    const request = format2({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account2 == null ? void 0 : account2.address,
      accessList,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: deploylessCall ? void 0 : to,
      value
    });
    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {
      try {
        return await scheduleMulticall(client2, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client2.request({
      method: "eth_call",
      params: rpcStateOverride ? [
        request,
        block,
        rpcStateOverride
      ] : [request, block]
    });
    if (response === "0x")
      return { data: void 0 };
    return { data: response };
  } catch (err) {
    const data2 = getRevertErrorData(err);
    const { offchainLookup, offchainLookupSignature } = await __vitePreload(async () => {
      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await import("./ccip-1-9qVS1a.js");
      return { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 };
    }, true ? [] : void 0, import.meta.url);
    if (client2.ccipRead !== false && (data2 == null ? void 0 : data2.slice(0, 10)) === offchainLookupSignature && to)
      return { data: await offchainLookup(client2, { data: data2, to }) };
    if (deploylessCall && (data2 == null ? void 0 : data2.slice(0, 10)) === "0x101bb98d")
      throw new CounterfactualDeploymentFailedError({ factory: factory2 });
    throw getCallError(err, {
      ...args,
      account: account2,
      chain: client2.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data, to, ...request_ } = request;
  if (!data)
    return false;
  if (data.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x2) => typeof x2 !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client2, args) {
  var _a2;
  const { batchSize = 1024, wait: wait2 = 0 } = typeof ((_a2 = client2.batch) == null ? void 0 : _a2.multicall) === "object" ? client2.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new ClientChainNotConfiguredError();
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client2.uid}.${block}`,
    wait: wait2,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data2 }) => size3 + (data2.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data2 = await client2.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data2 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: void 0 };
  return { data: returnData };
}
function toDeploylessCallViaBytecodeData(parameters) {
  const { code: code2, data } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(bytes, bytes)"]),
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [code2, data]
  });
}
function toDeploylessCallViaFactoryData(parameters) {
  const { data, factory: factory2, factoryData, to } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
    bytecode: deploylessCallViaFactoryBytecode,
    args: [to, data, factory2, factoryData]
  });
}
function getRevertErrorData(err) {
  var _a2;
  if (!(err instanceof BaseError$3))
    return void 0;
  const error = err.walk();
  return typeof (error == null ? void 0 : error.data) === "object" ? (_a2 = error.data) == null ? void 0 : _a2.data : error.data;
}
async function readContract$1(client2, parameters) {
  const { abi: abi2, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data } = await getAction$1(client2, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi: abi2,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}
async function getEnsAddress(client2, { blockNumber, blockTag, coinType, name: name2, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash$1(name2), BigInt(coinType)] } : { args: [namehash$1(name2)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex$1(packetToBytes(name2)), functionData],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract$1, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash$1(name2), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError$3 {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError$3 {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError$3 {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError$3 {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType == null ? void 0 : contentType.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img2 = new Image();
      img2.onload = () => {
        resolve(true);
      };
      img2.onerror = () => {
        resolve(false);
      };
      img2.src = uri;
    });
  }
}
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = (networkRegexMatch == null ? void 0 : networkRegexMatch.groups) || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS2 = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS2) {
    let replacedUri = uri;
    if (gatewayUrls == null ? void 0 : gatewayUrls.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls == null ? void 0 : gatewayUrls.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS2) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client2, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract$1(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract$1(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
async function parseAvatarRecord(client2, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client2, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client2, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client2, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? (
      // if it is encoded, decode it
      atob(resolvedNftUri.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      resolvedNftUri
    );
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}
async function getEnsText(client2, { blockNumber, blockTag, name: name2, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex$1(packetToBytes(name2)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash$1(name2), key]
        })
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract$1, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
async function getEnsAvatar(client2, { blockNumber, blockTag, assetGatewayUrls, name: name2, gatewayUrls, strict, universalResolverAddress }) {
  const record = await getAction$1(client2, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name: name2,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client2, {
      record,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}
async function getEnsName(client2, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex$1(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract$1, "readContract");
    const [name2, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name2;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}
async function getEnsResolver(client2, { blockNumber, blockTag, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction$1(client2, readContract$1, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex$1(packetToBytes(name2))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}
function createFilterRequestScope(client2, { method }) {
  var _a2, _b2;
  const requestMap = {};
  if (client2.transport.type === "fallback")
    (_b2 = (_a2 = client2.transport).onResponse) == null ? void 0 : _b2.call(_a2, ({ method: method_, response: id2, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id2] = transport.request;
    });
  return (id2) => requestMap[id2] || client2.request;
}
async function createBlockFilter(client2) {
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newBlockFilter"
  });
  const id2 = await client2.request({
    method: "eth_newBlockFilter"
  });
  return { id: id2, request: getRequest(id2), type: "block" };
}
class FilterTypeNotSupportedError extends BaseError$3 {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
}
const docsPath$1 = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  var _a2;
  const { abi: abi2, eventName, args } = parameters;
  let abiItem = abi2[0];
  if (eventName) {
    const item2 = getAbiItem({ abi: abi2, name: eventName });
    if (!item2)
      throw new AbiEventNotFoundError(eventName, { docsPath: docsPath$1 });
    abiItem = item2;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath: docsPath$1 });
  const definition = formatAbiItem$1(abiItem);
  const signature2 = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = (_a2 = abiItem.inputs) == null ? void 0 : _a2.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x2) => args[x2.name])) ?? [] : [];
    if (args_.length > 0) {
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i) => {
        if (Array.isArray(args_[i]))
          return args_[i].map((_, j2) => encodeArg({ param, value: args_[i][j2] }));
        return args_[i] ? encodeArg({ param, value: args_[i] }) : null;
      })) ?? [];
    }
  }
  return [signature2, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256$1(toBytes$3(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}
async function createContractEventFilter(client2, parameters) {
  const { address, abi: abi2, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi: abi2,
    args,
    eventName
  }) : void 0;
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi2,
    args,
    eventName,
    id: id2,
    request: getRequest(id2),
    strict: Boolean(strict),
    type: "event"
  };
}
async function createEventFilter(client2, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id: id2,
    request: getRequest(id2),
    strict: Boolean(strict),
    toBlock,
    type: "event"
  };
}
async function createPendingTransactionFilter(client2) {
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newPendingTransactionFilter"
  });
  const id2 = await client2.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id2, request: getRequest(id2), type: "transaction" };
}
async function estimateContractGas(client2, parameters) {
  const { abi: abi2, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    const gas = await getAction$1(client2, estimateGas, "estimateGas")({
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account2 = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account2 == null ? void 0 : account2.address
    });
  }
}
async function getBlobBaseFee(client2) {
  const baseFee = await client2.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}
const promiseCache$1 = /* @__PURE__ */ new Map();
const responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache2) => ({
    clear: () => cache2.delete(cacheKey3),
    get: () => cache2.get(cacheKey3),
    set: (data) => cache2.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache$1);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache2 = getCache(cacheKey2);
  const response = cache2.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache2.promise.get();
  if (!promise) {
    promise = fn();
    cache2.promise.set(promise);
  }
  try {
    const data = await promise;
    cache2.response.set({ created: /* @__PURE__ */ new Date(), data });
    return data;
  } finally {
    cache2.promise.clear();
  }
}
const cacheKey = (id2) => `blockNumber.${id2}`;
async function getBlockNumber(client2, { cacheTime = client2.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client2.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client2.uid), cacheTime });
  return BigInt(blockNumberHex);
}
async function getBlockTransactionCount(client2, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count2;
  if (blockHash) {
    count2 = await client2.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    }, { dedupe: true });
  } else {
    count2 = await client2.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  return hexToNumber$2(count2);
}
async function getCode(client2, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex2 = await client2.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  }, { dedupe: Boolean(blockNumberHex) });
  if (hex2 === "0x")
    return void 0;
  return hex2;
}
function isAddressEqual(a2, b2) {
  if (!isAddress$1(a2, { strict: false }))
    throw new InvalidAddressError({ address: a2 });
  if (!isAddress$1(b2, { strict: false }))
    throw new InvalidAddressError({ address: b2 });
  return a2.toLowerCase() === b2.toLowerCase();
}
const docsPath = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi: abi2, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature2, ...argTopics] = topics;
  if (!signature2)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath });
  const abiItem = (() => {
    if (abi2.length === 1)
      return abi2[0];
    return abi2.find((x2) => x2.type === "event" && signature2 === toEventSelector(formatAbiItem$1(x2)));
  })();
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature2, { docsPath });
  const { name: name2, inputs } = abiItem;
  const isUnnamed = inputs == null ? void 0 : inputs.some((x2) => !("name" in x2 && x2.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x2) => "indexed" in x2 && x2.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x2) => !("indexed" in x2 && x2.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size$5(data)
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name2,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}
function parseEventLogs(parameters) {
  const { abi: abi2, args, logs, strict = true } = parameters;
  const eventName = (() => {
    if (!parameters.eventName)
      return void 0;
    if (Array.isArray(parameters.eventName))
      return parameters.eventName;
    return [parameters.eventName];
  })();
  return logs.map((log) => {
    var _a2;
    try {
      const abiItem = abi2.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
      if (!abiItem)
        return null;
      const event = decodeEventLog({
        ...log,
        abi: [abiItem],
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      if (!includesArgs({
        args: event.args,
        inputs: abiItem.inputs,
        matchArgs: args
      }))
        return null;
      return { ...event, ...log };
    } catch (err) {
      let eventName2;
      let isUnnamed;
      if (err instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err.abiItem.name;
        isUnnamed = (_a2 = err.abiItem.inputs) == null ? void 0 : _a2.some((x2) => !("name" in x2 && x2.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function includesArgs(parameters) {
  const { args, inputs, matchArgs } = parameters;
  if (!matchArgs)
    return true;
  if (!args)
    return false;
  function isEqual(input2, value, arg) {
    try {
      if (input2.type === "address")
        return isAddressEqual(value, arg);
      if (input2.type === "string" || input2.type === "bytes")
        return keccak256$1(toBytes$3(value)) === arg;
      return value === arg;
    } catch {
      return false;
    }
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    return matchArgs.every((value, index2) => {
      if (value === null)
        return true;
      const input2 = inputs[index2];
      if (!input2)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input2, value2, args[index2]));
    });
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    return Object.entries(matchArgs).every(([key, value]) => {
      if (value === null)
        return true;
      const input2 = inputs.find((input3) => input3.name === key);
      if (!input2)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input2, value2, args[key]));
    });
  return false;
}
function formatLog$1(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
async function getLogs(client2, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: events_ ? void 0 : args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog$1(log));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    args,
    logs: formattedLogs,
    strict
  });
}
async function getContractEvents(client2, parameters) {
  const { abi: abi2, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi: abi2, name: eventName }) : void 0;
  const events = !event ? abi2.filter((x2) => x2.type === "event") : void 0;
  return getAction$1(client2, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}
class Eip712DomainNotFoundError extends BaseError$3 {
  constructor({ address }) {
    super(`No EIP-712 domain found on contract "${address}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${address}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
}
async function getEip712Domain(client2, parameters) {
  const { address, factory: factory2, factoryData } = parameters;
  try {
    const [fields, name2, version2, chainId, verifyingContract, salt, extensions] = await getAction$1(client2, readContract$1, "readContract")({
      abi: abi$9,
      address,
      functionName: "eip712Domain",
      factory: factory2,
      factoryData
    });
    return {
      domain: {
        name: name2,
        version: version2,
        chainId: Number(chainId),
        verifyingContract,
        salt
      },
      extensions,
      fields
    };
  } catch (e2) {
    const error = e2;
    if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") {
      throw new Eip712DomainNotFoundError({ address });
    }
    throw error;
  }
}
const abi$9 = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
function formatFeeHistory(feeHistory) {
  var _a2;
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: (_a2 = feeHistory.reward) == null ? void 0 : _a2.map((reward) => reward.map((value) => BigInt(value)))
  };
}
async function getFeeHistory(client2, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client2.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  }, { dedupe: Boolean(blockNumberHex) });
  return formatFeeHistory(feeHistory);
}
async function getFilterChanges(_client3, { filter: filter2 }) {
  const strict = "strict" in filter2 && filter2.strict;
  const logs = await filter2.request({
    method: "eth_getFilterChanges",
    params: [filter2.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog$1(log));
  if (!("abi" in filter2) || !filter2.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter2.abi,
    logs: formattedLogs,
    strict
  });
}
async function getFilterLogs(_client3, { filter: filter2 }) {
  const strict = filter2.strict ?? false;
  const logs = await filter2.request({
    method: "eth_getFilterLogs",
    params: [filter2.id]
  });
  const formattedLogs = logs.map((log) => formatLog$1(log));
  if (!filter2.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter2.abi,
    logs: formattedLogs,
    strict
  });
}
async function getStorageAt(client2, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client2.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}
async function getTransaction(client2, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  var _a2, _b2, _c2;
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction2 = null;
  if (hash2) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    }, { dedupe: true });
  } else if (blockHash) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    }, { dedupe: true });
  } else if (blockNumberHex || blockTag) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!transaction2)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.transaction) == null ? void 0 : _c2.format) || formatTransaction;
  return format2(transaction2);
}
async function getTransactionConfirmations(client2, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction2] = await Promise.all([
    getAction$1(client2, getBlockNumber, "getBlockNumber")({}),
    hash2 ? getAction$1(client2, getTransaction, "getTransaction")({ hash: hash2 }) : void 0
  ]);
  const transactionBlockNumber = (transactionReceipt == null ? void 0 : transactionReceipt.blockNumber) || (transaction2 == null ? void 0 : transaction2.blockNumber);
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt$1(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog$1(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber$2(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
async function getTransactionReceipt$1(client2, { hash: hash2 }) {
  var _a2, _b2, _c2;
  const receipt = await client2.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  }, { dedupe: true });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.transactionReceipt) == null ? void 0 : _c2.format) || formatTransactionReceipt$1;
  return format2(receipt);
}
async function multicall(client2, parameters) {
  var _a2;
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof ((_a2 = client2.batch) == null ? void 0 : _a2.multicall) === "object" && client2.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0; i < contracts.length; i++) {
    const { abi: abi2, address, args, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({ abi: abi2, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (
        // Check if batching is enabled.
        batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
        currentChunkSize > batchSize && // Check if the current chunk is not already empty.
        chunkedCalls[currentChunk].length > 0
      ) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction$1(client2, readContract$1, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results2 = [];
  for (let i = 0; i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j2 = 0; j2 < chunkedCalls[i].length; j2++) {
        results2.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j2 = 0; j2 < aggregate3Result.length; j2++) {
      const { returnData, success } = aggregate3Result[j2];
      const { callData } = chunkedCalls[i][j2];
      const { abi: abi2, address, functionName, args } = contracts[results2.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi2,
          args,
          data: returnData,
          functionName
        });
        results2.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi: abi2,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results2.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results2.length !== contracts.length)
    throw new BaseError$3("multicall results mismatch");
  return results2;
}
const listenersCache = /* @__PURE__ */ new Map();
const cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb2) => cb2.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit2 = {};
  for (const key in callbacks) {
    emit2[key] = (...args) => {
      var _a2, _b2;
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        (_b2 = (_a2 = listener.fns)[key]) == null ? void 0 : _b2.call(_a2, ...args);
    };
  }
  const cleanup = fn(emit2);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
async function wait$1(time2) {
  return new Promise((res) => setTimeout(res, time2));
}
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = void 0;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await (initialWaitTime == null ? void 0 : initialWaitTime(data)) ?? interval;
    await wait$1(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait$1(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}
function watchBlocks(client2, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify$3([
      "watchBlocks",
      client2.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit2) => poll(async () => {
      var _a2;
      try {
        const block = await getAction$1(client2, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number && (prevBlock == null ? void 0 : prevBlock.number)) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = (prevBlock == null ? void 0 : prevBlock.number) + 1n; i < block.number; i++) {
              const block2 = await getAction$1(client2, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit2.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (
          // If no previous block exists, emit.
          !(prevBlock == null ? void 0 : prevBlock.number) || // If the block tag is "pending" with no block number, emit.
          blockTag === "pending" && !(block == null ? void 0 : block.number) || // If the next block number is greater than the previous block number, emit.
          // We don't want to emit blocks in the past.
          block.number && block.number > prevBlock.number
        ) {
          emit2.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err) {
        (_a2 = emit2.onError) == null ? void 0 : _a2.call(emit2, err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let emitFetched = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        if (emitOnBegin) {
          getAction$1(client2, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          }).then((block) => {
            if (!active)
              return;
            if (!emitFetched)
              return;
            onBlock(block, void 0);
            emitFetched = false;
          });
        }
        const transport = (() => {
          if (client2.transport.type === "fallback") {
            const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client2.transport;
            return transport2.value;
          }
          return client2.transport;
        })();
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            var _a2, _b2, _c2;
            if (!active)
              return;
            const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.block) == null ? void 0 : _c2.format) || formatBlock$1;
            const block = format2(data.result);
            onBlock(block, prevBlock);
            emitFetched = false;
            prevBlock = block;
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError == null ? void 0 : onError(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}
function watchBlockNumber(client2, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify$3([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit2) => poll(async () => {
      var _a2;
      try {
        const blockNumber = await getAction$1(client2, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
              emit2.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit2.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        (_a2 = emit2.onError) == null ? void 0 : _a2.call(emit2, err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify$3([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit2) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client2.transport.type === "fallback") {
              const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client2.transport;
              return transport2.value;
            }
            return client2.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              var _a2;
              if (!active)
                return;
              const blockNumber = hexToBigInt((_a2 = data.result) == null ? void 0 : _a2.number);
              emit2.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              var _a2;
              (_a2 = emit2.onError) == null ? void 0 : _a2.call(emit2, error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError == null ? void 0 : onError(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
async function uninstallFilter(_client3, { filter: filter2 }) {
  return filter2.request({
    method: "eth_uninstallFilter",
    params: [filter2.id]
  });
}
function watchEvent(client2, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify$3([
      "watchEvent",
      address,
      args,
      batch,
      client2.uid,
      event,
      pollingInterval,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit2) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        var _a2;
        if (!initialized) {
          try {
            filter2 = await getAction$1(client2, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction$1(client2, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction$1(client2, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction$1(client2, getLogs, "getLogs")({
                address,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit2.onLogs(logs);
          else
            for (const log of logs)
              emit2.onLogs([log]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError)
            initialized = false;
          (_a2 = emit2.onError) == null ? void 0 : _a2.call(emit2, err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$1(client2, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const transport = (() => {
          if (client2.transport.type === "fallback") {
            const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client2.transport;
            return transport2.value;
          }
          return client2.transport;
        })();
        const events_ = events ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          const encoded = events_.flatMap((event2) => encodeEventTopics({
            abi: [event2],
            eventName: event2.name,
            args
          }));
          topics = [encoded];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            var _a2;
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_ ?? [],
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog$1(log, { args: args2, eventName });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = (_a2 = err.abiItem.inputs) == null ? void 0 : _a2.some((x2) => !("name" in x2 && x2.name));
              }
              const formatted = formatLog$1(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError == null ? void 0 : onError(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
function watchPendingTransactions(client2, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify$3([
      "watchPendingTransactions",
      client2.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit2) => {
      let filter2;
      const unwatch = poll(async () => {
        var _a2;
        try {
          if (!filter2) {
            try {
              filter2 = await getAction$1(client2, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction$1(client2, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          if (hashes.length === 0)
            return;
          if (batch)
            emit2.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit2.onTransactions([hash2]);
        } catch (err) {
          (_a2 = emit2.onError) == null ? void 0 : _a2.call(emit2, err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$1(client2, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction2 = data.result;
            onTransactions([transaction2]);
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError == null ? void 0 : onError(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}
async function getAddresses(client2) {
  var _a2;
  if (((_a2 = client2.account) == null ? void 0 : _a2.type) === "local")
    return [client2.account.address];
  const addresses = await client2.request({ method: "eth_accounts" }, { dedupe: true });
  return addresses.map((address) => checksumAddress(address));
}
async function getPermissions(client2) {
  const permissions = await client2.request({ method: "wallet_getPermissions" }, { dedupe: true });
  return permissions;
}
const promiseCache = /* @__PURE__ */ new LruMap(8192);
function withDedupe(fn, { enabled = true, id: id2 }) {
  if (!enabled || !id2)
    return fn();
  if (promiseCache.get(id2))
    return promiseCache.get(id2);
  const promise = fn().finally(() => promiseCache.delete(id2));
  promiseCache.set(id2, promise);
  return promise;
}
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count: count2 = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count: count2, error }) : delay_;
        if (delay2)
          await wait$1(delay2);
        attemptRetry({ count: count2 + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count2 < retryCount && await shouldRetry2({ count: count2, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const requestId = dedupe ? keccak256$1(stringToHex(`${uid2}.${stringify$3(args)}`)) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err, { method: args.method });
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err, {
              method: args.method
            });
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case 5e3:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError$3)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count: count2, error }) => {
        var _a2;
        if (error && error instanceof HttpRequestError) {
          const retryAfter = (_a2 = error == null ? void 0 : error.headers) == null ? void 0 : _a2.get("Retry-After");
          if (retryAfter == null ? void 0 : retryAfter.match(/\d/))
            return Number.parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count2) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: (controller == null ? void 0 : controller.signal) || null }));
      } catch (err) {
        if ((err == null ? void 0 : err.name) === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      var _a2;
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init2 = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify$3(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify$3({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init2);
          if (onRequest)
            await onRequest(request);
          const response2 = await fetch(url, init2);
          return response2;
        }, {
          errorInstance: new TimeoutError$2({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if ((_a2 = response.headers.get("Content-Type")) == null ? void 0 : _a2.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          data = JSON.parse(data || "{}");
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify$3(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError$2)
          throw err;
        throw new HttpRequestError({
          body,
          cause: err,
          url
        });
      }
    }
  };
}
function hashTypedData(parameters) {
  const { domain: domain2 = {}, message, primaryType } = parameters;
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain: domain2 }),
    ...parameters.types
  };
  validateTypedData({
    domain: domain2,
    message,
    primaryType,
    types: types2
  });
  const parts = ["0x1901"];
  if (domain2)
    parts.push(hashDomain({
      domain: domain2,
      types: types2
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types: types2
    }));
  return keccak256$1(concat$1(parts));
}
function hashDomain({ domain: domain2, types: types2 }) {
  return hashStruct({
    data: domain2,
    primaryType: "EIP712Domain",
    types: types2
  });
}
function hashStruct({ data, primaryType, types: types2 }) {
  const encoded = encodeData({
    data,
    primaryType,
    types: types2
  });
  return keccak256$1(encoded);
}
function encodeData({ data, primaryType, types: types2 }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types: types2 })];
  for (const field of types2[primaryType]) {
    const [type, value] = encodeField({
      types: types2,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types: types2 }) {
  const encodedHashType = toHex$1(encodeType$1({ primaryType, types: types2 }));
  return keccak256$1(encodedHashType);
}
function encodeType$1({ primaryType, types: types2 }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types: types2 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types2[type].map(({ name: name2, type: t2 }) => `${t2} ${name2}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types: types2 }, results2 = /* @__PURE__ */ new Set()) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match == null ? void 0 : match[0];
  if (results2.has(primaryType) || types2[primaryType] === void 0) {
    return results2;
  }
  results2.add(primaryType);
  for (const field of types2[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types: types2 }, results2);
  }
  return results2;
}
function encodeField({ types: types2, name: name2, type, value }) {
  if (types2[type] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256$1(encodeData({ data: value, primaryType: type, types: types2 }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256$1(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256$1(toHex$1(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item2) => encodeField({
      name: name2,
      type: parsedType,
      types: types2,
      value: item2
    }));
    return [
      { type: "bytes32" },
      keccak256$1(encodeAbiParameters(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v3]) => v3)))
    ];
  }
  return [{ type }, value];
}
function serializeTypedData(parameters) {
  const { domain: domain_, message: message_, primaryType, types: types2 } = parameters;
  const normalizeData = (struct, data_) => {
    const data = { ...data_ };
    for (const param of struct) {
      const { name: name2, type } = param;
      if (type === "address")
        data[name2] = data[name2].toLowerCase();
    }
    return data;
  };
  const domain2 = (() => {
    if (!types2.EIP712Domain)
      return {};
    if (!domain_)
      return {};
    return normalizeData(types2.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return void 0;
    return normalizeData(types2[primaryType], message_);
  })();
  return stringify$3({ domain: domain2, message, primaryType, types: types2 });
}
function validateTypedData(parameters) {
  const { domain: domain2, message, primaryType, types: types2 } = parameters;
  const validateData = (struct, data) => {
    for (const param of struct) {
      const { name: name2, type } = param;
      const value = data[name2];
      const integerMatch = type.match(integerRegex);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type2, base, size_] = integerMatch;
        numberToHex(value, {
          signed: base === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress$1(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex);
      if (bytesMatch) {
        const [_type2, size_] = bytesMatch;
        if (size_ && size$5(value) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size$5(value)
          });
      }
      const struct2 = types2[type];
      if (struct2)
        validateData(struct2, value);
    }
  };
  if (types2.EIP712Domain && domain2)
    validateData(types2.EIP712Domain, domain2);
  if (primaryType !== "EIP712Domain")
    validateData(types2[primaryType], message);
}
function getTypesForEIP712Domain({ domain: domain2 }) {
  return [
    typeof (domain2 == null ? void 0 : domain2.name) === "string" && { name: "name", type: "string" },
    (domain2 == null ? void 0 : domain2.version) && { name: "version", type: "string" },
    typeof (domain2 == null ? void 0 : domain2.chainId) === "number" && {
      name: "chainId",
      type: "uint256"
    },
    (domain2 == null ? void 0 : domain2.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain2 == null ? void 0 : domain2.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const presignMessagePrefix = "Ethereum Signed Message:\n";
function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === "string")
      return stringToHex(message_);
    if (typeof message_.raw === "string")
      return message_.raw;
    return bytesToHex$3(message_.raw);
  })();
  const prefix = stringToHex(`${presignMessagePrefix}${size$5(message)}`);
  return concat$1([prefix, message]);
}
function hashMessage$1(message, to_) {
  return keccak256$1(toPrefixedMessage(message), to_);
}
const erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";
function isErc6492Signature(signature2) {
  return sliceHex(signature2, -32) === erc6492MagicBytes;
}
function serializeErc6492Signature(parameters) {
  const { address, data, signature: signature2, to = "hex" } = parameters;
  const signature_ = concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature2]),
    erc6492MagicBytes
  ]);
  if (to === "hex")
    return signature_;
  return hexToBytes$2(signature_);
}
class InvalidDecimalNumberError extends BaseError$3 {
  constructor({ value }) {
    super(`Number \`${value}\` is not a valid decimal number.`, {
      name: "InvalidDecimalNumberError"
    });
  }
}
function parseUnits$3(value, decimals) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
    throw new InvalidDecimalNumberError({ value });
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : void 0,
    nonce: proof.nonce ? hexToNumber$2(proof.nonce) : void 0,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
  };
}
async function getProof(client2, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof = await client2.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}
async function waitForTransactionReceipt(client2, {
  confirmations = 1,
  hash: hash2,
  onReplaced,
  pollingInterval = client2.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count: count2 }) => ~~(1 << count2) * 200,
  // exponential backoff
  timeout
}) {
  const observerId = stringify$3(["waitForTransactionReceipt", client2.uid, hash2]);
  let count2 = 0;
  let transaction2;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit2) => {
      const _unwatch = getAction$1(client2, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          let blockNumber = blockNumber_;
          if (retrying)
            return;
          if (count2 > retryCount)
            done(() => emit2.reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })));
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit2.resolve(receipt));
              return;
            }
            if (!transaction2) {
              retrying = true;
              await withRetry(async () => {
                transaction2 = await getAction$1(client2, getTransaction, "getTransaction")({ hash: hash2 });
                if (transaction2.blockNumber)
                  blockNumber = transaction2.blockNumber;
              }, {
                delay: retryDelay,
                retryCount
              });
              retrying = false;
            }
            receipt = await getAction$1(client2, getTransactionReceipt$1, "getTransactionReceipt")({ hash: hash2 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit2.resolve(receipt));
          } catch (err) {
            if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
              if (!transaction2) {
                retrying = false;
                return;
              }
              try {
                replacedTransaction = transaction2;
                retrying = true;
                const block = await withRetry(() => getAction$1(client2, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: retryDelay,
                  retryCount,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction$1(client2, getTransactionReceipt$1, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  var _a2;
                  (_a2 = emit2.onReplaced) == null ? void 0 : _a2.call(emit2, {
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit2.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit2.reject(err_));
              }
            } else {
              done(() => emit2.reject(err));
            }
          } finally {
            count2++;
          }
        }
      });
    });
  });
}
async function requestAddresses(client2) {
  const addresses = await client2.request({ method: "eth_requestAccounts" }, { dedupe: true, retryCount: 0 });
  return addresses.map((address) => getAddress$1(address));
}
async function requestPermissions(client2, permissions) {
  return client2.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  }, { retryCount: 0 });
}
async function signTransaction(client2, parameters) {
  var _a2, _b2, _c2, _d2;
  const { account: account_ = client2.account, chain = client2.chain, ...transaction2 } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account2 = parseAccount(account_);
  assertRequest({
    account: account2,
    ...parameters
  });
  const chainId = await getAction$1(client2, getChainId$2, "getChainId")({});
  if (chain !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain
    });
  const formatters = (chain == null ? void 0 : chain.formatters) || ((_a2 = client2.chain) == null ? void 0 : _a2.formatters);
  const format2 = ((_b2 = formatters == null ? void 0 : formatters.transactionRequest) == null ? void 0 : _b2.format) || formatTransactionRequest;
  if (account2.signTransaction)
    return account2.signTransaction({
      ...transaction2,
      chainId
    }, { serializer: (_d2 = (_c2 = client2.chain) == null ? void 0 : _c2.serializers) == null ? void 0 : _d2.transaction });
  return await client2.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format2(transaction2),
        chainId: numberToHex(chainId),
        from: account2.address
      }
    ]
  }, { retryCount: 0 });
}
async function signMessage$1(client2, { account: account_ = client2.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account2 = parseAccount(account_);
  if (account2.signMessage)
    return account2.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex$1(message.raw);
    return message.raw;
  })();
  return client2.request({
    method: "personal_sign",
    params: [message_, account2.address]
  }, { retryCount: 0 });
}
async function signTypedData(client2, parameters) {
  const { account: account_ = client2.account, domain: domain2, message, primaryType } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account2 = parseAccount(account_);
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain: domain2 }),
    ...parameters.types
  };
  validateTypedData({ domain: domain2, message, primaryType, types: types2 });
  if (account2.signTypedData)
    return account2.signTypedData({ domain: domain2, message, primaryType, types: types2 });
  const typedData = serializeTypedData({ domain: domain2, message, primaryType, types: types2 });
  return client2.request({
    method: "eth_signTypedData_v4",
    params: [account2.address, typedData]
  }, { retryCount: 0 });
}
async function simulateContract$1(client2, parameters) {
  const { abi: abi2, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account2 = callRequest.account ? parseAccount(callRequest.account) : client2.account;
  const calldata = encodeFunctionData({ abi: abi2, args, functionName });
  try {
    const { data } = await getAction$1(client2, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account: account2
    });
    const result = decodeFunctionResult({
      abi: abi2,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi2.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account: account2
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account2 == null ? void 0 : account2.address
    });
  }
}
async function switchChain$1(client2, { id: id2 }) {
  await client2.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id2)
      }
    ]
  }, { retryCount: 0 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$8 = BigInt(0);
const _1n$a = BigInt(1);
const _2n$6 = BigInt(2);
function isBytes$1(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function abytes(item2) {
  if (!isBytes$1(item2))
    throw new Error("Uint8Array expected");
}
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$2(bytes2) {
  abytes(bytes2);
  let hex2 = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex2 += hexes$2[bytes2[i]];
  }
  return hex2;
}
function numberToHexUnpadded$1(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber$1(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes$1(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl2 = hex2.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
  const array = new Uint8Array(al2);
  for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi2));
    const n2 = asciiToBase16(hex2.charCodeAt(hi2 + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi2] + hex2[hi2 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
    }
    array[ai2] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE$1(bytes2) {
  return hexToNumber$1(bytesToHex$2(bytes2));
}
function bytesToNumberLE$1(bytes2) {
  abytes(bytes2);
  return hexToNumber$1(bytesToHex$2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE$1(n2, len) {
  return hexToBytes$1(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE$1(n2, len) {
  return numberToBytesBE$1(n2, len).reverse();
}
function numberToVarBytesBE$1(n2) {
  return hexToBytes$1(numberToHexUnpadded$1(n2));
}
function ensureBytes$1(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes$1(hex2);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e2}`);
    }
  } else if (isBytes$1(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes$2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a2 = arrays[i];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const a2 = arrays[i];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
function equalBytes$1(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a2.length; i++)
    diff |= a2[i] ^ b2[i];
  return diff === 0;
}
function utf8ToBytes$3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen$1(n2) {
  let len;
  for (len = 0; n2 > _0n$8; n2 >>= _1n$a, len += 1)
    ;
  return len;
}
function bitGet$1(n2, pos) {
  return n2 >> BigInt(pos) & _1n$a;
}
function bitSet$1(n2, pos, value) {
  return n2 | (value ? _1n$a : _0n$8) << BigInt(pos);
}
const bitMask$1 = (n2) => (_2n$6 << BigInt(n2 - 1)) - _1n$a;
const u8n$1 = (data) => new Uint8Array(data);
const u8fr$1 = (arr) => Uint8Array.from(arr);
function createHmacDrbg$1(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v3 = u8n$1(hashLen);
  let k2 = u8n$1(hashLen);
  let i = 0;
  const reset = () => {
    v3.fill(1);
    k2.fill(0);
    i = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v3, ...b2);
  const reseed = (seed = u8n$1()) => {
    k2 = h2(u8fr$1([0]), seed);
    v3 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr$1([1]), seed);
    v3 = h2();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v3 = h2();
      const sl2 = v3.slice();
      out.push(sl2);
      len += v3.length;
    }
    return concatBytes$2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns$1 = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes$1(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject$1(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns$1[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
const ut$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abytes,
  bitGet: bitGet$1,
  bitLen: bitLen$1,
  bitMask: bitMask$1,
  bitSet: bitSet$1,
  bytesToHex: bytesToHex$2,
  bytesToNumberBE: bytesToNumberBE$1,
  bytesToNumberLE: bytesToNumberLE$1,
  concatBytes: concatBytes$2,
  createHmacDrbg: createHmacDrbg$1,
  ensureBytes: ensureBytes$1,
  equalBytes: equalBytes$1,
  hexToBytes: hexToBytes$1,
  hexToNumber: hexToNumber$1,
  isBytes: isBytes$1,
  numberToBytesBE: numberToBytesBE$1,
  numberToBytesLE: numberToBytesLE$1,
  numberToHexUnpadded: numberToHexUnpadded$1,
  numberToVarBytesBE: numberToVarBytesBE$1,
  utf8ToBytes: utf8ToBytes$3,
  validateObject: validateObject$1
}, Symbol.toStringTag, { value: "Module" }));
function isBytesEqual(a_, b_) {
  const a2 = isHex(a_) ? toBytes$3(a_) : a_;
  const b2 = isHex(b_) ? toBytes$3(b_) : b_;
  return equalBytes$1(a2, b2);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0), _1n$9 = BigInt(1), _2n$5 = BigInt(2), _3n$3 = BigInt(3);
const _4n$1 = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$1(a2, b2) {
  const result = a2 % b2;
  return result >= _0n$7 ? result : b2 + result;
}
function pow$1(num, power, modulo) {
  if (modulo <= _0n$7 || power < _0n$7)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$9)
    return _0n$7;
  let res = _1n$9;
  while (power > _0n$7) {
    if (power & _1n$9)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$9;
  }
  return res;
}
function pow2$1(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$7) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert$1(number2, modulo) {
  if (number2 === _0n$7 || modulo <= _0n$7) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod$1(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$7, u2 = _1n$9;
  while (a2 !== _0n$7) {
    const q2 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q2;
    b2 = a2, a2 = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$9)
    throw new Error("invert: does not exist");
  return mod$1(x2, modulo);
}
function tonelliShanks$1(P2) {
  const legendreC = (P2 - _1n$9) / _2n$5;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n$9, S2 = 0; Q2 % _2n$5 === _0n$7; Q2 /= _2n$5, S2++)
    ;
  for (Z2 = _2n$5; Z2 < P2 && pow$1(Z2, legendreC, P2) !== P2 - _1n$9; Z2++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$9) / _4n$1;
    return function tonelliFast(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  const Q1div2 = (Q2 + _1n$9) / _2n$5;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q2);
    let x2 = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g2, _1n$9 << BigInt(r2 - m2 - 1));
      g2 = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g2);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt$1(P2) {
  if (P2 % _4n$1 === _3n$3) {
    const p1div4 = (P2 + _1n$9) / _4n$1;
    return function sqrt3mod4(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P2 % _8n$1 === _5n$1) {
    const c1 = (P2 - _5n$1) / _8n$1;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$5);
      const v3 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v3);
      const i = Fp2.mul(Fp2.mul(nv, _2n$5), v3);
      const root2 = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  return tonelliShanks$1(P2);
}
const FIELD_FIELDS$1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$1(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS$1.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject$1(field, opts);
}
function FpPow$1(f2, num, power) {
  if (power < _0n$7)
    throw new Error("Expected power > 0");
  if (power === _0n$7)
    return f2.ONE;
  if (power === _1n$9)
    return num;
  let p2 = f2.ONE;
  let d2 = num;
  while (power > _0n$7) {
    if (power & _1n$9)
      p2 = f2.mul(p2, d2);
    d2 = f2.sqr(d2);
    power >>= _1n$9;
  }
  return p2;
}
function FpInvertBatch$1(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength$1(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field$1(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$7)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength$1(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt$1(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask$1(BITS),
    ZERO: _0n$7,
    ONE: _1n$9,
    create: (num) => mod$1(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$7 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$7,
    isOdd: (num) => (num & _1n$9) === _1n$9,
    neg: (num) => mod$1(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod$1(num * num, ORDER),
    add: (lhs, rhs) => mod$1(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod$1(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod$1(lhs * rhs, ORDER),
    pow: (num, power) => FpPow$1(f2, num, power),
    div: (lhs, rhs) => mod$1(lhs * invert$1(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert$1(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch$1(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE$1(num, BYTES) : numberToBytesBE$1(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE$1(bytes2) : bytesToNumberBE$1(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength$1(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength$1(fieldOrder) {
  const length = getFieldBytesLength$1(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField$1(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength$1(fieldOrder);
  const minLen = getMinHashLength$1(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE$1(key) : bytesToNumberLE$1(key);
  const reduced = mod$1(num, fieldOrder - _1n$9) + _1n$9;
  return isLE2 ? numberToBytesLE$1(reduced, fieldLen) : numberToBytesBE$1(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$6 = BigInt(0);
const _1n$8 = BigInt(1);
function wNAF$1(c2, bits) {
  const constTimeNegate = (condition, item2) => {
    const neg = item2.negate();
    return condition ? neg : item2;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p2 = c2.ZERO;
      let d2 = elm;
      while (n2 > _0n$6) {
        if (n2 & _1n$8)
          p2 = p2.add(d2);
        d2 = d2.double();
        n2 >>= _1n$8;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p2;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p2);
          points.push(base);
        }
        p2 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f2 = c2.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$8;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n2, transform) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n2);
    }
  };
}
function validateBasic$1(curve) {
  validateField$1(curve.Fp);
  validateObject$1(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength$1(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts$1(curve) {
  const opts = validateBasic$1(curve);
  validateObject$1(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$1;
const DER$1 = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER$1;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n$1(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E2 } = DER$1;
    const data = typeof hex2 === "string" ? h2b$1(hex2) : hex2;
    abytes(data);
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER$1._parseInt(data.subarray(2));
    const { d: s2, l: rBytesLeft } = DER$1._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s: s2 };
  },
  hexFromSig(sig) {
    const slice2 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h2 = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s2 = slice2(h2(sig.s));
    const r2 = slice2(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r2.length / 2;
    const sl2 = h2(shl);
    const rl2 = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s2}`;
  }
};
const _0n$5 = BigInt(0), _1n$7 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);
function weierstrassPoints$1(opts) {
  const CURVE = validatePointOpts$1(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes$2(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a2)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n$5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes$1(key))
        key = bytesToHex$2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE$1(ensureBytes$1("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod$1(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px2, py, pz) {
      this.px = px2;
      this.py = py;
      this.pz = pz;
      if (px2 == null || !Fp2.isValid(px2))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes$1("pointHex", hex2)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y2 } = this.toAffine();
      if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x2);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n$2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n$2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I2 = Point.ZERO;
      if (n2 === _0n$5)
        return I2;
      assertGE(n2);
      if (n2 === _1n$7)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n$5 || k2 > _0n$5) {
        if (k1 & _1n$7)
          k1p = k1p.add(d2);
        if (k2 & _1n$7)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$7;
        k2 >>= _1n$7;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(n2);
        point = p2;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G2 = Point.BASE;
      const mul = (P2, a3) => a3 === _0n$5 || a3 === _1n$7 || !P2.equals(G2) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul(this, a2).add(mul(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y2, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x2, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$7)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$7)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex$2(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF$1(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts$1(curve) {
  const opts = validateBasic$1(curve);
  validateObject$1(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass$1(curveDef) {
  const CURVE = validateOpts$1(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n$5 < num && num < Fp2.ORDER;
  }
  function modN(a2) {
    return mod$1(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert$1(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints$1({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a2 = point.toAffine();
      const x2 = Fp2.toBytes(a2.x);
      const cat = concatBytes$2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE$1(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3;
        try {
          y3 = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n$7) === _1n$7;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex$2(numberToBytesBE$1(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$7;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE$1(b2.slice(from, to));
  class Signature2 {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l2 = CURVE.nByteLength;
      hex2 = ensureBytes$1("compactSignature", hex2, l2 * 2);
      return new Signature2(slcNum(hex2, 0, l2), slcNum(hex2, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r2, s: s2 } = DER$1.toSig(ensureBytes$1("DER", hex2));
      return new Signature2(r2, s2);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes$1("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER$1.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength$1(CURVE.n);
      return mapHashToField$1(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item2) {
    const arr = isBytes$1(item2);
    const str = typeof item2 === "string";
    const len = (arr || str) && item2.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item2 instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE$1(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask$1(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n$5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE$1(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes$1("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes$1("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes$1("extraEntropy", e2));
    }
    const seed = concatBytes$2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q2 = Point.BASE.multiply(k2).toAffine();
      const r2 = modN(q2.x);
      if (r2 === _0n$5)
        return;
      const s2 = modN(ik2 * modN(m2 + r2 * d2));
      if (s2 === _0n$5)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n$7);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg$1(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature2, msgHash, publicKey, opts = defaultVerOpts) {
    var _a2;
    const sg2 = signature2;
    msgHash = ensureBytes$1("msgHash", msgHash);
    publicKey = ensureBytes$1("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || isBytes$1(sg2)) {
        try {
          _sig2 = Signature2.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER$1.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s3 } = sg2;
        _sig2 = new Signature2(r3, s3);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig2;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s2);
    const u1 = modN(h2 * is);
    const u2 = modN(r2 * is);
    const R2 = (_a2 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R2)
      return false;
    const v3 = modN(R2.x);
    return v3 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils: utils2
  };
}
let HMAC$1 = class HMAC extends Hash$2 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$2(hash2);
    const key = toBytes$2(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash2.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists$2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists$2(this);
    bytes$2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
const hmac$2 = (hash2, key, message) => new HMAC$1(hash2, key).update(message).digest();
hmac$2.create = (hash2, key) => new HMAC$1(hash2, key);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac$2(hash2, key, concatBytes$3(...msgs)),
    randomBytes: randomBytes$3
  };
}
function createCurve$1(curveDef, defHash) {
  const create = (hash2) => weierstrass$1({ ...curveDef, ...getHash$1(hash2) });
  return Object.freeze({ ...create(defHash), create });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n$6 = BigInt(1);
const _2n$4 = BigInt(2);
const divNearest$1 = (a2, b2) => (a2 + b2 / _2n$4) / b2;
function sqrtMod$1(y2) {
  const P2 = secp256k1P$1;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2$1(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2$1(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2$1(b9, _2n$4, P2) * b2 % P2;
  const b22 = pow2$1(b11, _11n, P2) * b11 % P2;
  const b44 = pow2$1(b22, _22n, P2) * b22 % P2;
  const b88 = pow2$1(b44, _44n, P2) * b44 % P2;
  const b176 = pow2$1(b88, _88n, P2) * b88 % P2;
  const b220 = pow2$1(b176, _44n, P2) * b44 % P2;
  const b223 = pow2$1(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2$1(b223, _23n, P2) * b22 % P2;
  const t2 = pow2$1(t1, _6n, P2) * b2 % P2;
  const root2 = pow2$1(t2, _2n$4, P2);
  if (!Fp$1.eql(Fp$1.sqr(root2), y2))
    throw new Error("Cannot find square root");
  return root2;
}
const Fp$1 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 });
const secp256k1$1 = createCurve$1({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp$1,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N$1,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N$1;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n$6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest$1(b2 * k2, n2);
      const c2 = divNearest$1(-b1 * k2, n2);
      let k1 = mod$1(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod$1(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$4);
BigInt(0);
secp256k1$1.ProjectivePoint;
const secp256k1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  secp256k1: secp256k1$1
}, Symbol.toStringTag, { value: "Module" }));
function serializeSignature({ r: r2, s: s2, to = "hex", v: v3, yParity }) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v3 && (v3 === 27n || v3 === 28n || v3 >= 35n))
      return v3 % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  const signature2 = `0x${new secp256k1$1.Signature(hexToBigInt(r2), hexToBigInt(s2)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
  if (to === "hex")
    return signature2;
  return hexToBytes$2(signature2);
}
async function verifyHash(client2, parameters) {
  const { address, factory: factory2, factoryData, hash: hash2, signature: signature2, ...rest } = parameters;
  const signatureHex = (() => {
    if (isHex(signature2))
      return signature2;
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2)
      return serializeSignature(signature2);
    return bytesToHex$3(signature2);
  })();
  const wrappedSignature = await (async () => {
    if (!factory2 && !factoryData)
      return signatureHex;
    if (isErc6492Signature(signatureHex))
      return signatureHex;
    return serializeErc6492Signature({
      address: factory2,
      data: factoryData,
      signature: signatureHex
    });
  })();
  try {
    const { data } = await getAction$1(client2, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash2, wrappedSignature],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...rest
    });
    return isBytesEqual(data ?? "0x0", "0x1");
  } catch (error) {
    try {
      const verified = isAddressEqual(getAddress$1(address), await recoverAddress$1({ hash: hash2, signature: signature2 }));
      if (verified)
        return true;
    } catch {
    }
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}
async function verifyMessage$1(client2, { address, message, factory: factory2, factoryData, signature: signature2, ...callRequest }) {
  const hash2 = hashMessage$1(message);
  return verifyHash(client2, {
    address,
    factory: factory2,
    factoryData,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
async function verifyTypedData$1(client2, parameters) {
  const { address, factory: factory2, factoryData, signature: signature2, message, primaryType, types: types2, domain: domain2, ...callRequest } = parameters;
  const hash2 = hashTypedData({ message, primaryType, types: types2, domain: domain2 });
  return verifyHash(client2, {
    address,
    factory: factory2,
    factoryData,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
async function watchAsset(client2, params) {
  const added = await client2.request({
    method: "wallet_watchAsset",
    params
  }, { retryCount: 0 });
  return added;
}
function watchContractEvent(client2, parameters) {
  const { abi: abi2, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify$3([
      "watchContractEvent",
      address,
      args,
      batch,
      client2.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit2) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        var _a2;
        if (!initialized) {
          try {
            filter2 = await getAction$1(client2, createContractEventFilter, "createContractEventFilter")({
              abi: abi2,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction$1(client2, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction$1(client2, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber < blockNumber) {
              logs = await getAction$1(client2, getContractEvents, "getContractEvents")({
                abi: abi2,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit2.onLogs(logs);
          else
            for (const log of logs)
              emit2.onLogs([log]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError)
            initialized = false;
          (_a2 = emit2.onError) == null ? void 0 : _a2.call(emit2, err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$1(client2, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify$3([
      "watchContractEvent",
      address,
      args,
      batch,
      client2.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit2) => {
      (async () => {
        try {
          const transport = (() => {
            if (client2.transport.type === "fallback") {
              const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client2.transport;
              return transport2.value;
            }
            return client2.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi: abi2,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              var _a2;
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi: abi2,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog$1(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit2.onLogs([formatted]);
              } catch (err) {
                let eventName2;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err.abiItem.name;
                  isUnnamed = (_a2 = err.abiItem.inputs) == null ? void 0 : _a2.some((x2) => !("name" in x2 && x2.name));
                }
                const formatted = formatLog$1(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit2.onLogs([formatted]);
              }
            },
            onError(error) {
              var _a2;
              (_a2 = emit2.onError) == null ? void 0 : _a2.call(emit2, error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError == null ? void 0 : onError(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
async function writeContract$1(client2, parameters) {
  const { abi: abi2, account: account_ = client2.account, address, args, dataSuffix, functionName, ...request } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const account2 = parseAccount(account_);
  const data = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    return await getAction$1(client2, sendTransaction$1, "sendTransaction")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      account: account2,
      ...request
    });
  } catch (error) {
    throw getContractError(error, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/writeContract",
      functionName,
      sender: account2.address
    });
  }
}
function getAction(client2, actionFn, name2) {
  const action_implicit = client2[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client2[name2];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client2, params);
}
const version$7 = "2.13.5";
const getVersion$1 = () => `@wagmi/core@${version$7}`;
var __classPrivateFieldGet$3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _BaseError_instances, _BaseError_walk;
let BaseError$1 = class BaseError3 extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return getVersion$1();
  }
  constructor(shortMessage, options = {}) {
    var _a2;
    super();
    _BaseError_instances.add(this);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiCoreError"
    });
    const details = options.cause instanceof BaseError3 ? options.cause.details : ((_a2 = options.cause) == null ? void 0 : _a2.message) ? options.cause.message : options.details;
    const docsPath2 = options.cause instanceof BaseError3 ? options.cause.docsPath || options.docsPath : options.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...options.metaMessages ? [...options.metaMessages, ""] : [],
      ...docsPath2 ? [
        `Docs: ${this.docsBaseUrl}${docsPath2}.html${options.docsSlug ? `#${options.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (options.cause)
      this.cause = options.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = options.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return __classPrivateFieldGet$3(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn);
  }
};
_BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function _BaseError_walk2(err, fn) {
  if (fn == null ? void 0 : fn(err))
    return err;
  if (err.cause)
    return __classPrivateFieldGet$3(this, _BaseError_instances, "m", _BaseError_walk2).call(this, err.cause, fn);
  return err;
};
class ChainNotConfiguredError extends BaseError$1 {
  constructor() {
    super("Chain not configured.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotConfiguredError"
    });
  }
}
class ConnectorAlreadyConnectedError extends BaseError$1 {
  constructor() {
    super("Connector already connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAlreadyConnectedError"
    });
  }
}
class ConnectorNotConnectedError extends BaseError$1 {
  constructor() {
    super("Connector not connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorNotConnectedError"
    });
  }
}
class ConnectorAccountNotFoundError extends BaseError$1 {
  constructor({ address, connector }) {
    super(`Account "${address}" not found for connector "${connector.name}".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAccountNotFoundError"
    });
  }
}
class ConnectorChainMismatchError extends BaseError$1 {
  constructor({ connectionChainId, connectorChainId }) {
    super(`The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`, {
      metaMessages: [
        `Current Chain ID:  ${connectorChainId}`,
        `Expected Chain ID: ${connectionChainId}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorChainMismatchError"
    });
  }
}
class ConnectorUnavailableReconnectingError extends BaseError$1 {
  constructor({ connector }) {
    super(`Connector "${connector.name}" unavailable while reconnecting.`, {
      details: [
        "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uuid`.",
        "All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.",
        "This error commonly occurs for connectors that asynchronously inject after reconnection has already started."
      ].join(" ")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorUnavailableReconnectingError"
    });
  }
}
async function connect(config2, parameters) {
  var _a2;
  let connector;
  if (typeof parameters.connector === "function") {
    connector = config2._internal.connectors.setup(parameters.connector);
  } else
    connector = parameters.connector;
  if (connector.uid === config2.state.current)
    throw new ConnectorAlreadyConnectedError();
  try {
    config2.setState((x2) => ({ ...x2, status: "connecting" }));
    connector.emitter.emit("message", { type: "connecting" });
    const data = await connector.connect({ chainId: parameters.chainId });
    const accounts = data.accounts;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem("recentConnectorId", connector.id));
    config2.setState((x2) => ({
      ...x2,
      connections: new Map(x2.connections).set(connector.uid, {
        accounts,
        chainId: data.chainId,
        connector
      }),
      current: connector.uid,
      status: "connected"
    }));
    return { accounts, chainId: data.chainId };
  } catch (error) {
    config2.setState((x2) => ({
      ...x2,
      // Keep existing connector connected in case of error
      status: x2.current ? "connected" : "disconnected"
    }));
    throw error;
  }
}
const size$4 = 256;
let index$8 = size$4;
let buffer$2;
function uid$1(length = 11) {
  if (!buffer$2 || index$8 + length > size$4 * 2) {
    buffer$2 = "";
    index$8 = 0;
    for (let i = 0; i < size$4; i++) {
      buffer$2 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$2.substring(index$8, index$8++ + length);
}
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, ccipRead, key = "base", name: name2 = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain = parameters.chain;
  const account2 = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config2, ...value };
  const client2 = {
    account: account2,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key,
    name: name2,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid$1()
  };
  function extend(base) {
    return (extendFn) => {
      const extended = extendFn(base);
      for (const key2 in client2)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client2, { extend: extend(client2) });
}
function createTransport({ key, name: name2, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  const uid2 = uid$1();
  return {
    config: {
      key,
      name: name2,
      request,
      retryCount,
      retryDelay,
      timeout,
      type
    },
    request: buildRequest(request, { retryCount, retryDelay, uid: uid2 }),
    value
  };
}
function custom(provider2, config2 = {}) {
  const { key = "custom", name: name2 = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key,
    name: name2,
    request: provider2.request.bind(provider2),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
class UrlRequiredError extends BaseError$3 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function http(url, config2 = {}) {
  const { batch, fetchOptions, key = "http", name: name2 = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = chain == null ? void 0 : chain.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      name: name2,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a2, b2) => a2.id - b2.id
        });
        const fn = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
function parseSiweMessage(message) {
  var _a2, _b2, _c2;
  const { scheme, statement, ...prefix } = ((_a2 = message.match(prefixRegex)) == null ? void 0 : _a2.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b2 = message.match(suffixRegex)) == null ? void 0 : _b2.groups) ?? {};
  const resources = (_c2 = message.split("Resources:")[1]) == null ? void 0 : _c2.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
const prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
const suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function validateSiweMessage(parameters) {
  const { address, domain: domain2, message, nonce, scheme, time: time2 = /* @__PURE__ */ new Date() } = parameters;
  if (domain2 && message.domain !== domain2)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time2 >= message.expirationTime)
    return false;
  if (message.notBefore && time2 < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isAddressEqual(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}
async function verifySiweMessage(client2, parameters) {
  const { address, domain: domain2, message, nonce, scheme, signature: signature2, time: time2 = /* @__PURE__ */ new Date(), ...callRequest } = parameters;
  const parsed = parseSiweMessage(message);
  if (!parsed.address)
    return false;
  const isValid2 = validateSiweMessage({
    address,
    domain: domain2,
    message: parsed,
    nonce,
    scheme,
    time: time2
  });
  if (!isValid2)
    return false;
  const hash2 = hashMessage$1(message);
  return verifyHash(client2, {
    address: parsed.address,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
function publicActions(client2) {
  return {
    call: (args) => call(client2, args),
    createBlockFilter: () => createBlockFilter(client2),
    createContractEventFilter: (args) => createContractEventFilter(client2, args),
    createEventFilter: (args) => createEventFilter(client2, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client2),
    estimateContractGas: (args) => estimateContractGas(client2, args),
    estimateGas: (args) => estimateGas(client2, args),
    getBalance: (args) => getBalance(client2, args),
    getBlobBaseFee: () => getBlobBaseFee(client2),
    getBlock: (args) => getBlock(client2, args),
    getBlockNumber: (args) => getBlockNumber(client2, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client2, args),
    getBytecode: (args) => getCode(client2, args),
    getChainId: () => getChainId$2(client2),
    getCode: (args) => getCode(client2, args),
    getContractEvents: (args) => getContractEvents(client2, args),
    getEip712Domain: (args) => getEip712Domain(client2, args),
    getEnsAddress: (args) => getEnsAddress(client2, args),
    getEnsAvatar: (args) => getEnsAvatar(client2, args),
    getEnsName: (args) => getEnsName(client2, args),
    getEnsResolver: (args) => getEnsResolver(client2, args),
    getEnsText: (args) => getEnsText(client2, args),
    getFeeHistory: (args) => getFeeHistory(client2, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client2, args),
    getFilterChanges: (args) => getFilterChanges(client2, args),
    getFilterLogs: (args) => getFilterLogs(client2, args),
    getGasPrice: () => getGasPrice(client2),
    getLogs: (args) => getLogs(client2, args),
    getProof: (args) => getProof(client2, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client2, args),
    getStorageAt: (args) => getStorageAt(client2, args),
    getTransaction: (args) => getTransaction(client2, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client2, args),
    getTransactionCount: (args) => getTransactionCount(client2, args),
    getTransactionReceipt: (args) => getTransactionReceipt$1(client2, args),
    multicall: (args) => multicall(client2, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client2, args),
    readContract: (args) => readContract$1(client2, args),
    sendRawTransaction: (args) => sendRawTransaction(client2, args),
    simulateContract: (args) => simulateContract$1(client2, args),
    verifyMessage: (args) => verifyMessage$1(client2, args),
    verifySiweMessage: (args) => verifySiweMessage(client2, args),
    verifyTypedData: (args) => verifyTypedData$1(client2, args),
    uninstallFilter: (args) => uninstallFilter(client2, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client2, args),
    watchBlocks: (args) => watchBlocks(client2, args),
    watchBlockNumber: (args) => watchBlockNumber(client2, args),
    watchContractEvent: (args) => watchContractEvent(client2, args),
    watchEvent: (args) => watchEvent(client2, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client2, args)
  };
}
function walletActions(client2) {
  return {
    addChain: (args) => addChain(client2, args),
    deployContract: (args) => deployContract(client2, args),
    getAddresses: () => getAddresses(client2),
    getChainId: () => getChainId$2(client2),
    getPermissions: () => getPermissions(client2),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client2, args),
    requestAddresses: () => requestAddresses(client2),
    requestPermissions: (args) => requestPermissions(client2, args),
    sendRawTransaction: (args) => sendRawTransaction(client2, args),
    sendTransaction: (args) => sendTransaction$1(client2, args),
    signMessage: (args) => signMessage$1(client2, args),
    signTransaction: (args) => signTransaction(client2, args),
    signTypedData: (args) => signTypedData(client2, args),
    switchChain: (args) => switchChain$1(client2, args),
    watchAsset: (args) => watchAsset(client2, args),
    writeContract: (args) => writeContract$1(client2, args)
  };
}
const zeroAddress = "0x0000000000000000000000000000000000000000";
async function getConnectorClient(config2, parameters = {}) {
  let connection;
  if (parameters.connector) {
    const { connector: connector2 } = parameters;
    if (config2.state.status === "reconnecting" && !connector2.getAccounts && !connector2.getChainId)
      throw new ConnectorUnavailableReconnectingError({ connector: connector2 });
    const [accounts, chainId2] = await Promise.all([
      connector2.getAccounts(),
      connector2.getChainId()
    ]);
    connection = {
      accounts,
      chainId: chainId2,
      connector: connector2
    };
  } else
    connection = config2.state.connections.get(config2.state.current);
  if (!connection)
    throw new ConnectorNotConnectedError();
  const chainId = parameters.chainId ?? connection.chainId;
  const connectorChainId = await connection.connector.getChainId();
  if (connectorChainId !== connection.chainId)
    throw new ConnectorChainMismatchError({
      connectionChainId: connection.chainId,
      connectorChainId
    });
  const connector = connection.connector;
  if (connector.getClient)
    return connector.getClient({ chainId });
  const account2 = parseAccount(parameters.account ?? connection.accounts[0]);
  account2.address = getAddress$1(account2.address);
  if (parameters.account && !connection.accounts.some((x2) => x2.toLowerCase() === account2.address.toLowerCase()))
    throw new ConnectorAccountNotFoundError({
      address: account2.address,
      connector
    });
  const chain = config2.chains.find((chain2) => chain2.id === chainId);
  const provider2 = await connection.connector.getProvider({ chainId });
  return createClient({
    account: account2,
    chain,
    name: "Connector Client",
    transport: (opts) => custom(provider2)({ ...opts, retryCount: 0 })
  });
}
async function disconnect(config2, parameters = {}) {
  var _a2, _b2;
  let connector;
  if (parameters.connector)
    connector = parameters.connector;
  else {
    const { connections: connections2, current } = config2.state;
    const connection = connections2.get(current);
    connector = connection == null ? void 0 : connection.connector;
  }
  const connections = config2.state.connections;
  if (connector) {
    await connector.disconnect();
    connector.emitter.off("change", config2._internal.events.change);
    connector.emitter.off("disconnect", config2._internal.events.disconnect);
    connector.emitter.on("connect", config2._internal.events.connect);
    connections.delete(connector.uid);
  }
  config2.setState((x2) => {
    if (connections.size === 0)
      return {
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      };
    const nextConnection = connections.values().next().value;
    return {
      ...x2,
      connections: new Map(connections),
      current: nextConnection.connector.uid
    };
  });
  {
    const current = config2.state.current;
    if (!current)
      return;
    const connector2 = (_a2 = config2.state.connections.get(current)) == null ? void 0 : _a2.connector;
    if (!connector2)
      return;
    await ((_b2 = config2.storage) == null ? void 0 : _b2.setItem("recentConnectorId", connector2.id));
  }
}
function getAccount$1(config2) {
  const uid2 = config2.state.current;
  const connection = config2.state.connections.get(uid2);
  const addresses = connection == null ? void 0 : connection.accounts;
  const address = addresses == null ? void 0 : addresses[0];
  const chain = config2.chains.find((chain2) => chain2.id === (connection == null ? void 0 : connection.chainId));
  const status = config2.state.status;
  switch (status) {
    case "connected":
      return {
        address,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: !!address,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function readContract(config2, parameters) {
  const { chainId, ...rest } = parameters;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, readContract$1, "readContract");
  return action(rest);
}
function getChainId$1(config2) {
  return config2.state.chainId;
}
function deepEqual$1(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    let length;
    let i;
    if (Array.isArray(a2) && Array.isArray(b2)) {
      length = a2.length;
      if (length !== b2.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!deepEqual$1(a2[i], b2[i]))
          return false;
      return true;
    }
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    const keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key && !deepEqual$1(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
let previousChains = [];
function getChains(config2) {
  const chains2 = config2.chains;
  if (deepEqual$1(previousChains, chains2))
    return previousChains;
  previousChains = chains2;
  return chains2;
}
function getClient(config2, parameters = {}) {
  let client2 = void 0;
  try {
    client2 = config2.getClient(parameters);
  } catch {
  }
  return client2;
}
let previousConnections = [];
function getConnections(config2) {
  const connections = [...config2.state.connections.values()];
  if (config2.state.status === "reconnecting")
    return previousConnections;
  if (deepEqual$1(previousConnections, connections))
    return previousConnections;
  previousConnections = connections;
  return connections;
}
let previousConnectors = [];
function getConnectors(config2) {
  const connectors = config2.connectors;
  if (deepEqual$1(previousConnectors, connectors))
    return previousConnectors;
  previousConnectors = connectors;
  return connectors;
}
function getPublicClient(config2, parameters = {}) {
  const client2 = getClient(config2, parameters);
  return client2 == null ? void 0 : client2.extend(publicActions);
}
async function getWalletClient(config2, parameters = {}) {
  const client2 = await getConnectorClient(config2, parameters);
  client2.extend(walletActions);
  return client2.extend(walletActions);
}
let isReconnecting = false;
async function reconnect(config2, parameters = {}) {
  var _a2, _b2;
  if (isReconnecting)
    return [];
  isReconnecting = true;
  config2.setState((x2) => ({
    ...x2,
    status: x2.current ? "reconnecting" : "connecting"
  }));
  const connectors = [];
  if ((_a2 = parameters.connectors) == null ? void 0 : _a2.length) {
    for (const connector_ of parameters.connectors) {
      let connector;
      if (typeof connector_ === "function")
        connector = config2._internal.connectors.setup(connector_);
      else
        connector = connector_;
      connectors.push(connector);
    }
  } else
    connectors.push(...config2.connectors);
  let recentConnectorId;
  try {
    recentConnectorId = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem("recentConnectorId"));
  } catch {
  }
  const scores = {};
  for (const [, connection] of config2.state.connections) {
    scores[connection.connector.id] = 1;
  }
  if (recentConnectorId)
    scores[recentConnectorId] = 0;
  const sorted = Object.keys(scores).length > 0 ? (
    // .toSorted()
    [...connectors].sort((a2, b2) => (scores[a2.id] ?? 10) - (scores[b2.id] ?? 10))
  ) : connectors;
  let connected = false;
  const connections = [];
  const providers = [];
  for (const connector of sorted) {
    const provider2 = await connector.getProvider().catch(() => void 0);
    if (!provider2)
      continue;
    if (providers.some((x2) => x2 === provider2))
      continue;
    const isAuthorized = await connector.isAuthorized();
    if (!isAuthorized)
      continue;
    const data = await connector.connect({ isReconnecting: true }).catch(() => null);
    if (!data)
      continue;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    config2.setState((x2) => {
      const connections2 = new Map(connected ? x2.connections : /* @__PURE__ */ new Map()).set(connector.uid, { accounts: data.accounts, chainId: data.chainId, connector });
      return {
        ...x2,
        current: connected ? x2.current : connector.uid,
        connections: connections2
      };
    });
    connections.push({
      accounts: data.accounts,
      chainId: data.chainId,
      connector
    });
    providers.push(provider2);
    connected = true;
  }
  if (config2.state.status === "reconnecting" || config2.state.status === "connecting") {
    if (!connected)
      config2.setState((x2) => ({
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      }));
    else
      config2.setState((x2) => ({ ...x2, status: "connected" }));
  }
  isReconnecting = false;
  return connections;
}
async function sendTransaction(config2, parameters) {
  const { account: account2, chainId, connector, gas: gas_, ...rest } = parameters;
  let client2;
  if (typeof account2 === "object" && account2.type === "local")
    client2 = config2.getClient({ chainId });
  else
    client2 = await getConnectorClient(config2, { account: account2, chainId, connector });
  const { connector: activeConnector } = getAccount$1(config2);
  const gas = await (async () => {
    var _a2;
    if (!("data" in parameters) || !parameters.data)
      return void 0;
    if ((_a2 = connector ?? activeConnector) == null ? void 0 : _a2.supportsSimulation)
      return void 0;
    if (gas_ === null)
      return void 0;
    if (gas_ === void 0) {
      const action2 = getAction(client2, estimateGas, "estimateGas");
      return action2({
        ...rest,
        account: account2,
        chain: chainId ? { id: chainId } : null
      });
    }
    return gas_;
  })();
  const action = getAction(client2, sendTransaction$1, "sendTransaction");
  const hash2 = await action({
    ...rest,
    ...account2 ? { account: account2 } : {},
    gas,
    chain: chainId ? { id: chainId } : null
  });
  return hash2;
}
async function simulateContract(config2, parameters) {
  const { abi: abi2, chainId, connector, ...rest } = parameters;
  let account2;
  if (parameters.account)
    account2 = parameters.account;
  else {
    const connectorClient = await getConnectorClient(config2, {
      chainId,
      connector
    });
    account2 = connectorClient.account;
  }
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, simulateContract$1, "simulateContract");
  const { result, request } = await action({ ...rest, abi: abi2, account: account2 });
  return {
    chainId: client2.chain.id,
    result,
    request: { __mode: "prepared", ...request, chainId }
  };
}
class ProviderNotFoundError extends BaseError$1 {
  constructor() {
    super("Provider not found.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderNotFoundError"
    });
  }
}
class SwitchChainNotSupportedError extends BaseError$1 {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainNotSupportedError"
    });
  }
}
async function switchChain(config2, parameters) {
  var _a2;
  const { addEthereumChainParameter, chainId } = parameters;
  const connection = config2.state.connections.get(((_a2 = parameters.connector) == null ? void 0 : _a2.uid) ?? config2.state.current);
  if (connection) {
    const connector = connection.connector;
    if (!connector.switchChain)
      throw new SwitchChainNotSupportedError({ connector });
    const chain2 = await connector.switchChain({
      addEthereumChainParameter,
      chainId
    });
    return chain2;
  }
  const chain = config2.chains.find((x2) => x2.id === chainId);
  if (!chain)
    throw new ChainNotConfiguredError();
  config2.setState((x2) => ({ ...x2, chainId }));
  return chain;
}
function watchAccount(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getAccount$1(config2), onChange, {
    equalityFn(a2, b2) {
      const { connector: aConnector, ...aRest } = a2;
      const { connector: bConnector, ...bRest } = b2;
      return deepEqual$1(aRest, bRest) && // check connector separately
      (aConnector == null ? void 0 : aConnector.id) === (bConnector == null ? void 0 : bConnector.id) && (aConnector == null ? void 0 : aConnector.uid) === (bConnector == null ? void 0 : bConnector.uid);
    }
  });
}
function watchChainId(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe((state) => state.chainId, onChange);
}
function watchConnections(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getConnections(config2), onChange, {
    equalityFn: deepEqual$1
  });
}
function watchConnectors(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.connectors.subscribe((connectors, prevConnectors) => {
    onChange(Object.values(connectors), prevConnectors);
  });
}
function watchPublicClient(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getPublicClient(config2), onChange, {
    equalityFn(a2, b2) {
      return (a2 == null ? void 0 : a2.uid) === (b2 == null ? void 0 : b2.uid);
    }
  });
}
async function writeContract(config2, parameters) {
  const { account: account2, chainId, connector, __mode, ...rest } = parameters;
  let client2;
  if (typeof account2 === "object" && account2.type === "local")
    client2 = config2.getClient({ chainId });
  else
    client2 = await getConnectorClient(config2, { account: account2, chainId, connector });
  const { connector: activeConnector } = getAccount$1(config2);
  let request;
  if (__mode === "prepared" || (activeConnector == null ? void 0 : activeConnector.supportsSimulation))
    request = rest;
  else {
    const { request: simulateRequest } = await simulateContract(config2, {
      ...rest,
      account: account2,
      chainId
    });
    request = simulateRequest;
  }
  const action = getAction(client2, writeContract$1, "writeContract");
  const hash2 = await action({
    ...request,
    ...account2 ? { account: account2 } : {},
    chain: chainId ? { id: chainId } : null
  });
  return hash2;
}
function createConnector(createConnectorFn) {
  return createConnectorFn;
}
const supportsSimulationIdRegex = /(rabby|trustwallet)/;
const targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (window2 == null ? void 0 : window2.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(window2) {
      return findProvider(window2, (provider2) => {
        if (!provider2.isMetaMask)
          return false;
        if (provider2.isBraveWallet && !provider2._events && !provider2._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider2[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      var _a2, _b2;
      if ((_a2 = window2 == null ? void 0 : window2.phantom) == null ? void 0 : _a2.ethereum)
        return (_b2 = window2.phantom) == null ? void 0 : _b2.ethereum;
      return findProvider(window2, "isPhantom");
    }
  }
};
injected$1.type = "injected";
function injected$1(parameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      provider(window2) {
        return window2 == null ? void 0 : window2.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect2;
  let disconnect2;
  return createConnector((config2) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    get supportsSimulation() {
      return supportsSimulationIdRegex.test(this.id.toLowerCase());
    },
    type: injected$1.type,
    async setup() {
      const provider2 = await this.getProvider();
      if (provider2 && parameters.target) {
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider2.on("connect", connect2);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      var _a2, _b2, _c2, _d2, _e2, _f2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      let accounts = [];
      if (isReconnecting2)
        accounts = await this.getAccounts().catch(() => []);
      else if (shimDisconnect) {
        try {
          const permissions = await provider2.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts = (_d2 = (_c2 = (_b2 = (_a2 = permissions[0]) == null ? void 0 : _a2.caveats) == null ? void 0 : _b2[0]) == null ? void 0 : _c2.value) == null ? void 0 : _d2.map((x2) => getAddress$1(x2));
          if (accounts.length > 0) {
            const sortedAccounts = await this.getAccounts();
            accounts = sortedAccounts;
          }
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!(accounts == null ? void 0 : accounts.length) && !isReconnecting2) {
          const requestedAccounts = await provider2.request({
            method: "eth_requestAccounts"
          });
          accounts = requestedAccounts.map((x2) => getAddress$1(x2));
        }
        if (connect2) {
          provider2.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        if (shimDisconnect)
          await ((_e2 = config2.storage) == null ? void 0 : _e2.removeItem(`${this.id}.disconnected`));
        if (!parameters.target)
          await ((_f2 = config2.storage) == null ? void 0 : _f2.setItem("injected.connected", true));
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a2, _b2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
      try {
        await withTimeout(() => (
          // TODO: Remove explicit type for viem@3
          provider2.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      if (shimDisconnect) {
        await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem(`${this.id}.disconnected`, true));
      }
      if (!parameters.target)
        await ((_b2 = config2.storage) == null ? void 0 : _b2.removeItem("injected.connected"));
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const accounts = await provider2.request({ method: "eth_accounts" });
      return accounts.map((x2) => getAddress$1(x2));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const hexChainId = await provider2.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider2;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider2 = target.provider(window);
      else if (typeof target.provider === "string")
        provider2 = findProvider(window, target.provider);
      else
        provider2 = target.provider;
      if (provider2 && !provider2.removeListener) {
        if ("off" in provider2 && typeof provider2.off === "function")
          provider2.removeListener = provider2.off;
        else
          provider2.removeListener = () => {
          };
      }
      return provider2;
    },
    async isAuthorized() {
      var _a2, _b2;
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(`${this.id}.disconnected`));
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem("injected.connected"));
          if (!connected)
            return false;
        }
        const provider2 = await this.getProvider();
        if (!provider2) {
          if (unstable_shimAsyncInject !== void 0 && unstable_shimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider3 = await this.getProvider();
              return !!provider3;
            };
            const timeout = typeof unstable_shimAsyncInject === "number" ? unstable_shimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise((resolve) => window.addEventListener("ethereum#initialized", () => resolve(handleEthereum()), { once: true }))
              ] : [],
              new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout))
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError();
        }
        const accounts = await withRetry(() => this.getAccounts());
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2, _d2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          provider2.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config2.emitter.emit("change", { chainId });
          }),
          new Promise((resolve) => config2.emitter.once("change", ({ chainId: currentChainId }) => {
            if (currentChainId === chainId)
              resolve();
          }))
        ]);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b2 = (_a2 = error == null ? void 0 : error.data) == null ? void 0 : _a2.originalError) == null ? void 0 : _b2.code) === 4902) {
          try {
            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x2) => x2.url)
              ];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            const currentChainId = await this.getChainId();
            if (currentChainId !== chainId)
              throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts) {
      var _a2;
      if (accounts.length === 0)
        this.onDisconnect();
      else if (config2.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await ((_a2 = config2.storage) == null ? void 0 : _a2.removeItem(`${this.id}.disconnected`));
      } else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress$1(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config2.emitter.emit("connect", { accounts, chainId });
      const provider2 = await this.getProvider();
      if (provider2) {
        if (connect2) {
          provider2.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
      }
    },
    async onDisconnect(error) {
      const provider2 = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider2 && !!(await this.getAccounts()).length)
          return;
      }
      config2.emitter.emit("disconnect");
      if (provider2) {
        if (chainChanged) {
          provider2.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider2.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider2.on("connect", connect2);
        }
      }
    }
  }));
}
function findProvider(window2, select) {
  function isProvider(provider2) {
    if (typeof select === "function")
      return select(provider2);
    if (typeof select === "string")
      return provider2[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum == null ? void 0 : ethereum.providers)
    return ethereum.providers.find((provider2) => isProvider(provider2));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}
function requestProviders(listener) {
  if (typeof window === "undefined")
    return;
  const handler = (event) => listener(event.detail);
  window.addEventListener("eip6963:announceProvider", handler);
  window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
  return () => window.removeEventListener("eip6963:announceProvider", handler);
}
function createStore$1() {
  const listeners = /* @__PURE__ */ new Set();
  let providerDetails = [];
  const request = () => requestProviders((providerDetail) => {
    if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
      return;
    providerDetails = [...providerDetails, providerDetail];
    listeners.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
  });
  let unwatch = request();
  return {
    _listeners() {
      return listeners;
    },
    clear() {
      listeners.forEach((listener) => listener([], { removed: [...providerDetails] }));
      providerDetails = [];
    },
    destroy() {
      this.clear();
      listeners.clear();
      unwatch == null ? void 0 : unwatch();
    },
    findProvider({ rdns }) {
      return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
    },
    getProviders() {
      return providerDetails;
    },
    reset() {
      this.clear();
      unwatch == null ? void 0 : unwatch();
      unwatch = request();
    },
    subscribe(listener, { emitImmediately } = {}) {
      listeners.add(listener);
      if (emitImmediately)
        listener(providerDetails, { added: providerDetails });
      return () => listeners.delete(listener);
    }
  };
}
const __vite_import_meta_env__$1 = { "BASE_URL": "./", "DEV": false, "MODE": "production", "PROD": true, "SSR": false };
const subscribeWithSelectorImpl = (fn) => (set, get2, api2) => {
  const origSubscribe = api2.subscribe;
  api2.subscribe = (selector2, optListener, options) => {
    let listener = selector2;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector2(api2.getState());
      listener = (state) => {
        const nextSlice = selector2(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get2, api2);
  return initialState;
};
const subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name2) => {
      var _a2;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0);
      };
      const str = (_a2 = storage.getItem(name2)) != null ? _a2 : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name2, newValue) => storage.setItem(
      name2,
      JSON.stringify(newValue, void 0)
    ),
    removeItem: (name2) => storage.removeItem(name2)
  };
  return persistStorage;
}
const toThenable = (fn) => (input2) => {
  try {
    const result = fn(input2);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const oldImpl = (config2, baseOptions) => (set, get2, api2) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e2) {
  }
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get2,
      api2
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get2() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e2) => {
      errorInSync = e2;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api2.setState;
  api2.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get2,
    api2
  );
  let stateFromStorage;
  const hydrate2 = () => {
    var _a2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => cb2(get2()));
    const postRehydrationCallback = ((_a2 = options.onRehydrateStorage) == null ? void 0 : _a2.call(options, get2())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get2()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api2.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  hydrate2();
  return stateFromStorage || configResult;
};
const newImpl = (config2, baseOptions) => (set, get2, api2) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get2,
      api2
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get2() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api2.setState;
  api2.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get2,
    api2
  );
  let stateFromStorage;
  const hydrate2 = () => {
    var _a2, _b2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => {
      var _a22;
      return cb2((_a22 = get2()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b2 = options.onRehydrateStorage) == null ? void 0 : _b2.call(options, (_a2 = get2()) != null ? _a2 : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get2()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get2();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api2.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate2();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config2, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config2, baseOptions);
  }
  return newImpl(config2, baseOptions);
};
const persist = persistImpl;
const __vite_import_meta_env__ = { "BASE_URL": "./", "DEV": false, "MODE": "production", "PROD": true, "SSR": false };
const createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((__vite_import_meta_env__ ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api2 = { setState, getState: getState2, subscribe, destroy };
  state = createState2(setState, getState2, api2);
  return api2;
};
const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
var eventemitter3 = { exports: {} };
(function(module2) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context2, once) {
    this.fn = fn;
    this.context = context2;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context2, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names2 = [], events, name2;
    if (this._eventsCount === 0) return names2;
    for (name2 in events = this._events) {
      if (has.call(events, name2)) names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j2;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
              args[j2 - 1] = arguments[j2];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context2) {
    return addListener(this, event, fn, context2, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context2) {
    return addListener(this, event, fn, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
          events.push(listeners[i]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports);
class Emitter {
  constructor(uid2) {
    Object.defineProperty(this, "uid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: uid2
    });
    Object.defineProperty(this, "_emitter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new EventEmitter()
    });
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, ...params) {
    const data = params[0];
    this._emitter.emit(eventName, { uid: this.uid, ...data });
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
}
function createEmitter(uid2) {
  return new Emitter(uid2);
}
function deserialize(value, reviver) {
  return JSON.parse(value, (key, value_) => {
    let value2 = value_;
    if ((value2 == null ? void 0 : value2.__type) === "bigint")
      value2 = BigInt(value2.value);
    if ((value2 == null ? void 0 : value2.__type) === "Map")
      value2 = new Map(value2.value);
    return (reviver == null ? void 0 : reviver(key, value2)) ?? value2;
  });
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length } = array;
  for (let index2 = 0; index2 < length; ++index2) {
    if (array[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache2 = [];
  const keys = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache2.length) {
        const thisCutoff = getCutoff(cache2, this);
        if (thisCutoff === 0) {
          cache2[cache2.length] = this;
        } else {
          cache2.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key;
        const valueCutoff = getCutoff(cache2, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache2[0] = value;
        keys[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer((key, value_) => {
    let value2 = value_;
    if (typeof value2 === "bigint")
      value2 = { __type: "bigint", value: value_.toString() };
    if (value2 instanceof Map)
      value2 = { __type: "Map", value: Array.from(value_.entries()) };
    return (replacer == null ? void 0 : replacer(key, value2)) ?? value2;
  }, circularReplacer), indent ?? void 0);
}
function createStorage(parameters) {
  const { deserialize: deserialize$1 = deserialize, key: prefix = "wagmi", serialize: serialize$1 = serialize, storage = noopStorage } = parameters;
  function unwrap2(value) {
    if (value instanceof Promise)
      return value.then((x2) => x2).catch(() => null);
    return value;
  }
  return {
    ...storage,
    key: prefix,
    async getItem(key, defaultValue) {
      const value = storage.getItem(`${prefix}.${key}`);
      const unwrapped = await unwrap2(value);
      if (unwrapped)
        return deserialize$1(unwrapped) ?? null;
      return defaultValue ?? null;
    },
    async setItem(key, value) {
      const storageKey2 = `${prefix}.${key}`;
      if (value === null)
        await unwrap2(storage.removeItem(storageKey2));
      else
        await unwrap2(storage.setItem(storageKey2, serialize$1(value)));
    },
    async removeItem(key) {
      await unwrap2(storage.removeItem(`${prefix}.${key}`));
    }
  };
}
const noopStorage = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
};
const size$3 = 256;
let index$7 = size$3;
let buffer$1;
function uid(length = 11) {
  if (!buffer$1 || index$7 + length > size$3 * 2) {
    buffer$1 = "";
    index$7 = 0;
    for (let i = 0; i < size$3; i++) {
      buffer$1 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$1.substring(index$7, index$7++ + length);
}
function createConfig$1(parameters) {
  const { multiInjectedProviderDiscovery = true, storage = createStorage({
    storage: typeof window !== "undefined" && window.localStorage ? window.localStorage : noopStorage
  }), syncConnectedChain = true, ssr = false, ...rest } = parameters;
  const mipd = typeof window !== "undefined" && multiInjectedProviderDiscovery ? createStore$1() : void 0;
  const chains2 = createStore(() => rest.chains);
  const connectors = createStore(() => [
    ...rest.connectors ?? [],
    ...!ssr ? (mipd == null ? void 0 : mipd.getProviders().map(providerDetailToConnector)) ?? [] : []
  ].map(setup));
  function setup(connectorFn) {
    var _a2;
    const emitter = createEmitter(uid());
    const connector = {
      ...connectorFn({
        emitter,
        chains: chains2.getState(),
        storage,
        transports: rest.transports
      }),
      emitter,
      uid: emitter.uid
    };
    emitter.on("connect", connect2);
    (_a2 = connector.setup) == null ? void 0 : _a2.call(connector);
    return connector;
  }
  function providerDetailToConnector(providerDetail) {
    const { info } = providerDetail;
    const provider2 = providerDetail.provider;
    return injected$1({ target: { ...info, id: info.rdns, provider: provider2 } });
  }
  const clients = /* @__PURE__ */ new Map();
  function getClient2(config2 = {}) {
    const chainId = config2.chainId ?? store.getState().chainId;
    const chain = chains2.getState().find((x2) => x2.id === chainId);
    if (config2.chainId && !chain)
      throw new ChainNotConfiguredError();
    {
      const client3 = clients.get(store.getState().chainId);
      if (client3 && !chain)
        return client3;
      if (!chain)
        throw new ChainNotConfiguredError();
    }
    {
      const client3 = clients.get(chainId);
      if (client3)
        return client3;
    }
    let client2;
    if (rest.client)
      client2 = rest.client({ chain });
    else {
      const chainId2 = chain.id;
      const chainIds = chains2.getState().map((x2) => x2.id);
      const properties = {};
      const entries = Object.entries(rest);
      for (const [key, value] of entries) {
        if (key === "chains" || key === "client" || key === "connectors" || key === "transports")
          continue;
        if (typeof value === "object") {
          if (chainId2 in value)
            properties[key] = value[chainId2];
          else {
            const hasChainSpecificValue = chainIds.some((x2) => x2 in value);
            if (hasChainSpecificValue)
              continue;
            properties[key] = value;
          }
        } else
          properties[key] = value;
      }
      client2 = createClient({
        ...properties,
        chain,
        batch: properties.batch ?? { multicall: true },
        transport: (parameters2) => rest.transports[chainId2]({ ...parameters2, connectors })
      });
    }
    clients.set(chainId, client2);
    return client2;
  }
  function getInitialState() {
    return {
      chainId: chains2.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: null,
      status: "disconnected"
    };
  }
  let currentVersion;
  const prefix = "0.0.0-canary-";
  if (version$7.startsWith(prefix))
    currentVersion = Number.parseInt(version$7.replace(prefix, ""));
  else
    currentVersion = Number.parseInt(version$7.split(".")[0] ?? "0");
  const store = createStore(subscribeWithSelector(
    // only use persist middleware if storage exists
    storage ? persist(getInitialState, {
      migrate(persistedState, version2) {
        if (version2 === currentVersion)
          return persistedState;
        const initialState = getInitialState();
        const chainId = validatePersistedChainId(persistedState, initialState.chainId);
        return { ...initialState, chainId };
      },
      name: "store",
      partialize(state) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(state.connections.entries()).map(([key, connection]) => {
              const { id: id2, name: name2, type, uid: uid2 } = connection.connector;
              const connector = { id: id2, name: name2, type, uid: uid2 };
              return [key, { ...connection, connector }];
            })
          },
          chainId: state.chainId,
          current: state.current
        };
      },
      merge(persistedState, currentState) {
        if (typeof persistedState === "object" && persistedState && "status" in persistedState)
          delete persistedState.status;
        const chainId = validatePersistedChainId(persistedState, currentState.chainId);
        return {
          ...currentState,
          ...persistedState,
          chainId
        };
      },
      skipHydration: ssr,
      storage,
      version: currentVersion
    }) : getInitialState
  ));
  function validatePersistedChainId(persistedState, defaultChainId) {
    return persistedState && typeof persistedState === "object" && "chainId" in persistedState && typeof persistedState.chainId === "number" && chains2.getState().some((x2) => x2.id === persistedState.chainId) ? persistedState.chainId : defaultChainId;
  }
  if (syncConnectedChain)
    store.subscribe(({ connections, current }) => {
      var _a2;
      return current ? (_a2 = connections.get(current)) == null ? void 0 : _a2.chainId : void 0;
    }, (chainId) => {
      const isChainConfigured = chains2.getState().some((x2) => x2.id === chainId);
      if (!isChainConfigured)
        return;
      return store.setState((x2) => ({
        ...x2,
        chainId: chainId ?? x2.chainId
      }));
    });
  mipd == null ? void 0 : mipd.subscribe((providerDetails) => {
    const currentConnectorIds = /* @__PURE__ */ new Map();
    for (const connector of connectors.getState()) {
      currentConnectorIds.set(connector.id, true);
    }
    const newConnectors = [];
    for (const providerDetail of providerDetails) {
      const connector = setup(providerDetailToConnector(providerDetail));
      if (currentConnectorIds.has(connector.id))
        continue;
      newConnectors.push(connector);
    }
    if (storage && !store.persist.hasHydrated())
      return;
    connectors.setState((x2) => [...x2, ...newConnectors], true);
  });
  function change(data) {
    store.setState((x2) => {
      const connection = x2.connections.get(data.uid);
      if (!connection)
        return x2;
      return {
        ...x2,
        connections: new Map(x2.connections).set(data.uid, {
          accounts: data.accounts ?? connection.accounts,
          chainId: data.chainId ?? connection.chainId,
          connector: connection.connector
        })
      };
    });
  }
  function connect2(data) {
    if (store.getState().status === "connecting" || store.getState().status === "reconnecting")
      return;
    store.setState((x2) => {
      const connector = connectors.getState().find((x3) => x3.uid === data.uid);
      if (!connector)
        return x2;
      if (connector.emitter.listenerCount("connect"))
        connector.emitter.off("connect", change);
      if (!connector.emitter.listenerCount("change"))
        connector.emitter.on("change", change);
      if (!connector.emitter.listenerCount("disconnect"))
        connector.emitter.on("disconnect", disconnect2);
      return {
        ...x2,
        connections: new Map(x2.connections).set(data.uid, {
          accounts: data.accounts,
          chainId: data.chainId,
          connector
        }),
        current: data.uid,
        status: "connected"
      };
    });
  }
  function disconnect2(data) {
    store.setState((x2) => {
      const connection = x2.connections.get(data.uid);
      if (connection) {
        const connector = connection.connector;
        if (connector.emitter.listenerCount("change"))
          connection.connector.emitter.off("change", change);
        if (connector.emitter.listenerCount("disconnect"))
          connection.connector.emitter.off("disconnect", disconnect2);
        if (!connector.emitter.listenerCount("connect"))
          connection.connector.emitter.on("connect", connect2);
      }
      x2.connections.delete(data.uid);
      if (x2.connections.size === 0)
        return {
          ...x2,
          connections: /* @__PURE__ */ new Map(),
          current: null,
          status: "disconnected"
        };
      const nextConnection = x2.connections.values().next().value;
      return {
        ...x2,
        connections: new Map(x2.connections),
        current: nextConnection.connector.uid
      };
    });
  }
  return {
    get chains() {
      return chains2.getState();
    },
    get connectors() {
      return connectors.getState();
    },
    storage,
    getClient: getClient2,
    get state() {
      return store.getState();
    },
    setState(value) {
      let newState;
      if (typeof value === "function")
        newState = value(store.getState());
      else
        newState = value;
      const initialState = getInitialState();
      if (typeof newState !== "object")
        newState = initialState;
      const isCorrupt = Object.keys(initialState).some((x2) => !(x2 in newState));
      if (isCorrupt)
        newState = initialState;
      store.setState(newState, true);
    },
    subscribe(selector2, listener, options) {
      return store.subscribe(selector2, listener, options ? {
        ...options,
        fireImmediately: options.emitImmediately
        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`
      } : void 0);
    },
    _internal: {
      mipd,
      store,
      ssr: Boolean(ssr),
      syncConnectedChain,
      transports: rest.transports,
      chains: {
        setState(value) {
          const nextChains = typeof value === "function" ? value(chains2.getState()) : value;
          if (nextChains.length === 0)
            return;
          return chains2.setState(nextChains, true);
        },
        subscribe(listener) {
          return chains2.subscribe(listener);
        }
      },
      connectors: {
        providerDetailToConnector,
        setup,
        setState(value) {
          return connectors.setState(typeof value === "function" ? value(connectors.getState()) : value, true);
        },
        subscribe(listener) {
          return connectors.subscribe(listener);
        }
      },
      events: { change, connect: connect2, disconnect: disconnect2 }
    }
  };
}
function hydrate(config2, parameters) {
  const { initialState, reconnectOnMount } = parameters;
  if (initialState && !config2._internal.store.persist.hasHydrated())
    config2.setState({
      ...initialState,
      chainId: config2.chains.some((x2) => x2.id === initialState.chainId) ? initialState.chainId : config2.chains[0].id,
      connections: reconnectOnMount ? initialState.connections : /* @__PURE__ */ new Map(),
      status: reconnectOnMount ? "reconnecting" : "disconnected"
    });
  return {
    async onMount() {
      var _a2;
      if (config2._internal.ssr) {
        await config2._internal.store.persist.rehydrate();
        const mipdConnectors = (_a2 = config2._internal.mipd) == null ? void 0 : _a2.getProviders().map(config2._internal.connectors.providerDetailToConnector).map(config2._internal.connectors.setup);
        config2._internal.connectors.setState((connectors) => [
          ...connectors,
          ...mipdConnectors ?? []
        ]);
      }
      if (reconnectOnMount)
        reconnect(config2);
      else if (config2.storage)
        config2.setState((x2) => ({
          ...x2,
          connections: /* @__PURE__ */ new Map()
        }));
    }
  };
}
function extractRpcUrls(parameters) {
  var _a2, _b2, _c2;
  const { chain } = parameters;
  const fallbackUrl = chain.rpcUrls.default.http[0];
  if (!parameters.transports)
    return [fallbackUrl];
  const transport = (_b2 = (_a2 = parameters.transports) == null ? void 0 : _a2[chain.id]) == null ? void 0 : _b2.call(_a2, { chain });
  const transports = ((_c2 = transport == null ? void 0 : transport.value) == null ? void 0 : _c2.transports) || [transport];
  return transports.map(({ value }) => (value == null ? void 0 : value.url) || fallbackUrl);
}
function Hydrate(parameters) {
  const { children, config: config2, initialState, reconnectOnMount = true } = parameters;
  const { onMount } = hydrate(config2, {
    initialState,
    reconnectOnMount
  });
  if (!config2._internal.ssr)
    onMount();
  const active = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (!active.current)
      return;
    if (!config2._internal.ssr)
      return;
    onMount();
    return () => {
      active.current = false;
    };
  }, []);
  return children;
}
const WagmiContext = reactExports.createContext(void 0);
function WagmiProvider(parameters) {
  const { children, config: config2 } = parameters;
  const props = { value: config2 };
  return reactExports.createElement(Hydrate, parameters, reactExports.createElement(WagmiContext.Provider, props, children));
}
const version$6 = "2.12.12";
const getVersion = () => `wagmi@${version$6}`;
class BaseError4 extends BaseError$1 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return getVersion();
  }
}
class WagmiProviderNotFoundError extends BaseError4 {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiProviderNotFoundError"
    });
  }
}
function useConfig(parameters = {}) {
  const config2 = parameters.config ?? reactExports.useContext(WagmiContext);
  if (!config2)
    throw new WagmiProviderNotFoundError();
  return config2;
}
function watchChains(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.chains.subscribe((chains2, prevChains) => {
    onChange(chains2, prevChains);
  });
}
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$1 = reactExports;
function h$2(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$1 = "function" === typeof Object.is ? Object.is : h$2, l$1 = e$1.useState, m$1 = e$1.useEffect, n$3 = e$1.useLayoutEffect, p$2 = e$1.useDebugValue;
function q$2(a2, b2) {
  var d2 = b2(), f2 = l$1({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$3(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$2(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$1(function() {
    r$2(c2) && g2({ inst: c2 });
    return a2(function() {
      r$2(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$2(d2);
  return d2;
}
function r$2(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$1(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$2(a2, b2) {
  return b2();
}
var u$2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$2 : q$2;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$1.useSyncExternalStore ? e$1.useSyncExternalStore : u$2;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$1 = reactExports, n$2 = shimExports;
function p$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$1 = "function" === typeof Object.is ? Object.is : p$1, r$1 = n$2.useSyncExternalStore, t$1 = h$1.useRef, u$1 = h$1.useEffect, v$1 = h$1.useMemo, w = h$1.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$1(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else f2 = c2.current;
  c2 = v$1(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4)) return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$1(d3, a4)) return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3)) return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$1(a2, c2[0], c2[1]);
  u$1(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
const isPlainObject$1 = (obj) => typeof obj === "object" && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe, getSnapshot, getServerSnapshot = getSnapshot, isEqual = deepEqual$1) {
  const trackedKeys = reactExports.useRef([]);
  const result = withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, (x2) => x2, (a2, b2) => {
    if (isPlainObject$1(a2) && isPlainObject$1(b2) && trackedKeys.current.length) {
      for (const key of trackedKeys.current) {
        const equal = isEqual(a2[key], b2[key]);
        if (!equal)
          return false;
      }
      return true;
    }
    return isEqual(a2, b2);
  });
  if (isPlainObject$1(result)) {
    const trackedResult = { ...result };
    let properties = {};
    for (const [key, value] of Object.entries(trackedResult)) {
      properties = {
        ...properties,
        [key]: {
          configurable: false,
          enumerable: true,
          get: () => {
            if (!trackedKeys.current.includes(key)) {
              trackedKeys.current.push(key);
            }
            return value;
          }
        }
      };
    }
    Object.defineProperties(trackedResult, properties);
    return trackedResult;
  }
  return result;
}
function useAccount(parameters = {}) {
  const config2 = useConfig(parameters);
  return useSyncExternalStoreWithTracked((onChange) => watchAccount(config2, { onChange }), () => getAccount$1(config2));
}
function structuralSharing(oldData, newData) {
  if (deepEqual$1(oldData, newData))
    return oldData;
  return replaceEqualDeep(oldData, newData);
}
function hashFn(queryKey) {
  return JSON.stringify(queryKey, (_, value) => {
    if (isPlainObject(value))
      return Object.keys(value).sort().reduce((result, key) => {
        result[key] = value[key];
        return result;
      }, {});
    if (typeof value === "bigint")
      return value.toString();
    return value;
  });
}
function isPlainObject(value) {
  if (!hasObjectPrototype(value)) {
    return false;
  }
  const ctor = value.constructor;
  if (typeof ctor === "undefined")
    return true;
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot))
    return false;
  if (!prot.hasOwnProperty("isPrototypeOf"))
    return false;
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function filterQueryOptions(options) {
  const {
    // import('@tanstack/query-core').QueryOptions
    _defaulted,
    behavior,
    gcTime,
    initialData,
    initialDataUpdatedAt,
    maxPages,
    meta,
    networkMode,
    queryFn,
    queryHash,
    queryKey,
    queryKeyHashFn,
    retry,
    retryDelay,
    structuralSharing: structuralSharing2,
    // import('@tanstack/query-core').InfiniteQueryObserverOptions
    getPreviousPageParam: getPreviousPageParam2,
    getNextPageParam: getNextPageParam2,
    initialPageParam,
    // import('@tanstack/react-query').UseQueryOptions
    _optimisticResults,
    enabled,
    notifyOnChangeProps,
    placeholderData,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retryOnMount,
    select,
    staleTime,
    suspense,
    throwOnError,
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // wagmi
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    config: config2,
    connector,
    query,
    ...rest
  } = options;
  return rest;
}
function connectMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return connect(config2, variables);
    },
    mutationKey: ["connect"]
  };
}
function disconnectMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return disconnect(config2, variables);
    },
    mutationKey: ["disconnect"]
  };
}
function getWalletClientQueryOptions(config2, options = {}) {
  return {
    gcTime: 0,
    async queryFn({ queryKey }) {
      const { connector } = options;
      const { connectorUid: _, scopeKey: _s2, ...parameters } = queryKey[1];
      return getWalletClient(config2, { ...parameters, connector });
    },
    queryKey: getWalletClientQueryKey(options)
  };
}
function getWalletClientQueryKey(options = {}) {
  const { connector, ...parameters } = options;
  return [
    "walletClient",
    { ...filterQueryOptions(parameters), connectorUid: connector == null ? void 0 : connector.uid }
  ];
}
function readContractQueryOptions(config2, options = {}) {
  return {
    // TODO: Support `signal` once Viem actions allow passthrough
    // https://tkdodo.eu/blog/why-you-want-react-query#bonus-cancellation
    async queryFn({ queryKey }) {
      const abi2 = options.abi;
      if (!abi2)
        throw new Error("abi is required");
      const { functionName, scopeKey: _, ...parameters } = queryKey[1];
      const addressOrCodeParams = (() => {
        const params = queryKey[1];
        if (params.address)
          return { address: params.address };
        if (params.code)
          return { code: params.code };
        throw new Error("address or code is required");
      })();
      if (!functionName)
        throw new Error("functionName is required");
      return readContract(config2, {
        abi: abi2,
        functionName,
        args: parameters.args,
        ...addressOrCodeParams,
        ...parameters
      });
    },
    queryKey: readContractQueryKey(options)
  };
}
function readContractQueryKey(options = {}) {
  const { abi: _, ...rest } = options;
  return ["readContract", filterQueryOptions(rest)];
}
function sendTransactionMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return sendTransaction(config2, variables);
    },
    mutationKey: ["sendTransaction"]
  };
}
function switchChainMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return switchChain(config2, variables);
    },
    mutationKey: ["switchChain"]
  };
}
function writeContractMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return writeContract(config2, variables);
    },
    mutationKey: ["writeContract"]
  };
}
function useQuery(parameters) {
  const result = useQuery$1({
    ...parameters,
    queryKeyHashFn: hashFn
    // for bigint support
  });
  result.queryKey = parameters.queryKey;
  return result;
}
function useChainId(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchChainId(config2, { onChange }), () => getChainId$1(config2), () => getChainId$1(config2));
}
function useChains(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchChains(config2, { onChange }), () => getChains(config2), () => getChains(config2));
}
function useConnectors(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchConnectors(config2, { onChange }), () => getConnectors(config2), () => getConnectors(config2));
}
function useConnect(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = connectMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  reactExports.useEffect(() => {
    return config2.subscribe(({ status }) => status, (status, previousStatus) => {
      if (previousStatus === "connected" && status === "disconnected")
        result.reset();
    });
  }, [config2, result.reset]);
  return {
    ...result,
    connect: mutate,
    connectAsync: mutateAsync,
    connectors: useConnectors({ config: config2 })
  };
}
function useConnections(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchConnections(config2, { onChange }), () => getConnections(config2), () => getConnections(config2));
}
function useDisconnect(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = disconnectMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    connectors: useConnections({ config: config2 }).map((connection) => connection.connector),
    disconnect: mutate,
    disconnectAsync: mutateAsync
  };
}
function usePublicClient(parameters = {}) {
  const config2 = useConfig(parameters);
  return withSelectorExports.useSyncExternalStoreWithSelector((onChange) => watchPublicClient(config2, { onChange }), () => getPublicClient(config2, parameters), () => getPublicClient(config2, parameters), (x2) => x2, (a2, b2) => (a2 == null ? void 0 : a2.uid) === (b2 == null ? void 0 : b2.uid));
}
function useReadContract(parameters = {}) {
  const { abi: abi2, address, functionName, query = {} } = parameters;
  const code2 = parameters.code;
  const config2 = useConfig(parameters);
  const chainId = useChainId({ config: config2 });
  const options = readContractQueryOptions(config2, { ...parameters, chainId: parameters.chainId ?? chainId });
  const enabled = Boolean((address || code2) && abi2 && functionName && (query.enabled ?? true));
  return useQuery({
    ...query,
    ...options,
    enabled,
    structuralSharing: query.structuralSharing ?? structuralSharing
  });
}
function useSendTransaction(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = sendTransactionMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    sendTransaction: mutate,
    sendTransactionAsync: mutateAsync
  };
}
function useSwitchChain(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = switchChainMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    chains: useChains({ config: config2 }),
    switchChain: mutate,
    switchChainAsync: mutateAsync
  };
}
function useWalletClient(parameters = {}) {
  const { query = {}, ...rest } = parameters;
  const config2 = useConfig(rest);
  const queryClient = useQueryClient();
  const { address, connector, status } = useAccount({ config: config2 });
  const chainId = useChainId({ config: config2 });
  const activeConnector = parameters.connector ?? connector;
  const { queryKey, ...options } = getWalletClientQueryOptions(config2, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
    connector: parameters.connector ?? connector
  });
  const enabled = Boolean((status === "connected" || status === "reconnecting" && (activeConnector == null ? void 0 : activeConnector.getProvider)) && (query.enabled ?? true));
  const addressRef = reactExports.useRef(address);
  reactExports.useEffect(() => {
    const previousAddress = addressRef.current;
    if (!address && previousAddress) {
      queryClient.removeQueries({ queryKey });
      addressRef.current = void 0;
    } else if (address !== previousAddress) {
      queryClient.invalidateQueries({ queryKey });
      addressRef.current = address;
    }
  }, [address, queryClient]);
  return useQuery({
    ...query,
    ...options,
    queryKey,
    enabled,
    staleTime: Number.POSITIVE_INFINITY
  });
}
function useWriteContract(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = writeContractMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    writeContract: mutate,
    writeContractAsync: mutateAsync
  };
}
const abi$7 = [{
  inputs: [{
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getAlternativeSignature",
  outputs: [{
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var erc5719 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$7
});
const abi$6 = [{
  type: "function",
  name: "isValidSignature",
  constant: true,
  inputs: [{
    type: "bytes32"
  }, {
    type: "bytes"
  }],
  outputs: [{
    type: "bytes4"
  }],
  payable: false,
  stateMutability: "view"
}];
const returns = {
  isValidSignatureBytes32: "0x1626ba7e"
};
var erc1271 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$6,
  returns
});
const abi$5 = [{
  inputs: [{
    internalType: "bytes",
    name: "error",
    type: "bytes"
  }],
  name: "ERC1271Revert",
  type: "error"
}, {
  inputs: [{
    internalType: "bytes",
    name: "error",
    type: "bytes"
  }],
  name: "ERC6492DeployFailed",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSig",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }, {
    internalType: "bool",
    name: "allowSideEffects",
    type: "bool"
  }, {
    internalType: "bool",
    name: "deployAlreadyDeployed",
    type: "bool"
  }],
  name: "isValidSigImpl",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSigNoThrow",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSigWithSideEffects",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSigWithSideEffectsNoThrow",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}];
var erc6492 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$5
});
const abi$4 = [{
  type: "function",
  name: "deploy",
  constant: false,
  inputs: [{
    type: "address"
  }, {
    type: "bytes32"
  }],
  outputs: [],
  payable: true,
  stateMutability: "payable"
}];
var factory = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$4
});
const abi$3 = [{
  type: "function",
  name: "nonce",
  constant: true,
  inputs: [],
  outputs: [{
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view"
}, {
  type: "function",
  name: "readNonce",
  constant: true,
  inputs: [{
    type: "uint256"
  }],
  outputs: [{
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view"
}, {
  type: "function",
  name: "updateImplementation",
  constant: false,
  inputs: [{
    type: "address"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "selfExecute",
  constant: false,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "execute",
  constant: false,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }, {
    type: "uint256"
  }, {
    type: "bytes"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "createContract",
  inputs: [{
    type: "bytes"
  }],
  payable: true,
  stateMutability: "payable"
}, {
  type: "function",
  name: "setExtraImageHash",
  constant: false,
  inputs: [{
    type: "bytes32",
    name: "imageHash"
  }, {
    type: "uint256",
    name: "expiration"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}];
var mainModule = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$3
});
const abi$2 = [{
  type: "function",
  name: "updateImageHash",
  constant: true,
  inputs: [{
    type: "bytes32"
  }],
  outputs: [],
  payable: false,
  stateMutability: "view"
}, {
  type: "function",
  name: "imageHash",
  constant: true,
  inputs: [],
  outputs: [{
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view"
}];
var mainModuleUpgradable = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$2
});
const abi$1$1 = [{
  inputs: [{
    internalType: "address",
    name: "_factory",
    type: "address"
  }, {
    internalType: "address",
    name: "_mainModule",
    type: "address"
  }],
  stateMutability: "nonpayable",
  type: "constructor"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    indexed: true,
    internalType: "bytes32",
    name: "_imageHash",
    type: "bytes32"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "_threshold",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "bytes",
    name: "_signers",
    type: "bytes"
  }],
  name: "RequiredConfig",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "_signer",
    type: "address"
  }],
  name: "RequiredSigner",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callBalanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callBlockNumber",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "_i",
    type: "uint256"
  }],
  name: "callBlockhash",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callChainId",
  outputs: [{
    internalType: "uint256",
    name: "id",
    type: "uint256"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callCode",
  outputs: [{
    internalType: "bytes",
    name: "code",
    type: "bytes"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callCodeHash",
  outputs: [{
    internalType: "bytes32",
    name: "codeHash",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callCodeSize",
  outputs: [{
    internalType: "uint256",
    name: "size",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callCoinbase",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callDifficulty",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callGasLeft",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callGasLimit",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callGasPrice",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callOrigin",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callTimestamp",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "knownImageHashes",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  name: "lastImageHashUpdate",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "lastSignerUpdate",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "lastWalletUpdate",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    components: [{
      internalType: "bool",
      name: "delegateCall",
      type: "bool"
    }, {
      internalType: "bool",
      name: "revertOnError",
      type: "bool"
    }, {
      internalType: "uint256",
      name: "gasLimit",
      type: "uint256"
    }, {
      internalType: "address",
      name: "target",
      type: "address"
    }, {
      internalType: "uint256",
      name: "value",
      type: "uint256"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct IModuleCalls.Transaction[]",
    name: "_txs",
    type: "tuple[]"
  }],
  name: "multiCall",
  outputs: [{
    internalType: "bool[]",
    name: "_successes",
    type: "bool[]"
  }, {
    internalType: "bytes[]",
    name: "_results",
    type: "bytes[]"
  }],
  stateMutability: "payable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_threshold",
    type: "uint256"
  }, {
    components: [{
      internalType: "uint256",
      name: "weight",
      type: "uint256"
    }, {
      internalType: "address",
      name: "signer",
      type: "address"
    }],
    internalType: "struct RequireUtils.Member[]",
    name: "_members",
    type: "tuple[]"
  }, {
    internalType: "bool",
    name: "_index",
    type: "bool"
  }],
  name: "publishConfig",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "uint256",
    name: "_sizeMembers",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }, {
    internalType: "bool",
    name: "_index",
    type: "bool"
  }],
  name: "publishInitialSigners",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_nonce",
    type: "uint256"
  }],
  name: "requireMinNonce",
  outputs: [],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "_expiration",
    type: "uint256"
  }],
  name: "requireNonExpired",
  outputs: [],
  stateMutability: "view",
  type: "function"
}];
var sequenceUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$1$1
});
const abi$8 = [{
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "requireFreshSigner",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var requireFreshSigner = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$8
});
const walletContracts = {
  erc6492,
  erc5719,
  erc1271,
  factory,
  mainModule,
  mainModuleUpgradable,
  sequenceUtils,
  requireFreshSigner
};
const abi$1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  walletContracts
}, Symbol.toStringTag, { value: "Module" }));
function _extends$h() {
  return _extends$h = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$h.apply(null, arguments);
}
const WebRPCVersion$3 = "v1";
const WebRPCSchemaVersion$3 = "v0.4.0";
const WebRPCSchemaHash$3 = "470a0f88ea399c2a57ff8c22da54358c033ed5f0";
let SortOrder$2 = /* @__PURE__ */ function(SortOrder2) {
  SortOrder2["DESC"] = "DESC";
  SortOrder2["ASC"] = "ASC";
  return SortOrder2;
}({});
let SardinePaymentType = /* @__PURE__ */ function(SardinePaymentType2) {
  SardinePaymentType2["ach"] = "ach";
  SardinePaymentType2["debit"] = "debit";
  SardinePaymentType2["credit"] = "credit";
  SardinePaymentType2["us_debit"] = "us_debit";
  SardinePaymentType2["international_debit"] = "international_debit";
  SardinePaymentType2["international_credit"] = "international_credit";
  return SardinePaymentType2;
}({});
let SardineQuoteType = /* @__PURE__ */ function(SardineQuoteType2) {
  SardineQuoteType2["buy"] = "buy";
  SardineQuoteType2["sell"] = "sell";
  return SardineQuoteType2;
}({});
let TokenType = /* @__PURE__ */ function(TokenType2) {
  TokenType2["ERC20"] = "ERC20";
  TokenType2["ERC721"] = "ERC721";
  TokenType2["ERC1155"] = "ERC1155";
  return TokenType2;
}({});
class API {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/API/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            version: _data6.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.clock = (headers, signal) => {
      return this.fetch(this.url("Clock"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            serverTime: _data6.serverTime
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSequenceContext = (headers, signal) => {
      return this.fetch(this.url("GetSequenceContext"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            data: _data6.data
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAuthToken = (args, headers, signal) => {
      return this.fetch(this.url("GetAuthToken"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status,
            jwtToken: _data6.jwtToken,
            address: _data6.address,
            user: _data6.user
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAuthToken2 = (args, headers, signal) => {
      return this.fetch(this.url("GetAuthToken2"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status,
            jwtToken: _data6.jwtToken,
            address: _data6.address,
            user: _data6.user
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sendPasswordlessLink = (args, headers, signal) => {
      return this.fetch(this.url("SendPasswordlessLink"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.friendList = (args, headers, signal) => {
      return this.fetch(this.url("FriendList"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            page: _data6.page,
            friends: _data6.friends
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getFriendByAddress = (args, headers, signal) => {
      return this.fetch(this.url("GetFriendByAddress"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status,
            friend: _data6.friend
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchFriends = (args, headers, signal) => {
      return this.fetch(this.url("SearchFriends"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            friends: _data6.friends
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addFriend = (args, headers, signal) => {
      return this.fetch(this.url("AddFriend"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status,
            friend: _data6.friend
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateFriendNickname = (args, headers, signal) => {
      return this.fetch(this.url("UpdateFriendNickname"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status,
            friend: _data6.friend
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeFriend = (args, headers, signal) => {
      return this.fetch(this.url("RemoveFriend"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.contractCall = (args, headers, signal) => {
      return this.fetch(this.url("ContractCall"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            returns: _data6.returns
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.decodeContractCall = (args, headers, signal) => {
      return this.fetch(this.url("DecodeContractCall"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            call: _data6.call
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.lookupContractCallSelectors = (args, headers, signal) => {
      return this.fetch(this.url("LookupContractCallSelectors"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            signatures: _data6.signatures
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageFetch = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageFetch"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            object: _data6.object
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageSave = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageSave"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageDelete = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageDelete"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageFetchAll = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageFetchAll"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            objects: _data6.objects
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMoonpayLink = (args, headers, signal) => {
      return this.fetch(this.url("GetMoonpayLink"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            signedUrl: _data6.signedUrl
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resolveENSAddress = (args, headers, signal) => {
      return this.fetch(this.url("ResolveENSAddress"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            address: _data6.address,
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidSignature = (args, headers, signal) => {
      return this.fetch(this.url("IsValidSignature"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            isValid: _data6.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidMessageSignature = (args, headers, signal) => {
      return this.fetch(this.url("IsValidMessageSignature"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            isValid: _data6.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidTypedDataSignature = (args, headers, signal) => {
      return this.fetch(this.url("IsValidTypedDataSignature"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            isValid: _data6.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidETHAuthProof = (args, headers, signal) => {
      return this.fetch(this.url("IsValidETHAuthProof"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            isValid: _data6.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetClientToken = (headers, signal) => {
      return this.fetch(this.url("SardineGetClientToken"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            token: _data6.token
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetNFTCheckoutToken = (args, headers, signal) => {
      return this.fetch(this.url("SardineGetNFTCheckoutToken"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            resp: _data6.resp
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetNFTCheckoutOrderStatus = (args, headers, signal) => {
      return this.fetch(this.url("SardineGetNFTCheckoutOrderStatus"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            resp: _data6.resp
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetSupportedRegions = (headers, signal) => {
      return this.fetch(this.url("SardineGetSupportedRegions"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            regions: _data6.regions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetSupportedFiatCurrencies = (headers, signal) => {
      return this.fetch(this.url("SardineGetSupportedFiatCurrencies"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            tokens: _data6.tokens
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetSupportedTokens = (headers, signal) => {
      return this.fetch(this.url("SardineGetSupportedTokens"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            tokens: _data6.tokens
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetEnabledTokens = (headers, signal) => {
      return this.fetch(this.url("SardineGetEnabledTokens"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            tokens: _data6.tokens
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sardineGetQuote = (args, headers, signal) => {
      return this.fetch(this.url("SardineGetQuote"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            quote: _data6.quote
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSardineClientToken = (headers, signal) => {
      return this.fetch(this.url("GetSardineClientToken"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            token: _data6.token
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSardineNFTCheckoutToken = (args, headers, signal) => {
      return this.fetch(this.url("GetSardineNFTCheckoutToken"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            resp: _data6.resp
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSardineNFTCheckoutOrderStatus = (args, headers, signal) => {
      return this.fetch(this.url("GetSardineNFTCheckoutOrderStatus"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            resp: _data6.resp
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getCoinPrices = (args, headers, signal) => {
      return this.fetch(this.url("GetCoinPrices"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            tokenPrices: _data6.tokenPrices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getCollectiblePrices = (args, headers, signal) => {
      return this.fetch(this.url("GetCollectiblePrices"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            tokenPrices: _data6.tokenPrices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getExchangeRate = (args, headers, signal) => {
      return this.fetch(this.url("GetExchangeRate"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            exchangeRate: _data6.exchangeRate
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.memoryStore = (args, headers, signal) => {
      return this.fetch(this.url("MemoryStore"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.memoryLoad = (args, headers, signal) => {
      return this.fetch(this.url("MemoryLoad"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            value: _data6.value
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getInviteInfo = (headers, signal) => {
      return this.fetch(this.url("GetInviteInfo"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            inviteInfo: _data6.inviteInfo
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidAccessCode = (args, headers, signal) => {
      return this.fetch(this.url("IsValidAccessCode"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.internalClaimAccessCode = (args, headers, signal) => {
      return this.fetch(this.url("InternalClaimAccessCode"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.blockNumberAtTime = (args, headers, signal) => {
      return this.fetch(this.url("BlockNumberAtTime"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            blocks: _data6.blocks
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.paperSessionSecret = (args, headers, signal) => {
      return this.fetch(this.url("PaperSessionSecret"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            secret: _data6.secret
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.paperSessionSecret2 = (args, headers, signal) => {
      return this.fetch(this.url("PaperSessionSecret2"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            secret: _data6.secret
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.linkWallet = (args, headers, signal) => {
      return this.fetch(this.url("LinkWallet"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getLinkedWallets = (args, headers, signal) => {
      return this.fetch(this.url("GetLinkedWallets"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            linkedWallets: _data6.linkedWallets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeLinkedWallet = (args, headers, signal) => {
      return this.fetch(this.url("RemoveLinkedWallet"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.generateWaaSVerificationURL = (args, headers, signal) => {
      return this.fetch(this.url("GenerateWaaSVerificationURL"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            nonce: _data6.nonce,
            verificationURL: _data6.verificationURL
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.validateWaaSVerificationNonce = (args, headers, signal) => {
      return this.fetch(this.url("ValidateWaaSVerificationNonce"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            walletAddress: _data6.walletAddress
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSwapPrices = (args, headers, signal) => {
      return this.fetch(this.url("GetSwapPrices"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            swapPrices: _data6.swapPrices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSwapQuote = (args, headers, signal) => {
      return this.fetch(this.url("GetSwapQuote"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            swapQuote: _data6.swapQuote
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listCurrencyGroups = (headers, signal) => {
      return this.fetch(this.url("ListCurrencyGroups"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            currencyGroups: _data6.currencyGroups
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addOffchainInventory = (args, headers, signal) => {
      return this.fetch(this.url("AddOffchainInventory"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            inventoryId: _data6.inventoryId
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getOffchainInventory = (args, headers, signal) => {
      return this.fetch(this.url("GetOffchainInventory"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            inventory: _data6.inventory
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listOffchainInventories = (args, headers, signal) => {
      return this.fetch(this.url("ListOffchainInventories"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            inventory: _data6.inventory
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateOffchainInventory = (args, headers, signal) => {
      return this.fetch(this.url("UpdateOffchainInventory"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteOffchainInventory = (args, headers, signal) => {
      return this.fetch(this.url("DeleteOffchainInventory"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.requestOffchainPayment = (args, headers, signal) => {
      return this.fetch(this.url("RequestOffchainPayment"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            payment: _data6.payment
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listOffchainPayments = (args, headers, signal) => {
      return this.fetch(this.url("ListOffchainPayments"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data6) => {
          return {
            page: _data6.page,
            payments: _data6.payments
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$7 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$h({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$7 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$7.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$7[code2] || WebrpcError$7).new(data);
    }
    return data;
  });
};
let WebrpcError$7 = class WebrpcError extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$7 = class WebrpcEndpointError extends WebrpcError$7 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
};
let WebrpcRequestFailedError$7 = class WebrpcRequestFailedError extends WebrpcError$7 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
};
let WebrpcBadRouteError$7 = class WebrpcBadRouteError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
};
let WebrpcBadMethodError$7 = class WebrpcBadMethodError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
};
let WebrpcBadRequestError$7 = class WebrpcBadRequestError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
};
let WebrpcBadResponseError$7 = class WebrpcBadResponseError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
};
let WebrpcServerPanicError$7 = class WebrpcServerPanicError extends WebrpcError$7 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
};
let WebrpcInternalErrorError$7 = class WebrpcInternalErrorError extends WebrpcError$7 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
};
let WebrpcClientDisconnectedError$7 = class WebrpcClientDisconnectedError extends WebrpcError$7 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
};
let WebrpcStreamLostError$7 = class WebrpcStreamLostError extends WebrpcError$7 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
};
let WebrpcStreamFinishedError$7 = class WebrpcStreamFinishedError extends WebrpcError$7 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
};
let UnauthorizedError$6 = class UnauthorizedError extends WebrpcError$7 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
};
let PermissionDeniedError$4 = class PermissionDeniedError extends WebrpcError$7 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError.prototype);
  }
};
let SessionExpiredError$4 = class SessionExpiredError extends WebrpcError$7 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError.prototype);
  }
};
let AbortedError$3 = class AbortedError extends WebrpcError$7 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError.prototype);
  }
};
let GeoblockedError$1 = class GeoblockedError extends WebrpcError$7 {
  constructor(name2 = "Geoblocked", code2 = 1006, message = "Geoblocked region", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, GeoblockedError.prototype);
  }
};
let InvalidArgumentError$5 = class InvalidArgumentError extends WebrpcError$7 {
  constructor(name2 = "InvalidArgument", code2 = 2e3, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError.prototype);
  }
};
let UnavailableError$3 = class UnavailableError extends WebrpcError$7 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError.prototype);
  }
};
let QueryFailedError$5 = class QueryFailedError extends WebrpcError$7 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError.prototype);
  }
};
let NotFoundError$6 = class NotFoundError extends WebrpcError$7 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
};
let errors$3 = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["SessionExpired"] = "SessionExpired";
  errors2["Aborted"] = "Aborted";
  errors2["Geoblocked"] = "Geoblocked";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["Unavailable"] = "Unavailable";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["NotFound"] = "NotFound";
  return errors2;
}({});
const webrpcErrorByCode$7 = {
  [0]: WebrpcEndpointError$7,
  [-1]: WebrpcRequestFailedError$7,
  [-2]: WebrpcBadRouteError$7,
  [-3]: WebrpcBadMethodError$7,
  [-4]: WebrpcBadRequestError$7,
  [-5]: WebrpcBadResponseError$7,
  [-6]: WebrpcServerPanicError$7,
  [-7]: WebrpcInternalErrorError$7,
  [-8]: WebrpcClientDisconnectedError$7,
  [-9]: WebrpcStreamLostError$7,
  [-10]: WebrpcStreamFinishedError$7,
  [1e3]: UnauthorizedError$6,
  [1001]: PermissionDeniedError$4,
  [1002]: SessionExpiredError$4,
  [1005]: AbortedError$3,
  [1006]: GeoblockedError$1,
  [2e3]: InvalidArgumentError$5,
  [2002]: UnavailableError$3,
  [2003]: QueryFailedError$5,
  [3e3]: NotFoundError$6
};
const fetch$6 = globalThis.fetch;
class SequenceAPIClient extends API {
  constructor(hostname, projectAccessKey2, jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$6);
    this.projectAccessKey = projectAccessKey2;
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init2) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      const projectAccessKey3 = this.projectAccessKey;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      if (projectAccessKey3 && projectAccessKey3.length > 0) {
        headers["X-Access-Key"] = projectAccessKey3;
      }
      init2.headers = _extends$h({}, init2.headers, headers);
      return fetch$6(input2, init2);
    };
    this.fetch = this._fetch;
  }
}
const api$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  API,
  AbortedError: AbortedError$3,
  GeoblockedError: GeoblockedError$1,
  InvalidArgumentError: InvalidArgumentError$5,
  NotFoundError: NotFoundError$6,
  PermissionDeniedError: PermissionDeniedError$4,
  QueryFailedError: QueryFailedError$5,
  SardinePaymentType,
  SardineQuoteType,
  SequenceAPIClient,
  SessionExpiredError: SessionExpiredError$4,
  SortOrder: SortOrder$2,
  TokenType,
  UnauthorizedError: UnauthorizedError$6,
  UnavailableError: UnavailableError$3,
  WebRPCSchemaHash: WebRPCSchemaHash$3,
  WebRPCSchemaVersion: WebRPCSchemaVersion$3,
  WebRPCVersion: WebRPCVersion$3,
  WebrpcBadMethodError: WebrpcBadMethodError$7,
  WebrpcBadRequestError: WebrpcBadRequestError$7,
  WebrpcBadResponseError: WebrpcBadResponseError$7,
  WebrpcBadRouteError: WebrpcBadRouteError$7,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$7,
  WebrpcEndpointError: WebrpcEndpointError$7,
  WebrpcError: WebrpcError$7,
  WebrpcInternalErrorError: WebrpcInternalErrorError$7,
  WebrpcRequestFailedError: WebrpcRequestFailedError$7,
  WebrpcServerPanicError: WebrpcServerPanicError$7,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$7,
  WebrpcStreamLostError: WebrpcStreamLostError$7,
  errors: errors$3
}, Symbol.toStringTag, { value: "Module" }));
const version$5 = "6.13.0";
function checkType(value, type, name2) {
  const types2 = type.split("|").map((t2) => t2.trim());
  for (let i = 0; i < types2.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name2}`;
  error.value = value;
  throw error;
}
async function resolveProperties$1(value) {
  const keys = Object.keys(value);
  const results2 = await Promise.all(keys.map((k2) => Promise.resolve(value[k2])));
  return results2.reduce((accum, v3, index2) => {
    accum[keys[index2]] = v3;
    return accum;
  }, {});
}
function defineProperties$1(target, values, types2) {
  for (let key in values) {
    let value = values[key];
    const type = types2 ? types2[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}
function stringify$2(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify$2).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify$2(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k2) => `${stringify$2(k2)}: ${stringify$2(value[k2])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code2) {
  return error && error.code === code2;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code2, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify$2(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify$2(value));
      }
    }
    details.push(`code=${code2}`);
    details.push(`version=${version$5}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code2) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties$1(error, { code: code2 });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties$1(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code2, info) {
  if (!check) {
    throw makeError(message, code2, info);
  }
}
function assertArgument(check, message, name2, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name2, value });
}
function assertArgumentCount(count2, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count2 >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count: count2,
    expectedCount
  });
  assert(count2 <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count: count2,
    expectedCount
  });
}
const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard2, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard2) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name2, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset2 = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset2, offset2 + 2), 16);
      offset2 += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name2 || "value", value);
}
function getBytes(value, name2) {
  return _getBytes(value, name2, false);
}
function getBytesCopy(value, name2) {
  return _getBytes(value, name2, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes2 = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v3 = bytes2[i];
    result += HexCharacters[(v3 & 240) >> 4] + HexCharacters[v3 & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d2) => hexlify(d2).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes2 = getBytes(data);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function stripZerosLeft(data) {
  let bytes2 = hexlify(data).substring(2);
  while (bytes2.startsWith("00")) {
    bytes2 = bytes2.substring(2);
  }
  return "0x" + bytes2;
}
function zeroPad(data, length, left) {
  const bytes2 = getBytes(data);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
const BN_0$a = BigInt(0);
const BN_1$5 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$a, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1$5) {
    const mask2 = (BN_1$5 << width) - BN_1$5;
    return -((~value & mask2) + BN_1$5);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$5 << width - BN_1$5;
  if (value < BN_0$a) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1$5 << width) - BN_1$5;
    return (~value & mask2) + BN_1$5;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$5 << bits) - BN_1$5;
}
function getBigInt(value, name2) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name2 || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name2 || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e2) {
        assertArgument(false, `invalid BigNumberish string: ${e2.message}`, name2 || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name2 || "value", value);
}
function getUint(value, name2) {
  const result = getBigInt(value, name2);
  assert(result >= BN_0$a, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles$1 = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v3 of value) {
      result += Nibbles$1[v3 >> 4];
      result += Nibbles$1[v3 & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name2) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name2 || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name2 || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name2 || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name2);
      } catch (e2) {
        assertArgument(false, `invalid numeric string: ${e2.message}`, name2 || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name2 || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0$a) {
    return new Uint8Array([]);
  }
  let hex2 = value.toString(16);
  if (hex2.length % 2) {
    hex2 = "0" + hex2;
  }
  const result = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset2 = i * 2;
    result[i] = parseInt(hex2.substring(offset2, offset2 + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
const BN_0$9 = BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes2 = getBytes(_value2);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_0$9;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
function decodeBase64(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i = 0; i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return getBytes(data);
}
function encodeBase64(_data6) {
  const data = getBytes(_data6);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
class EventPayload {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter2) {
    /**
     *  The event filter.
     */
    __publicField(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    __publicField(this, "emitter");
    __privateAdd(this, _listener);
    __privateSet(this, _listener, listener);
    defineProperties$1(this, { emitter, filter: filter2 });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (__privateGet(this, _listener) == null) {
      return;
    }
    await this.emitter.off(this.filter, __privateGet(this, _listener));
  }
}
_listener = new WeakMap();
function errorFunc(reason, offset2, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset2}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset2, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o2 = offset2 + 1; o2 < bytes2.length; o2++) {
      if (bytes2[o2] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset2 - 1;
  }
  return 0;
}
function replaceFunc(reason, offset2, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset2, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c2 = bytes2[i++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      assertArgument(i < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function createGetUrl(options) {
  async function getUrl2(req, _signal2) {
    assert(_signal2 == null || !_signal2.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal2) {
      _signal2.addListener(() => {
        error = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init2 = {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    };
    let resp;
    try {
      resp = await fetch(req.url, init2);
    } catch (_error2) {
      clearTimeout(timer);
      if (error) {
        throw error;
      }
      throw _error2;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl2;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$5 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  constructor(request) {
    __privateAdd(this, _listeners);
    __privateAdd(this, _cancelled);
    __privateSet(this, _listeners, []);
    __privateSet(this, _cancelled, false);
    fetchSignals.set(request, () => {
      if (__privateGet(this, _cancelled)) {
        return;
      }
      __privateSet(this, _cancelled, true);
      for (const listener of __privateGet(this, _listeners)) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      __privateSet(this, _listeners, []);
    });
  }
  addListener(listener) {
    assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    __privateGet(this, _listeners).push(listener);
  }
  get cancelled() {
    return __privateGet(this, _cancelled);
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
_listeners = new WeakMap();
_cancelled = new WeakMap();
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
const _FetchRequest = class _FetchRequest {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    __privateAdd(this, _FetchRequest_instances);
    __privateAdd(this, _allowInsecure);
    __privateAdd(this, _gzip);
    __privateAdd(this, _headers);
    __privateAdd(this, _method);
    __privateAdd(this, _timeout);
    __privateAdd(this, _url);
    __privateAdd(this, _body);
    __privateAdd(this, _bodyType);
    __privateAdd(this, _creds);
    // Hooks
    __privateAdd(this, _preflight);
    __privateAdd(this, _process);
    __privateAdd(this, _retry);
    __privateAdd(this, _signal);
    __privateAdd(this, _throttle);
    __privateAdd(this, _getUrlFunc);
    __privateSet(this, _url, String(url));
    __privateSet(this, _allowInsecure, false);
    __privateSet(this, _gzip, true);
    __privateSet(this, _headers, {});
    __privateSet(this, _method, "");
    __privateSet(this, _timeout, 3e5);
    __privateSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    __privateSet(this, _getUrlFunc, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return __privateGet(this, _url);
  }
  set url(url) {
    __privateSet(this, _url, String(url));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (__privateGet(this, _body) == null) {
      return null;
    }
    return new Uint8Array(__privateGet(this, _body));
  }
  set body(body) {
    if (body == null) {
      __privateSet(this, _body, void 0);
      __privateSet(this, _bodyType, void 0);
    } else if (typeof body === "string") {
      __privateSet(this, _body, toUtf8Bytes(body));
      __privateSet(this, _bodyType, "text/plain");
    } else if (body instanceof Uint8Array) {
      __privateSet(this, _body, body);
      __privateSet(this, _bodyType, "application/octet-stream");
    } else if (typeof body === "object") {
      __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
      __privateSet(this, _bodyType, "application/json");
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return __privateGet(this, _body) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (__privateGet(this, _method)) {
      return __privateGet(this, _method);
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    __privateSet(this, _method, String(method).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, __privateGet(this, _headers));
    if (__privateGet(this, _creds)) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
      headers["content-type"] = __privateGet(this, _bodyType);
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    __privateGet(this, _headers)[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    __privateSet(this, _headers, {});
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index2 = 0;
    return {
      next: () => {
        if (index2 < keys.length) {
          const key = keys[index2++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return __privateGet(this, _creds) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    __privateSet(this, _creds, `${username}:${password}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return __privateGet(this, _gzip);
  }
  set allowGzip(value) {
    __privateSet(this, _gzip, !!value);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!__privateGet(this, _allowInsecure);
  }
  set allowInsecureAuthentication(value) {
    __privateSet(this, _allowInsecure, !!value);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return __privateGet(this, _timeout);
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    __privateSet(this, _timeout, timeout);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return __privateGet(this, _preflight) || null;
  }
  set preflightFunc(preflight) {
    __privateSet(this, _preflight, preflight);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return __privateGet(this, _process) || null;
  }
  set processFunc(process2) {
    __privateSet(this, _process, process2);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return __privateGet(this, _retry) || null;
  }
  set retryFunc(retry) {
    __privateSet(this, _retry, retry);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    __privateSet(this, _getUrlFunc, value);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      __privateGet(this, _throttle).slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
    }
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    __privateSet(this, _signal, new FetchCancelSignal(this));
    return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime$2() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location2) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location2.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location2.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location2)})`
    });
    const req = new _FetchRequest(location2);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
    if (__privateGet(this, _body)) {
      __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
    }
    __privateSet(req, _bodyType, __privateGet(this, _bodyType));
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    __privateSet(clone, _method, __privateGet(this, _method));
    if (__privateGet(this, _body)) {
      __privateSet(clone, _body, __privateGet(this, _body));
    }
    __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
    __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
    __privateSet(clone, _creds, __privateGet(this, _creds));
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    __privateSet(clone, _preflight, __privateGet(this, _preflight));
    __privateSet(clone, _process, __privateGet(this, _process));
    __privateSet(clone, _retry, __privateGet(this, _retry));
    __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
    __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$5 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$5) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl2) {
    if (locked$5) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl2;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
_allowInsecure = new WeakMap();
_gzip = new WeakMap();
_headers = new WeakMap();
_method = new WeakMap();
_timeout = new WeakMap();
_url = new WeakMap();
_body = new WeakMap();
_bodyType = new WeakMap();
_creds = new WeakMap();
_preflight = new WeakMap();
_process = new WeakMap();
_retry = new WeakMap();
_signal = new WeakMap();
_throttle = new WeakMap();
_getUrlFunc = new WeakMap();
_FetchRequest_instances = new WeakSet();
send_fn = async function(attempt, expires, delay2, _request3, _response) {
  var _a2, _b2, _c2;
  if (attempt >= __privateGet(this, _throttle).maxAttempts) {
    return _response.makeServerError("exceeded maximum retry limit");
  }
  assert(getTime$2() <= expires, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: _request3
  });
  if (delay2 > 0) {
    await wait(delay2);
  }
  let req = this.clone();
  const scheme = (req.url.split(":")[0] || "").toLowerCase();
  if (scheme in Gateways) {
    const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request3, _signal)));
    if (result instanceof FetchResponse) {
      let response2 = result;
      if (this.processFunc) {
        checkSignal(__privateGet(_request3, _signal));
        try {
          response2 = await this.processFunc(req, response2);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response2.makeServerError("error in post-processing function", error).assertOk();
          }
        }
      }
      return response2;
    }
    req = result;
  }
  if (this.preflightFunc) {
    req = await this.preflightFunc(req);
  }
  const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request3, _signal)));
  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request3);
  if (response.statusCode === 301 || response.statusCode === 302) {
    try {
      const location2 = response.headers.location || "";
      return __privateMethod(_a2 = req.redirect(location2), _FetchRequest_instances, send_fn).call(_a2, attempt + 1, expires, 0, _request3, response);
    } catch (error) {
    }
    return response;
  } else if (response.statusCode === 429) {
    if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
      const retryAfter = response.headers["retry-after"];
      let delay3 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
        delay3 = parseInt(retryAfter);
      }
      return __privateMethod(_b2 = req.clone(), _FetchRequest_instances, send_fn).call(_b2, attempt + 1, expires, delay3, _request3, response);
    }
  }
  if (this.processFunc) {
    checkSignal(__privateGet(_request3, _signal));
    try {
      response = await this.processFunc(req, response);
    } catch (error) {
      if (error.throttle == null || typeof error.stall !== "number") {
        response.makeServerError("error in post-processing function", error).assertOk();
      }
      let delay3 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (error.stall >= 0) {
        delay3 = error.stall;
      }
      return __privateMethod(_c2 = req.clone(), _FetchRequest_instances, send_fn).call(_c2, attempt + 1, expires, delay3, _request3, response);
    }
  }
  return response;
};
let FetchRequest = _FetchRequest;
const _FetchResponse = class _FetchResponse {
  constructor(statusCode, statusMessage, headers, body, request) {
    __privateAdd(this, _statusCode);
    __privateAdd(this, _statusMessage);
    __privateAdd(this, _headers2);
    __privateAdd(this, _body2);
    __privateAdd(this, _request);
    __privateAdd(this, _error);
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _statusMessage, statusMessage);
    __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k2) => {
      accum[k2.toLowerCase()] = String(headers[k2]);
      return accum;
    }, {}));
    __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
    __privateSet(this, _request, request || null);
    __privateSet(this, _error, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return __privateGet(this, _statusCode);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return __privateGet(this, _statusMessage);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, __privateGet(this, _headers2));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index2 = 0;
    return {
      next: () => {
        if (index2 < keys.length) {
          const key = keys[index2++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
    __privateSet(response, _error, { message, error });
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error = new Error(message || "throttling requests");
    defineProperties$1(error, { stall: stall2, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return __privateGet(this, _body2) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return __privateGet(this, _request);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = __privateGet(this, _error);
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (__privateGet(this, _body2)) {
        responseBody = toUtf8String(__privateGet(this, _body2));
      }
    } catch (e2) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
_statusCode = new WeakMap();
_statusMessage = new WeakMap();
_headers2 = new WeakMap();
_body2 = new WeakMap();
_request = new WeakMap();
_error = new WeakMap();
let FetchResponse = _FetchResponse;
function getTime$2() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function wait(delay2) {
  return new Promise((resolve) => setTimeout(resolve, delay2));
}
const BN_N1 = BigInt(-1);
const BN_0$8 = BigInt(0);
const BN_1$4 = BigInt(1);
const BN_5 = BigInt(5);
const _guard$5 = {};
let Zeros$1 = "0000";
while (Zeros$1.length < 80) {
  Zeros$1 += Zeros$1;
}
function getTens(decimals) {
  let result = Zeros$1;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format2, safeOp) {
  const width = BigInt(format2.width);
  if (format2.signed) {
    const limit = BN_1$4 << width - BN_1$4;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0$8) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_1$4 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_1$4;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed2 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") ;
    else if (value === "ufixed") {
      signed2 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed2 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v3 = value;
    const check = (key, type, defaultValue) => {
      if (v3[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v3[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v3[key]);
      return v3[key];
    };
    signed2 = check("signed", "boolean", signed2);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name2 = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed2, width, decimals, name: name2 };
}
function toString$1(val, decimals) {
  let negative = "";
  if (val < BN_0$8) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros$1 + str;
  }
  const index2 = str.length - decimals;
  str = str.substring(0, index2) + "." + str.substring(index2);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
const _FixedNumber = class _FixedNumber {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard2, value, format2) {
    __privateAdd(this, _FixedNumber_instances);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    __publicField(this, "format");
    __privateAdd(this, _format);
    // The actual value (accounting for decimals)
    __privateAdd(this, _val);
    // A base-10 value to multiple values by to maintain the magnitude
    __privateAdd(this, _tens);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    __publicField(this, "_value");
    assertPrivate(guard2, _guard$5, "FixedNumber");
    __privateSet(this, _val, value);
    __privateSet(this, _format, format2);
    const _value2 = toString$1(value, format2.decimals);
    defineProperties$1(this, { format: format2.name, _value: _value2 });
    __privateSet(this, _tens, getTens(format2.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return __privateGet(this, _format).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return __privateGet(this, _format).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return __privateGet(this, _format).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return __privateGet(this, _val);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(other, _val);
    assert(value % __privateGet(this, _tens) === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert(__privateGet(other, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(this, _tens);
    assert(value % __privateGet(other, _val) === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a2 = this.value, b2 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b2 *= getTens(delta);
    } else if (delta < 0) {
      a2 *= getTens(-delta);
    }
    if (a2 < b2) {
      return -1;
    }
    if (a2 > b2) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) < BN_0$8) {
      val -= __privateGet(this, _tens) - BN_1$4;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) > BN_0$8) {
      val += __privateGet(this, _tens) - BN_1$4;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, __privateGet(this, _format), "round");
    return new _FixedNumber(_guard$5, value, __privateGet(this, _format));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return __privateGet(this, _val) === BN_0$8;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return __privateGet(this, _val) < BN_0$8;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format2) {
    return _FixedNumber.fromString(this.toString(), format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value2, _decimals, _format2) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format2 = getFormat(_format2);
    let value = getBigInt(_value2, "value");
    const delta = decimals - format2.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert(value % tens === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value2
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format2, "fromValue");
    return new _FixedNumber(_guard$5, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value2, _format2) {
    const match = _value2.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value2);
    const format2 = getFormat(_format2);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format2.decimals) {
      decimal += Zeros$1;
    }
    assert(decimal.substring(format2.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value2
    });
    decimal = decimal.substring(0, format2.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format2, "fromString");
    return new _FixedNumber(_guard$5, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value2, _format2) {
    let value = toBigInt(getBytes(_value2, "value"));
    const format2 = getFormat(_format2);
    if (format2.signed) {
      value = fromTwos(value, format2.width);
    }
    checkValue(value, format2, "fromBytes");
    return new _FixedNumber(_guard$5, value, format2);
  }
};
_format = new WeakMap();
_val = new WeakMap();
_tens = new WeakMap();
_FixedNumber_instances = new WeakSet();
checkFormat_fn = function(other) {
  assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
};
checkValue_fn = function(val, safeOp) {
  val = checkValue(val, __privateGet(this, _format), safeOp);
  return new _FixedNumber(_guard$5, val, __privateGet(this, _format));
};
add_fn = function(o2, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o2, _val), safeOp);
};
sub_fn = function(o2, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o2, _val), safeOp);
};
mul_fn = function(o2, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o2, _val) / __privateGet(this, _tens), safeOp);
};
div_fn = function(o2, safeOp) {
  assert(__privateGet(o2, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  });
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o2, _val), safeOp);
};
let FixedNumber = _FixedNumber;
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset2, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset2 + i];
  }
  return result;
}
function _decodeChildren(data, offset2, childOffset, length) {
  const result = [];
  while (childOffset < offset2 + 1 + length) {
    const decoded = _decode$1(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset2 + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset: offset2
    });
  }
  return { consumed: 1 + length, result };
}
function _decode$1(data, offset2) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset3) => {
    assert(offset3 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset3
    });
  };
  if (data[offset2] >= 248) {
    const lengthLength = data[offset2] - 247;
    checkOffset(offset2 + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    checkOffset(offset2 + 1 + lengthLength + length);
    return _decodeChildren(data, offset2, offset2 + 1 + lengthLength, lengthLength + length);
  } else if (data[offset2] >= 192) {
    const length = data[offset2] - 192;
    checkOffset(offset2 + 1 + length);
    return _decodeChildren(data, offset2, offset2 + 1, length);
  } else if (data[offset2] >= 184) {
    const lengthLength = data[offset2] - 183;
    checkOffset(offset2 + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    checkOffset(offset2 + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset2 + 1 + lengthLength, offset2 + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset2] >= 128) {
    const length = data[offset2] - 128;
    checkOffset(offset2 + 1 + length);
    const result = hexlify(data.slice(offset2 + 1, offset2 + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset2]) };
}
function decodeRlp(_data6) {
  const data = getBytes(_data6, "data");
  const decoded = _decode$1(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data6);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode$1(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode$1(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v3 of _encode$1(object2)) {
    result += nibbles[v3 >> 4];
    result += nibbles[v3 & 15];
  }
  return result;
}
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits$1(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index2 = names.indexOf(unit);
    assertArgument(index2 >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index2;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits$2(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index2 = names.indexOf(unit);
    assertArgument(index2 >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index2;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther$1(wei) {
  return formatUnits$1(wei, 18);
}
function parseEther$1(ether) {
  return parseUnits$2(ether, 18);
}
function uuidV4(randomBytes2) {
  const bytes2 = getBytes(randomBytes2, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value = hexlify(bytes2);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$4 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name2, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name2}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item2, index2) => {
      if (item2 instanceof Result) {
        return toObject(getNames(item2), item2, deep);
      }
      return item2;
    });
  }
  return names2.reduce((accum, name2, index2) => {
    let item2 = items.getValue(name2);
    if (!(name2 in accum)) {
      if (deep && item2 instanceof Result) {
        item2 = toObject(getNames(item2), item2, deep);
      }
      accum[name2] = item2;
    }
    return accum;
  }, {});
}
const _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard2 = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap2 = true;
    if (guard2 !== _guard$4) {
      items = args;
      names2 = [];
      wrap2 = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names);
    items.forEach((item2, index2) => {
      this[index2] = item2;
    });
    const nameCounts = names2.reduce((accum, name2) => {
      if (typeof name2 === "string") {
        accum.set(name2, (accum.get(name2) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item2, index2) => {
      const name2 = names2[index2];
      if (name2 != null && nameCounts.get(name2) === 1) {
        return name2;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap2) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index2 = getNumber(prop, "%index");
            if (index2 < 0 || index2 >= this.length) {
              throw new RangeError("out of result range");
            }
            const item2 = target[index2];
            if (item2 instanceof Error) {
              throwError(`index ${index2}`, item2);
            }
            return item2;
          }
          if (passProperties$1.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item2, index2) => {
      if (item2 instanceof Error) {
        throwError(`index ${index2}`, item2);
      }
      if (deep && item2 instanceof _Result) {
        item2 = item2.toArray(deep);
      }
      result.push(item2);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name2, index2) => {
      assert(name2 != null, `value at index ${index2} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names2.push(_names2[i]);
    }
    return new _Result(_guard$4, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i = 0; i < this.length; i++) {
      const item2 = this[i];
      if (item2 instanceof Error) {
        throwError(`index ${i}`, item2);
      }
      if (callback.call(thisArg, item2, i, this)) {
        result.push(item2);
        names2.push(_names2[i]);
      }
    }
    return new _Result(_guard$4, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item2 = this[i];
      if (item2 instanceof Error) {
        throwError(`index ${i}`, item2);
      }
      result.push(callback.call(thisArg, item2, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name2) {
    const index2 = getNames(this).indexOf(name2);
    if (index2 === -1) {
      return void 0;
    }
    const value = this[index2];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name2)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard$4, items, keys);
  }
};
_names = new WeakMap();
let Result = _Result;
function checkResultErrors(result) {
  const errors2 = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key in object2) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object2[key]);
      } catch (error) {
        errors2.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors2;
}
function getValue$1(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
class Coder {
  constructor(name2, type, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties$1(this, { name: name2, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  constructor() {
    __privateAdd(this, _Writer_instances);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data2);
    __privateAdd(this, _dataLength);
    __privateSet(this, _data2, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat(__privateGet(this, _data2));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset2 = __privateGet(this, _data2).length;
    __privateGet(this, _data2).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data2)[offset2] = getValue$1(value);
    };
  }
}
_data2 = new WeakMap();
_dataLength = new WeakMap();
_Writer_instances = new WeakSet();
writeData_fn = function(data) {
  __privateGet(this, _data2).push(data);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
  return data.length;
};
const _Reader = class _Reader {
  constructor(data, allowLoose, maxInflation) {
    __privateAdd(this, _Reader_instances);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data3);
    __privateAdd(this, _offset);
    __privateAdd(this, _bytesRead);
    __privateAdd(this, _parent);
    __privateAdd(this, _maxInflation);
    defineProperties$1(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data3, getBytesCopy(data));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data3));
  }
  get dataLength() {
    return __privateGet(this, _data3).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data3));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset2) {
    const reader2 = new _Reader(__privateGet(this, _data3).slice(__privateGet(this, _offset) + offset2), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader2, _parent, this);
    return reader2;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes2.length);
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data3 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_Reader_instances = new WeakSet();
incrementBytesRead_fn = function(count2) {
  var _a2;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a2 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a2, count2);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count2);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data3)),
    offset: __privateGet(this, _offset),
    length: count2,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
peekBytes_fn = function(offset2, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data3).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data3).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data3)),
        length: __privateGet(this, _data3).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data3).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
let Reader = _Reader;
const global$1 = globalThis || void 0 || self;
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes$1(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists$1(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(out, instance) {
  bytes$1(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
const crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (a2) => a2 instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$1 = (word, shift2) => word << 32 - shift2 | word >>> shift2;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb2) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb2(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes$2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$1(data) {
  if (typeof data === "string")
    data = utf8ToBytes$2(data);
  if (!u8a$1(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes$1(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a$1(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad2);
    pad2 += a2.length;
  });
  return r2;
}
let Hash$1 = class Hash2 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
const toStr = {}.toString;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor$1(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$2(bytesLength = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues === "function") {
    return crypto$2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
class HMAC2 extends Hash$1 {
  constructor(hash$12, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$12);
    const key = toBytes$1(_key);
    this.iHash = hash$12.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash$12.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash$12.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists$1(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists$1(this);
    bytes$1(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac$1 = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
hmac$1.create = (hash2, key) => new HMAC2(hash2, key);
function pbkdf2Init(hash$12, _password, _salt, _opts) {
  hash(hash$12);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  number(c2);
  number(dkLen);
  number(asyncTick);
  if (c2 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes$1(_password);
  const salt = toBytes$1(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac$1.create(hash$12, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u2.fill(0);
  return DK;
}
function pbkdf2$1(hash2, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView$1(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
    const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti2, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti2.set(u2.subarray(0, Ti2.length));
    for (let ui2 = 1; ui2 < c2; ui2++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i = 0; i < Ti2.length; i++)
        Ti2[i] ^= u2[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}
function setBigUint64$1(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
class SHA2 extends Hash$1 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    exists$1(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$1(this);
    output$1(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const Chi$1 = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj$1 = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
const SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class SHA2562 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W$1[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$1[i - 15];
      const W2 = SHA256_W$1[i - 2];
      const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i] = s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$1(E2, 6) ^ rotr$1(E2, 11) ^ rotr$1(E2, 25);
      const T12 = H2 + sigma1 + Chi$1(E2, F2, G2) + SHA256_K$1[i] + SHA256_W$1[i] | 0;
      const sigma0 = rotr$1(A2, 2) ^ rotr$1(A2, 13) ^ rotr$1(A2, 22);
      const T22 = sigma0 + Maj$1(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T12 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$2 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split$1(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l: l2 } = fromBig(lst[i], le2);
    [Ah2[i], Al[i]] = [h2, l2];
  }
  return [Ah2, Al];
}
const toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
const shrSH = (h2, _l2, s2) => h2 >>> s2;
const shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
const rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
const rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
const rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
const rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
const rotr32H = (_h2, l2) => l2;
const rotr32L = (h2, _l2) => h2;
const rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
const rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
const rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
const rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
function add(Ah2, Al, Bh2, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah2 + Bh2 + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
const u64 = {
  fromBig,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    return [Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl];
  }
  // prettier-ignore
  set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl) {
    this.Ah = Ah2 | 0;
    this.Al = Al | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh2 | 0;
    this.El = El | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4) {
      SHA512_W_H[i] = view.getUint32(offset2);
      SHA512_W_L[i] = view.getUint32(offset2 += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah: Ah2, Al, Bh: Bh2, Bl, Ch: Ch2, Cl, Dh: Dh2, Dl, Eh: Eh2, El, Fh: Fh2, Fl, Gh: Gh2, Gl, Hh: Hh2, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64.rotrSH(Eh2, El, 14) ^ u64.rotrSH(Eh2, El, 18) ^ u64.rotrBH(Eh2, El, 41);
      const sigma1l = u64.rotrSL(Eh2, El, 14) ^ u64.rotrSL(Eh2, El, 18) ^ u64.rotrBL(Eh2, El, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64.rotrSH(Ah2, Al, 28) ^ u64.rotrBH(Ah2, Al, 34) ^ u64.rotrBH(Ah2, Al, 39);
      const sigma0l = u64.rotrSL(Ah2, Al, 28) ^ u64.rotrBL(Ah2, Al, 34) ^ u64.rotrBL(Ah2, Al, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh2 = Gh2 | 0;
      Hl = Gl | 0;
      Gh2 = Fh2 | 0;
      Gl = Fl | 0;
      Fh2 = Eh2 | 0;
      Fl = El | 0;
      ({ h: Eh2, l: El } = u64.add(Dh2 | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl = Cl | 0;
      Ch2 = Bh2 | 0;
      Cl = Bl | 0;
      Bh2 = Ah2 | 0;
      Bl = Al | 0;
      const All = u64.add3L(T1l, sigma0l, MAJl);
      Ah2 = u64.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah2, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al | 0));
    ({ h: Bh2, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl | 0));
    ({ h: Ch2, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl | 0));
    ({ h: Dh2, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl | 0));
    ({ h: Eh2, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh2 | 0, El | 0));
    ({ h: Fh2, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl | 0));
    ({ h: Gh2, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl | 0));
    ({ h: Hh2, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl | 0));
    this.set(Ah2, Al, Bh2, Bl, Ch2, Cl, Dh2, Dl, Eh2, El, Fh2, Fl, Gh2, Gl, Hh2, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512$1 = /* @__PURE__ */ wrapConstructor$1(() => new SHA512());
function getGlobal$1() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global$1 !== "undefined") {
    return global$1;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal$1();
const crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256$2.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256: sha256$2, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac$1.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256: sha256$2, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2$1(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes$1(length) {
  assert(crypto$1 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto$1.getRandomValues(result);
  return result;
}
let locked$4 = false;
const _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
let __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data6) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data6, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked$4 = true;
};
computeHmac.register = function(func) {
  if (locked$4) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round2 = 0, R2 = _1n$5, x2 = 1, y2 = 0; round2 < 24; round2++) {
  [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x2));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n$4;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n$5 ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n$3)
      t2 ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j2)) - _1n$5;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
const rotlH = (h2, l2, s2) => s2 > 32 ? rotlBH(h2, l2, s2) : rotlSH(h2, l2, s2);
const rotlL = (h2, l2, s2) => s2 > 32 ? rotlBL(h2, l2, s2) : rotlSL(h2, l2, s2);
function keccakP(s2, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x2 + y2] ^= Th2;
        s2[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift2 = SHA3_ROTL[t2];
      const Th2 = rotlH(curH, curL, shift2);
      const Tl = rotlL(curH, curL, shift2);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th2;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s2[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round2];
    s2[1] ^= SHA3_IOTA_L[round2];
  }
  B2.fill(0);
}
class Keccak2 extends Hash$1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists$1(this);
    const { blockLen, state } = this;
    data = toBytes$1(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists$1(this, false);
    bytes$1(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output$1(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak2(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked$3 = false;
const _keccak256 = function(data) {
  return keccak_256(data);
};
let __keccak256 = _keccak256;
function keccak256(_data6) {
  const data = getBytes(_data6, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked$3 = true;
};
keccak256.register = function(func) {
  if (locked$3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j2 of [idxL, idxR])
    j2.push(j2[i].map((k2) => Rho[k2]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j2) => shifts[i][j2]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j2) => shifts[i][j2]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
const rotl$1 = (word, shift2) => word << shift2 | word >>> 32 - shift2;
function f$1(group, x2, y2, z2) {
  if (group === 0)
    return x2 ^ y2 ^ z2;
  else if (group === 1)
    return x2 & y2 | ~x2 & z2;
  else if (group === 2)
    return (x2 | ~y2) ^ z2;
  else if (group === 3)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      BUF[i] = view.getUint32(offset2, true);
    let al2 = this.h0 | 0, ar = al2, bl2 = this.h1 | 0, br = bl2, cl2 = this.h2 | 0, cr = cl2, dl2 = this.h3 | 0, dr = dl2, el2 = this.h4 | 0, er = el2;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl2 = idxL[group], rr = idxR[group];
      const sl2 = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl2 = rotl$1(al2 + f$1(group, bl2, cl2, dl2) + BUF[rl2[i]] + hbl, sl2[i]) + el2 | 0;
        al2 = el2, el2 = dl2, dl2 = rotl$1(cl2, 10) | 0, cl2 = bl2, bl2 = tl2;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl$1(ar + f$1(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl2 + dr | 0, this.h2 + dl2 + er | 0, this.h3 + el2 + ar | 0, this.h4 + al2 + br | 0, this.h0 + bl2 + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160$1 = /* @__PURE__ */ wrapConstructor$1(() => new RIPEMD160());
let locked$2 = false;
const _ripemd160 = function(data) {
  return ripemd160$1(data);
};
let __ripemd160 = _ripemd160;
function ripemd160(_data6) {
  const data = getBytes(_data6, "data");
  return hexlify(__ripemd160(data));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function() {
  locked$2 = true;
};
ripemd160.register = function(func) {
  if (locked$2) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);
let locked$1 = false;
const _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function() {
  locked$1 = true;
};
pbkdf2.register = function(func) {
  if (locked$1) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);
let locked = false;
const _randomBytes = function(length) {
  return new Uint8Array(randomBytes$1(length));
};
let __randomBytes = _randomBytes;
function randomBytes(length) {
  return __randomBytes(length);
}
randomBytes._ = _randomBytes;
randomBytes.lock = function() {
  locked = true;
};
randomBytes.register = function(func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes);
const rotl = (a2, b2) => a2 << b2 | a2 >>> 32 - b2;
function XorAndSalsa(prev, pi2, input2, ii2, out, oi2) {
  let y00 = prev[pi2++] ^ input2[ii2++], y01 = prev[pi2++] ^ input2[ii2++];
  let y02 = prev[pi2++] ^ input2[ii2++], y03 = prev[pi2++] ^ input2[ii2++];
  let y04 = prev[pi2++] ^ input2[ii2++], y05 = prev[pi2++] ^ input2[ii2++];
  let y06 = prev[pi2++] ^ input2[ii2++], y07 = prev[pi2++] ^ input2[ii2++];
  let y08 = prev[pi2++] ^ input2[ii2++], y09 = prev[pi2++] ^ input2[ii2++];
  let y10 = prev[pi2++] ^ input2[ii2++], y11 = prev[pi2++] ^ input2[ii2++];
  let y12 = prev[pi2++] ^ input2[ii2++], y13 = prev[pi2++] ^ input2[ii2++];
  let y14 = prev[pi2++] ^ input2[ii2++], y15 = prev[pi2++] ^ input2[ii2++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi2++] = y00 + x00 | 0;
  out[oi2++] = y01 + x01 | 0;
  out[oi2++] = y02 + x02 | 0;
  out[oi2++] = y03 + x03 | 0;
  out[oi2++] = y04 + x04 | 0;
  out[oi2++] = y05 + x05 | 0;
  out[oi2++] = y06 + x06 | 0;
  out[oi2++] = y07 + x07 | 0;
  out[oi2++] = y08 + x08 | 0;
  out[oi2++] = y09 + x09 | 0;
  out[oi2++] = y10 + x10 | 0;
  out[oi2++] = y11 + x11 | 0;
  out[oi2++] = y12 + x12 | 0;
  out[oi2++] = y13 + x13 | 0;
  out[oi2++] = y14 + x14 | 0;
  out[oi2++] = y15 + x15 | 0;
}
function BlockMix(input2, ii2, out, oi2, r2) {
  let head = oi2 + 0;
  let tail = oi2 + 16 * r2;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input2[ii2 + (2 * r2 - 1) * 16 + i];
  for (let i = 0; i < r2; i++, head += 16, ii2 += 16) {
    XorAndSalsa(out, tail, input2, ii2, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input2, ii2 += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r: r2, p: p2, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N2);
  number(r2);
  number(p2);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p2 < 0 || p2 > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p2);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B2 = pbkdf2$1(sha256$2, password, salt, { c: 1, dkLen: blockSize * p2 });
  const B32 = u32(B2);
  const V2 = u32(new Uint8Array(blockSize * N2));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p2;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B2, V2, tmp) {
  const res = pbkdf2$1(sha256$2, password, B2, { c: 1, dkLen });
  B2.fill(0);
  V2.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt$1(password, salt, opts) {
  const { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi2 = 0; pi2 < p2; pi2++) {
    const Pi2 = blockSize32 * pi2;
    for (let i = 0; i < blockSize32; i++)
      V2[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N2 - 1; i++) {
      BlockMix(V2, pos, V2, pos += blockSize32, r2);
      blockMixCb();
    }
    BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    for (let i = 0; i < N2; i++) {
      const j2 = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k2 = 0; k2 < blockSize32; k2++)
        tmp[k2] = B32[Pi2 + k2] ^ V2[j2 * blockSize32 + k2];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B2, V2, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi2 = 0; pi2 < p2; pi2++) {
    const Pi2 = blockSize32 * pi2;
    for (let i = 0; i < blockSize32; i++)
      V2[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N2 - 1, asyncTick, () => {
      BlockMix(V2, pos, V2, pos += blockSize32, r2);
      blockMixCb();
    });
    BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    await asyncLoop(N2, asyncTick, () => {
      const j2 = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k2 = 0; k2 < blockSize32; k2++)
        tmp[k2] = B32[Pi2 + k2] ^ V2[j2 * blockSize32 + k2];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B2, V2, tmp);
}
let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function(passwd, salt, N2, r2, p2, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N2, r: r2, p: p2, dkLen, onProgress });
};
const _scryptSync = function(passwd, salt, N2, r2, p2, dkLen) {
  return scrypt$1(passwd, salt, { N: N2, r: r2, p: p2, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
async function scrypt(_passwd, _salt, N2, r2, p2, dkLen, progress2) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N2, r2, p2, dkLen, progress2));
}
scrypt._ = _scryptAsync;
scrypt.lock = function() {
  lockedAsync = true;
};
scrypt.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
function scryptSync(_passwd, _salt, N2, r2, p2, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N2, r2, p2, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);
const _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
const _sha512 = function(data) {
  return createHash("sha512").update(data).digest();
};
let __sha256 = _sha256;
let __sha512 = _sha512;
let locked256 = false, locked512 = false;
function sha256$1(_data6) {
  const data = getBytes(_data6, "data");
  return hexlify(__sha256(data));
}
sha256$1._ = _sha256;
sha256$1.lock = function() {
  locked256 = true;
};
sha256$1.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256$1);
function sha512(_data6) {
  const data = getBytes(_data6, "data");
  return hexlify(__sha512(data));
}
sha512._ = _sha512;
sha512.lock = function() {
  locked512 = true;
};
sha512.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha256$1);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a2) => a2 instanceof Uint8Array;
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$1(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex2 += hexes$1[bytes2[i]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len = hex2.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j2 = i * 2;
    const hexByte = hex2.slice(j2, j2 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex$1(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex$1(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e2}`);
    }
  } else if (u8a(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad2 = 0;
  arrays.forEach((a2) => {
    if (!u8a(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad2);
    pad2 += a2.length;
  });
  return r2;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$3; n2 >>= _1n$4, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$4;
}
const bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
};
const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v3 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v3.fill(1);
    k2.fill(0);
    i = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v3, ...b2);
  const reseed = (seed = u8n()) => {
    k2 = h2(u8fr([0]), seed);
    v3 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr([1]), seed);
    v3 = h2();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v3 = h2();
      const sl2 = v3.slice();
      out.push(sl2);
      len += v3.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes: utf8ToBytes$1,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a2, b2) {
  const result = a2 % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$2, u2 = _1n$3;
  while (a2 !== _0n$2) {
    const q2 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x2 - u2 * q2;
    b2 = a2, a2 = r2, x2 = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n$3) / _2n$1;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n$3, S2 = 0; Q2 % _2n$1 === _0n$2; Q2 /= _2n$1, S2++)
    ;
  for (Z2 = _2n$1; Z2 < P2 && pow(Z2, legendreC, P2) !== P2 - _1n$3; Z2++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  const Q1div2 = (Q2 + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q2);
    let x2 = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g2, _1n$3 << BigInt(r2 - m2 - 1));
      g2 = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g2);
      r2 = m2;
    }
    return x2;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n$1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$1);
      const v3 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v3);
      const i = Fp2.mul(Fp2.mul(nv, _2n$1), v3);
      const root2 = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  return tonelliShanks(P2);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p2 = f2.ONE;
  let d2 = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p2 = f2.mul(p2, d2);
    d2 = f2.sqr(d2);
    power >>= _1n$3;
  }
  return p2;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c2, bits) {
  const constTimeNegate = (condition, item2) => {
    const neg = item2.negate();
    return condition ? neg : item2;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p2 = c2.ZERO;
      let d2 = elm;
      while (n2 > _0n$1) {
        if (n2 & _1n$2)
          p2 = p2.add(d2);
        d2 = d2.double();
        n2 >>= _1n$2;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p2;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p2);
          points.push(base);
        }
        p2 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f2 = c2.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$2;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n2, transform) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E2 } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s: s2 };
  },
  hexFromSig(sig) {
    const slice2 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h2 = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s2 = slice2(h2(sig.s));
    const r2 = slice2(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r2.length / 2;
    const sl2 = h2(shl);
    const rl2 = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s2}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a2)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex$1(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  class Point {
    constructor(px2, py, pz) {
      this.px = px2;
      this.py = py;
      this.pz = pz;
      if (px2 == null || !Fp2.isValid(px2))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y2 } = this.toAffine();
      if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x2);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i) => p2.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I2 = Point.ZERO;
      if (n2 === _0n)
        return I2;
      assertGE(n2);
      if (n2 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d2);
        if (k2 & _1n$1)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(n2);
        point = p2;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G2 = Point.BASE;
      const mul = (P2, a3) => a3 === _0n || a3 === _1n$1 || !P2.equals(G2) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul(this, a2).add(mul(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y2, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x2, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex$1(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a2) {
    return mod(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a2 = point.toAffine();
      const x2 = Fp2.toBytes(a2.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3 = Fp2.sqrt(y2);
        const isYOdd = (y3 & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex$1(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l2 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l2 * 2);
      return new Signature2(slcNum(hex2, 0, l2), slcNum(hex2, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r2, s: s2 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature2(r2, s2);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item2) {
    const arr = item2 instanceof Uint8Array;
    const str = typeof item2 === "string";
    const len = (arr || str) && item2.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item2 instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q2 = Point.BASE.multiply(k2).toAffine();
      const r2 = modN(q2.x);
      if (r2 === _0n)
        return;
      const s2 = modN(ik2 * modN(m2 + r2 * d2));
      if (s2 === _0n)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n$1);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature2, msgHash, publicKey, opts = defaultVerOpts) {
    var _a2;
    const sg2 = signature2;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || sg2 instanceof Uint8Array) {
        try {
          _sig2 = Signature2.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s3 } = sg2;
        _sig2 = new Signature2(r3, s3);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig2;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s2);
    const u1 = modN(h2 * is);
    const u2 = modN(r2 * is);
    const R2 = (_a2 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R2)
      return false;
    const v3 = modN(R2.x);
    return v3 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac$1(hash2, key, concatBytes$1(...msgs)),
    randomBytes: randomBytes$2
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a2, b2) => (a2 + b2 / _2n) / b2;
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root2 = pow2(t2, _2n, P2);
  if (!Fp.eql(Fp.sqr(root2), y2))
    throw new Error("Cannot find square root");
  return root2;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k2, n2);
      const c2 = divNearest(-b1 * k2, n2);
      let k1 = mod(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$2);
BigInt(0);
secp256k1.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const WeiPerEther = BigInt("1000000000000000000");
const MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
const MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const EtherSymbol = "";
const MessagePrefix = "Ethereum Signed Message:\n";
const BN_0$7 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_2$3 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
const _Signature = class _Signature {
  /**
   *  @private
   */
  constructor(guard2, r2, s2, v3) {
    __privateAdd(this, _r);
    __privateAdd(this, _s);
    __privateAdd(this, _v);
    __privateAdd(this, _networkV);
    assertPrivate(guard2, _guard$3, "Signature");
    __privateSet(this, _r, r2);
    __privateSet(this, _s, s2);
    __privateSet(this, _v, v3);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return __privateGet(this, _s);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    const value = hexlify(_value2);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    __privateSet(this, _s, value);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v3 = getNumber(value, "value");
    assertArgument(v3 === 27 || v3 === 28, "invalid v", "v", value);
    __privateSet(this, _v, v3);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v3 = this.networkV;
    if (v3 == null) {
      return null;
    }
    return _Signature.getChainId(v3);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard$3, this.r, this.s, this.v);
    if (this.networkV) {
      __privateSet(clone, _networkV, this.networkV);
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v3) {
    const bv = getBigInt(v3, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v3);
    return (bv - BN_35$1) / BN_2$3;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v3) {
    return getBigInt(chainId) * BN_2$3 + BigInt(35 + v3 - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v3) {
    const bv = getBigInt(v3);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$3 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v3);
    return bv & BN_1$3 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new _Signature(_guard$3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r3 = hexlify(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        const v5 = s3[0] & 128 ? 28 : 27;
        s3[0] &= 127;
        return new _Signature(_guard$3, r3, hexlify(s3), v5);
      }
      if (bytes2.length === 65) {
        const r3 = hexlify(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        assertError((s3[0] & 128) === 0, "non-canonical s");
        const v5 = _Signature.getNormalizedV(bytes2[64]);
        return new _Signature(_guard$3, r3, hexlify(s3), v5);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r2 = sig.r;
    assertError(_r2 != null, "missing r");
    const r2 = toUint256(_r2);
    const s2 = function(s3, yParityAndS) {
      if (s3 != null) {
        return toUint256(s3);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s2)[0] & 128) == 0, "non-canonical s");
    const { networkV, v: v3 } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v5 = getBigInt(_v2);
        return {
          networkV: v5 >= BN_35$1 ? v5 : void 0,
          v: _Signature.getNormalizedV(v5)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard$3, r2, s2, v3);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};
_r = new WeakMap();
_s = new WeakMap();
_v = new WeakMap();
_networkV = new WeakMap();
let Signature = _Signature;
const _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature2) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature2);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature2);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
let SigningKey = _SigningKey;
function lock() {
  computeHmac.lock();
  keccak256.lock();
  pbkdf2.lock();
  randomBytes.lock();
  ripemd160.lock();
  scrypt.lock();
  scryptSync.lock();
  sha256$1.lock();
  sha512.lock();
  randomBytes.lock();
}
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
const Base36 = function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {
  }
  return false;
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n$1(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b$1(value, size2) {
  return new Typed(_gaurd, `bytes${size2 ? size2 : ""}`, value, { size: size2 });
}
const _typedSymbol = Symbol.for("_ethers_typed");
const _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties$1(this, { _typedSymbol, type, value });
    __privateSet(this, _options, options);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v3) => v3.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v3) {
    return n$1(v3, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v3) {
    return n$1(v3, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v3) {
    return n$1(v3, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v3) {
    return n$1(v3, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v3) {
    return n$1(v3, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v3) {
    return n$1(v3, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v3) {
    return n$1(v3, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v3) {
    return n$1(v3, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v3) {
    return n$1(v3, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v3) {
    return n$1(v3, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v3) {
    return n$1(v3, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v3) {
    return n$1(v3, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v3) {
    return n$1(v3, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v3) {
    return n$1(v3, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v3) {
    return n$1(v3, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v3) {
    return n$1(v3, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v3) {
    return n$1(v3, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v3) {
    return n$1(v3, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v3) {
    return n$1(v3, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v3) {
    return n$1(v3, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v3) {
    return n$1(v3, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v3) {
    return n$1(v3, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v3) {
    return n$1(v3, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v3) {
    return n$1(v3, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v3) {
    return n$1(v3, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v3) {
    return n$1(v3, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v3) {
    return n$1(v3, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v3) {
    return n$1(v3, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v3) {
    return n$1(v3, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v3) {
    return n$1(v3, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v3) {
    return n$1(v3, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v3) {
    return n$1(v3, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v3) {
    return n$1(v3, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v3) {
    return n$1(v3, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v3) {
    return n$1(v3, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v3) {
    return n$1(v3, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v3) {
    return n$1(v3, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v3) {
    return n$1(v3, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v3) {
    return n$1(v3, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v3) {
    return n$1(v3, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v3) {
    return n$1(v3, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v3) {
    return n$1(v3, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v3) {
    return n$1(v3, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v3) {
    return n$1(v3, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v3) {
    return n$1(v3, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v3) {
    return n$1(v3, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v3) {
    return n$1(v3, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v3) {
    return n$1(v3, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v3) {
    return n$1(v3, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v3) {
    return n$1(v3, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v3) {
    return n$1(v3, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v3) {
    return n$1(v3, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v3) {
    return n$1(v3, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v3) {
    return n$1(v3, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v3) {
    return n$1(v3, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v3) {
    return n$1(v3, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v3) {
    return n$1(v3, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v3) {
    return n$1(v3, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v3) {
    return n$1(v3, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v3) {
    return n$1(v3, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v3) {
    return n$1(v3, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v3) {
    return n$1(v3, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v3) {
    return n$1(v3, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v3) {
    return n$1(v3, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v3) {
    return n$1(v3, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v3) {
    return n$1(v3, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v3) {
    return b$1(v3, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v3) {
    return b$1(v3, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v3) {
    return b$1(v3, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v3) {
    return b$1(v3, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v3) {
    return b$1(v3, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v3) {
    return b$1(v3, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v3) {
    return b$1(v3, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v3) {
    return b$1(v3, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v3) {
    return b$1(v3, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v3) {
    return b$1(v3, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v3) {
    return b$1(v3, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v3) {
    return b$1(v3, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v3) {
    return b$1(v3, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v3) {
    return b$1(v3, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v3) {
    return b$1(v3, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v3) {
    return b$1(v3, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v3) {
    return b$1(v3, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v3) {
    return b$1(v3, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v3) {
    return b$1(v3, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v3) {
    return b$1(v3, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v3) {
    return b$1(v3, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v3) {
    return b$1(v3, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v3) {
    return b$1(v3, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v3) {
    return b$1(v3, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v3) {
    return b$1(v3, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v3) {
    return b$1(v3, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v3) {
    return b$1(v3, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v3) {
    return b$1(v3, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v3) {
    return b$1(v3, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v3) {
    return b$1(v3, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v3) {
    return b$1(v3, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v3) {
    return b$1(v3, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v3) {
    return new _Typed(_gaurd, "address", v3);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v3) {
    return new _Typed(_gaurd, "bool", !!v3);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v3) {
    return new _Typed(_gaurd, "bytes", v3);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v3) {
    return new _Typed(_gaurd, "string", v3);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v3, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v3, name2) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v3) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v3));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
let Typed = _Typed;
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader2) {
    return getAddress(toBeHex(reader2.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader2) {
    return this.coder.decode(reader2);
  }
}
function pack(writer, coders2, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders2.map((coder) => {
      const name2 = coder.localName;
      assert(name2, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name2], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name2] = true;
      return values[name2];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders2.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders2.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader2, coders2) {
  let values = [];
  let keys = [];
  let baseReader = reader2.subReader(0);
  coders2.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset2 = reader2.readIndex();
      let offsetReader = baseReader.subReader(offset2);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader2);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties$1(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders2 = [];
    for (let i = 0; i < value.length; i++) {
      coders2.push(this.coder);
    }
    return pack(writer, coders2, value);
  }
  decode(reader2) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader2.readIndex();
      assert(count2 * WordSize <= reader2.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader2.bytes, offset: count2 * WordSize, length: reader2.dataLength });
    }
    let coders2 = [];
    for (let i = 0; i < count2; i++) {
      coders2.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader2, coders2);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader2) {
    return !!reader2.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader2) {
    return reader2.readBytes(reader2.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader2) {
    return hexlify(super.decode(reader2));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    __publicField(this, "size");
    defineProperties$1(this, { size: size2 }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data);
  }
  decode(reader2) {
    return hexlify(reader2.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader2) {
    reader2.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  constructor(size2, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties$1(this, { size: size2, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$2)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader2) {
    let value = mask(reader2.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader2) {
    return toUtf8String(super.decode(reader2));
  }
}
class TupleCoder extends Coder {
  constructor(coders2, localName) {
    let dynamic = false;
    const types2 = [];
    coders2.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    __publicField(this, "coders");
    defineProperties$1(this, { coders: Object.freeze(coders2.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader2) {
    return unpack(reader2, this.coders);
  }
}
function id$1(value) {
  return keccak256(toUtf8Bytes(value));
}
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
const NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register2 = 0;
  for (let i = 0; i < N2; i++) register2 = register2 << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register2 - low + 1) * total - 1) / range2);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a2 = low + Math.floor(range2 * acc[start] / total);
    let b2 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register2 = register2 << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register2 = register2 & HALF | register2 << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range2 = 1 + b2 - a2;
  }
  let offset2 = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset2) {
      case 3:
        return offset2 + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset2 + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset2 + bytes2[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v3) {
  let pos = 0;
  return () => v3[pos++];
}
function read_compressed_payload(s2) {
  return read_payload(decode_arithmetic(unsafe_atob(s2)));
}
function unsafe_atob(s2) {
  let lookup2 = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i) => lookup2[c2.charCodeAt(0)] = i);
  let n2 = s2.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n2; i++) {
    carry = carry << 6 | lookup2[s2.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n2, next) {
  let v3 = Array(n2);
  for (let i = 0, x2 = 0; i < n2; i++) v3[i] = x2 += signed(next());
  return v3;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x2 = next();
    let n2 = next();
    if (!n2) break;
    prev += x2;
    for (let i = 0; i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v3 = read_sorted(next);
    if (v3.length) return v3;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0) break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0) break;
    ret.push(read_replacement_table(w2, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v3 = [];
  while (true) {
    let x2 = next(v3.length);
    if (!x2) break;
    v3.push(x2);
  }
  return v3;
}
function read_transposed(n2, w2, next) {
  let m2 = Array(n2).fill().map(() => []);
  for (let i = 0; i < w2; i++) {
    read_deltas(n2, next).forEach((x2, j2) => m2[j2].push(x2));
  }
  return m2;
}
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m2 = read_transposed(vN.length, 1 + w2, next);
  return m2.flatMap((v3, i) => {
    let [x2, ...ys] = v3;
    return Array(vN[i]).fill().map((_, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys.map((y2) => y2 + j_dy)];
    });
  });
}
function read_replacement_table(w2, next) {
  let n2 = 1 + next();
  let m2 = read_transposed(n2, 1 + w2, next);
  return m2.map((v3) => [v3[0], v3.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q2) {
    let S2 = next();
    let B2 = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length) return decode2(cps);
    });
    return { S: S2, B: B2, Q: Q2 };
  }
  function expand({ S: S2, B: B2 }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br of B2) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s2) {
  let cps = [];
  for (let pos = 0, len = s2.length; pos < len; ) {
    let cp = s2.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a2, b2) {
  let n2 = a2.length;
  let c2 = n2 - b2.length;
  for (let i = 0; c2 == 0 && i < n2; i++) c2 = a2[i] - b2[i];
  return c2;
}
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const S0 = 44032;
const L0 = 4352;
const V0 = 4449;
const T0 = 4519;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1$1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  let r2 = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r2).flatMap((v3, i) => v3.map((x2) => [x2, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r2));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r2)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a2, b2] = cps;
      let bucket = RECOMP.get(a2);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a2, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a2, b2) {
  if (a2 >= L0 && a2 < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a2 - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a2) && b2 > T0 && b2 < T1$1 && (a2 - S0) % T_COUNT == 0) {
    return a2 + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a2);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc2 = SHIFTED_RANK.get(cp);
    if (cc2) {
      check_order = true;
      cp |= cc2;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0) add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc2 = unpack_cc(ret[i]);
      if (cc2 == 0 || prev_cc <= cc2) {
        prev_cc = cc2;
        continue;
      }
      let j2 = i - 1;
      while (true) {
        let tmp = ret[j2 + 1];
        ret[j2 + 1] = ret[j2];
        ret[j2] = tmp;
        if (!j2) break;
        prev_cc = unpack_cc(ret[--j2]);
        if (prev_cc <= cc2) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v3) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v3) {
    let cc2 = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc2 == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc2) {
      if (cc2 == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc2;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc2 == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc2;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
const HYPHEN = 45;
const STOP_CH = ".";
const FE0F = 65039;
const UNIQUE_PH = 1;
const Array_from = (x2) => Array.from(x2);
function group_has_cp(g2, cp) {
  return g2.P.has(cp) || g2.Q.has(cp);
}
class Emoji extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
}
let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r2 = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r2);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v3) => v3.forEach((x2) => set.add(x2));
  MAPPED = new Map(read_mapped(r2));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  read_sorted_set();
  let chunks = read_sorted_arrays(r2);
  let unrestricted = r2();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N2 = read_array_while(r2).map((x2) => x2 + 96);
    if (N2.length) {
      let R2 = i >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R2) N2 = `Restricted[${N2}]`;
      let P2 = read_chunked();
      let Q2 = read_chunked();
      let M2 = !r2();
      return { N: N2, P: P2, Q: Q2, M: M2, R: R2 };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a2, b2) => a2 - b2);
  wholes.forEach((cp, i) => {
    let d2 = r2();
    let w2 = wholes[i] = d2 ? wholes[i - d2] : { V: [], M: /* @__PURE__ */ new Map() };
    w2.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w2);
    }
  });
  for (let { V: V2, M: M2 } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V2) {
      let gs = GROUPS.filter((g2) => group_has_cp(g2, cp));
      let rec = recs.find(({ G: G2 }) => gs.some((g2) => G2.has(g2)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x2) => Array_from(x2.G));
    for (let { G: G2, V: V3 } of recs) {
      let complement = new Set(union.filter((g2) => !G2.has(g2)));
      for (let cp of V3) {
        M2.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g2 of GROUPS) {
    for (let cp of g2.P) add_to_union(cp);
    for (let cp of g2.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r2).map((v3) => Emoji.from(v3)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x2 of prev) {
      x2.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s2) {
  return `"${s2}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i = 1; i < n2; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i) throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n2) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max2 = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max2) {
    max2 >>= 1;
    cps = [...cps.slice(0, max2), 8230, ...cps.slice(-max2)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0; i < n2; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name2) {
  return flatten(split(name2, nfc, filter_fe0f));
}
function split(name2, nf2, ef2) {
  if (!name2) return [];
  init();
  let offset2 = 0;
  return name2.split(STOP_CH).map((label) => {
    let input2 = explode_cp(label);
    let info = {
      input: input2,
      offset: offset2
      // codepoint, not substring!
    };
    offset2 += input2.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input2, nf2, ef2);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm2 = info.output = tokens.flat();
      check_leading_underscore(norm2);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm2.every((cp) => cp < 128)) {
        check_label_extension(norm2);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x2) => x2.is_emoji ? [] : x2);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm2[0])) throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm2);
          let unique = Array_from(new Set(chars));
          let [g2] = determine_group(unique);
          check_group(g2, chars);
          check_whole(g2, unique);
          type = g2.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g2) => set.has(g2)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g2 of maker) {
      if (shared.every((cp) => group_has_cp(g2, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g2.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g2) => group_has_cp(g2, cp));
    if (!gs.length) {
      if (!GROUPS.some((g2) => group_has_cp(g2, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input: input2, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input2, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g2, cp) {
  let quoted = quoted_cp(cp);
  let gg2 = GROUPS.find((g3) => g3.P.has(cp));
  if (gg2) {
    quoted = `${gg2.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g2.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g2, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g2, cp)) {
      throw error_group_member(g2, cp);
    }
  }
  if (g2.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e2 = decomposed2.length; i < e2; i++) {
      if (NSM.has(decomposed2[i])) {
        let j2 = i + 1;
        for (let cp; j2 < e2 && NSM.has(cp = decomposed2[j2]); j2++) {
          for (let k2 = i; k2 < j2; k2++) {
            if (decomposed2[k2] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j2 - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j2)))} (${j2 - i}/${NSM_MAX})`);
        }
        i = j2;
      }
    }
  }
}
function tokens_from_str(input2, nf2, ef2) {
  let ret = [];
  let chars = [];
  input2 = input2.slice().reverse();
  while (input2.length) {
    let emoji = consume_emoji_reversed(input2);
    if (emoji) {
      if (chars.length) {
        ret.push(nf2(chars));
        chars = [];
      }
      ret.push(ef2(emoji));
    } else {
      let cp = input2.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf2(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V: V2 } = node;
    if (V2) {
      emoji = V2;
      cps.length = pos;
    }
  }
  return emoji;
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name2) {
  const bytes2 = toUtf8Bytes(ensNormalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d2 = bytes2[i];
    if (d2 === 46) {
      comps.push(checkComponent(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name2);
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function ensNormalize(name2) {
  try {
    if (name2.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name2);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name2);
  }
}
function isValidName(name2) {
  try {
    return ensNameSplit(name2).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name2) {
  assertArgument(typeof name2 === "string", "invalid ENS name; not a string", "name", name2);
  assertArgument(name2.length, `invalid ENS name (empty label)`, "name", name2);
  let result = Zeros;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name2).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name2)} exceeds ${length} bytes`, "name", name2);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey2, index2) => {
      assertArgument(isHexString(storageKey2, 32), "invalid slot", `storageKeys[${index2}]`, storageKey2);
      return storageKey2.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index2) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index2}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey2) => {
      accum[storageKey2] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature2) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature2));
}
const BN_0$4 = BigInt(0);
const BN_2$2 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getVersionedHash(version2, hash2) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256$1(hash2).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value2, name2) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name2}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v3 = handleUint(fields[6], "v");
  const r2 = handleUint(fields[7], "r");
  const s2 = handleUint(fields[8], "s");
  if (r2 === BN_0$4 && s2 === BN_0$4) {
    tx.chainId = v3;
  } else {
    let chainId = (v3 - BN_35) / BN_2$2;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v3 === BN_27 || v3 === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v3
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v3 = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v3 = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v3) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v3));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r2 = zeroPadValue(fields[1], 32);
  const s2 = zeroPadValue(fields[2], 32);
  const signature2 = Signature.from({ r: r2, s: s2, yParity });
  tx.signature = signature2;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
const _Transaction = class _Transaction {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __privateAdd(this, _type);
    __privateAdd(this, _to);
    __privateAdd(this, _data4);
    __privateAdd(this, _nonce);
    __privateAdd(this, _gasLimit);
    __privateAdd(this, _gasPrice);
    __privateAdd(this, _maxPriorityFeePerGas);
    __privateAdd(this, _maxFeePerGas);
    __privateAdd(this, _value);
    __privateAdd(this, _chainId2);
    __privateAdd(this, _sig);
    __privateAdd(this, _accessList);
    __privateAdd(this, _maxFeePerBlobGas);
    __privateAdd(this, _blobVersionedHashes);
    __privateAdd(this, _kzg);
    __privateAdd(this, _blobs);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_0$4);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data4, "0x");
    __privateSet(this, _value, BN_0$4);
    __privateSet(this, _chainId2, BN_0$4);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _kzg, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data4);
  }
  set data(value) {
    __privateSet(this, _data4, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId2);
  }
  set chainId(value) {
    __privateSet(this, _chainId2, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature.from(value));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs2.length; i++) {
      const blob = _blobs2[i];
      if (isBytesLike(blob)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    __privateSet(this, _kzg, kzg);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types2 = this.inferTypes();
    if (types2.indexOf(2) >= 0) {
      return 2;
    }
    return types2.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types2 = [];
    if (this.type != null) {
      types2.push(this.type);
    } else {
      if (hasFee) {
        types2.push(2);
      } else if (hasGasPrice) {
        types2.push(1);
        if (!hasAccessList) {
          types2.push(0);
        }
      } else if (hasAccessList) {
        types2.push(1);
        types2.push(2);
      } else if (hasBlob && this.to) {
        types2.push(3);
      } else {
        types2.push(0);
        types2.push(1);
        types2.push(2);
        types2.push(3);
      }
    }
    types2.sort();
    return types2;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s2 = (v3) => {
      if (v3 == null) {
        return null;
      }
      return v3.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s2(this.gasLimit),
      gasPrice: s2(this.gasPrice),
      maxPriorityFeePerGas: s2(this.maxPriorityFeePerGas),
      maxFeePerGas: s2(this.maxFeePerGas),
      value: s2(this.value),
      chainId: s2(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};
_type = new WeakMap();
_to = new WeakMap();
_data4 = new WeakMap();
_nonce = new WeakMap();
_gasLimit = new WeakMap();
_gasPrice = new WeakMap();
_maxPriorityFeePerGas = new WeakMap();
_maxFeePerGas = new WeakMap();
_value = new WeakMap();
_chainId2 = new WeakMap();
_sig = new WeakMap();
_accessList = new WeakMap();
_maxFeePerBlobGas = new WeakMap();
_blobVersionedHashes = new WeakMap();
_kzg = new WeakMap();
_blobs = new WeakMap();
_Transaction_instances = new WeakSet();
getSerialized_fn = function(signed2, sidecar) {
  assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed2 ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Transaction = _Transaction;
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray2) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let signed2 = match[1] === "int";
    let size2 = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size2)) && size2 % 8 === 0 && size2 !== 0 && size2 <= 256, "invalid number type", "type", type);
    if (isArray2) {
      size2 = 256;
    }
    if (signed2) {
      value = toTwos(value, size2);
    }
    return getBytes(zeroPadValue(toBeArray(value), size2 / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    const size2 = parseInt(match[1]);
    assertArgument(String(size2) === match[1] && size2 !== 0 && size2 <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === size2, `invalid value for ${type}`, "value", value);
    if (isArray2) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count2 = parseInt(match[2] || String(value.length));
    assertArgument(count2 === value.length, `invalid array length for ${type}`, "value", value);
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return getBytes(concat(result));
  }
  assertArgument(false, "invalid type", "type", type);
}
function solidityPacked(types2, values) {
  assertArgument(types2.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types2.forEach(function(type, index2) {
    tight.push(_pack(type, values[index2]));
  });
  return hexlify(concat(tight));
}
function solidityPackedKeccak256(types2, values) {
  return keccak256(solidityPacked(types2, values));
}
function solidityPackedSha256(types2, values) {
  return sha256$1(solidityPacked(types2, values));
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = toBeHex(BN_1$1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT256, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_1$1) * BN__1 : BN_0$3;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id$1(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
const _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types2) {
    __privateAdd(this, _TypedDataEncoder_instances);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types);
    __privateAdd(this, _fullTypes);
    __privateAdd(this, _encoderCache);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types2 = {};
    Object.keys(_types2).forEach((type) => {
      types2[type] = _types2[type].map(({ name: name2, type: type2 }) => {
        let { base, index: index2 } = splitArray(type2);
        if (base === "int" && !_types2["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types2["uint"]) {
          base = "uint256";
        }
        return { name: name2, type: base + (index2 || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types2));
    for (const name2 in types2) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types2[name2]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", _types2);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name2, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
        const encoder2 = getBaseEncoder(baseType);
        if (encoder2) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
        parents.get(baseType).push(name2);
        links.get(name2).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types2);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", _types2);
    defineProperties$1(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types2);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name2, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      __privateGet(this, _fullTypes).set(name2, encodeType(name2, types2[name2]) + st.map((t2) => encodeType(t2, types2[t2])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder2 = __privateGet(this, _encoderCache).get(type);
    if (!encoder2) {
      encoder2 = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type);
      __privateGet(this, _encoderCache).set(type, encoder2);
    }
    return encoder2;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name2) {
    const result = __privateGet(this, _fullTypes).get(name2);
    assertArgument(result, `unknown type: ${JSON.stringify(name2)}`, "name", name2);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name2, value) {
    return keccak256(this.encodeData(name2, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder2 = getBaseEncoder(type);
      if (encoder2) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v3) => this._visit(array.prefix, v3, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types2) {
    return new _TypedDataEncoder(types2);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types2) {
    return _TypedDataEncoder.from(types2).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name2, types2, value) {
    return _TypedDataEncoder.from(types2).hashStruct(name2, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain2) {
    const domainFields = [];
    for (const name2 in domain2) {
      if (domain2[name2] == null) {
        continue;
      }
      const type = domainFieldTypes[name2];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain2, types2, value) {
    return concat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain2),
      _TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain2, types2, value) {
    return keccak256(_TypedDataEncoder.encode(domain2, types2, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain2, types2, value, resolveName) {
    domain2 = Object.assign({}, domain2);
    for (const key in domain2) {
      if (domain2[key] == null) {
        delete domain2[key];
      }
    }
    const ensCache = {};
    if (domain2.verifyingContract && !isHexString(domain2.verifyingContract, 20)) {
      ensCache[domain2.verifyingContract] = "0x";
    }
    const encoder2 = _TypedDataEncoder.from(types2);
    encoder2.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name2 in ensCache) {
      ensCache[name2] = await resolveName(name2);
    }
    if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
      domain2.verifyingContract = ensCache[domain2.verifyingContract];
    }
    value = encoder2.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain: domain2, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain2, types2, value) {
    _TypedDataEncoder.hashDomain(domain2);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain2[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder2 = _TypedDataEncoder.from(types2);
    types2 = encoder2.types;
    const typesWithDomain = Object.assign({}, types2);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder2.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder2.primaryType,
      message: encoder2.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
_types = new WeakMap();
_fullTypes = new WeakMap();
_encoderCache = new WeakMap();
_TypedDataEncoder_instances = new WeakSet();
getEncoder_fn = function(type) {
  {
    const encoder2 = getBaseEncoder(type);
    if (encoder2) {
      return encoder2;
    }
  }
  const array = splitArray(type).array;
  if (array) {
    const subtype = array.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type];
  if (fields) {
    const encodedType = id$1(__privateGet(this, _fullTypes).get(type));
    return (value) => {
      const values = fields.map(({ name: name2, type: type2 }) => {
        const result = this.getEncoder(type2)(value[name2]);
        if (__privateGet(this, _fullTypes).has(type2)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type}`, "type", type);
};
let TypedDataEncoder = _TypedDataEncoder;
function verifyTypedData(domain2, types2, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain2, types2, value), signature2);
}
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k2) => result.add(k2));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
const _TokenString = class _TokenString {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances);
    __privateAdd(this, _offset2);
    __privateAdd(this, _tokens);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _TokenString(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
      const token = __privateGet(this, _tokens)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset2 = new WeakMap();
_tokens = new WeakMap();
_TokenString_instances = new WeakSet();
subTokenString_fn = function(from = 0, to = 0) {
  return new _TokenString(__privateGet(this, _tokens).slice(from, to).map((t2) => {
    return Object.freeze(Object.assign({}, t2, {
      match: t2.match - from,
      linkBack: t2.linkBack - from,
      linkNext: t2.linkNext - from
    }));
  }));
};
let TokenString = _TokenString;
function lex(text2) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset2 < text2.length ? JSON.stringify(text2[offset2]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset2}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset2 = 0;
  while (offset2 < text2.length) {
    let cur = text2.substring(offset2);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset2 += match[1].length;
      cur = text2.substring(offset2);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: offset2, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset2++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset2 += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset2 += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset2}`);
  }
  return new TokenString(tokens.map((t2) => Object.freeze(t2)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t2) => ParamType.from(t2, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size2 = parseInt(match[3]);
    assertArgument(size2 !== 0 && size2 <= 256 && size2 % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
const _guard$2 = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
const _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard2, name2, type, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard2, _guard$2, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties$1(this, {
      name: name2,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      const name2 = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name2;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: name2
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c2) => JSON.parse(c2.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format2);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v3) => _this.arrayChildren.walk(v3, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v3, i) => _this.components[i].walk(v3, process2));
    }
    return process2(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t2) => _ParamType.from(t2));
        type2 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard$2, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name3 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard$2, name3, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name2 = obj.name;
    assertArgument(!name2 || typeof name2 === "string" && name2.match(regexId), "invalid name", "obj.name", name2);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard$2, name2 || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard$2, name2 || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard$2, name2 || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal;
  }
};
_ParamType_instances = new WeakSet();
walkAsync_fn = function(promises, value, process2, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index2) => {
      var _a2;
      __privateMethod(_a2 = childType, _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index2) => {
      var _a2;
      __privateMethod(_a2 = components[index2], _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process2(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
let ParamType = _ParamType;
class Fragment {
  /**
   *  @private
   */
  constructor(guard2, type, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard2, _guard$2, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties$1(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e2) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard2, type, name2, inputs) {
    super(guard2, type, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name2 === "string" && name2.match(regexId), "invalid identifier", "name", name2);
    inputs = Object.freeze(inputs.slice());
    defineProperties$1(this, { name: name2 });
  }
}
function joinParams(format2, params) {
  return "(" + params.map((p2) => p2.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name2, inputs) {
    super(guard2, "error", name2, inputs);
    Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id$1(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input2) => JSON.parse(input2.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name2 = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard$2, name2, inputs);
    }
    return new ErrorFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name2, inputs, anonymous) {
    super(guard2, "event", name2, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
    defineProperties$1(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id$1(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name2, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new EventFragment(_guard$2, name2, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name2 = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard$2, name2, inputs, anonymous);
    }
    return new EventFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map((p2) => ParamType.from(p2, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard2, type, inputs, payable, gas) {
    super(guard2, type, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
    defineProperties$1(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format2) {
    assert(format2 != null && format2 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format2 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [`constructor${joinParams(format2, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard$2, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard$2, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  constructor(guard2, inputs, payable) {
    super(guard2, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
    defineProperties$1(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format2) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format2 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard$2, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard$2, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard$2, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard$2, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name2, stateMutability, inputs, outputs, gas) {
    super(guard2, "function", name2, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties$1(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id$1(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2))),
        outputs: this.outputs.map((o2) => JSON.parse(o2.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format2, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name2, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new FunctionFragment(_guard$2, name2, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name2 = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard$2, name2, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard$2, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard2, name2, inputs) {
    super(guard2, "struct", name2, inputs);
    Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name2 = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard$2, name2, inputs);
    }
    return new StructFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes2 = getBytes(data);
    data = hexlify(data);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code2 = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code2]
        };
        reason = `Panic due to ${PanicReasons$1.get(code2) || "UNKNOWN"}(${code2})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction2 = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction2.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction: transaction2,
    invocation,
    revert
  });
}
const _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _AbiCoder_instances);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types2) {
    const coders2 = types2.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders2, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types2, values) {
    assertArgumentCount(values.length, types2.length, "types/values length mismatch");
    const coders2 = types2.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders2, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types2, data, loose) {
    const coders2 = types2.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders2, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};
_AbiCoder_instances = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c2) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c2)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size2 = parseInt(match[2] || "256");
    assertArgument(size2 !== 0 && size2 <= 256 && size2 % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size2 / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size2 = parseInt(match[1]);
    assertArgument(size2 !== 0 && size2 <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size2, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
let AbiCoder = _AbiCoder;
function encodeBytes32String(text2) {
  const bytes2 = toUtf8Bytes(text2);
  if (bytes2.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes(bytes2, 32);
}
function decodeBytes32String(_bytes) {
  const data = getBytes(_bytes, "bytes");
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
class LogDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name2 = fragment.name, signature2 = fragment.format();
    defineProperties$1(this, {
      fragment,
      name: name2,
      signature: signature2,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector2, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name2 = fragment.name, signature2 = fragment.format();
    defineProperties$1(this, {
      fragment,
      name: name2,
      args,
      signature: signature2,
      selector: selector2,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector2, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name2 = fragment.name, signature2 = fragment.format();
    defineProperties$1(this, {
      fragment,
      name: name2,
      args,
      signature: signature2,
      selector: selector2
    });
  }
}
class Indexed {
  /**
   *  @_ignore:
   */
  constructor(hash2) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties$1(this, { hash: hash2, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code2) => {
      let reason = "unknown panic code";
      if (code2 >= 0 && code2 <= 255 && PanicReasons[code2.toString()]) {
        reason = PanicReasons[code2.toString()];
      }
      return `reverted with panic code 0x${code2.toString(16)} (${reason})`;
    }
  }
};
const _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors);
    __privateAdd(this, _events);
    __privateAdd(this, _functions);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder);
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a2 of abi2) {
      try {
        frags.push(Fragment.from(a2));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error.message);
      }
    }
    defineProperties$1(this, {
      fragments: Object.freeze(frags)
    });
    let fallback2 = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index2) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties$1(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback2 || fragment.payable !== fallback2.payable, "conflicting fallback fragments", `fragments[${index2}]`, fragment);
            fallback2 = fragment;
            receive = fallback2.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature2 = fragment.format();
      if (bucket.has(signature2)) {
        return;
      }
      bucket.set(signature2, fragment);
    });
    if (!this.deploy) {
      defineProperties$1(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties$1(this, { fallback: fallback2, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format2 = minimal ? "minimal" : "full";
    const abi2 = this.fragments.map((f2) => f2.format(format2));
    return abi2;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi2 = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi2.map((j2) => JSON.parse(j2)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(__privateGet(this, _functions).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name2 = names2[i];
      callback(__privateGet(this, _functions).get(name2), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(__privateGet(this, _events).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name2 = names2[i];
      callback(__privateGet(this, _events).get(name2), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector2 = key.toLowerCase();
      if (BuiltinErrors[selector2]) {
        return ErrorFragment.from(BuiltinErrors[selector2].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector2 === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name2, fragment] of __privateGet(this, _errors)) {
        if (name2.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(__privateGet(this, _errors).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i = 0; i < names2.length; i++) {
      const name2 = names2[i];
      callback(__privateGet(this, _errors).get(name2), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return __privateGet(this, _abiCoder).decode(params, data);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data);
    if (bytes2.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data6, tx) {
    const data = getBytes(_data6, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector2 = hexlify(data.slice(0, 4));
      const ef2 = this.getError(selector2);
      if (ef2) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef2.inputs, data.slice(4));
          error.revert = {
            name: ef2.name,
            signature: ef2.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e2) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id$1(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      const param = fragment.inputs[index2];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id$1(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index2) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index2]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_Interface_instances = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const selector2 = key.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector2 === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name2, fragment] of __privateGet(this, _functions)) {
      if (name2.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (j2 >= inputs.length) {
            if (values[j2].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const eventTopic = key.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name2, fragment] of __privateGet(this, _events)) {
      if (name2.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m2) => JSON.stringify(m2.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
let Interface = _Interface;
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    /**
     *  The gas price for legacy networks.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxPriorityFeePerGas");
    defineProperties$1(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider2) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    __publicField(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    __publicField(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    __publicField(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    __publicField(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    __publicField(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    __publicField(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    __publicField(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    __publicField(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    __publicField(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    __publicField(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    __publicField(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    __publicField(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    __publicField(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    __publicField(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    __publicField(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    __publicField(this, "baseFeePerGas");
    __privateAdd(this, _transactions);
    __privateSet(this, _transactions, block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider2);
      }
      return tx;
    }));
    defineProperties$1(this, {
      provider: provider2,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return __privateGet(this, _transactions).map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = __privateGet(this, _transactions).slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash2, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions: transactions2 } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash2,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions: transactions2
    };
  }
  [Symbol.iterator]() {
    let index2 = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index2 < this.length) {
          return {
            value: txs[index2++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return __privateGet(this, _transactions).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = __privateGet(this, _transactions)[indexOrHash];
    } else {
      const hash2 = indexOrHash.toLowerCase();
      for (const v3 of __privateGet(this, _transactions)) {
        if (typeof v3 === "string") {
          if (v3 !== hash2) {
            continue;
          }
          tx = v3;
          break;
        } else {
          if (v3.hash === hash2) {
            continue;
          }
          tx = v3;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
_transactions = new WeakMap();
class Log {
  /**
   *  @_ignore:
   */
  constructor(log, provider2) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    __publicField(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    __publicField(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    __publicField(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    __publicField(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    __publicField(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    __publicField(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    __publicField(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    __publicField(this, "transactionIndex");
    this.provider = provider2;
    const topics = Object.freeze(log.topics.slice());
    defineProperties$1(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index: index2, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index: index2,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(tx, provider2) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    __publicField(this, "to");
    /**
     *  The sender of the transaction.
     */
    __publicField(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    __publicField(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    __publicField(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    __publicField(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    __publicField(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    __publicField(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    __publicField(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    __publicField(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    __publicField(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    __publicField(this, "root");
    __privateAdd(this, _logs);
    __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider2);
    })));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties$1(this, {
      provider: provider2,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return __privateGet(this, _logs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash2,
      index: index2,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root: root2
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash2,
      index: index2,
      logs,
      logsBloom,
      root: root2,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index2 = 0;
    return {
      next: () => {
        if (index2 < this.length) {
          return { value: this.logs[index2++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
_logs = new WeakMap();
const _TransactionResponse = class _TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(tx, provider2) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    __publicField(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    __publicField(this, "index");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    __publicField(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    __publicField(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    __publicField(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    __publicField(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    __publicField(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    __publicField(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    __publicField(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    __publicField(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    __publicField(this, "value");
    /**
     *  The chain ID.
     */
    __publicField(this, "chainId");
    /**
     *  The signature.
     */
    __publicField(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    __publicField(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    __publicField(this, "blobVersionedHashes");
    __privateAdd(this, _startBlock);
    this.provider = provider2;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    __privateSet(this, _startBlock, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index: index2, hash: hash2, type, to, from, nonce, data, signature: signature2, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash2,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature: signature2,
      to,
      index: index2,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties$1({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout2) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout2 == null ? 0 : _timeout2;
    let startBlock = __privateGet(this, _startBlock);
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties$1({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < __privateGet(this, _startBlock)) {
          nextScan = __privateGet(this, _startBlock);
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash2 of block) {
          if (hash2 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    __privateSet(tx, _startBlock, startBlock);
    return tx;
  }
};
_startBlock = new WeakMap();
let TransactionResponse = _TransactionResponse;
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
class EventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The matching event.
     */
    __publicField(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    __publicField(this, "args");
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties$1(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    __publicField(this, "error");
    defineProperties$1(this, { error });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(iface, provider2, tx) {
    super(tx, provider2);
    __privateAdd(this, _iface);
    __privateSet(this, _iface, iface);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, __privateGet(this, _iface), fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
}
_iface = new WeakMap();
class ContractTransactionResponse extends TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(iface, provider2, tx) {
    super(tx, provider2);
    __privateAdd(this, _iface2);
    __privateSet(this, _iface2, iface);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
  }
}
_iface2 = new WeakMap();
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  @_event:
   */
  constructor(contract, listener, filter2, log) {
    super(contract, listener, filter2);
    /**
     *  The log with no matching events.
     */
    __publicField(this, "log");
    defineProperties$1(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter2, fragment, _log) {
    super(contract, listener, filter2, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties$1(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  constructor(contract, fragment, args) {
    __privateAdd(this, _filter);
    __publicField(this, "fragment");
    defineProperties$1(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    __privateSet(this, _filter, async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index2) => {
        const arg = args[index2];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index2], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v3) => resolveAddress(v3, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }());
  }
  getTopicFilter() {
    return __privateGet(this, _filter);
  }
}
_filter = new WeakMap();
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index2) => {
    return param.walkAsync(args[index2], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider2 = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider2, tx);
  };
  const estimateGas2 = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties$1(method, {
    _contract: contract,
    estimateGas: estimateGas2,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties$1({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider2 = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider2, tx);
  };
  const estimateGas2 = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties$1(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas: estimateGas2,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties$1(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name2) {
      if (isHexString(name2, 32)) {
        return name2;
      }
      const fragment2 = contract.interface.getEvent(name2);
      assertArgument(fragment2, "unknown fragment", "name", name2);
      return fragment2.topicHash;
    };
    topics = event.map((e2) => {
      if (e2 == null) {
        return null;
      }
      if (Array.isArray(e2)) {
        return e2.map(topicHashify);
      }
      return topicHashify(e2);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t2) => {
    if (t2 == null) {
      return null;
    }
    if (Array.isArray(t2)) {
      const items = Array.from(new Set(t2.map((t3) => t3.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t2.toLowerCase();
  });
  const tag = topics.map((t2) => {
    if (t2 == null) {
      return "null";
    }
    if (Array.isArray(t2)) {
      return t2.join("|");
    }
    return t2;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider2 = getProvider(contract.runner);
  assert(provider2, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter2 = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider2.on(filter2, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider2.off(filter2, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count2 = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count2 > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
_k = internal;
const _BaseContract = class _BaseContract {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi2, runner, _deployTx) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    __publicField(this, "target");
    /**
     *  The contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    __publicField(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    __publicField(this, "filters");
    /**
     *  @_ignore:
     */
    __publicField(this, _k);
    /**
     *  The fallback or receive function if any.
     */
    __publicField(this, "fallback");
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi2);
    defineProperties$1(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider2 = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider2, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties$1(this, { filters });
    defineProperties$1(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider2 = getProvider(this.runner);
    assert(provider2, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code2 = await provider2.getCode(await this.getAddress());
    if (code2 === "0x") {
      return null;
    }
    return code2;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code2 = await this.getDeployedCode();
    if (code2 != null) {
      return this;
    }
    const provider2 = getProvider(this.runner);
    assert(provider2 != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code3 = await this.getDeployedCode();
          if (code3 != null) {
            return resolve(this);
          }
          provider2.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash2) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter2 = { address, topics, fromBlock, toBlock };
    const provider2 = getProvider(this.runner);
    assert(provider2, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider2.getLogs(filter2)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider2);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index2 >= 0) {
        sub.listeners.splice(index2, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi2) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi2, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi2, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi2, runner);
    return contract;
  }
};
let BaseContract = _BaseContract;
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
class ContractFactory {
  /**
   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
   *  optionally connected to %%runner%%.
   *
   *  The %%bytecode%% may be the ``bytecode`` property within the
   *  standard Solidity JSON output.
   */
  constructor(abi2, bytecode, runner) {
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The Contract deployment bytecode. Often called the initcode.
     */
    __publicField(this, "bytecode");
    /**
     *  The ContractRunner to deploy the Contract as.
     */
    __publicField(this, "runner");
    const iface = Interface.from(abi2);
    if (bytecode instanceof Uint8Array) {
      bytecode = hexlify(getBytes(bytecode));
    } else {
      if (typeof bytecode === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = hexlify(getBytes(bytecode));
    }
    defineProperties$1(this, {
      bytecode,
      interface: iface,
      runner: runner || null
    });
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Resolves to the transaction to deploy the contract, passing %%args%%
   *  into the constructor.
   */
  async getDeployTransaction(...args) {
    let overrides = {};
    const fragment = this.interface.deploy;
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("incorrect number of arguments to constructor");
    }
    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
    const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
    return Object.assign({}, overrides, { data });
  }
  /**
   *  Resolves to the Contract deployed by passing %%args%% into the
   *  constructor.
   *
   *  This will resolve to the Contract before it has been deployed to the
   *  network, so the [[BaseContract-waitForDeployment]] should be used before
   *  sending any transactions to it.
   */
  async deploy(...args) {
    const tx = await this.getDeployTransaction(...args);
    assert(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
      operation: "sendTransaction"
    });
    const sentTx = await this.runner.sendTransaction(tx);
    const address = getCreateAddress(sentTx);
    return new BaseContract(address, this.interface, this.runner, sentTx);
  }
  /**
   *  Return a new **ContractFactory** with the same ABI and bytecode,
   *  but connected to %%runner%%.
   */
  connect(runner) {
    return new ContractFactory(this.interface, this.bytecode, runner);
  }
  /**
   *  Create a new **ContractFactory** from the standard Solidity JSON output.
   */
  static fromSolidity(output2, runner) {
    assertArgument(output2 != null, "bad compiler output", "output", output2);
    if (typeof output2 === "string") {
      output2 = JSON.parse(output2);
    }
    const abi2 = output2.abi;
    let bytecode = "";
    if (output2.bytecode) {
      bytecode = output2.bytecode;
    } else if (output2.evm && output2.evm.bytecode) {
      bytecode = output2.evm.bytecode;
    }
    return new this(abi2, bytecode, runner);
  }
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name2) {
    /**
     *  The name.
     */
    __publicField(this, "name");
    defineProperties$1(this, { name: name2 });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
const _EnsResolver = class _EnsResolver {
  constructor(provider2, address, name2) {
    __privateAdd(this, _EnsResolver_instances);
    /**
     *  The connected provider.
     */
    __publicField(this, "provider");
    /**
     *  The address of the resolver.
     */
    __publicField(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    __publicField(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    __privateAdd(this, _supports2544);
    __privateAdd(this, _resolver);
    defineProperties$1(this, { provider: provider2, address, name: name2 });
    __privateSet(this, _supports2544, null);
    __privateSet(this, _resolver, new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider2));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (__privateGet(this, _supports2544) == null) {
      __privateSet(this, _supports2544, (async () => {
        try {
          return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          __privateSet(this, _supports2544, null);
          throw error;
        }
      })());
    }
    return await __privateGet(this, _supports2544);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key) {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar2 = await this._getAvatar();
    return avatar2.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar2 = await this.getText("avatar");
      if (avatar2 == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar2 });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar2.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar2 });
            return { linkage, url: avatar2 };
          case "ipfs": {
            const url = getIpfsLink(avatar2);
            linkage.push({ type: "ipfs", value: avatar2 });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector2 = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar2 });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector2](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata2 = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata2 = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata2) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata2) });
            let imageUrl = metadata2.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider2) {
    const network2 = await provider2.getNetwork();
    const ensPlugin = network2.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network: network2 }
    });
    return ensPlugin.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider2, name2) {
    var _a2;
    let currentName = name2;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name2 !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await __privateMethod(_a2 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a2, provider2, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider2, addr, name2);
        if (currentName !== name2 && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};
_supports2544 = new WeakMap();
_resolver = new WeakMap();
_EnsResolver_instances = new WeakSet();
fetch_fn = async function(funcName, params) {
  params = (params || []).slice();
  const iface = __privateGet(this, _resolver).interface;
  params.unshift(namehash(this.name));
  let fragment = null;
  if (await this.supportsWildcard()) {
    fragment = iface.getFunction(funcName);
    assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
      info: { funcName }
    });
    params = [
      dnsEncode(this.name, 255),
      iface.encodeFunctionData(fragment, params)
    ];
    funcName = "resolve(bytes,bytes)";
  }
  params.push({
    enableCcipRead: true
  });
  try {
    const result = await __privateGet(this, _resolver)[funcName](...params);
    if (fragment) {
      return iface.decodeFunctionResult(fragment, result)[0];
    }
    return result;
  } catch (error) {
    if (!isError(error, "CALL_EXCEPTION")) {
      throw error;
    }
  }
  return null;
};
_EnsResolver_static = new WeakSet();
getResolver_fn = async function(provider2, name2) {
  const ensAddr = await _EnsResolver.getEnsAddress(provider2);
  try {
    const contract = new Contract(ensAddr, [
      "function resolver(bytes32) view returns (address)"
    ], provider2);
    const addr = await contract.resolver(namehash(name2), {
      enableCcipRead: true
    });
    if (addr === ZeroAddress) {
      return null;
    }
    return addr;
  } catch (error) {
    throw error;
  }
  return null;
};
__privateAdd(_EnsResolver, _EnsResolver_static);
let EnsResolver = _EnsResolver;
const BN_0 = BigInt(0);
function allowNull(format2, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format2(value);
  };
}
function arrayOf(format2, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format2(i));
  };
}
function object(format2, altNames) {
  return (value) => {
    const result = {};
    for (const key in format2) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format2[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name2) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    __publicField(this, "name");
    defineProperties$1(this, { name: name2 });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    __publicField(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    __publicField(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    __publicField(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    __publicField(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    __publicField(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListAddress");
    const props = { effectiveBlock };
    function set(name2, nullish) {
      let value = (costs || {})[name2];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name2}`, "costs", costs);
      props[name2] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties$1(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    __publicField(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    __publicField(this, "targetNetwork");
    defineProperties$1(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
const _FeeDataNetworkPlugin = class _FeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    __privateAdd(this, _feeDataFunc);
    __privateSet(this, _feeDataFunc, feeDataFunc);
  }
  /**
   *  The fee data function provided to the constructor.
   */
  get feeDataFunc() {
    return __privateGet(this, _feeDataFunc);
  }
  /**
   *  Resolves to the fee data.
   */
  async getFeeData(provider2) {
    return await __privateGet(this, _feeDataFunc).call(this, provider2);
  }
  clone() {
    return new _FeeDataNetworkPlugin(__privateGet(this, _feeDataFunc));
  }
};
_feeDataFunc = new WeakMap();
let FeeDataNetworkPlugin = _FeeDataNetworkPlugin;
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    __privateAdd(this, _url2);
    __privateAdd(this, _processFunc);
    __privateSet(this, _url2, url);
    __privateSet(this, _processFunc, processFunc);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return __privateGet(this, _url2);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return __privateGet(this, _processFunc);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
_url2 = new WeakMap();
_processFunc = new WeakMap();
const Networks = /* @__PURE__ */ new Map();
const _Network = class _Network {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name2, chainId) {
    __privateAdd(this, _name);
    __privateAdd(this, _chainId3);
    __privateAdd(this, _plugins);
    __privateSet(this, _name, name2);
    __privateSet(this, _chainId3, getBigInt(chainId));
    __privateSet(this, _plugins, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return __privateGet(this, _name);
  }
  set name(value) {
    __privateSet(this, _name, value);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return __privateGet(this, _chainId3);
  }
  set chainId(value) {
    __privateSet(this, _chainId3, getBigInt(value, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins).set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name2) {
    return __privateGet(this, _plugins).get(name2) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p2) => p2.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network2) {
    injectCommonNetworks();
    if (network2 == null) {
      return _Network.from("mainnet");
    }
    if (typeof network2 === "number") {
      network2 = BigInt(network2);
    }
    if (typeof network2 === "string" || typeof network2 === "bigint") {
      const networkFunc = Networks.get(network2);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network2 === "bigint") {
        return new _Network("unknown", network2);
      }
      assertArgument(false, "unknown network", "network", network2);
    }
    if (typeof network2.clone === "function") {
      const clone = network2.clone();
      return clone;
    }
    if (typeof network2 === "object") {
      assertArgument(typeof network2.name === "string" && typeof network2.chainId === "number", "invalid network object name or chainId", "network", network2);
      const custom2 = new _Network(network2.name, network2.chainId);
      if (network2.ensAddress || network2.ensNetwork != null) {
        custom2.attachPlugin(new EnsPlugin(network2.ensAddress, network2.ensNetwork));
      }
      return custom2;
    }
    assertArgument(false, "invalid network", "network", network2);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
_name = new WeakMap();
_chainId3 = new WeakMap();
_plugins = new WeakMap();
let Network = _Network;
function parseUnits$1(_value2, decimals) {
  const value = String(_value2);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider2, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits$1(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits$1(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name2, chainId, options) {
    const func = function() {
      const network2 = new Network(name2, chainId);
      if (options.ensNetwork != null) {
        network2.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network2.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network2.attachPlugin(plugin);
      });
      return network2;
    };
    Network.register(name2, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name3) => {
        Network.register(name3, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$3(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider2) {
    __privateAdd(this, _PollingBlockSubscriber_instances);
    __privateAdd(this, _provider);
    __privateAdd(this, _poller);
    __privateAdd(this, _interval);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber);
    __privateSet(this, _provider, provider2);
    __privateSet(this, _poller, null);
    __privateSet(this, _interval, 4e3);
    __privateSet(this, _blockNumber, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return __privateGet(this, _interval);
  }
  set pollingInterval(value) {
    __privateSet(this, _interval, value);
  }
  start() {
    if (__privateGet(this, _poller)) {
      return;
    }
    __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
    __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
  }
  stop() {
    if (!__privateGet(this, _poller)) {
      return;
    }
    __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
    __privateSet(this, _poller, null);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider = new WeakMap();
_poller = new WeakMap();
_interval = new WeakMap();
_blockNumber = new WeakMap();
_PollingBlockSubscriber_instances = new WeakSet();
poll_fn = async function() {
  try {
    const blockNumber = await __privateGet(this, _provider).getBlockNumber();
    if (__privateGet(this, _blockNumber) === -2) {
      __privateSet(this, _blockNumber, blockNumber);
      return;
    }
    if (blockNumber !== __privateGet(this, _blockNumber)) {
      for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
        if (__privateGet(this, _poller) == null) {
          return;
        }
        await __privateGet(this, _provider).emit("block", b2);
      }
      __privateSet(this, _blockNumber, blockNumber);
    }
  } catch (error) {
  }
  if (__privateGet(this, _poller) == null) {
    return;
  }
  __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
};
class OnBlockSubscriber {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider2) {
    __privateAdd(this, _provider2);
    __privateAdd(this, _poll);
    __privateAdd(this, _running);
    __privateSet(this, _provider2, provider2);
    __privateSet(this, _running, false);
    __privateSet(this, _poll, (blockNumber) => {
      this._poll(blockNumber, __privateGet(this, _provider2));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider2) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, true);
    __privateGet(this, _poll).call(this, -2);
    __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
  }
  stop() {
    if (!__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, false);
    __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
_provider2 = new WeakMap();
_poll = new WeakMap();
_running = new WeakMap();
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  constructor(provider2, tag) {
    super(provider2);
    __privateAdd(this, _tag);
    __privateAdd(this, _lastBlock);
    __privateSet(this, _tag, tag);
    __privateSet(this, _lastBlock, -2);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateSet(this, _lastBlock, -2);
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider2) {
    const block = await provider2.getBlock(__privateGet(this, _tag));
    if (block == null) {
      return;
    }
    if (__privateGet(this, _lastBlock) === -2) {
      __privateSet(this, _lastBlock, block.number);
    } else if (block.number > __privateGet(this, _lastBlock)) {
      provider2.emit(__privateGet(this, _tag), block.number);
      __privateSet(this, _lastBlock, block.number);
    }
  }
}
_tag = new WeakMap();
_lastBlock = new WeakMap();
class PollingOrphanSubscriber extends OnBlockSubscriber {
  constructor(provider2, filter2) {
    super(provider2);
    __privateAdd(this, _filter2);
    __privateSet(this, _filter2, copy$3(filter2));
  }
  async _poll(blockNumber, provider2) {
    throw new Error("@TODO");
  }
}
_filter2 = new WeakMap();
class PollingTransactionSubscriber extends OnBlockSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider2, hash2) {
    super(provider2);
    __privateAdd(this, _hash);
    __privateSet(this, _hash, hash2);
  }
  async _poll(blockNumber, provider2) {
    const tx = await provider2.getTransactionReceipt(__privateGet(this, _hash));
    if (tx) {
      provider2.emit(__privateGet(this, _hash), tx);
    }
  }
}
_hash = new WeakMap();
class PollingEventSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider2, filter2) {
    __privateAdd(this, _PollingEventSubscriber_instances);
    __privateAdd(this, _provider3);
    __privateAdd(this, _filter3);
    __privateAdd(this, _poller2);
    __privateAdd(this, _running2);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber2);
    __privateSet(this, _provider3, provider2);
    __privateSet(this, _filter3, copy$3(filter2));
    __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
    __privateSet(this, _running2, false);
    __privateSet(this, _blockNumber2, -2);
  }
  start() {
    if (__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, true);
    if (__privateGet(this, _blockNumber2) === -2) {
      __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
        __privateSet(this, _blockNumber2, blockNumber);
      });
    }
    __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
  }
  stop() {
    if (!__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, false);
    __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber2, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider3 = new WeakMap();
_filter3 = new WeakMap();
_poller2 = new WeakMap();
_running2 = new WeakMap();
_blockNumber2 = new WeakMap();
_PollingEventSubscriber_instances = new WeakSet();
poll_fn2 = async function(blockNumber) {
  if (__privateGet(this, _blockNumber2) === -2) {
    return;
  }
  const filter2 = copy$3(__privateGet(this, _filter3));
  filter2.fromBlock = __privateGet(this, _blockNumber2) + 1;
  filter2.toBlock = blockNumber;
  const logs = await __privateGet(this, _provider3).getLogs(filter2);
  if (logs.length === 0) {
    if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
      __privateSet(this, _blockNumber2, blockNumber - 60);
    }
    return;
  }
  for (const log of logs) {
    __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log);
    __privateSet(this, _blockNumber2, log.blockNumber);
  }
};
const BN_2$1 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise$1(value) {
  return value && typeof value.then === "function";
}
function getTag$1(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k2, v3) => {
    if (v3 == null) {
      return "null";
    }
    if (typeof v3 === "bigint") {
      return `bigint:${v3.toString()}`;
    }
    if (typeof v3 === "string") {
      return v3.toLowerCase();
    }
    if (typeof v3 === "object" && !Array.isArray(v3)) {
      const keys = Object.keys(v3);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v3[key];
        return accum;
      }, {});
    }
    return v3;
  });
}
class UnmanagedSubscriber {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name2) {
    /**
     *  The name fof the event.
     */
    __publicField(this, "name");
    defineProperties$1(this, { name: name2 });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$2(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event2, provider2) {
  if (_event2 == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event2)) {
    _event2 = { topics: _event2 };
  }
  if (typeof _event2 === "string") {
    switch (_event2) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event2, tag: _event2 };
      }
    }
  }
  if (isHexString(_event2, 32)) {
    const hash2 = _event2.toLowerCase();
    return { type: "transaction", tag: getTag$1("tx", { hash: hash2 }), hash: hash2 };
  }
  if (_event2.orphan) {
    const event = _event2;
    return { type: "orphan", tag: getTag$1("orphan", event), filter: copy$2(event) };
  }
  if (_event2.address || _event2.topics) {
    const event = _event2;
    const filter2 = {
      topics: (event.topics || []).map((t2) => {
        if (t2 == null) {
          return null;
        }
        if (Array.isArray(t2)) {
          return concisify(t2.map((t3) => t3.toLowerCase()));
        }
        return t2.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider2));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter2.address = concisify(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter: filter2, tag: getTag$1("event", filter2), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event2);
}
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network3, options) {
    __privateAdd(this, _AbstractProvider_instances);
    __privateAdd(this, _subs);
    __privateAdd(this, _plugins2);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    __privateAdd(this, _pausedState);
    __privateAdd(this, _destroyed);
    __privateAdd(this, _networkPromise);
    __privateAdd(this, _anyNetwork);
    __privateAdd(this, _performCache);
    // The most recent block number if running an event or -1 if no "block" event
    __privateAdd(this, _lastBlockNumber);
    __privateAdd(this, _nextTimer);
    __privateAdd(this, _timers);
    __privateAdd(this, _disableCcipRead);
    __privateAdd(this, _options2);
    __privateSet(this, _options2, Object.assign({}, defaultOptions$1, options || {}));
    if (_network3 === "any") {
      __privateSet(this, _anyNetwork, true);
      __privateSet(this, _networkPromise, null);
    } else if (_network3) {
      const network2 = Network.from(_network3);
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, Promise.resolve(network2));
      setTimeout(() => {
        this.emit("network", network2, null);
      }, 0);
    } else {
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, null);
    }
    __privateSet(this, _lastBlockNumber, -1);
    __privateSet(this, _performCache, /* @__PURE__ */ new Map());
    __privateSet(this, _subs, /* @__PURE__ */ new Map());
    __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
    __privateSet(this, _pausedState, null);
    __privateSet(this, _destroyed, false);
    __privateSet(this, _nextTimer, 1);
    __privateSet(this, _timers, /* @__PURE__ */ new Map());
    __privateSet(this, _disableCcipRead, false);
  }
  get pollingInterval() {
    return __privateGet(this, _options2).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins2).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins2).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name2) {
    return __privateGet(this, _plugins2).get(name2) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return __privateGet(this, _disableCcipRead);
  }
  set disableCcipRead(value) {
    __privateSet(this, _disableCcipRead, !!value);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      const resp = await request.send();
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network2) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network2) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network2) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network2) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
    if (__privateGet(this, _lastBlockNumber) >= 0) {
      __privateSet(this, _lastBlockNumber, blockNumber);
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (__privateGet(this, _lastBlockNumber) >= 0) {
        return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter2) {
    const topics = (filter2.topics || []).map((t2) => {
      if (t2 == null) {
        return null;
      }
      if (Array.isArray(t2)) {
        return concisify(t2.map((t3) => t3.toLowerCase()));
      }
      return t2.toLowerCase();
    });
    const blockHash = "blockHash" in filter2 ? filter2.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter3 = {};
      if (address2) {
        filter3.address = address2;
      }
      if (topics.length) {
        filter3.topics = topics;
      }
      if (fromBlock2) {
        filter3.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter3.toBlock = toBlock2;
      }
      if (blockHash) {
        filter3.blockHash = blockHash;
      }
      return filter3;
    };
    let address = [];
    if (filter2.address) {
      if (Array.isArray(filter2.address)) {
        for (const addr of filter2.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter2.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter2) {
      fromBlock = this._getBlockTag(filter2.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter2) {
      toBlock = this._getBlockTag(filter2.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request3) {
    const request = copyRequest(_request3);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key], this);
      if (isPromise$1(addr)) {
        promises.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise$1(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (__privateGet(this, _networkPromise) == null) {
      const detectNetwork = (async () => {
        try {
          const network2 = await this._detectNetwork();
          this.emit("network", network2, null);
          return network2;
        } catch (error) {
          if (__privateGet(this, _networkPromise) === detectNetwork) {
            __privateSet(this, _networkPromise, null);
          }
          throw error;
        }
      })();
      __privateSet(this, _networkPromise, detectNetwork);
      return (await detectNetwork).clone();
    }
    const networkPromise = __privateGet(this, _networkPromise);
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (__privateGet(this, _anyNetwork)) {
        this.emit("network", actual, expected);
        if (__privateGet(this, _networkPromise) === networkPromise) {
          __privateSet(this, _networkPromise, Promise.resolve(actual));
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network2 = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties$1({
        _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
        gasPrice: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network2);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_2$1 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network2.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise$1(tx)) {
      tx = await tx;
    }
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties$1({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash2, network: network2 } = await resolveProperties$1({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash2) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network2).replaceableTransaction(blockNumber);
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network: network2, params } = await resolveProperties$1({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network2);
  }
  async getTransaction(hash2) {
    const { network: network2, params } = await resolveProperties$1({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network2);
  }
  async getTransactionReceipt(hash2) {
    const { network: network2, params } = await resolveProperties$1({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash2 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network2);
  }
  async getTransactionResult(hash2) {
    const { result } = await resolveProperties$1({
      network: this.getNetwork(),
      result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash: hash2 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter5) {
    let filter2 = this._getFilter(_filter5);
    if (isPromise$1(filter2)) {
      filter2 = await filter2;
    }
    const { network: network2, params } = await resolveProperties$1({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter: filter2 })
    });
    return params.map((p2) => this._wrapLog(p2, network2));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name2) {
    return await EnsResolver.fromName(this, name2);
  }
  async getAvatar(name2) {
    const resolver = await this.getResolver(name2);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name2) {
    const resolver = await this.getResolver(name2);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name2 = await resolverContract.name(node);
      const check = await this.resolveName(name2);
      if (check !== address) {
        return null;
      }
      return name2;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash2, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash2);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash2);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = __privateGet(this, _timers).get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    __privateGet(this, _timers).delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = __privateWrapper(this, _nextTimer)._++;
    const func = () => {
      __privateGet(this, _timers).delete(timerId);
      _func();
    };
    if (this.paused) {
      __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      __privateGet(this, _timers).set(timerId, { timer, func, time: getTime$1() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of __privateGet(this, _subs).values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of __privateGet(this, _subs).values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (__privateGet(this, _pausedState) != null) {
          newSub.pause(__privateGet(this, _pausedState));
        }
        break;
      }
    }
  }
  async on(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count2 = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return count2 > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of __privateGet(this, _subs).values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of __privateGet(this, _subs).values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index2 >= 0) {
        sub.listeners.splice(index2, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
      if (started) {
        subscriber.stop();
      }
      __privateGet(this, _subs).delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
        if (started) {
          subscriber.stop();
        }
        __privateGet(this, _subs).delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return __privateGet(this, _destroyed);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of __privateGet(this, _timers).keys()) {
      this._clearTimeout(timerId);
    }
    __privateSet(this, _destroyed, true);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return __privateGet(this, _pausedState) != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    __privateSet(this, _lastBlockNumber, -1);
    if (__privateGet(this, _pausedState) != null) {
      if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s2) => s2.pause(dropWhilePaused));
    __privateSet(this, _pausedState, !!dropWhilePaused);
    for (const timer of __privateGet(this, _timers).values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime$1() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (__privateGet(this, _pausedState) == null) {
      return;
    }
    this._forEachSubscriber((s2) => s2.resume());
    __privateSet(this, _pausedState, null);
    for (const timer of __privateGet(this, _timers).values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime$1();
      setTimeout(timer.func, timeout);
    }
  }
}
_subs = new WeakMap();
_plugins2 = new WeakMap();
_pausedState = new WeakMap();
_destroyed = new WeakMap();
_networkPromise = new WeakMap();
_anyNetwork = new WeakMap();
_performCache = new WeakMap();
_lastBlockNumber = new WeakMap();
_nextTimer = new WeakMap();
_timers = new WeakMap();
_disableCcipRead = new WeakMap();
_options2 = new WeakMap();
_AbstractProvider_instances = new WeakSet();
perform_fn = async function(req) {
  const timeout = __privateGet(this, _options2).cacheTimeout;
  if (timeout < 0) {
    return await this._perform(req);
  }
  const tag = getTag$1(req.method, req);
  let perform = __privateGet(this, _performCache).get(tag);
  if (!perform) {
    perform = this._perform(req);
    __privateGet(this, _performCache).set(tag, perform);
    setTimeout(() => {
      if (__privateGet(this, _performCache).get(tag) === perform) {
        __privateGet(this, _performCache).delete(tag);
      }
    }, timeout);
  }
  return await perform;
};
call_fn = async function(tx, blockTag, attempt) {
  assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
  });
  const transaction2 = copyRequest(tx);
  try {
    return hexlify(await this._perform({ method: "call", transaction: transaction2, blockTag }));
  } catch (error) {
    if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction2.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
      const data = error.data;
      const txSender = await resolveAddress(transaction2.to, this);
      let ccipArgs;
      try {
        ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
      } catch (error2) {
        assert(false, error2.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction: transaction2,
          info: { data }
        });
      }
      assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data,
        reason: "OffchainLookup",
        transaction: transaction2,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: ccipArgs.errorArgs
        }
      });
      const ccipResult = await this.ccipReadFetch(transaction2, ccipArgs.calldata, ccipArgs.urls);
      assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction: transaction2,
        info: { data: error.data, errorArgs: ccipArgs.errorArgs }
      });
      const tx2 = {
        to: txSender,
        data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
      try {
        const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
        this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
        return result;
      } catch (error2) {
        this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
        throw error2;
      }
    }
    throw error;
  }
};
checkNetwork_fn = async function(promise) {
  const { value } = await resolveProperties$1({
    network: this.getNetwork(),
    value: promise
  });
  return value;
};
getAccountValue_fn = async function(request, _address, _blockTag) {
  let address = this._getAddress(_address);
  let blockTag = this._getBlockTag(_blockTag);
  if (typeof address !== "string" || typeof blockTag !== "string") {
    [address, blockTag] = await Promise.all([address, blockTag]);
  }
  return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request, { address, blockTag })));
};
getBlock_fn = async function(block, includeTransactions) {
  if (isHexString(block, 32)) {
    return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "getBlock",
      blockHash: block,
      includeTransactions
    });
  }
  let blockTag = this._getBlockTag(block);
  if (typeof blockTag !== "string") {
    blockTag = await blockTag;
  }
  return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
    method: "getBlock",
    blockTag,
    includeTransactions
  });
};
hasSub_fn = async function(event, emitArgs) {
  let sub = await getSubscription(event, this);
  if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
    sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
  }
  return __privateGet(this, _subs).get(sub.tag) || null;
};
getSub_fn = async function(event) {
  const subscription = await getSubscription(event, this);
  const tag = subscription.tag;
  let sub = __privateGet(this, _subs).get(tag);
  if (!sub) {
    const subscriber = this._getSubscriber(subscription);
    const addressableMap = /* @__PURE__ */ new WeakMap();
    const nameMap = /* @__PURE__ */ new Map();
    sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
    __privateGet(this, _subs).set(tag, sub);
  }
  return sub;
};
function _parseString(result, start) {
  try {
    const bytes2 = _parseBytes(result, start);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset2 = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset2, offset2 + 32));
    return dataSlice(result, offset2 + 32, offset2 + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u2 = 0; u2 < urlsLength; u2++) {
      const url = _parseString(urlsData, u2 * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k2) => result[k2]);
  return result;
}
function checkProvider(signer2, operation) {
  if (signer2.provider) {
    return signer2.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer2, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer2);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer2.getAddress(),
      resolveAddress(from, signer2)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer2.getAddress();
  }
  return await resolveProperties$1(pop);
}
class AbstractSigner {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider2) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties$1(this, { provider: provider2 || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider2 = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network2 = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network2.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network2.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider2.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider2.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties$1(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name2) {
    const provider2 = checkProvider(this, "resolveName");
    return await provider2.resolveName(name2);
  }
  async sendTransaction(tx) {
    const provider2 = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider2.broadcastTransaction(await this.signTransaction(txObj));
  }
}
const _VoidSigner = class _VoidSigner extends AbstractSigner {
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider2) {
    super(provider2);
    __privateAdd(this, _VoidSigner_instances);
    /**
     *  The signer address.
     */
    __publicField(this, "address");
    defineProperties$1(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider2) {
    return new _VoidSigner(this.address, provider2);
  }
  async signTransaction(tx) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "transactions", "signTransaction");
  }
  async signMessage(message) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "messages", "signMessage");
  }
  async signTypedData(domain2, types2, value) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
  }
};
_VoidSigner_instances = new WeakSet();
throwUnsupported_fn = function(suffix, operation) {
  assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
};
let VoidSigner = _VoidSigner;
const shown = /* @__PURE__ */ new Set();
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}
function copy$1(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider2) {
    __privateAdd(this, _FilterIdSubscriber_instances);
    __privateAdd(this, _provider4);
    __privateAdd(this, _filterIdPromise);
    __privateAdd(this, _poller3);
    __privateAdd(this, _running3);
    __privateAdd(this, _network);
    __privateAdd(this, _hault);
    __privateSet(this, _provider4, provider2);
    __privateSet(this, _filterIdPromise, null);
    __privateSet(this, _poller3, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).bind(this));
    __privateSet(this, _running3, false);
    __privateSet(this, _network, null);
    __privateSet(this, _hault, false);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider2) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider2, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider2) {
    throw new Error("subclasses must override this");
  }
  start() {
    if (__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, true);
    __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).call(this, -2);
  }
  stop() {
    if (!__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, false);
    __privateSet(this, _hault, true);
    __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    }
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  resume() {
    this.start();
  }
}
_provider4 = new WeakMap();
_filterIdPromise = new WeakMap();
_poller3 = new WeakMap();
_running3 = new WeakMap();
_network = new WeakMap();
_hault = new WeakMap();
_FilterIdSubscriber_instances = new WeakSet();
poll_fn3 = async function(blockNumber) {
  try {
    if (__privateGet(this, _filterIdPromise) == null) {
      __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
    }
    let filterId = null;
    try {
      filterId = await __privateGet(this, _filterIdPromise);
    } catch (error) {
      if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
        throw error;
      }
    }
    if (filterId == null) {
      __privateSet(this, _filterIdPromise, null);
      __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
      return;
    }
    const network2 = await __privateGet(this, _provider4).getNetwork();
    if (!__privateGet(this, _network)) {
      __privateSet(this, _network, network2);
    }
    if (__privateGet(this, _network).chainId !== network2.chainId) {
      throw new Error("chaid changed");
    }
    if (__privateGet(this, _hault)) {
      return;
    }
    const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
    await this._emitResults(__privateGet(this, _provider4), result);
  } catch (error) {
    console.log("@TODO", error);
  }
  __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
};
teardown_fn = function() {
  const filterIdPromise = __privateGet(this, _filterIdPromise);
  if (filterIdPromise) {
    __privateSet(this, _filterIdPromise, null);
    filterIdPromise.then((filterId) => {
      if (__privateGet(this, _provider4).destroyed) {
        return;
      }
      __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
    });
  }
};
class FilterIdEventSubscriber extends FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider2, filter2) {
    super(provider2);
    __privateAdd(this, _event);
    __privateSet(this, _event, copy$1(filter2));
  }
  _recover(provider2) {
    return new PollingEventSubscriber(provider2, __privateGet(this, _event));
  }
  async _subscribe(provider2) {
    const filterId = await provider2.send("eth_newFilter", [__privateGet(this, _event)]);
    return filterId;
  }
  async _emitResults(provider2, results2) {
    for (const result of results2) {
      provider2.emit(__privateGet(this, _event), provider2._wrapLog(result, provider2._network));
    }
  }
}
_event = new WeakMap();
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider2) {
    return await provider2.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider2, results2) {
    for (const result of results2) {
      provider2.emit("pending", result);
    }
  }
}
const Primitive$1 = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive$1.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall$3(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  constructor(provider2, address) {
    super(provider2);
    __publicField(this, "address");
    address = getAddress(address);
    defineProperties$1(this, { address });
  }
  connect(provider2) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to2 = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to2, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash2 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash2);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain2, types2, _value2) {
    const value = deepCopy(_value2);
    const populated = await TypedDataEncoder.resolveNames(domain2, types2, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  constructor(network2, options) {
    super(network2, options);
    __privateAdd(this, _JsonRpcApiProvider_instances);
    __privateAdd(this, _options3);
    // The next ID to use for the JSON-RPC ID field
    __privateAdd(this, _nextId2);
    // Payloads are queued and triggered in batches using the drainTimer
    __privateAdd(this, _payloads);
    __privateAdd(this, _drainTimer);
    __privateAdd(this, _notReady);
    __privateAdd(this, _network2);
    __privateAdd(this, _pendingDetectNetwork);
    __privateSet(this, _nextId2, 1);
    __privateSet(this, _options3, Object.assign({}, defaultOptions, options || {}));
    __privateSet(this, _payloads, []);
    __privateSet(this, _drainTimer, null);
    __privateSet(this, _network2, null);
    __privateSet(this, _pendingDetectNetwork, null);
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      __privateSet(this, _notReady, { promise, resolve });
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network2 !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network2 != null) {
        __privateSet(this, _network2, Network.from(network2));
      }
    } else if (staticNetwork) {
      assertArgument(network2 == null || staticNetwork.matches(network2), "staticNetwork MUST match network object", "options", options);
      __privateSet(this, _network2, staticNetwork);
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key) {
    return __privateGet(this, _options3)[key];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
    return __privateGet(this, _network2);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network2 = this._getOption("staticNetwork");
    if (network2) {
      if (network2 === true) {
        if (__privateGet(this, _network2)) {
          return __privateGet(this, _network2);
        }
      } else {
        return network2;
      }
    }
    if (__privateGet(this, _pendingDetectNetwork)) {
      return await __privateGet(this, _pendingDetectNetwork);
    }
    if (this.ready) {
      __privateSet(this, _pendingDetectNetwork, (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          __privateSet(this, _pendingDetectNetwork, null);
          return result;
        } catch (error) {
          __privateSet(this, _pendingDetectNetwork, null);
          throw error;
        }
      })());
      return await __privateGet(this, _pendingDetectNetwork);
    }
    __privateSet(this, _pendingDetectNetwork, (async () => {
      const payload = {
        id: __privateWrapper(this, _nextId2)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        __privateSet(this, _pendingDetectNetwork, null);
      } catch (error) {
        __privateSet(this, _pendingDetectNetwork, null);
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })());
    return await __privateGet(this, _pendingDetectNetwork);
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
      return;
    }
    __privateGet(this, _notReady).resolve();
    __privateSet(this, _notReady, null);
    (async () => {
      while (__privateGet(this, _network2) == null && !this.destroyed) {
        try {
          __privateSet(this, _network2, await this._detectNetwork());
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall$3(1e3);
        }
      }
      __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (__privateGet(this, _notReady) == null) {
      return;
    }
    return await __privateGet(this, _notReady).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return __privateGet(this, _notReady) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h2) => h2.toLowerCase());
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error2) {
    const { method } = payload;
    const { error } = _error2;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e2 = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e2.info = { error, payload };
      return e2;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction2 = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: transaction2,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction: transaction2, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: transaction2, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction: transaction2, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = __privateWrapper(this, _nextId2)._++;
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _payloads).push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties$1({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account2 of accounts) {
      if (getAddress(account2) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner(this, a2));
  }
  destroy() {
    if (__privateGet(this, _drainTimer)) {
      clearTimeout(__privateGet(this, _drainTimer));
      __privateSet(this, _drainTimer, null);
    }
    for (const { payload, reject } of __privateGet(this, _payloads)) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    __privateSet(this, _payloads, []);
    super.destroy();
  }
}
_options3 = new WeakMap();
_nextId2 = new WeakMap();
_payloads = new WeakMap();
_drainTimer = new WeakMap();
_notReady = new WeakMap();
_network2 = new WeakMap();
_pendingDetectNetwork = new WeakMap();
_JsonRpcApiProvider_instances = new WeakSet();
scheduleDrain_fn = function() {
  if (__privateGet(this, _drainTimer)) {
    return;
  }
  const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  __privateSet(this, _drainTimer, setTimeout(() => {
    __privateSet(this, _drainTimer, null);
    const payloads = __privateGet(this, _payloads);
    __privateSet(this, _payloads, []);
    while (payloads.length) {
      const batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === __privateGet(this, _options3).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        const bytes2 = JSON.stringify(batch.map((p2) => p2.payload));
        if (bytes2.length > __privateGet(this, _options3).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      (async () => {
        const payload = batch.length === 1 ? batch[0].payload : batch.map((p2) => p2.payload);
        this.emit("debug", { action: "sendRpcPayload", payload });
        try {
          const result = await this._send(payload);
          this.emit("debug", { action: "receiveRpcResult", result });
          for (const { resolve, reject, payload: payload2 } of batch) {
            if (this.destroyed) {
              reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
              continue;
            }
            const resp = result.filter((r2) => r2.id === payload2.id)[0];
            if (resp == null) {
              const error = makeError("missing response for request", "BAD_DATA", {
                value: result,
                info: { payload: payload2 }
              });
              this.emit("error", error);
              reject(error);
              continue;
            }
            if ("error" in resp) {
              reject(this.getRpcError(payload2, resp));
              continue;
            }
            resolve(resp.result);
          }
        } catch (error) {
          this.emit("debug", { action: "receiveRpcError", error });
          for (const { reject } of batch) {
            reject(error);
          }
        }
      })();
    }
  }, stallTime));
};
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  constructor(network2, options) {
    super(network2, options);
    __privateAdd(this, _pollingInterval);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    __privateSet(this, _pollingInterval, pollingInterval);
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = __privateGet(this, _pollingInterval);
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return __privateGet(this, _pollingInterval);
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    __privateSet(this, _pollingInterval, value);
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = __privateGet(this, _pollingInterval);
      }
    });
  }
}
_pollingInterval = new WeakMap();
let JsonRpcProvider$1 = (_l = class extends JsonRpcApiPollingProvider {
  constructor(url, network2, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network2, options);
    __privateAdd(this, _connect);
    if (typeof url === "string") {
      __privateSet(this, _connect, new FetchRequest(url));
    } else {
      __privateSet(this, _connect, url.clone());
    }
  }
  _getConnection() {
    return __privateGet(this, _connect).clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}, _connect = new WeakMap(), _l);
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
const defaultApiKey$1 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost$5(name2) {
  switch (name2) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  assertArgument(false, "unsupported network", "network", name2);
}
class AnkrProvider extends JsonRpcProvider$1 {
  /**
   *  Create a new **AnkrProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network3, apiKey) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network2 = Network.from(_network3);
    if (apiKey == null) {
      apiKey = defaultApiKey$1;
    }
    const options = { polling: true, staticNetwork: network2 };
    const request = AnkrProvider.getRequest(network2, apiKey);
    super(request, network2, options);
    /**
     *  The API key for the Ankr connection.
     */
    __publicField(this, "apiKey");
    defineProperties$1(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AnkrProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%apiKey%%.
   */
  static getRequest(network2, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey$1;
    }
    const request = new FetchRequest(`https://${getHost$5(network2.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey$1) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("AnkrProvider");
        return true;
      };
    }
    return request;
  }
  getRpcError(payload, error) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$1;
  }
}
const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost$4(name2) {
  switch (name2) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-amoy":
      return "polygon-amoy.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  assertArgument(false, "unsupported network", "network", name2);
}
class AlchemyProvider extends JsonRpcProvider$1 {
  constructor(_network3, apiKey) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network2 = Network.from(_network3);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const request = AlchemyProvider.getRequest(network2, apiKey);
    super(request, network2, { staticNetwork: network2 });
    __publicField(this, "apiKey");
    defineProperties$1(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AlchemyProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx } = await resolveProperties$1({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx == null) {
        return null;
      }
      let data;
      let error = false;
      try {
        data = trace[0].result.output;
        error = trace[0].error === "Reverted";
      } catch (error2) {
      }
      if (data) {
        assert(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data,
          reason: null,
          transaction: tx,
          invocation: null,
          revert: null
          // @TODO
        });
        return data;
      }
      assert(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
  static getRequest(network2, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const request = new FetchRequest(`https://${getHost$4(network2.name)}/v2/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("alchemy");
        return true;
      };
    }
    return request;
  }
}
function getApiKey(name2) {
  switch (name2) {
    case "mainnet":
      return "39f1d67cedf8b7831010a665328c9197";
    case "arbitrum":
      return "0550c209db33c3abf4cc927e1e18cea1";
    case "bnb":
      return "98b5a77e531614387366f6fc5da097f8";
    case "matic":
      return "cd9d4d70377471aa7c142ec4a4205249";
  }
  assertArgument(false, "unsupported network", "network", name2);
}
function getHost$3(name2) {
  switch (name2) {
    case "mainnet":
      return "ethereum-mainnet.core.chainstack.com";
    case "arbitrum":
      return "arbitrum-mainnet.core.chainstack.com";
    case "bnb":
      return "bsc-mainnet.core.chainstack.com";
    case "matic":
      return "polygon-mainnet.core.chainstack.com";
  }
  assertArgument(false, "unsupported network", "network", name2);
}
class ChainstackProvider extends JsonRpcProvider$1 {
  /**
   *  Creates a new **ChainstackProvider**.
   */
  constructor(_network3, apiKey) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network2 = Network.from(_network3);
    if (apiKey == null) {
      apiKey = getApiKey(network2.name);
    }
    const request = ChainstackProvider.getRequest(network2, apiKey);
    super(request, network2, { staticNetwork: network2 });
    /**
     *  The API key for the Chainstack connection.
     */
    __publicField(this, "apiKey");
    defineProperties$1(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new ChainstackProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === getApiKey(this._network.name);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%apiKey%% and %%projectSecret%%.
   */
  static getRequest(network2, apiKey) {
    if (apiKey == null) {
      apiKey = getApiKey(network2.name);
    }
    const request = new FetchRequest(`https://${getHost$3(network2.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === getApiKey(network2.name)) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("ChainstackProvider");
        return true;
      };
    }
    return request;
  }
}
class CloudflareProvider extends JsonRpcProvider$1 {
  constructor(_network3) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network2 = Network.from(_network3);
    assertArgument(network2.name === "mainnet", "unsupported network", "network", _network3);
    super("https://cloudflare-eth.com/", network2, { staticNetwork: network2 });
  }
}
const THROTTLE = 2e3;
function isPromise(value) {
  return value && typeof value.then === "function";
}
const EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
class EtherscanPlugin extends NetworkPlugin {
  /**
   *  Creates a new **EtherscanProvider** which will use
   *  %%baseUrl%%.
   */
  constructor(baseUrl) {
    super(EtherscanPluginId);
    /**
     *  The Etherscan API base URL.
     */
    __publicField(this, "baseUrl");
    defineProperties$1(this, { baseUrl });
  }
  clone() {
    return new EtherscanPlugin(this.baseUrl);
  }
}
const skipKeys = ["enableCcipRead"];
let nextId = 1;
class EtherscanProvider extends AbstractProvider {
  /**
   *  Creates a new **EtherscanBaseProvider**.
   */
  constructor(_network3, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    /**
     *  The connected network.
     */
    __publicField(this, "network");
    /**
     *  The API key or null if using the community provided bandwidth.
     */
    __publicField(this, "apiKey");
    __privateAdd(this, _plugin);
    const network2 = Network.from(_network3);
    __privateSet(this, _plugin, network2.getPlugin(EtherscanPluginId));
    defineProperties$1(this, { apiKey, network: network2 });
    this.getBaseUrl();
  }
  /**
   *  Returns the base URL.
   *
   *  If an [[EtherscanPlugin]] is configured on the
   *  [[EtherscanBaseProvider_network]], returns the plugin's
   *  baseUrl.
   */
  getBaseUrl() {
    if (__privateGet(this, _plugin)) {
      return __privateGet(this, _plugin).baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "holesky":
        return "https://api-holesky.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "base":
        return "https://api.basescan.org";
      case "base-sepolia":
        return "https://api-sepolia.basescan.org";
      case "bnb":
        return "https://api.bscscan.com";
      case "bnbt":
        return "https://api-testnet.bscscan.com";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-amoy":
        return "https://api-amoy.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
    }
    assertArgument(false, "unsupported network", "network", this.network);
  }
  /**
   *  Returns the URL for the %%module%% and %%params%%.
   */
  getUrl(module2, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.getBaseUrl()}/api?module=${module2}${query}${apiKey}`;
  }
  /**
   *  Returns the URL for using POST requests.
   */
  getPostUrl() {
    return `${this.getBaseUrl()}/api`;
  }
  /**
   *  Returns the parameters for using POST requests.
   */
  getPostData(module2, params) {
    params.module = module2;
    params.apikey = this.apiKey;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the result of calling %%module%% with %%params%%.
   *
   *  If %%post%%, the request is made as a POST request.
   */
  async fetch(module2, params, post) {
    const id2 = nextId++;
    const url = post ? this.getPostUrl() : this.getUrl(module2, params);
    const payload = post ? this.getPostData(module2, params) : null;
    this.emit("debug", { action: "sendRequest", id: id2, url, payload });
    const request = new FetchRequest(url);
    request.setThrottleParams({ slotInterval: 1e3 });
    request.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage("Etherscan");
      }
      return Promise.resolve(true);
    };
    request.processFunc = async (request2, response2) => {
      const result2 = response2.hasBody() ? JSON.parse(toUtf8String(response2.body)) : {};
      const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module2 === "proxy") {
        if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id2, reason: "proxy-NOTOK", error: result2 });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id2, reason: "null result", error: result2.result });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      }
      return response2;
    };
    if (payload) {
      request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request.body = Object.keys(payload).map((k2) => `${k2}=${payload[k2]}`).join("&");
    }
    const response = await request.send();
    try {
      response.assertOk();
    } catch (error) {
      this.emit("debug", { action: "receiveError", id: id2, error, reason: "assertOk" });
      assert(false, "response error", "SERVER_ERROR", { request, response });
    }
    if (!response.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id2, error: "missing body", reason: "null body" });
      assert(false, "missing response", "SERVER_ERROR", { request, response });
    }
    const result = JSON.parse(toUtf8String(response.body));
    if (module2 === "proxy") {
      if (result.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id2, result, reason: "invalid JSON-RPC" });
        assert(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
      }
      if (result.error) {
        this.emit("debug", { action: "receiveError", id: id2, result, reason: "JSON-RPC error" });
        assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id2, result });
      return result.result;
    } else {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id2, result });
        return result.result;
      }
      if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id2, result });
        assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id2, result });
      return result.result;
    }
  }
  /**
   *  Returns %%transaction%% normalized for the Etherscan API.
   */
  _getTransactionPostData(transaction2) {
    const result = {};
    for (let key in transaction2) {
      if (skipKeys.indexOf(key) >= 0) {
        continue;
      }
      if (transaction2[key] == null) {
        continue;
      }
      let value = transaction2[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if (key === "blockTag" && value === "latest") {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = toQuantity(value);
      } else if (key === "accessList") {
        value = "[" + accessListify(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else if (key === "blobVersionedHashes") {
        if (value.length === 0) {
          continue;
        }
        assert(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
          operation: "_getTransactionPostData",
          info: { transaction: transaction2 }
        });
      } else {
        value = hexlify(value);
      }
      result[key] = value;
    }
    return result;
  }
  /**
   *  Throws the normalized Etherscan error.
   */
  _checkError(req, error, transaction2) {
    let message = "";
    if (isError(error, "SERVER_ERROR")) {
      try {
        message = error.info.result.error.message;
      } catch (e2) {
      }
      if (!message) {
        try {
          message = error.info.message;
        } catch (e2) {
        }
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data = "";
        try {
          data = error.info.result.error.data;
        } catch (error2) {
        }
        const e2 = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
        e2.info = { request: req, error };
        throw e2;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction3 = Transaction.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction3
          });
        }
        if (message.match(/insufficient funds/)) {
          assert(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction3
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction3
          });
        }
      }
    }
    throw error;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getPriorityFee":
        if (this.network.name === "mainnet") {
          return "1000000000";
        } else if (this.network.name === "optimism") {
          return "1000000";
        } else {
          throw new Error("fallback onto the AbstractProvider default");
        }
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error) => {
          return this._checkError(req, error, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  /**
   *  Resolves to the current price of ether.
   *
   *  This returns ``0`` on any network other than ``mainnet``.
   */
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  /**
   *  Resolves to a [Contract]] for %%address%%, using the
   *  Etherscan API to retreive the Contract ABI.
   */
  async getContract(_address) {
    let address = this._getAddress(_address);
    if (isPromise(address)) {
      address = await address;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address
      });
      const abi2 = JSON.parse(resp);
      return new Contract(address, abi2, this);
    } catch (error) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}
_plugin = new WeakMap();
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global$1 !== "undefined") {
    return global$1;
  }
  throw new Error("unable to locate global object");
}
const _WebSocket = getGlobal().WebSocket;
class SocketSubscriber {
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  constructor(provider2, filter2) {
    __privateAdd(this, _provider5);
    __privateAdd(this, _filter4);
    __privateAdd(this, _filterId);
    __privateAdd(this, _paused);
    __privateAdd(this, _emitPromise);
    __privateSet(this, _provider5, provider2);
    __privateSet(this, _filter4, JSON.stringify(filter2));
    __privateSet(this, _filterId, null);
    __privateSet(this, _paused, null);
    __privateSet(this, _emitPromise, null);
  }
  /**
   *  The filter.
   */
  get filter() {
    return JSON.parse(__privateGet(this, _filter4));
  }
  start() {
    __privateSet(this, _filterId, __privateGet(this, _provider5).send("eth_subscribe", this.filter).then((filterId) => {
      __privateGet(this, _provider5)._register(filterId, this);
      return filterId;
    }));
  }
  stop() {
    __privateGet(this, _filterId).then((filterId) => {
      if (__privateGet(this, _provider5).destroyed) {
        return;
      }
      __privateGet(this, _provider5).send("eth_unsubscribe", [filterId]);
    });
    __privateSet(this, _filterId, null);
  }
  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
  //        and resume
  pause(dropWhilePaused) {
    assert(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    __privateSet(this, _paused, !!dropWhilePaused);
  }
  resume() {
    __privateSet(this, _paused, null);
  }
  /**
   *  @_ignore:
   */
  _handleMessage(message) {
    if (__privateGet(this, _filterId) == null) {
      return;
    }
    if (__privateGet(this, _paused) === null) {
      let emitPromise = __privateGet(this, _emitPromise);
      if (emitPromise == null) {
        emitPromise = this._emit(__privateGet(this, _provider5), message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(__privateGet(this, _provider5), message);
        });
      }
      __privateSet(this, _emitPromise, emitPromise.then(() => {
        if (__privateGet(this, _emitPromise) === emitPromise) {
          __privateSet(this, _emitPromise, null);
        }
      }));
    }
  }
  /**
   *  Sub-classes **must** override this to emit the events on the
   *  provider.
   */
  async _emit(provider2, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
}
_provider5 = new WeakMap();
_filter4 = new WeakMap();
_filterId = new WeakMap();
_paused = new WeakMap();
_emitPromise = new WeakMap();
class SocketBlockSubscriber extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider2) {
    super(provider2, ["newHeads"]);
  }
  async _emit(provider2, message) {
    provider2.emit("block", parseInt(message.number));
  }
}
class SocketPendingSubscriber extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider2) {
    super(provider2, ["newPendingTransactions"]);
  }
  async _emit(provider2, message) {
    provider2.emit("pending", message);
  }
}
class SocketEventSubscriber extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider2, filter2) {
    super(provider2, ["logs", filter2]);
    __privateAdd(this, _logFilter);
    __privateSet(this, _logFilter, JSON.stringify(filter2));
  }
  /**
   *  The filter.
   */
  get logFilter() {
    return JSON.parse(__privateGet(this, _logFilter));
  }
  async _emit(provider2, message) {
    provider2.emit(this.logFilter, provider2._wrapLog(message, provider2._network));
  }
}
_logFilter = new WeakMap();
class SocketProvider extends JsonRpcApiProvider {
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  constructor(network2, _options4) {
    const options = Object.assign({}, _options4 != null ? _options4 : {});
    assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options4);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network2, options);
    __privateAdd(this, _callbacks);
    // Maps each filterId to its subscriber
    __privateAdd(this, _subs2);
    // If any events come in before a subscriber has finished
    // registering, queue them
    __privateAdd(this, _pending);
    __privateSet(this, _callbacks, /* @__PURE__ */ new Map());
    __privateSet(this, _subs2, /* @__PURE__ */ new Map());
    __privateSet(this, _pending, /* @__PURE__ */ new Map());
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "close":
        return new UnmanagedSubscriber("close");
      case "block":
        return new SocketBlockSubscriber(this);
      case "pending":
        return new SocketPendingSubscriber(this);
      case "event":
        return new SocketEventSubscriber(this, sub.filter);
      case "orphan":
        if (sub.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("drop-log");
        }
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Register a new subscriber. This is used internalled by Subscribers
   *  and generally is unecessary unless extending capabilities.
   */
  _register(filterId, subscriber) {
    __privateGet(this, _subs2).set(filterId, subscriber);
    const pending = __privateGet(this, _pending).get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      __privateGet(this, _pending).delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _callbacks).set(payload.id, { payload, resolve, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  // Sub-classes must call this once they are connected
  /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
  
          for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
  
          this.#ready = (async function() {
              await super._start();
          })();
      }
      */
  /**
   *  Sub-classes **must** call this with messages received over their
   *  transport to be processed and dispatched.
   */
  async _processMessage(message) {
    const result = JSON.parse(message);
    if (result && typeof result === "object" && "id" in result) {
      const callback = __privateGet(this, _callbacks).get(result.id);
      if (callback == null) {
        this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result
        }));
        return;
      }
      __privateGet(this, _callbacks).delete(result.id);
      callback.resolve(result);
    } else if (result && result.method === "eth_subscription") {
      const filterId = result.params.subscription;
      const subscriber = __privateGet(this, _subs2).get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result.params.result);
      } else {
        let pending = __privateGet(this, _pending).get(filterId);
        if (pending == null) {
          pending = [];
          __privateGet(this, _pending).set(filterId, pending);
        }
        pending.push(result.params.result);
      }
    } else {
      this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result
      }));
      return;
    }
  }
  /**
   *  Sub-classes **must** override this to send %%message%% over their
   *  transport.
   */
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
}
_callbacks = new WeakMap();
_subs2 = new WeakMap();
_pending = new WeakMap();
class WebSocketProvider extends SocketProvider {
  constructor(url, network2, options) {
    super(network2, options);
    __privateAdd(this, _connect2);
    __privateAdd(this, _websocket);
    if (typeof url === "string") {
      __privateSet(this, _connect2, () => {
        return new _WebSocket(url);
      });
      __privateSet(this, _websocket, __privateGet(this, _connect2).call(this));
    } else if (typeof url === "function") {
      __privateSet(this, _connect2, url);
      __privateSet(this, _websocket, url());
    } else {
      __privateSet(this, _connect2, null);
      __privateSet(this, _websocket, url);
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error) {
        console.log("failed to start WebsocketProvider", error);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  get websocket() {
    if (__privateGet(this, _websocket) == null) {
      throw new Error("websocket closed");
    }
    return __privateGet(this, _websocket);
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (__privateGet(this, _websocket) != null) {
      __privateGet(this, _websocket).close();
      __privateSet(this, _websocket, null);
    }
    super.destroy();
  }
}
_connect2 = new WeakMap();
_websocket = new WeakMap();
const defaultProjectId = "84842078b09946638c03157f83405213";
function getHost$2(name2) {
  switch (name2) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bnbsmartchain-mainnet.infura.io";
    case "bnbt":
      return "bnbsmartchain-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name2);
}
class InfuraWebSocketProvider extends WebSocketProvider {
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  constructor(network2, projectId) {
    const provider2 = new InfuraProvider(network2, projectId);
    const req = provider2._getConnection();
    assert(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, provider2._network);
    /**
     *  The Project ID for the INFURA connection.
     */
    __publicField(this, "projectId");
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    __publicField(this, "projectSecret");
    defineProperties$1(this, {
      projectId: provider2.projectId,
      projectSecret: provider2.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class InfuraProvider extends JsonRpcProvider$1 {
  /**
   *  Creates a new **InfuraProvider**.
   */
  constructor(_network3, projectId, projectSecret) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network2 = Network.from(_network3);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = InfuraProvider.getRequest(network2, projectId, projectSecret);
    super(request, network2, { staticNetwork: network2 });
    /**
     *  The Project ID for the INFURA connection.
     */
    __publicField(this, "projectId");
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    __publicField(this, "projectSecret");
    defineProperties$1(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  static getWebSocketProvider(network2, projectId) {
    return new InfuraWebSocketProvider(network2, projectId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%projectId%% and %%projectSecret%%.
   */
  static getRequest(network2, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest(`https://${getHost$2(network2.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("InfuraProvider");
        return true;
      };
    }
    return request;
  }
}
const defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost$1(name2) {
  switch (name2) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "sepolia":
      return "ethers.ethereum-sepolia.quiknode.pro";
    case "holesky":
      return "ethers.ethereum-holesky.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "arbitrum-sepolia":
      return "ethers.arbitrum-sepolia.quiknode.pro";
    case "base":
      return "ethers.base-mainnet.quiknode.pro";
    case "base-goerli":
      return "ethers.base-goerli.quiknode.pro";
    case "base-spolia":
      return "ethers.base-sepolia.quiknode.pro";
    case "bnb":
      return "ethers.bsc.quiknode.pro";
    case "bnbt":
      return "ethers.bsc-testnet.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
    case "optimism-sepolia":
      return "ethers.optimism-sepolia.quiknode.pro";
    case "xdai":
      return "ethers.xdai.quiknode.pro";
  }
  assertArgument(false, "unsupported network", "network", name2);
}
class QuickNodeProvider extends JsonRpcProvider$1 {
  /**
   *  Creates a new **QuickNodeProvider**.
   */
  constructor(_network3, token) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network2 = Network.from(_network3);
    if (token == null) {
      token = defaultToken;
    }
    const request = QuickNodeProvider.getRequest(network2, token);
    super(request, network2, { staticNetwork: network2 });
    /**
     *  The API token.
     */
    __publicField(this, "token");
    defineProperties$1(this, { token });
  }
  _getProvider(chainId) {
    try {
      return new QuickNodeProvider(chainId, this.token);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.token === defaultToken;
  }
  /**
   *  Returns a new request prepared for %%network%% and the
   *  %%token%%.
   */
  static getRequest(network2, token) {
    if (token == null) {
      token = defaultToken;
    }
    const request = new FetchRequest(`https://${getHost$1(network2.name)}/${token}`);
    request.allowGzip = true;
    if (token === defaultToken) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("QuickNodeProvider");
        return true;
      };
    }
    return request;
  }
}
const BN_1 = BigInt("1");
const BN_2 = BigInt("2");
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j2 = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j2];
    array[j2] = tmp;
  }
}
function stall$2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stringify$1(value) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof value2 === "bigint") {
      return { type: "bigint", value: value2.toString() };
    }
    return value2;
  });
}
const defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
const defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};
async function waitForSync(config2, blockNumber) {
  while (config2.blockNumber < 0 || config2.blockNumber < blockNumber) {
    if (!config2._updateNumber) {
      config2._updateNumber = (async () => {
        try {
          const blockNumber2 = await config2.provider.getBlockNumber();
          if (blockNumber2 > config2.blockNumber) {
            config2.blockNumber = blockNumber2;
          }
        } catch (error) {
          config2.blockNumber = -2;
          config2._lastFatalError = error;
          config2._lastFatalErrorTimestamp = getTime();
        }
        config2._updateNumber = null;
      })();
    }
    await config2._updateNumber;
    config2.outOfSync++;
    if (config2._lastFatalError) {
      break;
    }
  }
}
function _normalize(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((k2) => `${JSON.stringify(k2)}:${_normalize(value[k2])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult(value) {
  if ("error" in value) {
    const error = value.error;
    return { tag: _normalize(error), value: error };
  }
  const result = value.result;
  return { tag: _normalize(result), value: result };
}
function checkQuorum(quorum, results2) {
  const tally = /* @__PURE__ */ new Map();
  for (const { value, tag, weight } of results2) {
    const t2 = tally.get(tag) || { value, weight: 0 };
    t2.weight += weight;
    tally.set(tag, t2);
  }
  let best = null;
  for (const r2 of tally.values()) {
    if (r2.weight >= quorum && (!best || r2.weight > best.weight)) {
      best = r2;
    }
  }
  if (best) {
    return best.value;
  }
  return void 0;
}
function getMedian(quorum, results2) {
  let resultWeight = 0;
  const errorMap = /* @__PURE__ */ new Map();
  let bestError = null;
  const values = [];
  for (const { value, tag, weight } of results2) {
    if (value instanceof Error) {
      const e2 = errorMap.get(tag) || { value, weight: 0 };
      e2.weight += weight;
      errorMap.set(tag, e2);
      if (bestError == null || e2.weight > bestError.weight) {
        bestError = e2;
      }
    } else {
      values.push(BigInt(value));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return void 0;
  }
  values.sort((a2, b2) => a2 < b2 ? -1 : b2 > a2 ? 1 : 0);
  const mid = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[mid];
  }
  return (values[mid - 1] + values[mid] + BN_1) / BN_2;
}
function getAnyResult(quorum, results2) {
  const result = checkQuorum(quorum, results2);
  if (result !== void 0) {
    return result;
  }
  for (const r2 of results2) {
    if (r2.value) {
      return r2.value;
    }
  }
  return void 0;
}
function getFuzzyMode(quorum, results2) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results2), "%internal");
  }
  const tally = /* @__PURE__ */ new Map();
  const add2 = (result, weight) => {
    const t2 = tally.get(result) || { result, weight: 0 };
    t2.weight += weight;
    tally.set(result, t2);
  };
  for (const { weight, value } of results2) {
    const r2 = getNumber(value);
    add2(r2 - 1, weight);
    add2(r2, weight);
    add2(r2 + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = void 0;
  for (const { weight, result } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
      bestWeight = weight;
      bestResult = result;
    }
  }
  return bestResult;
}
class FallbackProvider extends AbstractProvider {
  /**
   *  Creates a new **FallbackProvider** with %%providers%% connected to
   *  %%network%%.
   *
   *  If a [[Provider]] is included in %%providers%%, defaults are used
   *  for the configuration.
   */
  constructor(providers, network2, options) {
    super(network2, options);
    __privateAdd(this, _FallbackProvider_instances);
    /**
     *  The number of backends that must agree on a value before it is
     *  accpeted.
     */
    __publicField(this, "quorum");
    /**
     *  @_ignore:
     */
    __publicField(this, "eventQuorum");
    /**
     *  @_ignore:
     */
    __publicField(this, "eventWorkers");
    __privateAdd(this, _configs);
    __privateAdd(this, _height);
    __privateAdd(this, _initialSyncPromise);
    __privateSet(this, _configs, providers.map((p2) => {
      if (p2 instanceof AbstractProvider) {
        return Object.assign({ provider: p2 }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p2, defaultState);
      }
    }));
    __privateSet(this, _height, -2);
    __privateSet(this, _initialSyncPromise, null);
    if (options && options.quorum != null) {
      this.quorum = options.quorum;
    } else {
      this.quorum = Math.ceil(__privateGet(this, _configs).reduce((accum, config2) => {
        accum += config2.weight;
        return accum;
      }, 0) / 2);
    }
    this.eventQuorum = 1;
    this.eventWorkers = 1;
    assertArgument(this.quorum <= __privateGet(this, _configs).reduce((a2, c2) => a2 + c2.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
  }
  get providerConfigs() {
    return __privateGet(this, _configs).map((c2) => {
      const result = Object.assign({}, c2);
      for (const key in result) {
        if (key[0] === "_") {
          delete result[key];
        }
      }
      return result;
    });
  }
  async _detectNetwork() {
    return Network.from(getBigInt(await this._perform({ method: "chainId" })));
  }
  // @TODO: Add support to select providers to be the event subscriber
  //_getSubscriber(sub: Subscription): Subscriber {
  //    throw new Error("@TODO");
  //}
  /**
   *  Transforms a %%req%% into the correct method call on %%provider%%.
   */
  async _translatePerform(provider2, req) {
    switch (req.method) {
      case "broadcastTransaction":
        return await provider2.broadcastTransaction(req.signedTransaction);
      case "call":
        return await provider2.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
      case "chainId":
        return (await provider2.getNetwork()).chainId;
      case "estimateGas":
        return await provider2.estimateGas(req.transaction);
      case "getBalance":
        return await provider2.getBalance(req.address, req.blockTag);
      case "getBlock": {
        const block = "blockHash" in req ? req.blockHash : req.blockTag;
        return await provider2.getBlock(block, req.includeTransactions);
      }
      case "getBlockNumber":
        return await provider2.getBlockNumber();
      case "getCode":
        return await provider2.getCode(req.address, req.blockTag);
      case "getGasPrice":
        return (await provider2.getFeeData()).gasPrice;
      case "getPriorityFee":
        return (await provider2.getFeeData()).maxPriorityFeePerGas;
      case "getLogs":
        return await provider2.getLogs(req.filter);
      case "getStorage":
        return await provider2.getStorage(req.address, req.position, req.blockTag);
      case "getTransaction":
        return await provider2.getTransaction(req.hash);
      case "getTransactionCount":
        return await provider2.getTransactionCount(req.address, req.blockTag);
      case "getTransactionReceipt":
        return await provider2.getTransactionReceipt(req.hash);
      case "getTransactionResult":
        return await provider2.getTransactionResult(req.hash);
    }
  }
  async _perform(req) {
    if (req.method === "broadcastTransaction") {
      const results2 = __privateGet(this, _configs).map((c2) => null);
      const broadcasts = __privateGet(this, _configs).map(async ({ provider: provider2, weight }, index2) => {
        try {
          const result3 = await provider2._perform(req);
          results2[index2] = Object.assign(normalizeResult({ result: result3 }), { weight });
        } catch (error) {
          results2[index2] = Object.assign(normalizeResult({ error }), { weight });
        }
      });
      while (true) {
        const done = results2.filter((r2) => r2 != null);
        for (const { value } of done) {
          if (!(value instanceof Error)) {
            return value;
          }
        }
        const result3 = checkQuorum(this.quorum, results2.filter((r2) => r2 != null));
        if (isError(result3, "INSUFFICIENT_FUNDS")) {
          throw result3;
        }
        const waiting = broadcasts.filter((b2, i) => results2[i] == null);
        if (waiting.length === 0) {
          break;
        }
        await Promise.race(waiting);
      }
      const result2 = getAnyResult(this.quorum, results2);
      assert(result2 !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: results2.map(stringify$1) }
      });
      if (result2 instanceof Error) {
        throw result2;
      }
      return result2;
    }
    await __privateMethod(this, _FallbackProvider_instances, initialSync_fn).call(this);
    const running = /* @__PURE__ */ new Set();
    let inflightQuorum = 0;
    while (true) {
      const runner = __privateMethod(this, _FallbackProvider_instances, addRunner_fn).call(this, running, req);
      if (runner == null) {
        break;
      }
      inflightQuorum += runner.config.weight;
      if (inflightQuorum >= this.quorum) {
        break;
      }
    }
    const result = await __privateMethod(this, _FallbackProvider_instances, waitForQuorum_fn).call(this, running, req);
    for (const runner of running) {
      if (runner.perform && runner.result == null) {
        runner.config.lateResponses++;
      }
    }
    return result;
  }
  async destroy() {
    for (const { provider: provider2 } of __privateGet(this, _configs)) {
      provider2.destroy();
    }
    super.destroy();
  }
}
_configs = new WeakMap();
_height = new WeakMap();
_initialSyncPromise = new WeakMap();
_FallbackProvider_instances = new WeakSet();
// Grab the next (random) config that is not already part of
// the running set
getNextConfig_fn = function(running) {
  const configs = Array.from(running).map((r2) => r2.config);
  const allConfigs = __privateGet(this, _configs).slice();
  shuffle(allConfigs);
  allConfigs.sort((a2, b2) => a2.priority - b2.priority);
  for (const config2 of allConfigs) {
    if (config2._lastFatalError) {
      continue;
    }
    if (configs.indexOf(config2) === -1) {
      return config2;
    }
  }
  return null;
};
// Adds a new runner (if available) to running.
addRunner_fn = function(running, req) {
  const config2 = __privateMethod(this, _FallbackProvider_instances, getNextConfig_fn).call(this, running);
  if (config2 == null) {
    return null;
  }
  const runner = {
    config: config2,
    result: null,
    didBump: false,
    perform: null,
    staller: null
  };
  const now = getTime();
  runner.perform = (async () => {
    try {
      config2.requests++;
      const result = await this._translatePerform(config2.provider, req);
      runner.result = { result };
    } catch (error) {
      config2.errorResponses++;
      runner.result = { error };
    }
    const dt = getTime() - now;
    config2._totalTime += dt;
    config2.rollingDuration = 0.95 * config2.rollingDuration + 0.05 * dt;
    runner.perform = null;
  })();
  runner.staller = (async () => {
    await stall$2(config2.stallTimeout);
    runner.staller = null;
  })();
  running.add(runner);
  return runner;
};
initialSync_fn = async function() {
  let initialSync = __privateGet(this, _initialSyncPromise);
  if (!initialSync) {
    const promises = [];
    __privateGet(this, _configs).forEach((config2) => {
      promises.push((async () => {
        await waitForSync(config2, 0);
        if (!config2._lastFatalError) {
          config2._network = await config2.provider.getNetwork();
        }
      })());
    });
    __privateSet(this, _initialSyncPromise, initialSync = (async () => {
      await Promise.all(promises);
      let chainId = null;
      for (const config2 of __privateGet(this, _configs)) {
        if (config2._lastFatalError) {
          continue;
        }
        const network2 = config2._network;
        if (chainId == null) {
          chainId = network2.chainId;
        } else if (network2.chainId !== chainId) {
          assert(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
            operation: "new FallbackProvider"
          });
        }
      }
    })());
  }
  await initialSync;
};
checkQuorum_fn = async function(running, req) {
  const results2 = [];
  for (const runner of running) {
    if (runner.result != null) {
      const { tag, value } = normalizeResult(runner.result);
      results2.push({ tag, value, weight: runner.config.weight });
    }
  }
  if (results2.reduce((a2, r2) => a2 + r2.weight, 0) < this.quorum) {
    return void 0;
  }
  switch (req.method) {
    case "getBlockNumber": {
      if (__privateGet(this, _height) === -2) {
        __privateSet(this, _height, Math.ceil(getNumber(getMedian(this.quorum, __privateGet(this, _configs).filter((c2) => !c2._lastFatalError).map((c2) => ({
          value: c2.blockNumber,
          tag: getNumber(c2.blockNumber).toString(),
          weight: c2.weight
        }))))));
      }
      const mode = getFuzzyMode(this.quorum, results2);
      if (mode === void 0) {
        return void 0;
      }
      if (mode > __privateGet(this, _height)) {
        __privateSet(this, _height, mode);
      }
      return __privateGet(this, _height);
    }
    case "getGasPrice":
    case "getPriorityFee":
    case "estimateGas":
      return getMedian(this.quorum, results2);
    case "getBlock":
      if ("blockTag" in req && req.blockTag === "pending") {
        return getAnyResult(this.quorum, results2);
      }
      return checkQuorum(this.quorum, results2);
    case "call":
    case "chainId":
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorage":
    case "getTransaction":
    case "getTransactionReceipt":
    case "getLogs":
      return checkQuorum(this.quorum, results2);
    case "broadcastTransaction":
      return getAnyResult(this.quorum, results2);
  }
  assert(false, "unsupported method", "UNSUPPORTED_OPERATION", {
    operation: `_perform(${stringify$1(req.method)})`
  });
};
waitForQuorum_fn = async function(running, req) {
  if (running.size === 0) {
    throw new Error("no runners?!");
  }
  const interesting = [];
  let newRunners = 0;
  for (const runner of running) {
    if (runner.perform) {
      interesting.push(runner.perform);
    }
    if (runner.staller) {
      interesting.push(runner.staller);
      continue;
    }
    if (runner.didBump) {
      continue;
    }
    runner.didBump = true;
    newRunners++;
  }
  const value = await __privateMethod(this, _FallbackProvider_instances, checkQuorum_fn).call(this, running, req);
  if (value !== void 0) {
    if (value instanceof Error) {
      throw value;
    }
    return value;
  }
  for (let i = 0; i < newRunners; i++) {
    __privateMethod(this, _FallbackProvider_instances, addRunner_fn).call(this, running, req);
  }
  assert(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
    request: "%sub-requests",
    info: { request: req, results: Array.from(running).map((r2) => stringify$1(r2.result)) }
  });
  await Promise.race(interesting);
  return await __privateMethod(this, _FallbackProvider_instances, waitForQuorum_fn).call(this, running, req);
};
function isWebSocketLike(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
}
const Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
function getDefaultProvider(network2, options) {
  if (options == null) {
    options = {};
  }
  const allowService = (name2) => {
    if (options[name2] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name2 === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name2) !== -1;
    }
    return true;
  };
  if (typeof network2 === "string" && network2.match(/^https?:/)) {
    return new JsonRpcProvider$1(network2);
  }
  if (typeof network2 === "string" && network2.match(/^wss?:/) || isWebSocketLike(network2)) {
    return new WebSocketProvider(network2);
  }
  let staticNetwork = null;
  try {
    staticNetwork = Network.from(network2);
  } catch (error) {
  }
  const providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new JsonRpcProvider$1("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
    } else if (staticNetwork.name === "matic-amoy") {
      providers.push(new JsonRpcProvider$1("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new AlchemyProvider(network2, options.alchemy));
    } catch (error) {
    }
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new AnkrProvider(network2, options.ankr));
    } catch (error) {
    }
  }
  if (allowService("chainstack")) {
    try {
      providers.push(new ChainstackProvider(network2, options.chainstack));
    } catch (error) {
    }
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new CloudflareProvider(network2));
    } catch (error) {
    }
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new EtherscanProvider(network2, options.etherscan));
    } catch (error) {
    }
  }
  if (allowService("infura")) {
    try {
      let projectId = options.infura;
      let projectSecret = void 0;
      if (typeof projectId === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider(network2, projectId, projectSecret));
    } catch (error) {
    }
  }
  if (allowService("quicknode")) {
    try {
      let token = options.quicknode;
      providers.push(new QuickNodeProvider(network2, token));
    } catch (error) {
    }
  }
  assert(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  let quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new FallbackProvider(providers, void 0, { quorum });
}
const _NonceManager = class _NonceManager extends AbstractSigner {
  /**
   *  Creates a new **NonceManager** to manage %%signer%%.
   */
  constructor(signer2) {
    super(signer2.provider);
    /**
     *  The Signer being managed.
     */
    __publicField(this, "signer");
    __privateAdd(this, _noncePromise);
    __privateAdd(this, _delta);
    defineProperties$1(this, { signer: signer2 });
    __privateSet(this, _noncePromise, null);
    __privateSet(this, _delta, 0);
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(provider2) {
    return new _NonceManager(this.signer.connect(provider2));
  }
  async getNonce(blockTag) {
    if (blockTag === "pending") {
      if (__privateGet(this, _noncePromise) == null) {
        __privateSet(this, _noncePromise, super.getNonce("pending"));
      }
      const delta = __privateGet(this, _delta);
      return await __privateGet(this, _noncePromise) + delta;
    }
    return super.getNonce(blockTag);
  }
  /**
   *  Manually increment the nonce. This may be useful when managng
   *  offline transactions.
   */
  increment() {
    __privateWrapper(this, _delta)._++;
  }
  /**
   *  Resets the nonce, causing the **NonceManager** to reload the current
   *  nonce from the blockchain on the next transaction.
   */
  reset() {
    __privateSet(this, _delta, 0);
    __privateSet(this, _noncePromise, null);
  }
  async sendTransaction(tx) {
    const noncePromise = this.getNonce("pending");
    this.increment();
    tx = await this.signer.populateTransaction(tx);
    tx.nonce = await noncePromise;
    return await this.signer.sendTransaction(tx);
  }
  signTransaction(tx) {
    return this.signer.signTransaction(tx);
  }
  signMessage(message) {
    return this.signer.signMessage(message);
  }
  signTypedData(domain2, types2, value) {
    return this.signer.signTypedData(domain2, types2, value);
  }
};
_noncePromise = new WeakMap();
_delta = new WeakMap();
let NonceManager = _NonceManager;
class BrowserProvider extends JsonRpcApiPollingProvider {
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(ethereum, network2, _options4) {
    const options = Object.assign({}, _options4 != null ? _options4 : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network2, options);
    __privateAdd(this, _request2);
    __privateSet(this, _request2, async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e2) {
        const error = new Error(e2.message);
        error.code = e2.code;
        error.data = e2.data;
        error.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error });
        throw error;
      }
    });
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await __privateGet(this, _request2).call(this, payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e2) {
      return [{
        id: payload.id,
        error: { code: e2.code, data: e2.data, message: e2.message }
      }];
    }
  }
  getRpcError(payload, error) {
    error = JSON.parse(JSON.stringify(error));
    switch (error.error.code || -1) {
      case 4001:
        error.error.message = `ethers-user-denied: ${error.error.message}`;
        break;
      case 4200:
        error.error.message = `ethers-unsupported: ${error.error.message}`;
        break;
    }
    return super.getRpcError(payload, error);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a2) => a2.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await __privateGet(this, _request2).call(this, "eth_requestAccounts", []);
      } catch (error) {
        const payload = error.payload;
        throw this.getRpcError(payload, { id: payload.id, error });
      }
    }
    return await super.getSigner(address);
  }
}
_request2 = new WeakMap();
const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
function getHost(name2) {
  switch (name2) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument(false, "unsupported network", "network", name2);
}
class PocketProvider extends JsonRpcProvider$1 {
  /**
   *  Create a new **PocketProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  constructor(_network3, applicationId, applicationSecret) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network2 = Network.from(_network3);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network2 };
    const request = PocketProvider.getRequest(network2, applicationId, applicationSecret);
    super(request, network2, options);
    /**
     *  The Application ID for the Pocket connection.
     */
    __publicField(this, "applicationId");
    /**
     *  The Application Secret for making authenticated requests
     *  to the Pocket connection.
     */
    __publicField(this, "applicationSecret");
    defineProperties$1(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%% with
   *  %%applicationId%%.
   */
  static getRequest(network2, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    const request = new FetchRequest(`https://${getHost(network2.name)}/v1/lb/${applicationId}`);
    request.allowGzip = true;
    if (applicationSecret) {
      request.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("PocketProvider");
        return true;
      };
    }
    return request;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}
const IpcSocketProvider = void 0;
const _BaseWallet = class _BaseWallet extends AbstractSigner {
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider2) {
    super(provider2);
    /**
     *  The wallet address.
     */
    __publicField(this, "address");
    __privateAdd(this, _signingKey);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    __privateSet(this, _signingKey, privateKey);
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties$1(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return __privateGet(this, _signingKey);
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider2) {
    return new _BaseWallet(__privateGet(this, _signingKey), provider2);
  }
  async signTransaction(tx) {
    const { to, from } = await resolveProperties$1({
      to: tx.to ? resolveAddress(tx.to, this.provider) : void 0,
      from: tx.from ? resolveAddress(tx.from, this.provider) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  async signTypedData(domain2, types2, value) {
    const populated = await TypedDataEncoder.resolveNames(domain2, types2, value, async (name2) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name: name2 }
      });
      const address = await this.provider.resolveName(name2);
      assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name2
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types2, populated.value)).serialized;
  }
};
_signingKey = new WeakMap();
let BaseWallet = _BaseWallet;
const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words2, sep) {
  let initial = 97;
  return words2.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode$1(data, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item2, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item2.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode$1(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}
class Wordlist {
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    __publicField(this, "locale");
    defineProperties$1(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words2) {
    return words2.join(" ");
  }
}
class WordlistOwl extends Wordlist {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum2) {
    super(locale);
    __privateAdd(this, _WordlistOwl_instances);
    __privateAdd(this, _data5);
    __privateAdd(this, _checksum);
    __privateAdd(this, _words);
    __privateSet(this, _data5, data);
    __privateSet(this, _checksum, checksum2);
    __privateSet(this, _words, null);
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return __privateGet(this, _data5);
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(__privateGet(this, _data5));
  }
  getWord(index2) {
    const words2 = __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this);
    assertArgument(index2 >= 0 && index2 < words2.length, `invalid word index: ${index2}`, "index", index2);
    return words2[index2];
  }
  getWordIndex(word) {
    return __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this).indexOf(word);
  }
}
_data5 = new WeakMap();
_checksum = new WeakMap();
_words = new WeakMap();
_WordlistOwl_instances = new WeakSet();
loadWords_fn = function() {
  if (__privateGet(this, _words) == null) {
    const words2 = this._decodeWords();
    const checksum2 = id$1(words2.join("\n") + "\n");
    if (checksum2 !== __privateGet(this, _checksum)) {
      throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
    }
    __privateSet(this, _words, words2);
  }
  return __privateGet(this, _words);
};
const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist = null;
class LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new LangEn();
    }
    return wordlist;
  }
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset2 = 0;
  for (let i = 0; i < words2.length; i++) {
    let index2 = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index2 >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset2 >> 3] |= 1 << 7 - offset2 % 8;
      }
      offset2++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha256$1(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha256$1(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
}
const _guard$1 = {};
class Mnemonic {
  /**
   *  @private
   */
  constructor(guard2, entropy, phrase, password, wordlist2) {
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    __publicField(this, "phrase");
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    __publicField(this, "password");
    /**
     *  The wordlist for this mnemonic.
     */
    __publicField(this, "wordlist");
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    __publicField(this, "entropy");
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard2, _guard$1, "Mnemonic");
    defineProperties$1(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new Mnemonic(_guard$1, entropy, phrase, password, wordlist2);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new Mnemonic(_guard$1, hexlify(entropy), phrase, password, wordlist2);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error) {
    }
    return false;
  }
}
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet$2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
const rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
const S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
const Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
const T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
const T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
const T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
const T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
const T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
const T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
const T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
const T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
const U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
const U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
const U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
const U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0; i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}
class AES {
  get key() {
    return __classPrivateFieldGet$2(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet$2(this, _AES_Ke, [], "f");
    __classPrivateFieldSet$2(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet$2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet$2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk2 = convertToInt32(this.key);
    let index2;
    for (let i = 0; i < KC; i++) {
      index2 = i >> 2;
      __classPrivateFieldGet$2(this, _AES_Ke, "f")[index2][i % 4] = tk2[i];
      __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - index2][i % 4] = tk2[i];
    }
    let rconpointer = 0;
    let t2 = KC, tt;
    while (t2 < roundKeyCount) {
      tt = tk2[KC - 1];
      tk2[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk2[i2] ^= tk2[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk2[i2] ^= tk2[i2 - 1];
        }
        tt = tk2[KC / 2 - 1];
        tk2[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk2[i2] ^= tk2[i2 - 1];
        }
      }
      let i = 0, r2, c2;
      while (i < KC && t2 < roundKeyCount) {
        r2 = t2 >> 2;
        c2 = t2 % 4;
        __classPrivateFieldGet$2(this, _AES_Ke, "f")[r2][c2] = tk2[i];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - r2][c2] = tk2[i++];
        t2++;
      }
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let c2 = 0; c2 < 4; c2++) {
        tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[r2][c2];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[r2][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Ke, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t2 = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t2[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, "f")[0][i];
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let i = 0; i < 4; i++) {
        a2[i] = T1[t2[i] >> 24 & 255] ^ T2[t2[(i + 1) % 4] >> 16 & 255] ^ T3[t2[(i + 2) % 4] >> 8 & 255] ^ T4[t2[(i + 3) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Ke, "f")[r2][i];
      }
      t2 = a2.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t2[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t2[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Kd, "f").length - 1;
    const a2 = [0, 0, 0, 0];
    let t2 = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t2[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, "f")[0][i];
    }
    for (let r2 = 1; r2 < rounds; r2++) {
      for (let i = 0; i < 4; i++) {
        a2[i] = T5[t2[i] >> 24 & 255] ^ T6[t2[(i + 3) % 4] >> 16 & 255] ^ T7[t2[(i + 2) % 4] >> 8 & 255] ^ T8[t2[(i + 1) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Kd, "f")[r2][i];
      }
      t2 = a2.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t2[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t2[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
class ModeOfOperation {
  constructor(name2, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name2} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name2 }
    });
  }
}
var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
class CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, CBC);
    _CBC_iv.set(this, void 0);
    _CBC_lastBlock.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0; i < plaintext.length; i += 16) {
      for (let j2 = 0; j2 < 16; j2++) {
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j2] ^= plaintext[i + j2];
      }
      __classPrivateFieldSet$1(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0; i < ciphertext.length; i += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j2 = 0; j2 < 16; j2++) {
        plaintext[i + j2] = block[j2] ^ __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j2];
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j2] = ciphertext[i + j2];
      }
    }
    return plaintext;
  }
}
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index2 = 15; index2 >= 0; --index2) {
      __classPrivateFieldGet(this, _CTR_counter, "f")[index2] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a2, _b2;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b2 = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a2 = _b2++, _b2), "f"), _a2];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data.length - padder;
  for (let i = 0; i < padder; i++) {
    if (data[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data.subarray(0, length));
}
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad$1(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object2, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object2;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}
const defaultPath$1 = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data = JSON.parse(json);
    const version2 = data.version != null ? parseInt(data.version) : 0;
    if (version2 === 3) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decrypt(data, key, ciphertext) {
  const cipher = spelunk(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  const account2 = { address, privateKey };
  const version2 = spelunk(data, "x-ethers.version:string");
  if (version2 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account2.mnemonic = {
      path: spelunk(data, "x-ethers.path:string") || defaultPath$1,
      locale: spelunk(data, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account2;
}
function getDecryptKdfParams(data) {
  const kdf = spelunk(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const N2 = spelunk(data, "crypto.kdfparams.n:int!");
      const r2 = spelunk(data, "crypto.kdfparams.r:int!");
      const p2 = spelunk(data, "crypto.kdfparams.p:int!");
      assertArgument(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
      assertArgument(r2 > 0 && p2 > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N2, r: r2, p: p2, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count2 = spelunk(data, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count: count2, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count: count2, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count2, dkLen2, algorithm);
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r: r2, p: p2, dkLen } = params;
  const key = scryptSync(password, salt, N2, r2, p2, dkLen);
  return getAccount(data, key);
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress2) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    if (progress2) {
      progress2(0);
      await stall$1(0);
    }
    const { salt: salt2, count: count2, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count2, dkLen2, algorithm);
    if (progress2) {
      progress2(1);
      await stall$1(0);
    }
    return getAccount(data, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r: r2, p: p2, dkLen } = params;
  const key = await scrypt(password, salt, N2, r2, p2, dkLen, progress2);
  return getAccount(data, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes(32);
  let N2 = 1 << 17, r2 = 8, p2 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p2 = options.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r2 === "number" && r2 > 0 && Number.isSafeInteger(r2), "invalid scrypt r parameter", "options.r", r2);
  assertArgument(typeof p2 === "number" && p2 > 0 && Number.isSafeInteger(p2), "invalid scrypt p parameter", "options.p", p2);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r: r2, p: p2 };
}
function _encryptKeystore(key, kdf, account2, options) {
  const privateKey = getBytes(account2.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data = {
    address: account2.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account2.mnemonic) {
    const client2 = options.client != null ? options.client : `ethers/${version$5}`;
    const path = account2.mnemonic.path || defaultPath$1;
    const locale = account2.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account2.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad$1(now.getUTCMonth() + 1, 2) + "-" + zpad$1(now.getUTCDate(), 2) + "T" + zpad$1(now.getUTCHours(), 2) + "-" + zpad$1(now.getUTCMinutes(), 2) + "-" + zpad$1(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client: client2,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account2, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account2, options);
}
async function encryptKeystoreJson(account2, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account2, options);
}
const defaultPath = "m/44'/60'/0'/0/0";
const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
const HardenedBit = 2147483648;
const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const Nibbles = "0123456789abcdef";
function zpad(value, length) {
  let result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value2) {
  const value = getBytes(_value2);
  const check = dataSlice(sha256$1(sha256$1(value)), 0, 4);
  const bytes2 = concat([value, check]);
  return encodeBase58(bytes2);
}
const _guard = {};
function ser_I(index2, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index2 & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index2 >> 24 - i & 255;
  }
  const I2 = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I2.slice(0, 32), IR: I2.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index2 = parseInt(component.substring(0, component.length - 1));
      assertArgument(index2 < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index2);
    } else if (component.match(/^[0-9]+$/)) {
      const index2 = parseInt(component);
      assertArgument(index2 < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index2);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
const _HDNodeWallet = class _HDNodeWallet extends BaseWallet {
  /**
   *  @private
   */
  constructor(guard2, signingKey, parentFingerprint, chainCode, path, index2, depth, mnemonic, provider2) {
    super(signingKey, provider2);
    __privateAdd(this, _HDNodeWallet_instances);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    __publicField(this, "mnemonic");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provide full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  encode it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard2, _guard, "HDNodeWallet");
    defineProperties$1(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd160(sha256$1(this.publicKey)), 0, 4);
    defineProperties$1(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index: index2,
      depth
    });
    defineProperties$1(this, { mnemonic });
  }
  connect(provider2) {
    return new _HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider2);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
      if (index2 & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index2, this.chainCode, this.publicKey, this.privateKey);
    const ki2 = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));
    return new _HDNodeWallet(_guard, ki2, this.fingerprint, hexlify(IR), path, index2, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index2 = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index2, depth, null);
      }
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index2, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path, wordlist2) {
    var _a2;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist2);
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path) {
    var _a2;
    if (!path) {
      path = defaultPath;
    }
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path, wordlist2) {
    var _a2;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    var _a2;
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, seed, null);
  }
};
_HDNodeWallet_instances = new WeakSet();
account_fn = function() {
  const account2 = { address: this.address, privateKey: this.privateKey };
  const m2 = this.mnemonic;
  if (this.path && m2 && m2.wordlist.locale === "en" && m2.password === "") {
    account2.mnemonic = {
      path: this.path,
      locale: "en",
      entropy: m2.entropy
    };
  }
  return account2;
};
_HDNodeWallet_static = new WeakSet();
fromSeed_fn = function(_seed, mnemonic) {
  assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
  const seed = getBytes(_seed, "seed");
  assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
  const I2 = getBytes(computeHmac("sha512", MasterSecret, seed));
  const signingKey = new SigningKey(hexlify(I2.slice(0, 32)));
  return new _HDNodeWallet(_guard, signingKey, "0x00000000", hexlify(I2.slice(32)), "m", 0, 0, mnemonic, null);
};
__privateAdd(_HDNodeWallet, _HDNodeWallet_static);
let HDNodeWallet = _HDNodeWallet;
class HDNodeVoidWallet extends VoidSigner {
  /**
   *  @private
   */
  constructor(guard2, address, publicKey, parentFingerprint, chainCode, path, index2, depth, provider2) {
    super(address, provider2);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent node fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard2, _guard, "HDNodeVoidWallet");
    defineProperties$1(this, { publicKey });
    const fingerprint = dataSlice(ripemd160(sha256$1(publicKey)), 0, 4);
    defineProperties$1(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index: index2,
      depth
    });
  }
  connect(provider2) {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider2);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
      if (index2 & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index2, this.chainCode, this.publicKey, null);
    const Ki2 = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki2);
    return new HDNodeVoidWallet(_guard, address, Ki2, this.fingerprint, hexlify(IR), path, index2, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
}
function getAccountPath(_index) {
  const index2 = getNumber(_index, "index");
  assertArgument(index2 >= 0 && index2 < HardenedBit, "invalid account index", "index", index2);
  return `m/44'/60'/${index2}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index2 = getNumber(_index, "index");
  assertArgument(index2 >= 0 && index2 < HardenedBit, "invalid account index", "index", index2);
  return `m/44'/60'/0'/0/${index2}`;
}
function isCrowdsaleJson(json) {
  try {
    const data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id$1(seedHex) };
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
let Wallet$1 = (_m = class extends BaseWallet {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key, provider2) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider2);
  }
  connect(provider2) {
    return new _m(this.signingKey, provider2);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account2 = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account2, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account2 = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account2, password);
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress2) {
    var _a2;
    let account2 = null;
    if (isKeystoreJson(json)) {
      account2 = await decryptKeystoreJson(json, password, progress2);
    } else if (isCrowdsaleJson(json)) {
      if (progress2) {
        progress2(0);
        await stall(0);
      }
      account2 = decryptCrowdsaleJson(json, password);
      if (progress2) {
        progress2(1);
        await stall(0);
      }
    }
    return __privateMethod(_a2 = _m, _Wallet_static, fromAccount_fn).call(_a2, account2);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    var _a2;
    let account2 = null;
    if (isKeystoreJson(json)) {
      account2 = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account2 = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return __privateMethod(_a2 = _m, _Wallet_static, fromAccount_fn).call(_a2, account2);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider2) {
    const wallet = HDNodeWallet.createRandom();
    if (provider2) {
      return wallet.connect(provider2);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider2) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider2) {
      return wallet.connect(provider2);
    }
    return wallet;
  }
}, _Wallet_static = new WeakSet(), fromAccount_fn = function(account2) {
  assertArgument(account2, "invalid JSON wallet", "json", "[ REDACTED ]");
  if ("mnemonic" in account2 && account2.mnemonic && account2.mnemonic.locale === "en") {
    const mnemonic = Mnemonic.fromEntropy(account2.mnemonic.entropy);
    const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account2.mnemonic.path);
    if (wallet2.address === account2.address && wallet2.privateKey === account2.privateKey) {
      return wallet2;
    }
    console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
  }
  const wallet = new _m(account2.privateKey);
  assertArgument(wallet.address === account2.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
  return wallet;
}, __privateAdd(_m, _Wallet_static), _m);
const Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
function decodeBits(width, data) {
  const maxValue2 = (1 << width) - 1;
  const result = [];
  let accum = 0, bits = 0, flood = 0;
  for (let i = 0; i < data.length; i++) {
    accum = accum << 6 | Base64.indexOf(data[i]);
    bits += 6;
    while (bits >= width) {
      const value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      if (value === 0) {
        flood += maxValue2;
      } else {
        result.push(value + flood);
        flood = 0;
      }
    }
  }
  return result;
}
function decodeOwlA(data, accents) {
  let words2 = decodeOwl(data).join(",");
  accents.split(/,/g).forEach((accent) => {
    const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match !== null, "internal error parsing accents", "accents", accents);
    let posOffset = 0;
    const positions = decodeBits(parseInt(match[3]), match[4]);
    const charCode = parseInt(match[2]);
    const regex = new RegExp(`([${match[1]}])`, "g");
    words2 = words2.replace(regex, (all, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words2.split(",");
}
class WordlistOwlA extends WordlistOwl {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
   *  and %%accent%% data and validated against the %%checksum%%.
   */
  constructor(locale, data, accent, checksum2) {
    super(locale, data, checksum2);
    __privateAdd(this, _accent);
    __privateSet(this, _accent, accent);
  }
  /**
   *  The OWLA-encoded accent data.
   */
  get _accent() {
    return __privateGet(this, _accent);
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwlA(this._data, this._accent);
  }
}
_accent = new WeakMap();
const wordlists = {
  en: LangEn.wordlist()
};
const ethers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder,
  AbstractProvider,
  AbstractSigner,
  AlchemyProvider,
  AnkrProvider,
  BaseContract,
  BaseWallet,
  Block,
  BrowserProvider,
  ChainstackProvider,
  CloudflareProvider,
  ConstructorFragment,
  Contract,
  ContractEventPayload,
  ContractFactory,
  ContractTransactionReceipt,
  ContractTransactionResponse,
  ContractUnknownEventPayload,
  EnsPlugin,
  EnsResolver,
  ErrorDescription,
  ErrorFragment,
  EtherSymbol,
  EtherscanPlugin,
  EtherscanProvider,
  EventFragment,
  EventLog,
  EventPayload,
  FallbackFragment,
  FallbackProvider,
  FeeData,
  FeeDataNetworkPlugin,
  FetchCancelSignal,
  FetchRequest,
  FetchResponse,
  FetchUrlFeeDataNetworkPlugin,
  FixedNumber,
  Fragment,
  FunctionFragment,
  GasCostPlugin,
  HDNodeVoidWallet,
  HDNodeWallet,
  Indexed,
  InfuraProvider,
  InfuraWebSocketProvider,
  Interface,
  IpcSocketProvider,
  JsonRpcApiProvider,
  JsonRpcProvider: JsonRpcProvider$1,
  JsonRpcSigner,
  LangEn,
  Log,
  LogDescription,
  MaxInt256,
  MaxUint256,
  MessagePrefix,
  MinInt256,
  Mnemonic,
  MulticoinProviderPlugin,
  N: N$1,
  NamedFragment,
  Network,
  NetworkPlugin,
  NonceManager,
  ParamType,
  PocketProvider,
  QuickNodeProvider,
  Result,
  Signature,
  SigningKey,
  SocketBlockSubscriber,
  SocketEventSubscriber,
  SocketPendingSubscriber,
  SocketProvider,
  SocketSubscriber,
  StructFragment,
  Transaction,
  TransactionDescription,
  TransactionReceipt,
  TransactionResponse,
  Typed,
  TypedDataEncoder,
  UndecodedEventLog,
  UnmanagedSubscriber,
  Utf8ErrorFuncs,
  VoidSigner,
  Wallet: Wallet$1,
  WebSocketProvider,
  WeiPerEther,
  Wordlist,
  WordlistOwl,
  WordlistOwlA,
  ZeroAddress,
  ZeroHash,
  accessListify,
  assert,
  assertArgument,
  assertArgumentCount,
  assertNormalize,
  assertPrivate,
  checkResultErrors,
  computeAddress,
  computeHmac,
  concat,
  copyRequest,
  dataLength,
  dataSlice,
  decodeBase58,
  decodeBase64,
  decodeBytes32String,
  decodeRlp,
  decryptCrowdsaleJson,
  decryptKeystoreJson,
  decryptKeystoreJsonSync,
  defaultPath,
  defineProperties: defineProperties$1,
  dnsEncode,
  encodeBase58,
  encodeBase64,
  encodeBytes32String,
  encodeRlp,
  encryptKeystoreJson,
  encryptKeystoreJsonSync,
  ensNormalize,
  formatEther: formatEther$1,
  formatUnits: formatUnits$1,
  fromTwos,
  getAccountPath,
  getAddress,
  getBigInt,
  getBytes,
  getBytesCopy,
  getCreate2Address,
  getCreateAddress,
  getDefaultProvider,
  getIcapAddress,
  getIndexedAccountPath,
  getNumber,
  getUint,
  hashMessage,
  hexlify,
  id: id$1,
  isAddress,
  isAddressable,
  isBytesLike,
  isCallException,
  isCrowdsaleJson,
  isError,
  isHexString,
  isKeystoreJson,
  isValidName,
  keccak256,
  lock,
  makeError,
  mask,
  namehash,
  parseEther: parseEther$1,
  parseUnits: parseUnits$2,
  pbkdf2,
  randomBytes,
  recoverAddress,
  resolveAddress,
  resolveProperties: resolveProperties$1,
  ripemd160,
  scrypt,
  scryptSync,
  sha256: sha256$1,
  sha512,
  showThrottleMessage,
  solidityPacked,
  solidityPackedKeccak256,
  solidityPackedSha256,
  stripZerosLeft,
  toBeArray,
  toBeHex,
  toBigInt,
  toNumber,
  toQuantity,
  toTwos,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  uuidV4,
  verifyMessage,
  verifyTypedData,
  version: version$5,
  wordlists,
  zeroPadBytes,
  zeroPadValue
}, Symbol.toStringTag, { value: "Module" }));
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2) {
  lookup[i$2] = code[i$2];
  revLookup[code.charCodeAt(i$2)] = i$2;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE2, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE2 ? nBytes - 1 : 0;
  var d2 = isLE2 ? -1 : 1;
  var s2 = buffer2[offset2 + i];
  i += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE2, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE2 ? 0 : nBytes - 1;
  var d2 = isLE2 ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer3;
  exports.SlowBuffer = SlowBuffer2;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer3, GlobalUint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer3.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize2(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer3.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer3.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer2(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a2, b2) {
    if (isInstance(a2, GlobalUint8Array)) a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, GlobalUint8Array)) b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
    if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2) return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a2[i] !== b2[i]) {
        x2 = a2[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat2(list2, length) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list2.length === 0) {
      return Buffer3.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list2.length; ++i) {
        length += list2[i].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list2.length; ++i) {
      let buf = list2[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b2) {
    if (!Buffer3.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer3.compare(this, b2) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset2, length) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset2 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset2, length) {
    return blitBuffer(utf8ToBytes2(string, buf.length - offset2), buf, offset2, length);
  }
  function asciiWrite(buf, string, offset2, length) {
    return blitBuffer(asciiToBytes(string), buf, offset2, length);
  }
  function base64Write(buf, string, offset2, length) {
    return blitBuffer(base64ToBytes(string), buf, offset2, length);
  }
  function ucs2Write(buf, string, offset2, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length);
  }
  Buffer3.prototype.write = function write(string, offset2, length, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length = this.length;
      offset2 = 0;
    } else if (length === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset2, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset2, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset2, length);
        case "base64":
          return base64Write(this, string, offset2, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset2, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes2 = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes2.length - 1; i += 2) {
      res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice2(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length) {
    if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
    if (offset2 + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset2 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi2 = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset2 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset2 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128)) return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max2, min2) {
    if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2] = hi2;
    return offset2 + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max2, min2) {
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
    if (offset2 < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes2 = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes2.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes2[i % len];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base2) {
    errors2[sym] = class NodeError extends Base2 {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input2) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input2;
      if (Number.isInteger(input2) && Math.abs(input2) > 2 ** 32) {
        received = addNumericalSeparator(String(input2));
      } else if (typeof input2 === "bigint") {
        received = String(input2);
        if (input2 > BigInt(2) ** BigInt(32) || input2 < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset2, byteLength3) {
    if (value > max2 || value < min2) {
      const n2 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c2 = str.charCodeAt(i);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset2, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset2 >= dst.length || i >= src.length) break;
      dst[i + offset2] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer2 = buffer.Buffer;
const Blob$1 = buffer.Blob;
const BlobOptions = buffer.BlobOptions;
const Buffer$1 = buffer.Buffer;
const File = buffer.File;
const FileOptions = buffer.FileOptions;
const INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;
const SlowBuffer = buffer.SlowBuffer;
const TranscodeEncoding = buffer.TranscodeEncoding;
const atob$1 = buffer.atob;
const btoa$1 = buffer.btoa;
const constants = buffer.constants;
const isAscii = buffer.isAscii;
const isUtf8 = buffer.isUtf8;
const kMaxLength = buffer.kMaxLength;
const kStringMaxLength = buffer.kStringMaxLength;
const resolveObjectURL = buffer.resolveObjectURL;
const transcode = buffer.transcode;
const dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants,
  default: Buffer2,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
const version$4 = "3.7.7";
const VERSION$2 = version$4;
const _hasBuffer = typeof Buffer2 === "function";
const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a2) => {
  let tab = {};
  a2.forEach((c2, i) => tab[c2] = i);
  return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
const _tidyB64 = (s2) => s2.replace(/[^A-Za-z0-9\+\/]/g, "");
const btoaPolyfill = (bin) => {
  let u322, c0, c1, c2, asc = "";
  const pad2 = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u322 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u322 >> 18 & 63] + b64chs[u322 >> 12 & 63] + b64chs[u322 >> 6 & 63] + b64chs[u322 & 63];
  }
  return pad2 ? asc.slice(0, pad2 - 3) + "===".substring(pad2) : asc;
};
const _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer2.from(bin, "binary").toString("base64") : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a2) => Buffer2.from(u8a2).toString("base64") : (u8a2) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l2 = u8a2.length; i < l2; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a2.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
const fromUint8Array = (u8a2, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a2)) : _fromUint8Array(u8a2);
const cb_utob = (c2) => {
  if (c2.length < 2) {
    var cc2 = c2.charCodeAt(0);
    return cc2 < 128 ? c2 : cc2 < 2048 ? _fromCC(192 | cc2 >>> 6) + _fromCC(128 | cc2 & 63) : _fromCC(224 | cc2 >>> 12 & 15) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
  } else {
    var cc2 = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
    return _fromCC(240 | cc2 >>> 18 & 7) + _fromCC(128 | cc2 >>> 12 & 63) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
  }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
const utob = (u2) => u2.replace(re_utob, cb_utob);
const _encode = _hasBuffer ? (s2) => Buffer2.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
const encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
const encodeURI$1 = (src) => encode(src, true);
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset2 = cp - 65536;
      return _fromCC((offset2 >>> 10) + 55296) + _fromCC((offset2 & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
const btou = (b2) => b2.replace(re_btou, cb_btou);
const atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
const _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer2.from(asc, "base64").toString("binary") : atobPolyfill;
const _toUint8Array = _hasBuffer ? (a2) => _U8Afrom(Buffer2.from(a2, "base64")) : (a2) => _U8Afrom(_atob(a2).split("").map((c2) => c2.charCodeAt(0)));
const toUint8Array$1 = (a2) => _toUint8Array(_unURI(a2));
const _decode = _hasBuffer ? (a2) => Buffer2.from(a2, "base64").toString("utf8") : _TD ? (a2) => _TD.decode(_toUint8Array(a2)) : (a2) => btou(_atob(a2));
const _unURI = (a2) => _tidyB64(a2.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
const decode = (src) => _decode(_unURI(src));
const isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
};
const _noEnum = (v3) => {
  return {
    value: v3,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
const extendString = function() {
  const _add = (name2, body) => Object.defineProperty(String.prototype, name2, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array$1(this);
  });
};
const extendUint8Array = function() {
  const _add = (name2, body) => Object.defineProperty(Uint8Array.prototype, name2, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
const extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
const gBase64 = {
  version: version$4,
  VERSION: VERSION$2,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI$1,
  encodeURL: encodeURI$1,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array: toUint8Array$1,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v3) {
      return step([n2, v3]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var encodeTypedDataHash$1 = function(typedData) {
  return TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message);
};
var ETHAuthVersion = "1";
var ETHAuthPrefix = "eth";
var ETHAuthEIP712Domain = {
  name: "ETHAuth",
  version: ETHAuthVersion
};
var Proof = (
  /** @class */
  function() {
    function Proof2(args) {
      this.prefix = ETHAuthPrefix;
      this.address = (args === null || args === void 0 ? void 0 : args.address) ? args.address.toLowerCase() : "";
      this.claims = (args === null || args === void 0 ? void 0 : args.claims) ? args.claims : { app: "", iat: 0, exp: 0, v: ETHAuthVersion };
      this.signature = (args === null || args === void 0 ? void 0 : args.signature) ? args.signature : "";
      this.extra = (args === null || args === void 0 ? void 0 : args.extra) ? args.extra : "";
    }
    Proof2.prototype.setIssuedAtNow = function() {
      this.claims.iat = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    };
    Proof2.prototype.setExpiryIn = function(seconds) {
      this.claims.exp = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + seconds;
    };
    Proof2.prototype.validateClaims = function() {
      return validateClaims(this.claims);
    };
    Proof2.prototype.messageDigest = function() {
      var isValid2 = this.validateClaims();
      if (isValid2.err) {
        throw isValid2.err;
      }
      return getBytes(encodeTypedDataHash$1(this.messageTypedData()));
    };
    Proof2.prototype.messageTypedData = function() {
      var domain2 = __assign({}, ETHAuthEIP712Domain);
      var types2 = {
        Claims: []
      };
      var message = {};
      var typedData = { domain: domain2, types: types2, message };
      if (this.claims.app && this.claims.app.length > 0) {
        typedData.types.Claims.push({ name: "app", type: "string" });
        typedData.message["app"] = this.claims.app;
      }
      if (this.claims.iat && this.claims.iat > 0) {
        typedData.types.Claims.push({ name: "iat", type: "int64" });
        typedData.message["iat"] = this.claims.iat;
      }
      if (this.claims.exp && this.claims.exp > 0) {
        typedData.types.Claims.push({ name: "exp", type: "int64" });
        typedData.message["exp"] = this.claims.exp;
      }
      if (this.claims.n && this.claims.n > 0) {
        typedData.types.Claims.push({ name: "n", type: "uint64" });
        typedData.message["n"] = this.claims.n;
      }
      if (this.claims.typ && this.claims.typ.length > 0) {
        typedData.types.Claims.push({ name: "typ", type: "string" });
        typedData.message["typ"] = this.claims.typ;
      }
      if (this.claims.ogn && this.claims.ogn.length > 0) {
        typedData.types.Claims.push({ name: "ogn", type: "string" });
        typedData.message["ogn"] = this.claims.ogn;
      }
      if (this.claims.v && this.claims.v.length > 0) {
        typedData.types.Claims.push({ name: "v", type: "string" });
        typedData.message["v"] = this.claims.v;
      }
      return typedData;
    };
    return Proof2;
  }()
);
var validateClaims = function(claims) {
  if (claims.app === "") {
    return { ok: false, err: new Error("claims: app is empty") };
  }
  var now = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  var drift = 5 * 60;
  var max2 = 60 * 60 * 24 * 365 + drift;
  if (claims.v === "") {
    return { ok: false, err: new Error("claims: ethauth version is empty") };
  }
  if (claims.iat && claims.iat !== 0 && (claims.iat > now + drift || claims.iat < now - max2)) {
    return { ok: false, err: new Error("claims: iat is invalid") };
  }
  if (claims.exp < now - drift || claims.exp > now + max2) {
    return { ok: false, err: new Error("claims: token has expired") };
  }
  return { ok: true };
};
var ValidateEOAProof = function(provider2, chainId, proof) {
  return __awaiter(void 0, void 0, void 0, function() {
    var messageDigest, address;
    return __generator(this, function(_a2) {
      messageDigest = proof.messageDigest();
      address = verifyMessage(messageDigest, proof.signature);
      if (address.slice(0, 2) === "0x" && address.length === 42 && address.toLowerCase() === proof.address.toLowerCase()) {
        return [2, { isValid: true, address: proof.address }];
      } else {
        return [2, { isValid: false }];
      }
    });
  });
};
var ValidateContractAccountProof = function(provider2, chainId, proof) {
  return __awaiter(void 0, void 0, void 0, function() {
    var messageDigest, walletCode, abi2, contract, isValidSignature2;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (!provider2 || provider2 === void 0) {
            return [2, { isValid: false }];
          }
          messageDigest = proof.messageDigest();
          return [4, provider2.getCode(proof.address)];
        case 1:
          walletCode = _a2.sent();
          if (walletCode === "0x" || walletCode.length <= 2) {
            throw new Error("ValidateContractAccountProof failed. unable to fetch wallet contract code");
          }
          abi2 = ["function isValidSignature(bytes32, bytes) public view returns (bytes4)"];
          contract = new Contract(proof.address, abi2, provider2);
          return [4, contract.isValidSignature(messageDigest, getBytes(proof.signature))];
        case 2:
          isValidSignature2 = _a2.sent();
          if (isValidSignature2 === IsValidSignatureBytes32MagicValue) {
            return [2, { isValid: true, address: proof.address }];
          } else {
            return [2, { isValid: false }];
          }
      }
    });
  });
};
var IsValidSignatureBytes32MagicValue = "0x1626ba7e";
var ETHAuth = (
  /** @class */
  /* @__PURE__ */ function() {
    function ETHAuth2() {
      var validators = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        validators[_i2] = arguments[_i2];
      }
      var _this = this;
      this.configJsonRpcProvider = function(ethereumJsonRpcURL) {
        return __awaiter(_this, void 0, void 0, function() {
          var netVersion;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.provider = new JsonRpcProvider$1(ethereumJsonRpcURL);
                return [4, this.provider.send("net_version", [])];
              case 1:
                netVersion = _a2.sent();
                this.chainId = parseInt(netVersion);
                if (!this.chainId) {
                  throw new Error("ethauth: unable to get chainId");
                }
                this.ethereumJsonRpcURL = ethereumJsonRpcURL;
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      this.configValidators = function() {
        var validators2 = [];
        for (var _i3 = 0; _i3 < arguments.length; _i3++) {
          validators2[_i3] = arguments[_i3];
        }
        if (validators2.length == 0) {
          throw new Error("validators list is empty");
        }
        _this.validators = validators2;
      };
      this.encodeProof = function(proof, skipSignatureValidation) {
        if (skipSignatureValidation === void 0) {
          skipSignatureValidation = false;
        }
        return __awaiter(_this, void 0, void 0, function() {
          var isValid2, claimsJSON, proofString;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (proof.address.length !== 42 || proof.address.slice(0, 2) !== "0x") {
                  throw new Error("ethauth: invalid address");
                }
                if (proof.signature === "" || proof.signature.slice(0, 2) !== "0x") {
                  throw new Error("ethauth: invalid signature");
                }
                if (proof.extra && proof.extra.slice(0, 2) !== "0x") {
                  throw new Error("ethauth: invalid extra encoding, expecting hex data");
                }
                return [4, this.validateProof(proof, skipSignatureValidation)];
              case 1:
                isValid2 = _a2.sent();
                if (!isValid2) {
                  throw new Error("ethauth: proof is invalid");
                }
                claimsJSON = JSON.stringify(proof.claims);
                proofString = ETHAuthPrefix + "." + proof.address.toLowerCase() + "." + gBase64.encode(claimsJSON, true) + "." + proof.signature;
                if (proof.extra && proof.extra.length > 0) {
                  proofString += "." + proof.extra;
                }
                return [2, proofString];
            }
          });
        });
      };
      this.decodeProof = function(proofString, skipSignatureValidation) {
        if (skipSignatureValidation === void 0) {
          skipSignatureValidation = false;
        }
        return __awaiter(_this, void 0, void 0, function() {
          var parts, prefix, address, messageBase64, signature2, extra, message, claims, proof, isValid2;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                parts = proofString.split(".");
                if (parts.length < 4 || parts.length > 5) {
                  throw new Error("ethauth: invalid proof string");
                }
                prefix = parts[0], address = parts[1], messageBase64 = parts[2], signature2 = parts[3], extra = parts[4];
                if (prefix !== ETHAuthPrefix) {
                  throw new Error("ethauth: not an ethauth proof");
                }
                message = gBase64.decode(messageBase64);
                claims = JSON.parse(message);
                proof = new Proof({ address, claims, signature: signature2, extra });
                return [4, this.validateProof(proof, skipSignatureValidation)];
              case 1:
                isValid2 = _a2.sent();
                if (!isValid2) {
                  throw new Error("ethauth: proof is invalid");
                }
                return [2, proof];
            }
          });
        });
      };
      this.validateProof = function(proof, skipSignatureValidation) {
        if (skipSignatureValidation === void 0) {
          skipSignatureValidation = false;
        }
        return __awaiter(_this, void 0, void 0, function() {
          var isValidClaims, isValidSig;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isValidClaims = this.validateProofClaims(proof);
                if (isValidClaims.err) {
                  throw new Error("ethauth: proof claims are invalid ".concat(isValidClaims.err));
                }
                if (!(skipSignatureValidation !== true)) return [3, 2];
                return [4, this.validateProofSignature(proof)];
              case 1:
                isValidSig = _a2.sent();
                if (isValidSig !== true) {
                  throw new Error("ethauth: proof signature is invalid");
                }
                _a2.label = 2;
              case 2:
                return [2, true];
            }
          });
        });
      };
      this.validateProofSignature = function(proof) {
        return __awaiter(_this, void 0, void 0, function() {
          var retIsValid, i, validator, isValid2, i;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                retIsValid = [];
                i = 0;
                _a2.label = 1;
              case 1:
                if (!(i < this.validators.length)) return [3, 6];
                _a2.label = 2;
              case 2:
                _a2.trys.push([2, 4, , 5]);
                validator = this.validators[i];
                return [4, validator(this.provider, this.chainId, proof)];
              case 3:
                isValid2 = _a2.sent().isValid;
                if (isValid2 === true) {
                  return [2, true];
                }
                retIsValid.push(isValid2);
                return [3, 5];
              case 4:
                _a2.sent();
                retIsValid.push(false);
                return [3, 5];
              case 5:
                i++;
                return [3, 1];
              case 6:
                for (i = 0; i < retIsValid.length; i++) {
                  if (retIsValid[i]) {
                    return [2, true];
                  }
                }
                return [2, false];
            }
          });
        });
      };
      this.validateProofClaims = function(proof) {
        return proof.validateClaims();
      };
      if (validators.length == 0) {
        this.validators = [ValidateEOAProof, ValidateContractAccountProof];
      } else {
        this.validators = validators;
      }
    }
    return ETHAuth2;
  }()
);
let ChainId$1 = /* @__PURE__ */ function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["ROPSTEN"] = 3] = "ROPSTEN";
  ChainId2[ChainId2["RINKEBY"] = 4] = "RINKEBY";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["KOVAN"] = 42] = "KOVAN";
  ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["POLYGON_ZKEVM"] = 1101] = "POLYGON_ZKEVM";
  ChainId2[ChainId2["POLYGON_AMOY"] = 80002] = "POLYGON_AMOY";
  ChainId2[ChainId2["BSC"] = 56] = "BSC";
  ChainId2[ChainId2["BSC_TESTNET"] = 97] = "BSC_TESTNET";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISM_KOVAN"] = 69] = "OPTIMISM_KOVAN";
  ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM"] = 42161] = "ARBITRUM";
  ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId2[ChainId2["ARBITRUM_SEPOLIA"] = 421614] = "ARBITRUM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM_NOVA"] = 42170] = "ARBITRUM_NOVA";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["AVALANCHE_TESTNET"] = 43113] = "AVALANCHE_TESTNET";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["BASE"] = 8453] = "BASE";
  ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId2[ChainId2["BASE_SEPOLIA"] = 84532] = "BASE_SEPOLIA";
  ChainId2[ChainId2["HOMEVERSE_TESTNET"] = 40875] = "HOMEVERSE_TESTNET";
  ChainId2[ChainId2["HOMEVERSE"] = 19011] = "HOMEVERSE";
  ChainId2[ChainId2["XAI"] = 660279] = "XAI";
  ChainId2[ChainId2["XAI_SEPOLIA"] = 37714555429] = "XAI_SEPOLIA";
  ChainId2[ChainId2["XR_SEPOLIA"] = 2730] = "XR_SEPOLIA";
  ChainId2[ChainId2["TELOS"] = 40] = "TELOS";
  ChainId2[ChainId2["B3"] = 8333] = "B3";
  ChainId2[ChainId2["B3_SEPOLIA"] = 1993] = "B3_SEPOLIA";
  ChainId2[ChainId2["APECHAIN"] = 33139] = "APECHAIN";
  ChainId2[ChainId2["APECHAIN_TESTNET"] = 33111] = "APECHAIN_TESTNET";
  ChainId2[ChainId2["BLAST"] = 81457] = "BLAST";
  ChainId2[ChainId2["BLAST_SEPOLIA"] = 168587773] = "BLAST_SEPOLIA";
  ChainId2[ChainId2["BORNE_TESTNET"] = 94984] = "BORNE_TESTNET";
  ChainId2[ChainId2["SKALE_NEBULA_TESTNET"] = 37084624] = "SKALE_NEBULA_TESTNET";
  ChainId2[ChainId2["SONEIUM_MINATO"] = 1946] = "SONEIUM_MINATO";
  ChainId2[ChainId2["TOY_TESTNET"] = 21e6] = "TOY_TESTNET";
  ChainId2[ChainId2["IMMUTABLE_ZKEVM"] = 13371] = "IMMUTABLE_ZKEVM";
  ChainId2[ChainId2["IMMUTABLE_ZKEVM_TESTNET"] = 13473] = "IMMUTABLE_ZKEVM_TESTNET";
  ChainId2[ChainId2["HARDHAT"] = 31337] = "HARDHAT";
  ChainId2[ChainId2["HARDHAT_2"] = 31338] = "HARDHAT_2";
  return ChainId2;
}({});
let NetworkType$1 = /* @__PURE__ */ function(NetworkType2) {
  NetworkType2["MAINNET"] = "mainnet";
  NetworkType2["TESTNET"] = "testnet";
  return NetworkType2;
}({});
const networks$1 = {
  [ChainId$1.MAINNET]: {
    chainId: ChainId$1.MAINNET,
    type: NetworkType$1.MAINNET,
    name: "mainnet",
    title: "Ethereum",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.MAINNET}.webp`,
    blockExplorer: {
      name: "Etherscan",
      rootUrl: "https://etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  [ChainId$1.ROPSTEN]: {
    chainId: ChainId$1.ROPSTEN,
    type: NetworkType$1.TESTNET,
    name: "ropsten",
    title: "Ropsten",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.ROPSTEN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Ropsten)",
      rootUrl: "https://ropsten.etherscan.io/"
    },
    nativeToken: {
      symbol: "roETH",
      name: "Ropsten Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId$1.RINKEBY]: {
    chainId: ChainId$1.RINKEBY,
    type: NetworkType$1.TESTNET,
    name: "rinkeby",
    title: "Rinkeby",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.RINKEBY}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Rinkeby)",
      rootUrl: "https://rinkeby.etherscan.io/"
    },
    nativeToken: {
      symbol: "rETH",
      name: "Rinkeby Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId$1.GOERLI]: {
    chainId: ChainId$1.GOERLI,
    type: NetworkType$1.TESTNET,
    name: "goerli",
    title: "Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Goerli)",
      rootUrl: "https://goerli.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId$1.KOVAN]: {
    chainId: ChainId$1.KOVAN,
    type: NetworkType$1.TESTNET,
    name: "kovan",
    title: "Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.KOVAN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Kovan)",
      rootUrl: "https://kovan.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId$1.SEPOLIA]: {
    chainId: ChainId$1.SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "sepolia",
    title: "Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Sepolia)",
      rootUrl: "https://sepolia.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId$1.POLYGON]: {
    chainId: ChainId$1.POLYGON,
    type: NetworkType$1.MAINNET,
    name: "polygon",
    title: "Polygon",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.POLYGON}.webp`,
    blockExplorer: {
      name: "Polygonscan",
      rootUrl: "https://polygonscan.com/"
    },
    nativeToken: {
      symbol: "POL",
      name: "POL",
      decimals: 18
    }
  },
  [ChainId$1.POLYGON_MUMBAI]: {
    chainId: ChainId$1.POLYGON_MUMBAI,
    type: NetworkType$1.TESTNET,
    name: "mumbai",
    title: "Polygon Mumbai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.POLYGON_MUMBAI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Polygonscan (Mumbai)",
      rootUrl: "https://mumbai.polygonscan.com/"
    },
    nativeToken: {
      symbol: "mMATIC",
      name: "Mumbai Polygon",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId$1.POLYGON_AMOY]: {
    chainId: ChainId$1.POLYGON_AMOY,
    type: NetworkType$1.TESTNET,
    name: "amoy",
    title: "Polygon Amoy",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.POLYGON_AMOY}.webp`,
    testnet: true,
    blockExplorer: {
      name: "OKLink (Amoy)",
      rootUrl: "https://www.oklink.com/amoy/"
    },
    nativeToken: {
      symbol: "aPOL",
      name: "Amoy POL",
      decimals: 18
    }
  },
  [ChainId$1.POLYGON_ZKEVM]: {
    chainId: ChainId$1.POLYGON_ZKEVM,
    type: NetworkType$1.MAINNET,
    name: "polygon-zkevm",
    title: "Polygon zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.POLYGON_ZKEVM}.webp`,
    blockExplorer: {
      name: "Polygonscan (zkEVM)",
      rootUrl: "https://zkevm.polygonscan.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.BSC]: {
    chainId: ChainId$1.BSC,
    type: NetworkType$1.MAINNET,
    name: "bsc",
    title: "BNB Smart Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BSC}.webp`,
    blockExplorer: {
      name: "BSCScan",
      rootUrl: "https://bscscan.com/"
    },
    nativeToken: {
      symbol: "BNB",
      name: "BNB",
      decimals: 18
    }
  },
  [ChainId$1.BSC_TESTNET]: {
    chainId: ChainId$1.BSC_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "bsc-testnet",
    title: "BNB Smart Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BSC_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "BSCScan (Testnet)",
      rootUrl: "https://testnet.bscscan.com/"
    },
    nativeToken: {
      symbol: "tBNB",
      name: "Testnet BNB",
      decimals: 18
    }
  },
  [ChainId$1.OPTIMISM]: {
    chainId: ChainId$1.OPTIMISM,
    type: NetworkType$1.MAINNET,
    name: "optimism",
    title: "Optimism",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.OPTIMISM}.webp`,
    blockExplorer: {
      name: "Etherscan (Optimism)",
      rootUrl: "https://optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.OPTIMISM_KOVAN]: {
    chainId: ChainId$1.OPTIMISM_KOVAN,
    type: NetworkType$1.TESTNET,
    name: "optimism-kovan",
    title: "Optimism Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.OPTIMISM_KOVAN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Kovan)",
      rootUrl: "https://kovan-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId$1.OPTIMISM_GOERLI]: {
    chainId: ChainId$1.OPTIMISM_GOERLI,
    type: NetworkType$1.TESTNET,
    name: "optimism-goerli",
    title: "Optimism Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.OPTIMISM_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Goerli)",
      rootUrl: "https://goerli-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId$1.OPTIMISM_SEPOLIA]: {
    chainId: ChainId$1.OPTIMISM_SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "optimism-sepolia",
    title: "Optimism Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.OPTIMISM_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Sepolia)",
      rootUrl: "https://sepolia-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId$1.ARBITRUM]: {
    chainId: ChainId$1.ARBITRUM,
    type: NetworkType$1.MAINNET,
    name: "arbitrum",
    title: "Arbitrum One",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.ARBITRUM}.webp`,
    blockExplorer: {
      name: "Arbiscan",
      rootUrl: "https://arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.ARBITRUM_GOERLI]: {
    chainId: ChainId$1.ARBITRUM_GOERLI,
    type: NetworkType$1.TESTNET,
    name: "arbitrum-goerli",
    title: "Arbitrum Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.ARBITRUM_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Arbiscan (Goerli Testnet)",
      rootUrl: "https://testnet.arbiscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId$1.ARBITRUM_SEPOLIA]: {
    chainId: ChainId$1.ARBITRUM_SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "arbitrum-sepolia",
    title: "Arbitrum Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.ARBITRUM_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Arbiscan (Sepolia Testnet)",
      rootUrl: "https://sepolia.arbiscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId$1.ARBITRUM_NOVA]: {
    chainId: ChainId$1.ARBITRUM_NOVA,
    type: NetworkType$1.MAINNET,
    name: "arbitrum-nova",
    title: "Arbitrum Nova",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.ARBITRUM_NOVA}.webp`,
    blockExplorer: {
      name: "Arbiscan Nova",
      rootUrl: "https://nova.arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.AVALANCHE]: {
    chainId: ChainId$1.AVALANCHE,
    type: NetworkType$1.MAINNET,
    name: "avalanche",
    title: "Avalanche",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.AVALANCHE}.webp`,
    blockExplorer: {
      name: "Snowtrace",
      rootUrl: "https://subnets.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "AVAX",
      name: "AVAX",
      decimals: 18
    }
  },
  [ChainId$1.AVALANCHE_TESTNET]: {
    chainId: ChainId$1.AVALANCHE_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "avalanche-testnet",
    title: "Avalanche Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.AVALANCHE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Snowtrace (Testnet)",
      rootUrl: "https://subnets-test.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "tAVAX",
      name: "Testnet AVAX",
      decimals: 18
    }
  },
  [ChainId$1.GNOSIS]: {
    chainId: ChainId$1.GNOSIS,
    type: NetworkType$1.MAINNET,
    name: "gnosis",
    title: "Gnosis Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.GNOSIS}.webp`,
    blockExplorer: {
      name: "Gnosis Chain Explorer",
      rootUrl: "https://blockscout.com/xdai/mainnet/"
    },
    nativeToken: {
      symbol: "XDAI",
      name: "XDAI",
      decimals: 18
    }
  },
  [ChainId$1.BASE]: {
    chainId: ChainId$1.BASE,
    type: NetworkType$1.MAINNET,
    name: "base",
    title: "Base (Coinbase)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BASE}.webp`,
    blockExplorer: {
      name: "Base Explorer",
      rootUrl: "https://basescan.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.BASE_GOERLI]: {
    chainId: ChainId$1.BASE_GOERLI,
    type: NetworkType$1.TESTNET,
    name: "base-goerli",
    title: "Base Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BASE_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Base Goerli Explorer",
      rootUrl: "https://goerli.basescan.org/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId$1.BASE_SEPOLIA]: {
    chainId: ChainId$1.BASE_SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "base-sepolia",
    title: "Base Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BASE_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Base Sepolia Explorer",
      rootUrl: "https://base-sepolia.blockscout.com/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId$1.HOMEVERSE]: {
    chainId: ChainId$1.HOMEVERSE,
    type: NetworkType$1.MAINNET,
    name: "homeverse",
    title: "Oasys Homeverse",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.HOMEVERSE}.webp`,
    blockExplorer: {
      name: "Oasys Homeverse Explorer",
      rootUrl: "https://explorer.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "OAS",
      name: "OAS",
      decimals: 18
    }
  },
  [ChainId$1.HOMEVERSE_TESTNET]: {
    chainId: ChainId$1.HOMEVERSE_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "homeverse-testnet",
    title: "Oasys Homeverse Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.HOMEVERSE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Oasys Homeverse Explorer (Testnet)",
      rootUrl: "https://explorer.testnet.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "tOAS",
      name: "Testnet OAS",
      decimals: 18
    }
  },
  [ChainId$1.XAI]: {
    chainId: ChainId$1.XAI,
    type: NetworkType$1.MAINNET,
    name: "xai",
    title: "Xai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.XAI}.webp`,
    blockExplorer: {
      name: "Xai Explorer",
      rootUrl: "https://explorer.xai-chain.net/"
    },
    nativeToken: {
      symbol: "XAI",
      name: "XAI",
      decimals: 18
    }
  },
  [ChainId$1.XAI_SEPOLIA]: {
    chainId: ChainId$1.XAI_SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "xai-sepolia",
    title: "Xai Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.XAI_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Xai Sepolia Explorer",
      rootUrl: "https://testnet-explorer-v2.xai-chain.net/"
    },
    nativeToken: {
      symbol: "sXAI",
      name: "Sepolia XAI",
      decimals: 18
    }
  },
  [ChainId$1.XR_SEPOLIA]: {
    chainId: ChainId$1.XR_SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "xr-sepolia",
    title: "XR Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.XR_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "XR Sepolia Explorer",
      rootUrl: "https://xr-sepolia-testnet.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "tXR",
      name: "Sepolia XR",
      decimals: 18
    }
  },
  [ChainId$1.B3]: {
    chainId: ChainId$1.B3,
    type: NetworkType$1.MAINNET,
    name: "b3",
    title: "B3",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.B3}.webp`,
    testnet: false,
    blockExplorer: {
      name: "B3 Explorer",
      rootUrl: "https://explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.B3_SEPOLIA]: {
    chainId: ChainId$1.B3_SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "b3-sepolia",
    title: "B3 Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.B3_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "B3 Sepolia Explorer",
      rootUrl: "https://sepolia.explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.APECHAIN]: {
    chainId: ChainId$1.APECHAIN,
    type: NetworkType$1.MAINNET,
    name: "apechain",
    title: "APE Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.APECHAIN}.webp`,
    testnet: false,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://apechain.calderaexplorer.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [ChainId$1.APECHAIN_TESTNET]: {
    chainId: ChainId$1.APECHAIN_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "apechain-testnet",
    title: "APE Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.APECHAIN_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://curtis.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [ChainId$1.BLAST]: {
    chainId: ChainId$1.BLAST,
    type: NetworkType$1.MAINNET,
    name: "blast",
    title: "Blast",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BLAST}.webp`,
    blockExplorer: {
      name: "Blast Explorer",
      rootUrl: "https://blastscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.BLAST_SEPOLIA]: {
    chainId: ChainId$1.BLAST_SEPOLIA,
    type: NetworkType$1.TESTNET,
    name: "blast-sepolia",
    title: "Blast Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BLAST_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Blast Sepolia Explorer",
      rootUrl: "https://sepolia.blastexplorer.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.TELOS]: {
    chainId: ChainId$1.TELOS,
    type: NetworkType$1.MAINNET,
    name: "telos",
    title: "Telos",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.TELOS}.webp`,
    blockExplorer: {
      name: "Telos Explorer",
      rootUrl: "https://explorer.telos.net/network/"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [ChainId$1.BORNE_TESTNET]: {
    chainId: ChainId$1.BORNE_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "borne-testnet",
    title: "Borne Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.BORNE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Borne Testnet Explorer",
      rootUrl: "https://subnets-test.avax.network/bornegfdn"
    },
    nativeToken: {
      symbol: "BORNE",
      name: "BORNE",
      decimals: 18
    }
  },
  [ChainId$1.SKALE_NEBULA_TESTNET]: {
    chainId: ChainId$1.SKALE_NEBULA_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "skale-nebula-testnet",
    title: "SKALE Nebula Gaming Hub Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.SKALE_NEBULA_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Testnet Explorer",
      rootUrl: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [ChainId$1.SONEIUM_MINATO]: {
    chainId: ChainId$1.SONEIUM_MINATO,
    type: NetworkType$1.TESTNET,
    name: "soneium-minato",
    title: "Soneium Minato (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.SONEIUM_MINATO}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Soneium Minato Explorer",
      rootUrl: "https://explorer-testnet.soneium.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.TOY_TESTNET]: {
    chainId: ChainId$1.TOY_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "toy-testnet",
    title: "TOY (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.TOY_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "TOY Testnet Explorer",
      rootUrl: "https://toy-chain-testnet.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "TOY",
      name: "TOY",
      decimals: 18
    }
  },
  [ChainId$1.IMMUTABLE_ZKEVM]: {
    chainId: ChainId$1.IMMUTABLE_ZKEVM,
    type: NetworkType$1.MAINNET,
    name: "immutable-zkevm",
    title: "Immutable zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.IMMUTABLE_ZKEVM}.webp`,
    testnet: false,
    blockExplorer: {
      name: "Immutable zkEVM Explorer",
      rootUrl: "https://explorer.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [ChainId$1.IMMUTABLE_ZKEVM_TESTNET]: {
    chainId: ChainId$1.IMMUTABLE_ZKEVM_TESTNET,
    type: NetworkType$1.TESTNET,
    name: "immutable-zkevm-testnet",
    title: "Immutable zkEVM Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId$1.IMMUTABLE_ZKEVM_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Immutable zkEVM Testnet Explorer",
      rootUrl: "https://explorer.testnet.immutable.com/"
    },
    nativeToken: {
      symbol: "IMX",
      name: "IMX",
      decimals: 18
    }
  },
  [ChainId$1.HARDHAT]: {
    chainId: ChainId$1.HARDHAT,
    name: "hardhat",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId$1.HARDHAT_2]: {
    chainId: ChainId$1.HARDHAT_2,
    name: "hardhat2",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  }
};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var browser$1 = { exports: {} };
var process = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e2) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e2) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e22) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e22) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name2) {
  return [];
};
process.binding = function(name2) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const extractProjectIdFromAccessKey = (accessKey) => {
  const base64String = accessKey.replace(/-/g, "+").replace(/_/g, "/");
  const binaryString = atob(base64String);
  const byteArray = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    byteArray[i] = binaryString.charCodeAt(i);
  }
  if (byteArray[0] !== 1) {
    throw new Error("UnsupportedVersion");
  }
  const projectIdBytes = byteArray.slice(1, 9);
  const projectId = projectIdBytes[7] | projectIdBytes[6] << 8 | projectIdBytes[5] << 16 | projectIdBytes[4] << 24 | projectIdBytes[3] << 32 | projectIdBytes[2] << 40 | projectIdBytes[1] << 48 | projectIdBytes[0] << 56;
  return projectId;
};
const MAX_UINT_256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const isBigNumberish = (value) => {
  return value != null && (typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint");
};
const toHexString = (value) => {
  const result = value.toString(16);
  return `${result.length % 2 === 0 ? "0x" : "0x0"}${result}`;
};
const parseUnits = (value, decimals = 18) => {
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative) {
    integer = integer.slice(1);
  }
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [fraction.slice(0, decimals - 1), fraction.slice(decimals - 1, decimals), fraction.slice(decimals)];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9) {
      fraction = `${BigInt(left) + 1n}0`.padStart(left.length + 1, "0");
    } else {
      fraction = `${left}${rounded}`;
    }
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
};
const parseEther = (value) => parseUnits(value, 18);
const formatUnits = (value, decimals = 18) => {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative) {
    display = display.slice(1);
  }
  display = display.padStart(decimals, "0");
  const integer = display.slice(0, display.length - decimals);
  let fraction = display.slice(display.length - decimals);
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
};
const formatEther = (value) => formatUnits(value, 18);
const bigintReplacer = (key, value) => {
  if (typeof value === "bigint") {
    return {
      $bigint: value.toString()
    };
  }
  return value;
};
const bigintReviver = (key, value) => {
  if (value !== null && typeof value === "object" && "$bigint" in value && typeof value.$bigint === "string") {
    return BigInt(value.$bigint);
  }
  if (value !== null && typeof value === "object" && value.type === "BigNumber" && isHexString(value.hex)) {
    return BigInt(value.hex);
  }
  return value;
};
const base64Encode = (val) => {
  return gBase64.encode(val, true);
};
const base64EncodeObject = (obj) => {
  return gBase64.encode(JSON.stringify(obj, bigintReplacer), true);
};
const base64Decode = (encodedString) => {
  if (encodedString === null || encodedString === void 0) {
    return void 0;
  }
  return gBase64.decode(encodedString);
};
const base64DecodeObject = (encodedObject) => {
  if (encodedObject === null || encodedObject === void 0) {
    return void 0;
  }
  return JSON.parse(gBase64.decode(encodedObject), bigintReviver);
};
const encodeMessageDigest = (message) => {
  if (typeof message === "string") {
    return getBytes(id$1(message));
  } else {
    return getBytes(keccak256(message));
  }
};
const packMessageData = (walletAddress, chainId, digest) => {
  return solidityPacked(["string", "uint256", "address", "bytes32"], ["", chainId, walletAddress, digest]);
};
const subDigestOf = (address, chainId, digest) => {
  return keccak256(packMessageData(address, chainId, digest));
};
const isNode$2 = () => {
  if (typeof window === "undefined" && typeof process$1 === "object") {
    return true;
  } else {
    return false;
  }
};
const isBrowser$1 = () => !isNode$2();
const jwtDecodeClaims = (jwt) => {
  const parts = jwt.split(".");
  if (parts.length !== 3) {
    throw new Error("invalid jwt");
  }
  const claims = JSON.parse(gBase64.decode(parts[1]));
  return claims;
};
function _extends$g() {
  return _extends$g = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$g.apply(null, arguments);
}
var logLevel$1 = /* @__PURE__ */ function(logLevel2) {
  logLevel2[logLevel2["DEBUG"] = 1] = "DEBUG";
  logLevel2[logLevel2["INFO"] = 2] = "INFO";
  logLevel2[logLevel2["WARN"] = 3] = "WARN";
  logLevel2[logLevel2["ERROR"] = 4] = "ERROR";
  logLevel2[logLevel2["DISABLED"] = 5] = "DISABLED";
  return logLevel2;
}(logLevel$1 || {});
let Logger$1 = class Logger {
  constructor(config2) {
    this.config = config2;
    this.logLevel = void 0;
    this.configure(config2);
  }
  configure(config2) {
    this.config = _extends$g({}, this.config, config2);
    switch (this.config.logLevel) {
      case "DEBUG":
        this.logLevel = logLevel$1.DEBUG;
        break;
      case "INFO":
        this.logLevel = logLevel$1.INFO;
        break;
      case "WARN":
        this.logLevel = logLevel$1.WARN;
        break;
      case "ERROR":
        this.logLevel = logLevel$1.ERROR;
        break;
      case "DISABLED":
        this.logLevel = logLevel$1.DISABLED;
        break;
      default:
        this.logLevel = logLevel$1.INFO;
        break;
    }
    if (this.config.silence === void 0) {
      this.config.silence = false;
    }
  }
  debug(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel === logLevel$1.DEBUG) {
      console.log(message, ...optionalParams);
    }
  }
  info(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel$1.INFO) {
      console.log(message, ...optionalParams);
    }
  }
  warn(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel$1.WARN) {
      console.warn(message, ...optionalParams);
      if (this.config.onwarn) {
        this.config.onwarn(message, optionalParams);
      }
    }
  }
  error(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel$1.ERROR) {
      console.error(message, ...optionalParams);
      if (this.config.onerror) {
        this.config.onerror(message, optionalParams);
      }
    }
  }
};
const logger = new Logger$1({
  logLevel: "INFO",
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: true
});
const configureLogger = (config2) => logger.configure(config2);
class Base {
  static bufferIndexOf(array, element, isSorted = false) {
    if (isSorted) {
      return Base.binarySearch(array, element, Base.compare);
    }
    const eqChecker = (buffer1, buffer2) => {
      if (buffer1 === buffer2) {
        return true;
      }
      if (buffer1.length !== buffer2.length) {
        return false;
      }
      for (let i = 0; i < buffer1.length; i++) {
        if (buffer1[i] !== buffer2[i]) {
          return false;
        }
      }
      return true;
    };
    return Base.linearSearch(array, element, eqChecker);
  }
  static binarySearch(array, element, compareFunction) {
    let start = 0;
    let end = array.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const ordering = compareFunction(array[mid], element);
      if (ordering === 0) {
        for (let i = mid - 1; i >= 0; i--) {
          if (compareFunction(array[i], element) === 0) continue;
          return i + 1;
        }
        return 0;
      } else if (ordering < 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    }
    return -1;
  }
  static compare(a2, b2) {
    const len = Math.min(a2.length, b2.length);
    for (let i = 0; i < len; i++) {
      if (a2[i] !== b2[i]) {
        return a2[i] - b2[i];
      }
    }
    return a2.length - b2.length;
  }
  static linearSearch(array, element, eqChecker) {
    for (let i = 0; i < array.length; i++) {
      if (eqChecker(array[i], element)) {
        return i;
      }
    }
    return -1;
  }
  static bufferify(value) {
    if (typeof value === "string") {
      return getBytes(value);
    }
    return value;
  }
  static isHexString(v3) {
    return typeof v3 === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v3);
  }
  static bufferToHex(value, withPrefix = true) {
    const prefixed = hexlify(value);
    return withPrefix ? prefixed : prefixed.substring(2);
  }
  static bufferifyFn(f2) {
    return (value) => {
      return Base.bufferify(f2(value));
    };
  }
}
class MerkleTree extends Base {
  constructor(leaves, options = {}) {
    super();
    this.hashFn = void 0;
    this.leaves = [];
    this.layers = [];
    this.sortLeaves = false;
    this.sortPairs = false;
    this.sortLeaves = !!options.sortLeaves;
    this.sortPairs = !!options.sortPairs;
    this.hashFn = Base.bufferifyFn(keccak256);
    this.processLeaves(leaves);
  }
  getOptions() {
    return {
      sortLeaves: this.sortLeaves,
      sortPairs: this.sortPairs
    };
  }
  processLeaves(leaves) {
    this.leaves = leaves.map(Base.bufferify);
    if (this.sortLeaves) {
      this.leaves = this.leaves.sort(Base.compare);
    }
    this.createHashes(this.leaves);
  }
  createHashes(nodes) {
    this.layers = [nodes];
    while (nodes.length > 1) {
      const layerIndex = this.layers.length;
      this.layers.push([]);
      const layerLimit = nodes.length;
      for (let i = 0; i < nodes.length; i += 2) {
        if (i >= layerLimit) {
          this.layers[layerIndex].push(...nodes.slice(layerLimit));
          break;
        } else if (i + 1 === nodes.length) {
          if (nodes.length % 2 === 1) {
            this.layers[layerIndex].push(nodes[i]);
            continue;
          }
        }
        const left = nodes[i];
        const right = i + 1 === nodes.length ? left : nodes[i + 1];
        const combined = [left, right];
        if (this.sortPairs) {
          combined.sort(Base.compare);
        }
        const hash2 = this.hashFn(concat(combined));
        this.layers[layerIndex].push(hash2);
      }
      nodes = this.layers[layerIndex];
    }
  }
  getRoot() {
    if (this.layers.length === 0) {
      return Uint8Array.from([]);
    }
    return this.layers[this.layers.length - 1][0] || Uint8Array.from([]);
  }
  getHexRoot() {
    return Base.bufferToHex(this.getRoot());
  }
  getProof(leaf, index2) {
    if (typeof leaf === "undefined") {
      throw new Error("leaf is required");
    }
    leaf = Base.bufferify(leaf);
    const proof = [];
    if (!Number.isInteger(index2)) {
      index2 = -1;
      for (let i = 0; i < this.leaves.length; i++) {
        if (Base.compare(leaf, this.leaves[i]) === 0) {
          index2 = i;
        }
      }
    }
    index2 = index2;
    if (index2 <= -1) {
      return [];
    }
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.layers[i];
      const isRightNode = index2 % 2;
      const pairIndex = isRightNode ? index2 - 1 : index2 + 1;
      if (pairIndex < layer.length) {
        proof.push({
          position: isRightNode ? "left" : "right",
          data: layer[pairIndex]
        });
      }
      index2 = index2 / 2 | 0;
    }
    return proof;
  }
  getHexProof(leaf, index2) {
    return this.getProof(leaf, index2).map((item2) => Base.bufferToHex(item2.data));
  }
  verify(proof, targetNode, root2) {
    let hash2 = Base.bufferify(targetNode);
    root2 = Base.bufferify(root2);
    if (!Array.isArray(proof) || !targetNode || !root2) {
      return false;
    }
    for (let i = 0; i < proof.length; i++) {
      const node = proof[i];
      let data;
      let isLeftNode;
      if (typeof node === "string") {
        data = Base.bufferify(node);
        isLeftNode = true;
      } else if (node instanceof Object) {
        data = node.data;
        isLeftNode = node.position === "left";
      } else {
        throw new Error("Expected node to be of type string or object");
      }
      const buffers = [];
      if (this.sortPairs) {
        if (Base.compare(hash2, data) < 0) {
          buffers.push(hash2, data);
        } else {
          buffers.push(data, hash2);
        }
        hash2 = this.hashFn(concat(buffers));
      } else {
        buffers.push(hash2);
        buffers[isLeftNode ? "unshift" : "push"](data);
        hash2 = this.hashFn(concat(buffers));
      }
    }
    return Base.compare(hash2, root2) === 0;
  }
}
class MerkleTreeGenerator {
  constructor(elements, toLeaf) {
    this.elements = void 0;
    this.toLeaf = void 0;
    this.tree = void 0;
    this.elements = elements;
    this.toLeaf = toLeaf;
  }
  generateTree() {
    const hashed = this.elements.map((e2) => this.toLeaf(e2));
    return new MerkleTree(hashed, {
      sortPairs: true,
      sortLeaves: true
    });
  }
  generateRoot() {
    if (!this.tree) this.tree = this.generateTree();
    return this.tree.getHexRoot();
  }
  generateProof(element) {
    if (!this.elements.includes(element)) throw new Error("Element not found");
    if (!this.tree) this.tree = this.generateTree();
    return this.tree.getHexProof(this.toLeaf(element));
  }
  verifyProof(element, proof) {
    if (!this.elements.includes(element)) throw new Error("Element not found");
    if (!this.tree) this.tree = this.generateTree();
    return this.tree.verify(proof, this.toLeaf(element), this.generateRoot());
  }
}
const getSaleItemsLeaf = (element) => solidityPackedKeccak256(["address", "uint256"], [element.address.toLowerCase(), element.tokenId]);
const getFetchRequest = (url, projectAccessKey2, jwt) => {
  const req = new FetchRequest(url);
  if (jwt) {
    req.setHeader("Authorization", `BEARER ${jwt}`);
  }
  if (projectAccessKey2) {
    req.setHeader("X-Access-Key", projectAccessKey2);
  }
  return req;
};
let PromiseCache$1 = class PromiseCache {
  constructor() {
    this.cache = void 0;
    this.cache = /* @__PURE__ */ new Map();
  }
  do(key, validMilliseconds, task, ...args) {
    key = `${key}:${id$1(JSON.stringify(args, deterministically$1))}`;
    let entry = this.cache.get(key);
    if (entry) {
      if (entry.expiration) {
        if (/* @__PURE__ */ new Date() >= entry.expiration) {
          entry = void 0;
          this.cache.delete(key);
        }
      }
    }
    if (!entry) {
      const entry_ = {
        promise: task(...args)
      };
      if (validMilliseconds !== void 0) {
        entry_.promise = entry_.promise.then((result) => {
          entry_.expiration = new Date(Date.now() + validMilliseconds);
          return result;
        });
      }
      entry = entry_;
      this.cache.set(key, entry);
    }
    return entry.promise;
  }
};
function deterministically$1(_key, value) {
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    return Object.fromEntries(Object.entries(value).sort());
  }
  return value;
}
function promisify(f2, thisContext) {
  return function(...a2) {
    const args = Array.prototype.slice.call(a2);
    return new Promise(async (resolve, reject) => {
      try {
        args.push((err, result) => err ? reject(err) : resolve(result));
        await f2.apply(thisContext, args);
      } catch (e2) {
        reject(e2);
      }
    });
  };
}
function queryStringFromObject(name2, obj) {
  const k2 = encodeURIComponent(name2);
  const v3 = encodeURIComponent(JSON.stringify(obj));
  return `${k2}=${v3}`;
}
function queryStringToObject(qs) {
  const p2 = qs.split("&");
  const o2 = {};
  for (const v3 of p2) {
    const z2 = v3.split("=");
    o2[decodeURIComponent(z2[0])] = JSON.parse(decodeURIComponent(z2[1]));
  }
  return o2;
}
const getRandomInt = (min2 = 0, max2 = Number.MAX_SAFE_INTEGER) => {
  min2 = Math.ceil(min2);
  max2 = Math.floor(max2);
  return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
};
const sanitizeNumberString = (numString) => {
  if (!numString || typeof numString !== "string") {
    return "";
  }
  const v3 = numString.match(/[\d.]+/);
  return v3 && v3.length > 0 ? v3[0].trim() : "";
};
const sanitizeAlphanumeric = (alphanum) => {
  if (!alphanum || typeof alphanum !== "string") {
    return "";
  }
  const v3 = alphanum.match(/[\w\s\d]+/);
  return v3 && v3.length > 0 ? v3[0].trim() : "";
};
const sanitizeHost = (host) => {
  if (!host || typeof host !== "string") {
    return "";
  }
  const v3 = host.match(/[\w\d.\-:\/]+/);
  return v3 && v3.length > 0 ? v3[0].trim() : "";
};
const sleep = (t2) => {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      clearTimeout(timeout);
      resolve();
    }, t2);
  });
};
const encodeTypedDataHash = (typedData) => {
  const types2 = _extends$g({}, typedData.types);
  delete types2["EIP712Domain"];
  return TypedDataEncoder.hash(typedData.domain, types2, typedData.message);
};
const encodeTypedDataDigest = (typedData) => {
  return getBytes(encodeTypedDataHash(typedData));
};
const {
  defineProperties,
  resolveProperties
} = ethers;
const urlClean = (url) => url.replace(/([^:]\/)\/+/g, "$1");
const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Logger: Logger$1,
  MAX_UINT_256,
  MerkleTreeGenerator,
  PromiseCache: PromiseCache$1,
  base64Decode,
  base64DecodeObject,
  base64Encode,
  base64EncodeObject,
  bigintReplacer,
  bigintReviver,
  configureLogger,
  defineProperties,
  encodeMessageDigest,
  encodeTypedDataDigest,
  encodeTypedDataHash,
  extractProjectIdFromAccessKey,
  formatEther,
  formatUnits,
  getFetchRequest,
  getRandomInt,
  getSaleItemsLeaf,
  isBigNumberish,
  isBrowser: isBrowser$1,
  isNode: isNode$2,
  jwtDecodeClaims,
  logger,
  packMessageData,
  parseEther,
  parseUnits,
  promisify,
  queryStringFromObject,
  queryStringToObject,
  resolveProperties,
  sanitizeAlphanumeric,
  sanitizeHost,
  sanitizeNumberString,
  sleep,
  subDigestOf,
  toHexString,
  urlClean
}, Symbol.toStringTag, { value: "Module" }));
function _extends$f() {
  return _extends$f = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$f.apply(null, arguments);
}
function isNetworkConfig(cand) {
  return cand && cand.chainId !== void 0 && cand.name !== void 0 && cand.rpcUrl !== void 0 && cand.relayer !== void 0;
}
const getChainId = (chainId) => {
  if (typeof chainId === "number") {
    return chainId;
  }
  if (chainId.chainId) {
    return chainId.chainId;
  }
  return Number(chainId);
};
const maybeChainId = (chainId) => {
  if (!chainId) return void 0;
  return getChainId(chainId);
};
const isValidNetworkConfig$1 = (networkConfig, raise = false, skipRelayerCheck = false) => {
  if (!networkConfig) throw new Error(`invalid network config: empty config`);
  const configs = [];
  if (Array.isArray(networkConfig)) {
    configs.push(...networkConfig);
  } else {
    configs.push(networkConfig);
  }
  if (configs.length === 0) {
    if (raise) throw new Error(`invalid network config: empty config`);
    return false;
  }
  const chainIds = configs.map((c2) => c2.chainId).sort();
  const dupes = chainIds.filter((c2, i) => chainIds.indexOf(c2) !== i);
  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }
  configs.forEach((c2) => c2.name = c2.name.toLowerCase());
  const names2 = configs.map((c2) => c2.name).sort();
  const nameDupes = names2.filter((c2, i) => names2.indexOf(c2) !== i);
  if (nameDupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`);
    return false;
  }
  let defaultChain = false;
  for (let i = 0; i < configs.length; i++) {
    const c2 = configs[i];
    if ((!c2.rpcUrl || c2.rpcUrl === "") && !c2.provider) {
      if (raise) throw new Error(`invalid network config for chainId ${c2.chainId}: rpcUrl or provider must be provided`);
      return false;
    }
    if (!skipRelayerCheck) {
      if (!c2.relayer) {
        if (raise) throw new Error(`invalid network config for chainId ${c2.chainId}: relayer must be provided`);
        return false;
      }
    }
    if (c2.isDefaultChain) {
      if (defaultChain) {
        if (raise) throw new Error(`invalid network config for chainId ${c2.chainId}: DefaultChain is already set by another config`);
        return false;
      }
      defaultChain = true;
    }
  }
  if (!defaultChain) {
    if (raise) throw new Error(`invalid network config: DefaultChain must be set`);
    return false;
  }
  return true;
};
const ensureValidNetworks$1 = (networks2, skipRelayerCheck = false) => {
  isValidNetworkConfig$1(networks2, true, skipRelayerCheck);
  return networks2;
};
const ensureUniqueNetworks = (networks2, raise = true) => {
  const chainIds = networks2.map((c2) => c2.chainId).sort();
  const dupes = chainIds.filter((c2, i) => chainIds.indexOf(c2) !== i);
  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }
  return true;
};
const updateNetworkConfig = (src, dest) => {
  if (!src || !dest) return;
  if (!src.chainId && !src.name) {
    throw new Error("failed to update network config: source config is missing chainId or name");
  }
  if (src.chainId !== dest.chainId && src.name !== dest.name) {
    throw new Error("failed to update network config: one of chainId or name must match");
  }
  if (src.rpcUrl) {
    dest.rpcUrl = src.rpcUrl;
    dest.provider = void 0;
  }
  if (src.provider) {
    dest.provider = src.provider;
  }
  if (src.relayer) {
    dest.relayer = src.relayer;
  }
};
const validateAndSortNetworks$1 = (networks2) => {
  return ensureValidNetworks$1(sortNetworks$1(networks2));
};
const findNetworkConfig = (networks2, chainId) => {
  if (typeof chainId === "string") {
    if (chainId.startsWith("0x")) {
      const id2 = Number(chainId);
      return networks2.find((n2) => n2.chainId === id2);
    } else {
      return networks2.find((n2) => n2.name === chainId || `${n2.chainId}` === chainId);
    }
  } else if (typeof chainId === "number") {
    return networks2.find((n2) => n2.chainId === chainId);
  } else if (chainId.chainId) {
    return networks2.find((n2) => n2.chainId === chainId.chainId);
  } else if (typeof chainId === "bigint") {
    const id2 = Number(chainId);
    return networks2.find((n2) => n2.chainId === id2);
  } else {
    return void 0;
  }
};
const checkNetworkConfig = (network2, chainId) => {
  if (!network2) return false;
  if (network2.name === chainId) return true;
  if (network2.chainId === chainId) return true;
  return false;
};
const networksIndex = (networks2) => {
  const index2 = {};
  for (let i = 0; i < networks2.length; i++) {
    index2[networks2[i].name] = networks2[i];
  }
  return index2;
};
const sortNetworks$1 = (networks2) => {
  if (!networks2) {
    return [];
  }
  const config2 = networks2.sort((a2, b2) => {
    if (a2.chainId === b2.chainId) return 0;
    return a2.chainId < b2.chainId ? -1 : 1;
  });
  const defaultConfigIdx = config2.findIndex((c2) => c2.isDefaultChain);
  if (defaultConfigIdx > 0) config2.splice(0, 0, config2.splice(defaultConfigIdx, 1)[0]);
  return config2;
};
const stringTemplate$1 = (sTemplate, mData) => {
  if (typeof sTemplate === "string") {
    mData = mData ? mData : {};
    return sTemplate.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(fullMath, grp) {
      let val = mData[grp];
      if (typeof val === "function") {
        val = val();
      } else if (val === null || val === void 0) {
        val = "";
      } else if (typeof val === "object" || typeof val === "symbol") {
        val = val.toString();
      } else {
        val = val.valueOf();
      }
      return val;
    });
  }
  return "";
};
const indexerURL$1 = (network2) => stringTemplate$1("https://${network}-indexer.sequence.app", {
  network: network2
});
const relayerURL$1 = (network2) => stringTemplate$1("https://${network}-relayer.sequence.app", {
  network: network2
});
const nodesURL$1 = (network2) => stringTemplate$1("https://nodes.sequence.app/${network}", {
  network: network2
});
function findSupportedNetwork(chainIdOrName) {
  return findNetworkConfig(allNetworks$1, chainIdOrName);
}
function toChainIdNumber(chainIdLike) {
  if (typeof chainIdLike === "bigint") {
    return chainIdLike;
  }
  if (isBigNumberish(chainIdLike)) {
    return BigInt(chainIdLike);
  }
  return BigInt(chainIdLike.chainId);
}
const createNetworkConfig$1 = (chainId, options) => {
  const network2 = networks$1[chainId];
  if (!network2) {
    throw new Error(`Network with chainId ${chainId} not found`);
  }
  const rpcUrl = nodesURL$1(network2.name);
  return _extends$f({}, network2, {
    rpcUrl,
    indexerUrl: indexerURL$1(network2.name),
    relayer: {
      url: relayerURL$1(network2.name),
      provider: {
        url: rpcUrl
      }
    }
  }, options);
};
const hardhatNetworks$1 = [_extends$f({}, networks$1[ChainId$1.HARDHAT], {
  rpcUrl: "http://localhost:8545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:8545"
    }
  }
}), _extends$f({}, networks$1[ChainId$1.HARDHAT_2], {
  rpcUrl: "http://localhost:9545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:9545"
    }
  }
})];
const allNetworks$1 = validateAndSortNetworks$1([_extends$f({}, createNetworkConfig$1(ChainId$1.POLYGON), {
  isDefaultChain: true,
  isAuthChain: true
}), createNetworkConfig$1(ChainId$1.MAINNET), createNetworkConfig$1(ChainId$1.BSC), createNetworkConfig$1(ChainId$1.AVALANCHE), createNetworkConfig$1(ChainId$1.ARBITRUM), createNetworkConfig$1(ChainId$1.ARBITRUM_NOVA), createNetworkConfig$1(ChainId$1.OPTIMISM), createNetworkConfig$1(ChainId$1.OPTIMISM_SEPOLIA), createNetworkConfig$1(ChainId$1.POLYGON_ZKEVM), createNetworkConfig$1(ChainId$1.GNOSIS), createNetworkConfig$1(ChainId$1.RINKEBY, {
  disabled: true
}), createNetworkConfig$1(ChainId$1.GOERLI, {
  disabled: true
}), createNetworkConfig$1(ChainId$1.SEPOLIA), createNetworkConfig$1(ChainId$1.POLYGON_MUMBAI, {
  disabled: true
}), createNetworkConfig$1(ChainId$1.POLYGON_AMOY), createNetworkConfig$1(ChainId$1.BSC_TESTNET), createNetworkConfig$1(ChainId$1.ARBITRUM_SEPOLIA), createNetworkConfig$1(ChainId$1.BASE), createNetworkConfig$1(ChainId$1.BASE_SEPOLIA), createNetworkConfig$1(ChainId$1.HOMEVERSE), createNetworkConfig$1(ChainId$1.HOMEVERSE_TESTNET), createNetworkConfig$1(ChainId$1.XAI), createNetworkConfig$1(ChainId$1.XAI_SEPOLIA), createNetworkConfig$1(ChainId$1.AVALANCHE_TESTNET), createNetworkConfig$1(ChainId$1.XR_SEPOLIA), createNetworkConfig$1(ChainId$1.B3), createNetworkConfig$1(ChainId$1.B3_SEPOLIA), createNetworkConfig$1(ChainId$1.APECHAIN), createNetworkConfig$1(ChainId$1.APECHAIN_TESTNET), createNetworkConfig$1(ChainId$1.BLAST), createNetworkConfig$1(ChainId$1.BLAST_SEPOLIA), createNetworkConfig$1(ChainId$1.TELOS), createNetworkConfig$1(ChainId$1.BORNE_TESTNET), createNetworkConfig$1(ChainId$1.SKALE_NEBULA_TESTNET), createNetworkConfig$1(ChainId$1.SONEIUM_MINATO), createNetworkConfig$1(ChainId$1.TOY_TESTNET), createNetworkConfig$1(ChainId$1.IMMUTABLE_ZKEVM), createNetworkConfig$1(ChainId$1.IMMUTABLE_ZKEVM_TESTNET), ...hardhatNetworks$1]);
class JsonRpcRouter {
  constructor(middlewares, sender) {
    this.sender = void 0;
    this.handler = void 0;
    this.sender = sender;
    if (middlewares) {
      this.setMiddleware(middlewares);
    }
  }
  setMiddleware(middlewares) {
    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender);
  }
  request(request) {
    return this.handler.request(request);
  }
}
const createJsonRpcMiddlewareStack = (middlewares, handler) => {
  if (middlewares.length === 0) return handler;
  const toMiddleware = (v3) => {
    if (v3.requestHandler) {
      return v3.requestHandler;
    } else {
      return v3;
    }
  };
  let chain;
  chain = toMiddleware(middlewares[middlewares.length - 1])(handler.request);
  for (let i = middlewares.length - 2; i >= 0; i--) {
    chain = toMiddleware(middlewares[i])(chain);
  }
  return {
    request: chain
  };
};
function isJsonRpcProvider$1(cand) {
  return cand !== void 0 && cand.send !== void 0 && cand.constructor.defaultUrl !== void 0 && cand.detectNetwork !== void 0 && cand.getSigner !== void 0 && cand.perform !== void 0;
}
function isJsonRpcSender(cand) {
  return cand !== void 0 && cand.send !== void 0;
}
class JsonRpcHandler {
  constructor(provider2, defaultChainId) {
    this.provider = void 0;
    this.defaultChainId = void 0;
    this.request = (request) => {
      if (!request.chainId) {
        request.chainId = this.defaultChainId;
      }
      return this.provider(request);
    };
    if (isJsonRpcSender(provider2)) {
      this.provider = (request) => {
        return provider2.send(request.method, request.params, request.chainId);
      };
    } else if (isJsonRpcProvider$1(provider2)) {
      this.provider = (request) => {
        return provider2.send(request.method, request.params || []);
      };
    } else {
      this.provider = provider2;
    }
    this.defaultChainId = defaultChainId;
  }
  send(method, params, chainId) {
    const request = {
      method,
      params,
      chainId
    };
    return this.request(request);
  }
}
class AllowProvider {
  constructor(isAllowedFunc) {
    this.requestHandler = void 0;
    this.isAllowedFunc = void 0;
    if (isAllowedFunc) {
      this.isAllowedFunc = isAllowedFunc;
    } else {
      this.isAllowedFunc = (request) => true;
    }
    this.requestHandler = allowProviderMiddleware(this.isAllowedFunc);
  }
  setIsAllowedFunc(fn) {
    this.isAllowedFunc = fn;
    this.requestHandler = allowProviderMiddleware(this.isAllowedFunc);
  }
}
const allowProviderMiddleware = (isAllowed) => (next) => {
  return (request) => {
    if (!isAllowed(request)) {
      throw new Error("allowProvider middleware precondition is unmet.");
    }
    return next(request);
  };
};
class CachedProvider {
  constructor(options) {
    var _this = this;
    this.cachableJsonRpcMethods = ["net_version", "eth_chainId", "eth_accounts", "sequence_getWalletContext", "sequence_getNetworks"];
    this.cachableJsonRpcMethodsByBlock = ["eth_call", "eth_getCode"];
    this.cache = void 0;
    this.cacheByBlock = void 0;
    this.cacheByBlockResetLock = false;
    this.onUpdateCallback = void 0;
    this.defaultChainId = void 0;
    this.requestHandler = (next) => {
      return async function(request) {
        if (_this.cachableJsonRpcMethods.includes(request.method) || _this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
          const key = _this.cacheKey(request.method, request.params, request.chainId || _this.defaultChainId);
          const _result = _this.getCacheValue(key);
          if (_result && _result !== "") {
            return {
              id: request.id,
              result: _result
            };
          }
        }
        const result = await next(request);
        if (_this.cachableJsonRpcMethods.includes(request.method) || _this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
          if (result && _this.shouldCacheResponse(request, result)) {
            const key = _this.cacheKey(request.method, request.params, request.chainId || _this.defaultChainId);
            if (_this.cachableJsonRpcMethods.includes(request.method)) {
              _this.setCacheValue(key, result);
            } else {
              _this.setCacheByBlockValue(key, result);
            }
          }
        }
        return result;
      };
    };
    this.cacheKey = (method, params, chainId) => {
      let key = "";
      if (chainId) {
        key = `${chainId}:${method}:`;
      } else {
        key = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key + "[]";
      }
      return key + JSON.stringify(params);
    };
    this.getCache = () => this.cache;
    this.setCache = (cache2) => {
      this.cache = cache2;
      if (this.onUpdateCallback) {
        this.onUpdateCallback();
      }
    };
    this.getCacheValue = (key) => {
      if (this.cache[key]) {
        return this.cache[key];
      }
      if (this.cacheByBlock[key]) {
        return this.cacheByBlock[key];
      }
      return void 0;
    };
    this.setCacheValue = (key, value) => {
      this.cache[key] = value;
      if (this.onUpdateCallback) {
        this.onUpdateCallback(key, value);
      }
    };
    this.setCacheByBlockValue = (key, value) => {
      this.cacheByBlock[key] = value;
      if (!this.cacheByBlockResetLock) {
        this.cacheByBlockResetLock = true;
        setTimeout(() => {
          this.cacheByBlockResetLock = false;
          this.cacheByBlock = {};
        }, 1500);
      }
    };
    this.shouldCacheResponse = (request, result) => {
      if (!result) {
        return false;
      }
      if (request.method === "eth_getCode" && result.length <= 2) {
        return false;
      }
      return true;
    };
    this.clearCache = () => {
      this.cache = {};
      this.cacheByBlock = {};
    };
    this.cache = {};
    this.cacheByBlock = {};
    this.defaultChainId = options == null ? void 0 : options.defaultChainId;
    if (!(options != null && options.blockCache)) {
      this.cachableJsonRpcMethodsByBlock = [];
    } else if ((options == null ? void 0 : options.blockCache) !== true) {
      this.cachableJsonRpcMethodsByBlock = options == null ? void 0 : options.blockCache;
    }
  }
  onUpdate(callback) {
    this.onUpdateCallback = callback;
  }
}
class EagerProvider {
  constructor(options) {
    var _this = this;
    this.options = void 0;
    this.requestHandler = (next) => {
      return async function(request) {
        switch (request.method) {
          case "net_version":
            if (_this.options.chainId) {
              return `${_this.options.chainId}`;
            }
            break;
          case "eth_chainId":
            if (_this.options.chainId) {
              return toQuantity(_this.options.chainId);
            }
            break;
          case "eth_accounts":
            if (_this.options.accountAddress) {
              return [getAddress(_this.options.accountAddress)];
            }
            break;
          case "sequence_getWalletContext":
            if (_this.options.walletContext) {
              return _this.options.walletContext;
            }
            break;
        }
        return next(request);
      };
    };
    this.options = options;
  }
}
const exceptionProviderMiddleware = (next) => {
  return async (request) => {
    try {
      return await next(request);
    } catch (error) {
      if (typeof error === "string") {
        throw new Error(error);
      } else {
        throw new Error(error.message);
      }
    }
  };
};
const loggingProviderMiddleware = (next) => {
  return async (request) => {
    const chainIdLabel = request.chainId ? ` chainId:${request.chainId}` : "";
    logger.info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params);
    try {
      const result = await next(request);
      logger.info(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `result:`, result);
      return result;
    } catch (error) {
      logger.warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error);
    }
  };
};
const networkProviderMiddleware = (getChainId2) => (next) => {
  return async (request) => {
    const networkChainId = getChainId2(request);
    switch (request.method) {
      case "net_version": {
        return `${networkChainId}`;
      }
      case "eth_chainId": {
        return toQuantity(networkChainId);
      }
    }
    return next(request);
  };
};
const SignerJsonRpcMethods = [
  "personal_sign",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "eth_sendRawTransaction",
  "sequence_sign",
  // sequence-aware personal_sign
  "sequence_signTypedData_v4",
  // sequence-aware eth_signTypedData_v4
  "sequence_getWalletContext",
  "sequence_getWalletConfig",
  "sequence_getWalletState",
  "sequence_getNetworks",
  "sequence_updateConfig",
  "sequence_publishConfig",
  "sequence_gasRefundOptions",
  "sequence_getNonce",
  "sequence_relay",
  "eth_decrypt",
  "eth_getEncryptionPublicKey",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
class SigningProvider {
  constructor(provider2) {
    this.provider = void 0;
    this.requestHandler = (next) => {
      return (request) => {
        if (SignerJsonRpcMethods.includes(request.method)) {
          return this.provider.request(request);
        }
        return next(request);
      };
    };
    this.provider = provider2;
  }
}
class PublicProvider {
  constructor(rpcUrl) {
    this.privateJsonRpcMethods = ["net_version", "eth_chainId", "eth_accounts", ...SignerJsonRpcMethods];
    this.provider = void 0;
    this.rpcUrl = void 0;
    this.requestHandler = (next) => {
      return (request) => {
        if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {
          return this.provider.send(request.method, request.params || []);
        }
        logger.debug("[public-provider] sending request to signer window", request.method);
        return next(request);
      };
    };
    if (rpcUrl) {
      this.setRpcUrl(rpcUrl);
    }
  }
  getRpcUrl() {
    return this.rpcUrl;
  }
  setRpcUrl(rpcUrl) {
    if (!rpcUrl || rpcUrl === "") {
      this.rpcUrl = void 0;
      this.provider = void 0;
    } else {
      this.rpcUrl = rpcUrl;
      this.provider = new JsonRpcProvider$1(rpcUrl);
    }
  }
}
class SingleflightMiddleware {
  constructor() {
    var _this = this;
    this.singleflightJsonRpcMethods = ["eth_chainId", "net_version", "eth_call", "eth_getCode", "eth_blockNumber", "eth_getBalance", "eth_getStorageAt", "eth_getTransactionCount", "eth_getBlockTransactionCountByHash", "eth_getBlockTransactionCountByNumber", "eth_getUncleCountByBlockHash", "eth_getUncleCountByBlockNumber", "eth_getBlockByHash", "eth_getBlockByNumber", "eth_getTransactionByHash", "eth_getTransactionByBlockHashAndIndex", "eth_getTransactionByBlockNumberAndIndex", "eth_getTransactionReceipt", "eth_getUncleByBlockHashAndIndex", "eth_getUncleByBlockNumberAndIndex", "eth_getLogs"];
    this.inflight = void 0;
    this.requestHandler = (next) => {
      return async function(request) {
        if (!_this.singleflightJsonRpcMethods.includes(request.method)) {
          return next(request);
        }
        const key = _this.requestKey(request.method, request.params || [], request.chainId);
        if (!_this.inflight[key]) {
          _this.inflight[key] = [];
        } else {
          return new Promise((resolve, reject) => {
            _this.inflight[key].push({
              id: request.id,
              callback: (error, response) => {
                if (error) {
                  reject(error);
                } else {
                  resolve(response);
                }
              }
            });
          });
        }
        try {
          const response = await next(request);
          _this.inflight[key].forEach(({
            callback
          }) => callback(void 0, response));
          return response;
        } catch (error) {
          _this.inflight[key].forEach(({
            callback
          }) => callback(error, void 0));
          throw error;
        } finally {
          delete _this.inflight[key];
        }
      };
    };
    this.requestKey = (method, params, chainId) => {
      let key = "";
      if (chainId) {
        key = `${chainId}:${method}:`;
      } else {
        key = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key + "[]";
      }
      return key + JSON.stringify(params);
    };
    this.inflight = {};
  }
}
function _classPrivateFieldLooseBase(e2, t2) {
  if (!{}.hasOwnProperty.call(e2, t2)) throw new TypeError("attempted to use private field on non-instance");
  return e2;
}
var id = 0;
function _classPrivateFieldLooseKey(e2) {
  return "__private_" + id++ + "_" + e2;
}
var _chainId = /* @__PURE__ */ _classPrivateFieldLooseKey("chainId");
var _nextId = /* @__PURE__ */ _classPrivateFieldLooseKey("nextId");
var _sender = /* @__PURE__ */ _classPrivateFieldLooseKey("sender");
class JsonRpcProvider extends JsonRpcProvider$1 {
  constructor(url, options, jsonRpcApiProviderOptions) {
    var _this;
    super(url, options == null ? void 0 : options.chainId, jsonRpcApiProviderOptions);
    _this = this;
    this.url = url;
    Object.defineProperty(this, _chainId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _nextId, {
      writable: true,
      value: 1
    });
    Object.defineProperty(this, _sender, {
      writable: true,
      value: void 0
    });
    this.fetch = async function(request) {
      if (_this.url === void 0) {
        throw new Error("missing provider URL");
      }
      const {
        method,
        params
      } = request;
      const jsonRpcRequest = {
        method,
        params,
        id: _classPrivateFieldLooseBase(_this, _nextId)[_nextId]++,
        jsonrpc: "2.0"
      };
      const fetchRequest = typeof _this.url === "string" ? new FetchRequest(_this.url) : _this.url;
      fetchRequest.body = JSON.stringify(jsonRpcRequest);
      try {
        const res = await fetchRequest.send();
        if (res.body) {
          try {
            const result = JSON.parse(toUtf8String(res.body));
            return getResult(result);
          } catch (err) {
            throw new Error("invalid JSON response");
          }
        }
        return null;
      } catch (err) {
        throw err;
      }
    };
    const chainId = options == null ? void 0 : options.chainId;
    const middlewares = options == null ? void 0 : options.middlewares;
    const blockCache = options == null ? void 0 : options.blockCache;
    _classPrivateFieldLooseBase(this, _chainId)[_chainId] = chainId;
    const router = new JsonRpcRouter(middlewares != null ? middlewares : [
      // loggingProviderMiddleware,
      new EagerProvider({
        chainId
      }),
      new SingleflightMiddleware(),
      new CachedProvider({
        defaultChainId: chainId,
        blockCache
      })
    ], new JsonRpcHandler(this.fetch, chainId));
    _classPrivateFieldLooseBase(this, _sender)[_sender] = router;
  }
  async request(request) {
    return _classPrivateFieldLooseBase(this, _sender)[_sender].request(request);
  }
  async send(method, params, chainId) {
    return this.request({
      method,
      params,
      chainId
    });
  }
  async getNetwork() {
    const chainId = _classPrivateFieldLooseBase(this, _chainId)[_chainId];
    if (chainId) {
      const network2 = networks$1[chainId];
      const name2 = (network2 == null ? void 0 : network2.name) || "";
      const ensAddress = network2 == null ? void 0 : network2.ensAddress;
      return Network.from({
        name: name2,
        chainId,
        ensAddress
      });
    } else {
      const chainIdHex = await this.send("eth_chainId", []);
      _classPrivateFieldLooseBase(this, _chainId)[_chainId] = Number(chainIdHex);
      return this.getNetwork();
    }
  }
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
const network$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AllowProvider,
  CachedProvider,
  ChainId: ChainId$1,
  EagerProvider,
  JsonRpcHandler,
  JsonRpcProvider,
  JsonRpcRouter,
  NetworkType: NetworkType$1,
  PublicProvider,
  SigningProvider,
  SingleflightMiddleware,
  allNetworks: allNetworks$1,
  allowProviderMiddleware,
  checkNetworkConfig,
  createJsonRpcMiddlewareStack,
  ensureUniqueNetworks,
  ensureValidNetworks: ensureValidNetworks$1,
  exceptionProviderMiddleware,
  findNetworkConfig,
  findSupportedNetwork,
  getChainId,
  hardhatNetworks: hardhatNetworks$1,
  indexerURL: indexerURL$1,
  isJsonRpcProvider: isJsonRpcProvider$1,
  isJsonRpcSender,
  isNetworkConfig,
  isValidNetworkConfig: isValidNetworkConfig$1,
  loggingProviderMiddleware,
  maybeChainId,
  networkProviderMiddleware,
  networks: networks$1,
  networksIndex,
  nodesURL: nodesURL$1,
  relayerURL: relayerURL$1,
  sortNetworks: sortNetworks$1,
  stringTemplate: stringTemplate$1,
  toChainIdNumber,
  updateNetworkConfig,
  validateAndSortNetworks: validateAndSortNetworks$1
}, Symbol.toStringTag, { value: "Module" }));
function _extends$e() {
  return _extends$e = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$e.apply(null, arguments);
}
function subdigestOf(payload) {
  return solidityPackedKeccak256(["bytes", "uint256", "address", "bytes32"], ["0x1901", payload.chainId, payload.address, payload.digest]);
}
function isSignedPayload(payload) {
  return payload.digest !== void 0 && payload.chainId !== void 0 && payload.address !== void 0;
}
var signature$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  subdigestOf,
  isSignedPayload
});
const EIP1271_MAGIC_VALUE = "0x1626ba7e";
const EIP1271_ABI = [{
  inputs: [{
    internalType: "bytes32",
    type: "bytes32"
  }, {
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSignature",
  outputs: [{
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view",
  type: "function"
}];
async function isValidEIP1271Signature(address, digest, signature2, provider2) {
  const contract = new Contract(address, EIP1271_ABI, provider2);
  const result = await contract.isValidSignature(digest, signature2);
  return result === EIP1271_MAGIC_VALUE;
}
var validateEIP1271 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isValidEIP1271Signature
});
let SigType = /* @__PURE__ */ function(SigType2) {
  SigType2[SigType2["EIP712"] = 1] = "EIP712";
  SigType2[SigType2["ETH_SIGN"] = 2] = "ETH_SIGN";
  SigType2[SigType2["WALLET_BYTES32"] = 3] = "WALLET_BYTES32";
  return SigType2;
}({});
function canRecover(signature2) {
  const bytes2 = getBytes(signature2);
  const type = bytes2[bytes2.length - 1];
  return type === SigType.EIP712 || type === SigType.ETH_SIGN;
}
function recoverSigner(digest, signature2) {
  const bytes2 = getBytes(signature2);
  const digestBytes = getBytes(digest);
  const type = bytes2[bytes2.length - 1];
  const r2 = hexlify(bytes2.slice(0, 32));
  const s2 = hexlify(bytes2.slice(32, 64));
  const v3 = Number(hexlify(bytes2.slice(64, 65)));
  const splitSignature = {
    r: r2,
    s: s2,
    v: v3
  };
  if (type === SigType.EIP712) {
    return recoverAddress(digestBytes, splitSignature);
  }
  if (type === SigType.ETH_SIGN) {
    return recoverAddress(hashMessage(digestBytes), splitSignature);
  }
  throw new Error(`Unsupported signature type: ${type}`);
}
function isValidSignature$1(address, digest, signature2, provider2) {
  const bytes2 = getBytes(signature2);
  const type = bytes2[bytes2.length - 1];
  if (type === SigType.EIP712 || type === SigType.ETH_SIGN) {
    return address === recoverSigner(digest, signature2);
  }
  if (type === SigType.WALLET_BYTES32) {
    return isValidEIP1271Signature(address, hexlify(digest), bytes2.slice(0, -1), provider2);
  }
  throw new Error(`Unsupported signature type: ${type}`);
}
function tryRecoverSigner(digest, signature2) {
  const bytes2 = getBytes(signature2);
  if (bytes2.length !== 66) return void 0;
  try {
    return recoverSigner(digest, bytes2);
  } catch (_unused) {
  }
  return void 0;
}
var signer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SigType,
  canRecover,
  recoverSigner,
  isValidSignature: isValidSignature$1,
  tryRecoverSigner
});
let SignaturePartType$1 = /* @__PURE__ */ function(SignaturePartType2) {
  SignaturePartType2[SignaturePartType2["EOASignature"] = 0] = "EOASignature";
  SignaturePartType2[SignaturePartType2["Address"] = 1] = "Address";
  SignaturePartType2[SignaturePartType2["DynamicSignature"] = 2] = "DynamicSignature";
  return SignaturePartType2;
}({});
function isAddressMember(member) {
  return member.address !== void 0 && !isUnrecoveredSignatureMember(member);
}
function isUnrecoveredSignatureMember(member) {
  return member.signature !== void 0 && member.weight !== void 0 && member.isDynamic !== void 0;
}
function isUnrecoveredSignature$1(signature2) {
  return signature2.threshold !== void 0 && signature2.signers !== void 0;
}
function decodeSignature$1(signature2) {
  const bytes2 = getBytes(signature2);
  const threshold = bytes2[0] << 8 | bytes2[1];
  const signers = [];
  for (let i = 2; i < bytes2.length; ) {
    const type = bytes2[i++];
    const weight = bytes2[i++];
    switch (type) {
      case SignaturePartType$1.EOASignature:
        signers.push({
          unrecovered: true,
          weight,
          signature: hexlify(bytes2.slice(i, i + 66)),
          isDynamic: false
        });
        i += 66;
        break;
      case SignaturePartType$1.Address:
        signers.push({
          weight,
          address: getAddress(hexlify(bytes2.slice(i, i + 20)))
        });
        i += 20;
        break;
      case SignaturePartType$1.DynamicSignature:
        const address = getAddress(hexlify(bytes2.slice(i, i + 20)));
        i += 20;
        const size2 = bytes2[i] << 8 | bytes2[i + 1];
        i += 2;
        signers.push({
          unrecovered: true,
          weight,
          signature: hexlify(bytes2.slice(i, i + size2)),
          address,
          isDynamic: true
        });
        i += size2;
        break;
      default:
        throw new Error(`Unknown signature part type: ${type}`);
    }
  }
  return {
    version: 1,
    threshold,
    signers
  };
}
function encodeSignature$1(signature2) {
  if (isBytesLike(signature2)) {
    return hexlify(signature2);
  }
  const {
    signers,
    threshold
  } = isUnrecoveredSignature$1(signature2) ? signature2 : signature2.config;
  const encodedSigners = signers.map((s2) => {
    if (isAddressMember(s2)) {
      return solidityPacked(["uint8", "uint8", "address"], [SignaturePartType$1.Address, s2.weight, s2.address]);
    }
    if (s2.isDynamic) {
      const bytes2 = getBytes(s2.signature);
      return solidityPacked(["uint8", "uint8", "address", "uint16", "bytes"], [SignaturePartType$1.DynamicSignature, s2.weight, s2.address, bytes2.length, bytes2]);
    }
    return solidityPacked(["uint8", "uint8", "bytes"], [SignaturePartType$1.EOASignature, s2.weight, s2.signature]);
  });
  return solidityPacked(["uint16", ...new Array(encodedSigners.length).fill("bytes")], [threshold, ...encodedSigners]);
}
async function recoverSignature$1(data, payload, provider2) {
  const subdigest = subdigestOf(payload);
  const signers = await Promise.all(data.signers.map(async (s2) => {
    if (isAddressMember(s2)) {
      return s2;
    }
    if (s2.isDynamic) {
      if (!s2.address) throw new Error("Dynamic signature part must have address");
      if (!isValidSignature$1(s2.address, subdigest, s2.signature, provider2)) {
        throw new Error(`Invalid dynamic signature part ${s2.address}`);
      }
      return {
        address: s2.address,
        weight: s2.weight,
        signature: s2.signature
      };
    } else {
      const address = recoverSigner(subdigest, s2.signature);
      return {
        address,
        weight: s2.weight,
        signature: s2.signature
      };
    }
  }));
  return {
    version: 1,
    payload,
    subdigest,
    config: {
      version: 1,
      threshold: data.threshold,
      signers
    }
  };
}
function encodeSigners$1(config2, signatures, subdigests, _) {
  if (subdigests.length !== 0) {
    throw new Error("Explicit subdigests not supported on v1");
  }
  let weight = 0n;
  const parts = config2.signers.map((s2) => {
    if (!signatures.has(s2.address)) {
      return s2;
    }
    const signature2 = signatures.get(s2.address);
    const bytes2 = getBytes(signature2.signature);
    weight += BigInt(s2.weight);
    if (signature2.isDynamic || bytes2.length !== 66) {
      return _extends$e({}, s2, {
        isDynamic: true,
        signature: signature2.signature,
        address: s2.address
      });
    }
    return _extends$e({}, s2, {
      isDynamic: false,
      signature: signature2.signature
    });
  });
  const encoded = encodeSignature$1({
    version: 1,
    threshold: config2.threshold,
    signers: parts
  });
  return {
    encoded,
    weight
  };
}
const SignatureCoder$1 = {
  decode: (data) => {
    return decodeSignature$1(data);
  },
  encode: (data) => {
    return encodeSignature$1(data);
  },
  trim: async (data) => {
    return data;
  },
  supportsNoChainId: true,
  recover: (data, payload, provider2) => {
    return recoverSignature$1(data, payload, provider2);
  },
  encodeSigners: (config2, signatures, subdigests, chainId) => {
    return encodeSigners$1(config2, signatures, subdigests);
  },
  hasEnoughSigningPower: (config2, signatures) => {
    const {
      weight
    } = SignatureCoder$1.encodeSigners(config2, signatures, [], 0);
    return weight >= BigInt(config2.threshold);
  },
  chainSignatures: (_main, _suffix) => {
    throw new Error("Signature chaining not supported on v1");
  },
  hashSetImageHash: function(_imageHash) {
    throw new Error("Image hash not supported on v1");
  },
  signaturesOf(config2) {
    return config2.signers.filter((s2) => s2.signature !== void 0).map((s2) => ({
      address: s2.address,
      signature: s2.signature
    }));
  },
  signaturesOfDecoded: function(data) {
    return data.signers.map((s2) => s2.signature).filter((s2) => s2 !== void 0);
  }
};
var signature$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignaturePartType: SignaturePartType$1,
  isAddressMember,
  isUnrecoveredSignatureMember,
  isUnrecoveredSignature: isUnrecoveredSignature$1,
  decodeSignature: decodeSignature$1,
  encodeSignature: encodeSignature$1,
  recoverSignature: recoverSignature$1,
  encodeSigners: encodeSigners$1,
  SignatureCoder: SignatureCoder$1
});
const ConfigCoder$1 = {
  isWalletConfig: (config2) => {
    return config2.version === 1 && config2.threshold !== void 0 && config2.signers !== void 0;
  },
  imageHashOf: (config2) => {
    return config2.signers.reduce((imageHash2, signer2) => keccak256(AbiCoder.defaultAbiCoder().encode(["bytes32", "uint8", "address"], [imageHash2, signer2.weight, signer2.address])), solidityPacked(["uint256"], [config2.threshold]));
  },
  hasSubdigest: (_walletConfig, _subdigest) => {
    return false;
  },
  isComplete: (_config) => {
    return true;
  },
  checkpointOf: (_config) => {
    return 0n;
  },
  signersOf: (config2) => {
    return config2.signers.map((s2) => ({
      address: s2.address,
      weight: Number(s2.weight)
    }));
  },
  fromSimple: (config2) => {
    if (BigInt(config2.checkpoint) !== 0n) {
      throw new Error("v1 wallet config does not support checkpoint");
    }
    if (config2.subdigests && config2.subdigests.length > 0) {
      throw new Error("v1 wallet config does not support subdigests");
    }
    return {
      version: 1,
      threshold: config2.threshold,
      signers: config2.signers
    };
  },
  update: {
    isKindUsed: true,
    buildTransaction: (wallet, config2, context2, kind) => {
      const module2 = new Interface([...walletContracts.mainModule.abi, ...walletContracts.mainModuleUpgradable.abi]);
      const transactions2 = [];
      if (!kind || kind === "first") {
        transactions2.push({
          to: wallet,
          data: module2.encodeFunctionData(module2.getFunction("updateImplementation"), [context2.mainModuleUpgradable]),
          gasLimit: 0,
          delegateCall: false,
          revertOnError: true,
          value: 0
        });
      }
      transactions2.push({
        to: wallet,
        data: module2.encodeFunctionData(module2.getFunction("updateImageHash"), [ConfigCoder$1.imageHashOf(config2)]),
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true,
        value: 0
      });
      return {
        entrypoint: wallet,
        transactions: transactions2
      };
    },
    decodeTransaction: function(tx) {
      throw new Error("Function not implemented.");
    }
  },
  toJSON: function(config2) {
    const plainMembers = config2.signers.map((signer2) => {
      return {
        weight: BigInt(signer2.weight).toString(),
        address: signer2.address
      };
    });
    return JSON.stringify({
      version: config2.version,
      threshold: BigInt(config2.threshold).toString(),
      signers: plainMembers
    });
  },
  fromJSON: function(json) {
    const parsed = JSON.parse(json);
    const signers = parsed.signers.map((signer2) => {
      return {
        weight: BigInt(signer2.weight),
        address: signer2.address
      };
    });
    return {
      version: parsed.version,
      threshold: BigInt(parsed.threshold),
      signers
    };
  },
  editConfig: function(config2, action) {
    var _action$threshold;
    const newSigners = config2.signers.slice();
    if (action.checkpoint && BigInt(action.checkpoint) !== 0n) {
      throw new Error("v1 wallet config does not support checkpoint");
    }
    if (action.add) {
      for (const signer2 of action.add) {
        if (newSigners.find((s2) => s2.address === signer2.address)) {
          continue;
        }
        newSigners.push({
          weight: signer2.weight,
          address: signer2.address
        });
      }
    }
    if (action.remove) {
      for (const address of action.remove) {
        const index2 = newSigners.findIndex((signer2) => signer2.address === address);
        if (index2 >= 0) {
          newSigners.splice(index2, 1);
        }
      }
    }
    return {
      version: config2.version,
      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config2.threshold,
      signers: newSigners
    };
  },
  buildStubSignature: function(config2, overrides) {
    const parts = /* @__PURE__ */ new Map();
    for (const [signer2, signature2] of overrides.entries()) {
      parts.set(signer2, {
        signature: signature2,
        isDynamic: true
      });
      const {
        encoded,
        weight
      } = encodeSigners$1(config2, parts, []);
      if (weight >= BigInt(config2.threshold)) {
        return encoded;
      }
    }
    const signers = config2.signers;
    for (const {
      address
    } of signers.sort(({
      weight: a2
    }, {
      weight: b2
    }) => Number(a2) - Number(b2))) {
      const signature2 = "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02";
      parts.set(address, {
        signature: signature2,
        isDynamic: false
      });
      const {
        encoded,
        weight
      } = encodeSigners$1(config2, parts, []);
      if (weight >= BigInt(config2.threshold)) {
        return encoded;
      }
    }
    return encodeSigners$1(config2, parts, []).encoded;
  }
};
var config$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ConfigCoder: ConfigCoder$1
});
var context$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const version$1$1 = 1;
const DeployedWalletContext$1 = {
  version: version$1$1,
  factory: "0xf9D09D634Fb818b05149329C1dcCFAeA53639d96",
  guestModule: "0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7",
  mainModule: "0xd01F11855bCcb95f88D7A48492F66410d4637313",
  mainModuleUpgradable: "0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var v1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: config$2,
  context: context$2,
  signature: signature$1,
  version: version$1$1,
  DeployedWalletContext: DeployedWalletContext$1
});
const SetImageHashPrefix = "0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1";
function hashSetImageHash(imageHash2) {
  return keccak256(messageSetImageHash(imageHash2));
}
function messageSetImageHash(imageHash2) {
  return solidityPacked(["bytes32", "bytes32"], [SetImageHashPrefix, imageHash2]);
}
function decodeMessageSetImageHash(message) {
  const arr = getBytes(message);
  if (arr.length !== 64) {
    return void 0;
  }
  if (hexlify(arr.slice(0, 32)) !== SetImageHashPrefix) {
    return void 0;
  }
  return hexlify(arr.slice(32, 64));
}
function isMessageSetImageHash(message) {
  return decodeMessageSetImageHash(message) !== void 0;
}
var chained = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SetImageHashPrefix,
  hashSetImageHash,
  messageSetImageHash,
  decodeMessageSetImageHash,
  isMessageSetImageHash
});
let SignatureType$1 = /* @__PURE__ */ function(SignatureType2) {
  SignatureType2[SignatureType2["Legacy"] = 0] = "Legacy";
  SignatureType2[SignatureType2["Dynamic"] = 1] = "Dynamic";
  SignatureType2[SignatureType2["NoChainIdDynamic"] = 2] = "NoChainIdDynamic";
  SignatureType2[SignatureType2["Chained"] = 3] = "Chained";
  return SignatureType2;
}({});
let SignaturePartType = /* @__PURE__ */ function(SignaturePartType2) {
  SignaturePartType2[SignaturePartType2["Signature"] = 0] = "Signature";
  SignaturePartType2[SignaturePartType2["Address"] = 1] = "Address";
  SignaturePartType2[SignaturePartType2["DynamicSignature"] = 2] = "DynamicSignature";
  SignaturePartType2[SignaturePartType2["Node"] = 3] = "Node";
  SignaturePartType2[SignaturePartType2["Branch"] = 4] = "Branch";
  SignaturePartType2[SignaturePartType2["Subdigest"] = 5] = "Subdigest";
  SignaturePartType2[SignaturePartType2["Nested"] = 6] = "Nested";
  return SignaturePartType2;
}({});
const SignaturePartTypeLength = 66;
function isUnrecoveredNode(node) {
  return node.left !== void 0 && node.right !== void 0;
}
function isUnrecoveredNestedLeaf(leaf) {
  return leaf.tree !== void 0;
}
function isUnrecoveredSignatureLeaf(leaf) {
  return leaf.unrecovered && leaf.signature !== void 0 && leaf.isDynamic !== void 0;
}
function decodeSignatureTree(body) {
  let arr = getBytes(body);
  let pointer;
  const append = (prevPointer, node) => {
    if (!prevPointer) {
      return {
        left: node
      };
    }
    if (!prevPointer.right) {
      return {
        left: prevPointer.left,
        right: node
      };
    }
    return {
      left: prevPointer,
      right: node
    };
  };
  while (arr.length > 0) {
    const type = arr[0];
    arr = arr.slice(1);
    switch (type) {
      case SignaturePartType.Signature:
        {
          const weight = arr[0];
          const signature2 = hexlify(arr.slice(1, SignaturePartTypeLength + 1));
          pointer = append(pointer, {
            signature: signature2,
            weight,
            unrecovered: true,
            isDynamic: false
          });
          arr = arr.slice(SignaturePartTypeLength + 1);
        }
        break;
      case SignaturePartType.Address:
        {
          const weight = arr[0];
          const address = getAddress(hexlify(arr.slice(1, 21)));
          pointer = append(pointer, {
            address,
            weight
          });
          arr = arr.slice(21);
        }
        break;
      case SignaturePartType.DynamicSignature:
        {
          const weight = arr[0];
          const address = getAddress(hexlify(arr.slice(1, 21)));
          const size2 = arr[21] << 16 | arr[22] << 8 | arr[23];
          const signature2 = hexlify(arr.slice(24, 24 + size2));
          pointer = append(pointer, {
            address,
            signature: signature2,
            weight,
            unrecovered: true,
            isDynamic: true
          });
          arr = arr.slice(24 + size2);
        }
        break;
      case SignaturePartType.Node:
        {
          const nodeHash = hexlify(arr.slice(0, 32));
          pointer = append(pointer, {
            nodeHash
          });
          arr = arr.slice(32);
        }
        break;
      case SignaturePartType.Branch:
        {
          const size2 = arr[0] << 16 | arr[1] << 8 | arr[2];
          const branch = decodeSignatureTree(arr.slice(3, 3 + size2));
          pointer = append(pointer, branch);
          arr = arr.slice(3 + size2);
        }
        break;
      case SignaturePartType.Subdigest:
        {
          const subdigest = hexlify(arr.slice(0, 32));
          pointer = append(pointer, {
            subdigest
          });
          arr = arr.slice(32);
        }
        break;
      case SignaturePartType.Nested:
        {
          const weight = arr[0];
          const threshold = arr[1] << 8 | arr[2];
          const size2 = arr[3] << 16 | arr[4] << 8 | arr[5];
          const tree = decodeSignatureTree(arr.slice(6, 6 + size2));
          pointer = append(pointer, {
            weight,
            threshold,
            tree
          });
          arr = arr.slice(6 + size2);
        }
        break;
      default:
        throw new Error(`Unknown signature part type: ${type}: ${hexlify(arr)}`);
    }
  }
  if (!pointer) {
    throw new Error("Empty signature tree");
  }
  if (pointer.right) {
    return pointer;
  }
  return pointer.left;
}
class InvalidSignatureLeafError extends Error {
  constructor(leaf) {
    super(`Invalid signature leaf: ${JSON.stringify(leaf)}`);
    this.leaf = leaf;
  }
}
async function recoverTopology(unrecovered, subdigest, provider2) {
  if (isUnrecoveredNode(unrecovered)) {
    const [left, right] = await Promise.all([recoverTopology(unrecovered.left, subdigest, provider2), recoverTopology(unrecovered.right, subdigest, provider2)]);
    return {
      left,
      right
    };
  }
  if (isUnrecoveredNestedLeaf(unrecovered)) {
    return {
      weight: unrecovered.weight,
      threshold: unrecovered.threshold,
      tree: await recoverTopology(unrecovered.tree, subdigest, provider2)
    };
  }
  if (isUnrecoveredSignatureLeaf(unrecovered)) {
    if (unrecovered.isDynamic) {
      if (!unrecovered.address) {
        throw new Error("Dynamic signature leaf without address");
      }
      const isValid2 = await isValidSignature$1(unrecovered.address, subdigest, unrecovered.signature, provider2);
      if (!isValid2) {
        throw new InvalidSignatureLeafError(unrecovered);
      }
      return {
        weight: unrecovered.weight,
        address: unrecovered.address,
        signature: unrecovered.signature,
        subdigest
      };
    } else {
      return {
        weight: unrecovered.weight,
        address: recoverSigner(subdigest, unrecovered.signature),
        signature: unrecovered.signature,
        subdigest
      };
    }
  }
  return unrecovered;
}
const partEncoder = {
  concat: (a2, b2) => {
    return solidityPacked(["bytes", "bytes"], [a2, b2]);
  },
  node: (nodeHash) => {
    return solidityPacked(["uint8", "bytes32"], [SignaturePartType.Node, nodeHash]);
  },
  branch: (tree) => {
    const arr = getBytes(tree);
    return solidityPacked(["uint8", "uint24", "bytes"], [SignaturePartType.Branch, arr.length, arr]);
  },
  nested: (weight, threshold, tree) => {
    const arr = getBytes(tree);
    return solidityPacked(["uint8", "uint8", "uint16", "uint24", "bytes"], [SignaturePartType.Nested, weight, threshold, arr.length, arr]);
  },
  subdigest: (subdigest) => {
    return solidityPacked(["uint8", "bytes32"], [SignaturePartType.Subdigest, subdigest]);
  },
  signature: (weight, signature2) => {
    return solidityPacked(["uint8", "uint8", "bytes"], [SignaturePartType.Signature, weight, signature2]);
  },
  dynamicSignature: (weight, address, signature2) => {
    const arrSignature = getBytes(signature2);
    return solidityPacked(["uint8", "uint8", "address", "uint24", "bytes"], [SignaturePartType.DynamicSignature, weight, address, arrSignature.length, arrSignature]);
  },
  address: (weight, address) => {
    return solidityPacked(["uint8", "uint8", "address"], [SignaturePartType.Address, weight, address]);
  }
};
function encodeSigners(config2, parts, subdigests, chainId, options = {}) {
  const tree = encodeTree(config2.tree, parts, subdigests, options);
  if (BigInt(chainId) === 0n) {
    return {
      encoded: solidityPacked(["uint8", "uint16", "uint32", "bytes"], [SignatureType$1.NoChainIdDynamic, config2.threshold, config2.checkpoint, tree.encoded]),
      weight: tree.weight
    };
  }
  if (BigInt(config2.threshold) > 255n) {
    return {
      encoded: solidityPacked(["uint8", "uint16", "uint32", "bytes"], [SignatureType$1.Dynamic, config2.threshold, config2.checkpoint, tree.encoded]),
      weight: tree.weight
    };
  }
  return {
    encoded: solidityPacked(["uint8", "uint8", "uint32", "bytes"], [SignatureType$1.Legacy, config2.threshold, config2.checkpoint, tree.encoded]),
    weight: tree.weight
  };
}
function encodeTree(topology, parts, subdigests, options = {}) {
  const trim2 = !options.disableTrim;
  if (isNode$1(topology)) {
    const left = encodeTree(topology.left, parts, subdigests);
    const right = encodeTree(topology.right, parts, subdigests);
    const isLeftSigner = isSignerLeaf(topology.left);
    const isRightSigner = isSignerLeaf(topology.right);
    if (trim2 && left.weight === 0n && right.weight === 0n && !isLeftSigner && !isRightSigner) {
      return {
        // We don't need to include anything for this node
        // just the hash will be enough
        encoded: partEncoder.node(hashNode(topology)),
        weight: 0n
      };
    }
    if (trim2 && right.weight === 0n && !isRightSigner) {
      return {
        // The right node doesn't have any weight
        // but we still need to include the left node encoded
        encoded: partEncoder.concat(left.encoded, partEncoder.node(hashNode(topology.right))),
        weight: left.weight
      };
    }
    if (trim2 && left.weight === 0n && !isLeftSigner) {
      return {
        // The left node doesn't have any weight
        // we can just append its hash, but for the right node
        // we need to create a new "branch"
        encoded: partEncoder.concat(partEncoder.node(hashNode(topology.left)), partEncoder.branch(right.encoded)),
        weight: right.weight
      };
    }
    return {
      // Both nodes have weight, we need to include both
      // the right one must be a branch
      encoded: partEncoder.concat(left.encoded, partEncoder.branch(right.encoded)),
      weight: left.weight + right.weight
    };
  }
  if (isNestedLeaf(topology)) {
    const tree = encodeTree(topology.tree, parts, subdigests);
    if (trim2 && tree.weight === 0n) {
      return {
        encoded: partEncoder.node(hashNode(topology)),
        weight: 0n
      };
    }
    return {
      encoded: partEncoder.nested(topology.weight, topology.threshold, tree.encoded),
      weight: tree.weight
    };
  }
  if (isNodeLeaf(topology)) {
    return {
      encoded: partEncoder.node(hashNode(topology)),
      weight: 0n
    };
  }
  if (isSubdigestLeaf(topology)) {
    const include = subdigests.includes(topology.subdigest);
    return {
      encoded: partEncoder.subdigest(topology.subdigest),
      weight: include ? MAX_UINT_256 : 0n
    };
  }
  if (isSignerLeaf(topology)) {
    const include = parts.has(topology.address);
    if (include) {
      const part = parts.get(topology.address);
      const signature2 = part.signature;
      if (options.forceDynamicEncoding || part.isDynamic) {
        return {
          encoded: partEncoder.dynamicSignature(topology.weight, topology.address, signature2),
          weight: BigInt(topology.weight)
        };
      } else {
        return {
          encoded: partEncoder.signature(topology.weight, signature2),
          weight: BigInt(topology.weight)
        };
      }
    } else {
      return {
        encoded: partEncoder.address(topology.weight, topology.address),
        weight: 0n
      };
    }
  }
  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(topology)}`);
}
function deepestConfigOfSignature(signature2) {
  return isChainedSignature(signature2) ? deepestConfigOfSignature(signature2.suffix[signature2.suffix.length - 1]) : signature2.config;
}
function isUnrecoveredSignature(sig) {
  return sig.type !== void 0 && sig.decoded !== void 0 && sig.version !== void 0 && sig.version === 2;
}
function isUnrecoveredChainedSignature(sig) {
  return sig.suffix !== void 0 && Array.isArray(sig.suffix) && sig.suffix.every(isUnrecoveredSignature);
}
function isSignature(sig) {
  return sig.type !== void 0 && sig.config !== void 0 && sig.digest !== void 0 && sig.version !== void 0 && sig.version === 2;
}
function isChainedSignature(sig) {
  return sig.chain !== void 0 && Array.isArray(sig.chain) && sig.chain.every(isSignature);
}
function decodeSignature(signature2) {
  const bytes2 = getBytes(signature2);
  const type = bytes2[0];
  switch (type) {
    case SignatureType$1.Legacy:
      return {
        version: 2,
        type: SignatureType$1.Legacy,
        decoded: decodeSignatureBody(bytes2)
      };
    case SignatureType$1.Dynamic:
      return {
        version: 2,
        type: SignatureType$1.Dynamic,
        decoded: decodeSignatureBody(bytes2.slice(1))
      };
    case SignatureType$1.NoChainIdDynamic:
      return {
        version: 2,
        type: SignatureType$1.NoChainIdDynamic,
        decoded: decodeSignatureBody(bytes2.slice(1))
      };
    case SignatureType$1.Chained:
      return decodeChainedSignature(bytes2);
    default:
      throw new Error(`Invalid signature type: ${type}`);
  }
}
function decodeSignatureBody(signature2) {
  const bytes2 = getBytes(signature2);
  const threshold = bytes2[0] << 8 | bytes2[1];
  const checkpoint = bytes2[2] << 24 | bytes2[3] << 16 | bytes2[4] << 8 | bytes2[5];
  const tree = decodeSignatureTree(bytes2.slice(6));
  return {
    threshold,
    checkpoint,
    tree
  };
}
function decodeChainedSignature(signature2) {
  const arr = getBytes(signature2);
  const type = arr[0];
  if (type !== SignatureType$1.Chained) {
    throw new Error(`Expected chained signature type: ${type}`);
  }
  const chain = [];
  let index2 = 1;
  while (index2 < arr.length) {
    const size2 = arr[index2] << 16 | arr[index2 + 1] << 8 | arr[index2 + 2];
    index2 += 3;
    const sig = decodeSignature(arr.slice(index2, index2 + size2));
    chain.push(sig);
    index2 += size2;
  }
  const main2 = chain[0];
  if (isUnrecoveredChainedSignature(main2)) {
    throw new Error(`Expected first link of chained signature to be a simple signature (not chained)`);
  }
  const suffix = chain.slice(1);
  return _extends$e({}, main2, {
    suffix
  });
}
function setImageHashStruct(imageHash2) {
  return solidityPacked(["bytes32", "bytes32"], [solidityPackedKeccak256(["string"], ["SetImageHash(bytes32 imageHash)"]), imageHash2]);
}
async function recoverSignature(signature2, payload, provider2) {
  const signedPayload = payload.subdigest === void 0 ? payload : void 0;
  const isNoChainId = signature2.type === SignatureType$1.NoChainIdDynamic;
  if (isNoChainId && signedPayload) {
    signedPayload.chainId = 0;
  }
  const subdigest = signedPayload ? subdigestOf(signedPayload) : payload.subdigest;
  if (!isUnrecoveredChainedSignature(signature2)) {
    const tree = await recoverTopology(signature2.decoded.tree, subdigest, provider2);
    return {
      version: 2,
      type: signature2.type,
      subdigest,
      config: _extends$e({
        version: 2
      }, signature2.decoded, {
        tree
      })
    };
  }
  if (!isSignedPayload(signedPayload)) {
    throw new Error(`Chained signature recovery requires detailed signed payload, subdigest is not enough`);
  }
  const result = [];
  let mutatedPayload = signedPayload;
  for (const sig of [_extends$e({}, signature2, {
    suffix: void 0
  }), ...signature2.suffix]) {
    const recovered = await recoverSignature(sig, mutatedPayload, provider2);
    result.unshift(recovered);
    const nextMessage = setImageHashStruct(imageHash(deepestConfigOfSignature(recovered)));
    mutatedPayload = _extends$e({}, mutatedPayload, {
      message: nextMessage,
      digest: keccak256(nextMessage)
    });
  }
  const main2 = result[0];
  const suffix = result.slice(1);
  return _extends$e({}, main2, {
    suffix
  });
}
function encodeChain(main2, suffix) {
  const allSignatures = [main2, ...suffix || []];
  const encodedMap = allSignatures.map((s2) => getBytes(encodeSignature(s2)));
  const body = solidityPacked(encodedMap.map(() => ["uint24", "bytes"]).flat(), encodedMap.map((s2) => [s2.length, s2]).flat());
  return solidityPacked(["uint8", "bytes"], [SignatureType$1.Chained, body]);
}
function encodeSignature(decoded) {
  if (isBytesLike(decoded)) return hexlify(decoded);
  if (isUnrecoveredChainedSignature(decoded) || isChainedSignature(decoded)) {
    return encodeChain(encodeSignature(decoded), (decoded.suffix || []).map(encodeSignature));
  }
  const body = isUnrecoveredSignature(decoded) ? decoded.decoded : decoded.config;
  switch (decoded.type) {
    case SignatureType$1.Legacy:
      if (BigInt(body.threshold) > 255n) {
        throw new Error(`Legacy signature threshold is too large: ${body.threshold} (max 255)`);
      }
      return encodeSignatureBody(body);
    case SignatureType$1.NoChainIdDynamic:
    case SignatureType$1.Dynamic:
      return solidityPacked(["uint8", "bytes"], [decoded.type, encodeSignatureBody(body)]);
    case SignatureType$1.Chained:
      throw new Error(`Unreachable code: Chained signature should be handled above`);
    default:
      throw new Error(`Invalid signature type: ${decoded.type}`);
  }
}
function encodeSignatureBody(decoded) {
  return solidityPacked(["uint16", "uint32", "bytes"], [decoded.threshold, decoded.checkpoint, encodeSignatureTree(decoded.tree)]);
}
function encodeSignatureTree(tree) {
  if (isNode$1(tree) || isUnrecoveredNode(tree)) {
    const encodedRight = getBytes(encodeSignatureTree(tree.right));
    const encodedLeft = getBytes(encodeSignatureTree(tree.left));
    const isBranching = isNode$1(tree.right) || isUnrecoveredNode(tree.right);
    if (isBranching) {
      return solidityPacked(["bytes", "uint8", "uint24", "bytes"], [encodedLeft, SignaturePartType.Branch, encodedRight.length, encodedRight]);
    } else {
      return solidityPacked(["bytes", "bytes"], [encodedLeft, encodedRight]);
    }
  }
  if (isNestedLeaf(tree) || isUnrecoveredNestedLeaf(tree)) {
    const nested = getBytes(encodeSignatureTree(tree.tree));
    return solidityPacked(["uint8", "uint8", "uint16", "uint24", "bytes"], [SignaturePartType.Nested, tree.weight, tree.threshold, nested.length, nested]);
  }
  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== void 0) {
    const signature2 = getBytes(tree.signature);
    if (tree.isDynamic || signature2.length !== SignaturePartTypeLength) {
      if (!tree.address) throw new Error(`Dynamic signature leaf must have address`);
      return solidityPacked(["uint8", "uint8", "address", "uint24", "bytes"], [SignaturePartType.DynamicSignature, tree.weight, tree.address, signature2.length, signature2]);
    } else {
      return solidityPacked(["uint8", "uint8", "bytes"], [SignaturePartType.Signature, tree.weight, signature2]);
    }
  }
  if (isSignerLeaf(tree)) {
    return solidityPacked(["uint8", "uint8", "address"], [SignaturePartType.Address, tree.weight, tree.address]);
  }
  if (isNodeLeaf(tree)) {
    return solidityPacked(["uint8", "bytes32"], [SignaturePartType.Node, tree.nodeHash]);
  }
  if (isSubdigestLeaf(tree)) {
    return solidityPacked(["uint8", "bytes32"], [SignaturePartType.Subdigest, tree.subdigest]);
  }
  throw new Error(`Unknown signature tree type: ${tree}`);
}
function signaturesOf(topology) {
  if (isNode$1(topology)) {
    return [...signaturesOf(topology.left), ...signaturesOf(topology.right)];
  }
  if (isNestedLeaf(topology)) {
    return signaturesOf(topology.tree);
  }
  if (isSignerLeaf(topology) && topology.signature) {
    return [{
      address: topology.address,
      signature: topology.signature
    }];
  }
  return [];
}
function signaturesOfDecoded(utopology) {
  if (isUnrecoveredNode(utopology)) {
    return [...signaturesOfDecoded(utopology.left), ...signaturesOfDecoded(utopology.right)];
  }
  if (isUnrecoveredNestedLeaf(utopology)) {
    return signaturesOfDecoded(utopology.tree);
  }
  if (isUnrecoveredSignatureLeaf(utopology)) {
    return [utopology.signature];
  }
  return [];
}
function subdigestsOfDecoded(utopology) {
  if (isUnrecoveredNode(utopology)) {
    return [...subdigestsOfDecoded(utopology.left), ...subdigestsOfDecoded(utopology.right)];
  }
  if (isUnrecoveredNestedLeaf(utopology)) {
    return subdigestsOfDecoded(utopology.tree);
  }
  if (isSubdigestLeaf(utopology)) {
    return [utopology.subdigest];
  }
  return [];
}
async function trimSignature(signature2) {
  const decoded = typeof signature2 === "string" ? decodeSignature(signature2) : signature2;
  if (isUnrecoveredChainedSignature(decoded)) {
    const _trimmed = await Promise.all([trimSignature(_extends$e({}, decoded, {
      suffix: void 0
    })), ...decoded.suffix.map((s2) => trimSignature(s2))]);
    return encodeChain(_trimmed[0], _trimmed.slice(1));
  }
  const {
    trimmed
  } = await trimUnrecoveredTree(decoded.decoded.tree);
  return encodeSignature(_extends$e({}, decoded, {
    decoded: _extends$e({}, decoded.decoded, {
      tree: trimmed
    })
  }));
}
async function trimUnrecoveredTree(tree, trimStaticDigest = true) {
  if (isUnrecoveredNode(tree)) {
    const [left, right] = await Promise.all([trimUnrecoveredTree(tree.left), trimUnrecoveredTree(tree.right)]);
    if (left.weight === 0 && right.weight === 0) {
      try {
        const recovered = await recoverTopology(tree, ZeroHash, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: hashNode(recovered)
          }
        };
      } catch (_unused) {
      }
    } else {
      return {
        weight: left.weight + right.weight,
        trimmed: {
          left: left.trimmed,
          right: right.trimmed
        }
      };
    }
  }
  if (isUnrecoveredNestedLeaf(tree)) {
    const trimmed = await trimUnrecoveredTree(tree.tree);
    if (trimmed.weight === 0) {
      try {
        const recovered = await recoverTopology(tree, ZeroHash, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: hashNode(recovered)
          }
        };
      } catch (_unused2) {
      }
    }
    return {
      weight: trimmed.weight,
      trimmed: {
        weight: tree.weight,
        threshold: tree.threshold,
        tree: trimmed.trimmed
      }
    };
  }
  if (isNodeLeaf(tree) && isEncodedSignerLeaf(tree.nodeHash)) {
    return {
      weight: 0,
      trimmed: _extends$e({}, decodeSignerLeaf(tree.nodeHash))
    };
  }
  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== void 0) {
    return {
      weight: Number(tree.weight),
      trimmed: tree
    };
  }
  if (!trimStaticDigest && isSubdigestLeaf(tree)) {
    return {
      weight: Infinity,
      trimmed: tree
    };
  }
  return {
    weight: 0,
    trimmed: tree
  };
}
const SignatureCoder = {
  decode: (data) => {
    return decodeSignature(data);
  },
  encode: (data) => {
    return encodeSignature(data);
  },
  trim: (data) => {
    return trimSignature(data);
  },
  supportsNoChainId: true,
  recover: (data, payload, provider2) => {
    return recoverSignature(data, payload, provider2);
  },
  encodeSigners: (config2, signatures, subdigests, chainId) => {
    return encodeSigners(config2, signatures, subdigests, chainId);
  },
  hasEnoughSigningPower: (config2, signatures) => {
    const {
      weight
    } = SignatureCoder.encodeSigners(config2, signatures, [], 0);
    return weight >= BigInt(config2.threshold);
  },
  chainSignatures: (main2, suffix) => {
    const reversed = suffix.reverse();
    const mraw = isBytesLike(main2) ? main2 : encodeSignature(main2);
    const sraw = reversed.map((s2) => isBytesLike(s2) ? s2 : encodeSignature(s2));
    return encodeChain(mraw, sraw);
  },
  hashSetImageHash: function(imageHash2) {
    return hashSetImageHash(imageHash2);
  },
  signaturesOf(config2) {
    return signaturesOf(config2.tree);
  },
  signaturesOfDecoded: function(data) {
    return signaturesOfDecoded(data.decoded.tree);
  }
};
var signature = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignatureType: SignatureType$1,
  SignaturePartType,
  SignaturePartTypeLength,
  isUnrecoveredNode,
  isUnrecoveredNestedLeaf,
  isUnrecoveredSignatureLeaf,
  decodeSignatureTree,
  InvalidSignatureLeafError,
  recoverTopology,
  partEncoder,
  encodeSigners,
  encodeTree,
  deepestConfigOfSignature,
  isUnrecoveredSignature,
  isUnrecoveredChainedSignature,
  isSignature,
  isChainedSignature,
  decodeSignature,
  decodeSignatureBody,
  decodeChainedSignature,
  setImageHashStruct,
  recoverSignature,
  encodeChain,
  encodeSignature,
  encodeSignatureBody,
  encodeSignatureTree,
  signaturesOf,
  signaturesOfDecoded,
  subdigestsOfDecoded,
  trimSignature,
  trimUnrecoveredTree,
  SignatureCoder
});
function isSignerLeaf(leaf) {
  return leaf.address !== void 0 && leaf.weight !== void 0;
}
function isSubdigestLeaf(leaf) {
  return leaf.subdigest !== void 0 && leaf.address === void 0;
}
function topologyToJSON(tree) {
  if (isNode$1(tree)) {
    return JSON.stringify({
      left: topologyToJSON(tree.left),
      right: topologyToJSON(tree.right)
    });
  }
  if (isNestedLeaf(tree)) {
    return JSON.stringify({
      weight: BigInt(tree.weight).toString(),
      threshold: BigInt(tree.threshold).toString(),
      tree: topologyToJSON(tree.tree)
    });
  }
  if (isSignerLeaf(tree)) {
    return JSON.stringify({
      address: tree.address,
      weight: BigInt(tree.weight).toString()
    });
  }
  return JSON.stringify(tree);
}
function topologyFromJSON(json) {
  const parsed = typeof json === "string" ? JSON.parse(json) : json;
  if (parsed.left !== void 0 && parsed.right !== void 0) {
    return {
      left: topologyFromJSON(parsed.left),
      right: topologyFromJSON(parsed.right)
    };
  }
  if (parsed.weight !== void 0 && parsed.threshold !== void 0 && parsed.tree !== void 0) {
    return {
      weight: BigInt(parsed.weight),
      threshold: BigInt(parsed.threshold),
      tree: topologyFromJSON(parsed.tree)
    };
  }
  if (parsed.address !== void 0 && parsed.weight !== void 0) {
    return {
      address: parsed.address,
      weight: BigInt(parsed.weight)
    };
  }
  return parsed;
}
function isNestedLeaf(leaf) {
  return leaf.tree !== void 0 && leaf.weight !== void 0 && leaf.threshold !== void 0;
}
function isNodeLeaf(leaf) {
  return leaf.nodeHash !== void 0;
}
function isLeaf$1(leaf) {
  return isSignerLeaf(leaf) || isSubdigestLeaf(leaf) || isNestedLeaf(leaf) || isNodeLeaf(leaf);
}
function isNode$1(node) {
  return node.left !== void 0 && node.right !== void 0;
}
function isTopology(topology) {
  return isNode$1(topology) || isLeaf$1(topology);
}
function encodeSignerLeaf(leaf) {
  return solidityPacked(["uint96", "address"], [leaf.weight, leaf.address]);
}
function decodeSignerLeaf(encoded) {
  const bytes2 = getBytes(encoded);
  if (bytes2.length !== 32) {
    throw new Error("Invalid encoded string length");
  }
  const weight = BigInt(hexlify(bytes2.slice(0, 12)));
  const address = getAddress(hexlify(bytes2.slice(12)));
  return {
    weight,
    address
  };
}
function isEncodedSignerLeaf(encoded) {
  const bytes2 = getBytes(encoded);
  if (bytes2.length !== 32) {
    return false;
  }
  const prefix = bytes2.slice(0, 11);
  return prefix.every((byte) => byte === 0);
}
function hashNode(node) {
  if (isSignerLeaf(node)) {
    return encodeSignerLeaf(node);
  }
  if (isSubdigestLeaf(node)) {
    return solidityPackedKeccak256(["string", "bytes32"], ["Sequence static digest:\n", node.subdigest]);
  }
  if (isNestedLeaf(node)) {
    const nested = hashNode(node.tree);
    return solidityPackedKeccak256(["string", "bytes32", "uint256", "uint256"], ["Sequence nested config:\n", nested, node.threshold, node.weight]);
  }
  if (isNodeLeaf(node)) {
    return node.nodeHash;
  }
  return solidityPackedKeccak256(["bytes32", "bytes32"], [hashNode(node.left), hashNode(node.right)]);
}
function leftFace(topology) {
  const stack = [];
  let prev = topology;
  while (!isLeaf$1(prev)) {
    stack.unshift(prev.right);
    prev = prev.left;
  }
  stack.unshift(prev);
  return stack;
}
function isWalletConfig(config2) {
  return config2.threshold !== void 0 && config2.checkpoint !== void 0 && config2.tree !== void 0 && config2.version !== void 0 && config2.version === 2;
}
function imageHash(config2) {
  return solidityPackedKeccak256(["bytes32", "uint256"], [solidityPackedKeccak256(["bytes32", "uint256"], [hashNode(config2.tree), config2.threshold]), config2.checkpoint]);
}
function isSimpleNestedMember(member) {
  return member.threshold !== void 0 && member.weight !== void 0 && member.members !== void 0;
}
function topologyToMembers(tree) {
  if (isSignerLeaf(tree) || isSubdigestLeaf(tree)) {
    return [tree];
  }
  if (isNestedLeaf(tree)) {
    return [{
      threshold: tree.threshold,
      weight: tree.weight,
      members: topologyToMembers(tree.tree)
    }];
  }
  if (isNodeLeaf(tree)) {
    return [];
  }
  return [...topologyToMembers(tree.left), ...topologyToMembers(tree.right)];
}
function hasUnknownNodes(tree) {
  if (isNodeLeaf(tree)) {
    return true;
  }
  if (isNode$1(tree)) {
    return hasUnknownNodes(tree.left) || hasUnknownNodes(tree.right);
  }
  return false;
}
function toSimpleWalletConfig(config2) {
  return {
    threshold: config2.threshold,
    checkpoint: config2.checkpoint,
    members: topologyToMembers(config2.tree)
  };
}
const membersAsTopologies = (members, builder) => {
  return members.map((member) => {
    if (isSimpleNestedMember(member)) {
      return {
        tree: builder(member.members),
        threshold: member.threshold,
        weight: member.weight
      };
    }
    return member;
  });
};
function legacyTopologyBuilder(members) {
  if (members.length === 0) {
    throw new Error("Empty members array");
  }
  const asTopologies = membersAsTopologies(members, legacyTopologyBuilder);
  return asTopologies.reduce((acc, member) => {
    return {
      left: acc,
      right: member
    };
  });
}
function merkleTopologyBuilder(members) {
  if (members.length === 0) {
    throw new Error("Empty members array");
  }
  const leaves = membersAsTopologies(members, merkleTopologyBuilder);
  for (let s2 = leaves.length; s2 > 1; s2 = s2 / 2) {
    for (let i = 0; i < s2 / 2; i++) {
      const j1 = i * 2;
      const j2 = j1 + 1;
      if (j2 >= s2) {
        leaves[i] = leaves[j1];
      } else {
        leaves[i] = {
          left: leaves[j1],
          right: leaves[j2]
        };
      }
    }
  }
  return leaves[0];
}
function optimized2SignersTopologyBuilder(members) {
  if (members.length > 8) {
    return merkleTopologyBuilder(members);
  }
  return legacyTopologyBuilder(members);
}
function toWalletConfig(simpleWalletConfig, builder = optimized2SignersTopologyBuilder) {
  return {
    version: 2,
    threshold: simpleWalletConfig.threshold,
    checkpoint: simpleWalletConfig.checkpoint,
    tree: builder(simpleWalletConfig.members)
  };
}
function hasSubdigest(tree, subdigest) {
  if (isSubdigestLeaf(tree)) {
    return tree.subdigest === subdigest;
  }
  if (isNode$1(tree)) {
    return hasSubdigest(tree.left, subdigest) || hasSubdigest(tree.right, subdigest);
  }
  return false;
}
function signersOf(tree) {
  const stack = [tree];
  const signers = /* @__PURE__ */ new Set();
  while (stack.length > 0) {
    const node = stack.pop();
    if (isNestedLeaf(node)) {
      stack.push(node.tree);
    } else if (isNode$1(node)) {
      stack.push(node.left);
      stack.push(node.right);
    } else if (isSignerLeaf(node)) {
      signers.add({
        address: node.address,
        weight: Number(node.weight)
      });
    }
  }
  return Array.from(signers);
}
function isComplete(tree) {
  if (isNode$1(tree)) {
    return isComplete(tree.left) && isComplete(tree.right);
  }
  return !isNodeLeaf(tree);
}
const ConfigCoder = {
  isWalletConfig: (config2) => {
    return config2.version === 2 && config2.threshold !== void 0 && config2.tree !== void 0;
  },
  imageHashOf: (config2) => {
    return imageHash(config2);
  },
  hasSubdigest: (config2, subdigest) => {
    return hasSubdigest(config2.tree, subdigest);
  },
  checkpointOf: (config2) => {
    return BigInt(config2.checkpoint);
  },
  signersOf: (config2) => {
    return signersOf(config2.tree);
  },
  fromSimple: (config2) => {
    var _config$subdigests;
    return toWalletConfig(_extends$e({}, config2, {
      members: [...config2.signers, ...((_config$subdigests = config2.subdigests) != null ? _config$subdigests : []).map((subdigest) => ({
        subdigest
      }))]
    }));
  },
  isComplete: (config2) => {
    return isComplete(config2.tree);
  },
  // isValid = (config: WalletConfig): boolean {}
  /**
   *
   * Notice: context and kind are ignored because v2
   * doesn't need to manually update the implementation before
   * a configuration update, it's automatically done by the contract.
   *
   */
  update: {
    isKindUsed: true,
    buildTransaction: (wallet, config2, _context, _kind) => {
      const module2 = new Interface(walletContracts.mainModuleUpgradable.abi);
      return {
        entrypoint: wallet,
        transactions: [{
          to: wallet,
          data: module2.encodeFunctionData(module2.getFunction("updateImageHash"), [ConfigCoder.imageHashOf(config2)]),
          gasLimit: 0,
          delegateCall: false,
          revertOnError: true,
          value: 0
        }]
      };
    },
    decodeTransaction: function(tx) {
      var _tx$transactions$0$va, _tx$transactions$, _tx$transactions$0$ga, _tx$transactions$2;
      const module2 = new Interface(walletContracts.mainModuleUpgradable.abi);
      if (tx.transactions.length !== 1) {
        throw new Error("Invalid transaction bundle, expected 1 transaction");
      }
      const data = tx.transactions[0].data;
      if (!data) {
        throw new Error("Invalid transaction bundle, expected data");
      }
      const decoded = module2.decodeFunctionData(module2.getFunction("updateImageHash"), data);
      if (!decoded) {
        throw new Error("Invalid transaction bundle, expected valid data");
      }
      if (tx.transactions[0].to !== tx.entrypoint) {
        throw new Error("Invalid transaction bundle, expected to be sent to entrypoint");
      }
      if (tx.transactions[0].delegateCall) {
        throw new Error("Invalid transaction bundle, expected not to be a delegateCall");
      }
      if (!tx.transactions[0].revertOnError) {
        throw new Error("Invalid transaction bundle, expected revertOnError");
      }
      if (BigInt((_tx$transactions$0$va = (_tx$transactions$ = tx.transactions[0]) == null ? void 0 : _tx$transactions$.value) != null ? _tx$transactions$0$va : 0) !== 0n) {
        throw new Error("Invalid transaction bundle, expected value to be 0");
      }
      if (BigInt((_tx$transactions$0$ga = (_tx$transactions$2 = tx.transactions[0]) == null ? void 0 : _tx$transactions$2.gasLimit) != null ? _tx$transactions$0$ga : 0) !== 0n) {
        throw new Error("Invalid transaction bundle, expected value to be 0");
      }
      return {
        address: tx.entrypoint,
        newImageHash: decoded[0],
        kind: void 0
      };
    }
  },
  toJSON: function(config2) {
    return JSON.stringify({
      version: config2.version,
      threshold: BigInt(config2.threshold).toString(),
      checkpoint: BigInt(config2.checkpoint).toString(),
      tree: topologyToJSON(config2.tree)
    });
  },
  fromJSON: function(json) {
    const config2 = JSON.parse(json);
    return {
      version: config2.version,
      threshold: BigInt(config2.threshold),
      checkpoint: BigInt(config2.checkpoint),
      tree: topologyFromJSON(config2.tree)
    };
  },
  editConfig: function(config2, action) {
    var _action$threshold, _action$checkpoint;
    const members = topologyToMembers(config2.tree);
    if (action.add) {
      for (const signer2 of action.add) {
        if (members.find((s2) => isSignerLeaf(s2) && s2.address === signer2.address)) {
          continue;
        }
        members.push({
          address: signer2.address,
          weight: signer2.weight
        });
      }
    }
    if (action.remove) {
      for (const address of action.remove) {
        const index2 = members.findIndex((s2) => isSignerLeaf(s2) && s2.address === address);
        if (index2 >= 0) {
          members.splice(index2, 1);
        }
      }
    }
    return {
      version: config2.version,
      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config2.threshold,
      checkpoint: (_action$checkpoint = action.checkpoint) != null ? _action$checkpoint : config2.checkpoint,
      tree: optimized2SignersTopologyBuilder(members)
    };
  },
  buildStubSignature: function(config2, overrides) {
    const parts = /* @__PURE__ */ new Map();
    for (const [signer2, signature2] of overrides.entries()) {
      parts.set(signer2, {
        signature: signature2,
        isDynamic: true
      });
      const {
        encoded,
        weight
      } = encodeSigners(config2, parts, [], 0);
      if (weight >= BigInt(config2.threshold)) {
        return encoded;
      }
    }
    const signers = signersOf(config2.tree);
    for (const {
      address
    } of signers.sort(({
      weight: a2
    }, {
      weight: b2
    }) => a2 - b2)) {
      const signature2 = "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02";
      parts.set(address, {
        signature: signature2,
        isDynamic: false
      });
      const {
        encoded,
        weight
      } = encodeSigners(config2, parts, [], 0);
      if (weight >= BigInt(config2.threshold)) {
        return encoded;
      }
    }
    return encodeSigners(config2, parts, [], 0).encoded;
  }
};
var config$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isSignerLeaf,
  isSubdigestLeaf,
  topologyToJSON,
  topologyFromJSON,
  isNestedLeaf,
  isNodeLeaf,
  isLeaf: isLeaf$1,
  isNode: isNode$1,
  isTopology,
  encodeSignerLeaf,
  decodeSignerLeaf,
  isEncodedSignerLeaf,
  hashNode,
  leftFace,
  isWalletConfig,
  imageHash,
  isSimpleNestedMember,
  topologyToMembers,
  hasUnknownNodes,
  toSimpleWalletConfig,
  legacyTopologyBuilder,
  merkleTopologyBuilder,
  optimized2SignersTopologyBuilder,
  toWalletConfig,
  hasSubdigest,
  signersOf,
  isComplete,
  ConfigCoder
});
var context$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const coders = {
  config: ConfigCoder,
  signature: SignatureCoder
};
const version$3 = 2;
const DeployedWalletContext = {
  version: version$3,
  factory: "0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A",
  guestModule: "0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE",
  mainModule: "0xfBf8f1A5E00034762D928f46d438B947f5d4065d",
  mainModuleUpgradable: "0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var v2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: config$1,
  signature,
  context: context$1,
  chained,
  coders,
  version: version$3,
  DeployedWalletContext
});
var config$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
function addressOf(context2, imageHash2) {
  const codeHash = keccak256(solidityPacked(["bytes", "bytes32"], [context2.walletCreationCode, zeroPadValue(context2.mainModule, 32)]));
  const hash2 = keccak256(solidityPacked(["bytes1", "address", "bytes32", "bytes32"], ["0xff", context2.factory, imageHash2, codeHash]));
  return getAddress(dataSlice(hash2, 12));
}
async function isValidCounterfactual(wallet, digest, signature2, chainId, provider2, contexts) {
  const res = await Promise.all(allVersions.map(async (version2) => {
    try {
      const decoded = version2.signature.SignatureCoder.decode(hexlify(signature2));
      const recovered1 = await version2.signature.SignatureCoder.recover(decoded, {
        address: wallet,
        digest: hexlify(digest),
        chainId
      }, provider2);
      const imageHash2 = version2.config.ConfigCoder.imageHashOf(recovered1.config);
      const counterfactualAddress = addressOf(contexts[version2.version], imageHash2);
      if (counterfactualAddress.toLowerCase() === wallet.toLowerCase()) {
        return true;
      }
      const recovered2 = await version2.signature.SignatureCoder.recover(decoded, {
        address: wallet,
        digest: hexlify(digest),
        chainId
      }, provider2);
      const imageHash22 = version2.config.ConfigCoder.imageHashOf(recovered2.config);
      const counterfactualAddress2 = addressOf(contexts[version2.version], imageHash22);
      return counterfactualAddress2.toLowerCase() === wallet.toLowerCase();
    } catch (_unused) {
    }
    return false;
  }));
  return res.some((r2) => r2);
}
function isValidVersionedContext(contexts) {
  const versions = Object.keys(contexts).length;
  for (let i = 1; i <= versions; i++) {
    const context2 = contexts[i];
    if (!context2 || context2.version !== i) {
      return false;
    }
  }
  return true;
}
function latestContext(contexts) {
  const versions = Object.keys(contexts).length;
  return contexts[versions];
}
const defaultContexts = {
  1: DeployedWalletContext$1,
  2: DeployedWalletContext
};
var context = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  addressOf,
  isValidCounterfactual,
  isValidVersionedContext,
  latestContext,
  defaultContexts
});
const MetaTransactionsType = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function intendTransactionBundle(bundle, wallet, chainId, id2) {
  return _extends$e({}, bundle, {
    chainId,
    intent: {
      id: id2,
      wallet
    }
  });
}
function intendedTransactionID(bundle) {
  return keccak256(AbiCoder.defaultAbiCoder().encode(["address", "uint256", "bytes32"], [bundle.intent.wallet, bundle.chainId, bundle.intent.id]));
}
function unpackMetaTransactionsData(data) {
  const res = AbiCoder.defaultAbiCoder().decode(["uint256", MetaTransactionsType], data);
  if (res.length !== 2 || !res[0] || !res[1]) throw new Error("Invalid meta transaction data");
  return [res[0], res[1]];
}
function packMetaTransactionsData(nonce, txs) {
  return AbiCoder.defaultAbiCoder().encode(["uint256", MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);
}
function digestOfTransactions(nonce, txs) {
  return keccak256(packMetaTransactionsData(nonce, txs));
}
function subdigestOfTransactions(address, chainId, nonce, txs) {
  return subdigestOf({
    address,
    chainId,
    digest: digestOfTransactions(nonce, txs)
  });
}
function subdigestOfGuestModuleTransactions(guestModule, chainId, txs) {
  return subdigestOf({
    address: guestModule,
    chainId,
    digest: keccak256(AbiCoder.defaultAbiCoder().encode(["string", MetaTransactionsType], ["guest:", sequenceTxAbiEncode(txs)]))
  });
}
function toSequenceTransactions(wallet, txs) {
  return txs.map((tx) => toSequenceTransaction(wallet, tx));
}
function toSequenceTransaction(wallet, tx) {
  if (tx.to && tx.to !== ZeroAddress) {
    return {
      nonce: !isNullish(tx.nonce) ? BigInt(tx.nonce) : void 0,
      transaction: {
        delegateCall: false,
        revertOnError: false,
        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : void 0,
        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise
        // Keeping this as is for now so we don't have to change everything to async
        to: tx.to,
        value: BigInt(tx.value || 0),
        data: tx.data || "0x"
      }
    };
  } else {
    const walletInterface = new Interface(walletContracts.mainModule.abi);
    const data = walletInterface.encodeFunctionData(walletInterface.getFunction("createContract"), [tx.data]);
    return {
      nonce: typeof tx.nonce === "number" ? BigInt(tx.nonce) : void 0,
      transaction: {
        delegateCall: false,
        revertOnError: false,
        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : void 0,
        to: wallet,
        value: BigInt(tx.value || 0),
        data
      }
    };
  }
}
function isSequenceTransaction(tx) {
  return tx.delegateCall !== void 0 || tx.revertOnError !== void 0;
}
function hasSequenceTransactions(txs) {
  return txs.every(isSequenceTransaction);
}
function sequenceTxAbiEncode(txs) {
  return txs.map((tx) => {
    var _tx$to;
    return {
      delegateCall: tx.delegateCall === true,
      revertOnError: tx.revertOnError === true,
      gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : 0n,
      target: (_tx$to = tx.to) != null ? _tx$to : ZeroAddress,
      value: !isNullish(tx.value) ? tx.value : 0n,
      data: tx.data || "0x"
    };
  });
}
function fromTxAbiEncode(txs) {
  return txs.map((tx) => ({
    delegateCall: tx.delegateCall,
    revertOnError: tx.revertOnError,
    gasLimit: tx.gasLimit,
    to: tx.target,
    value: tx.value,
    data: tx.data
  }));
}
function encodeNonce(space, nonce) {
  const bspace = BigInt(space);
  const bnonce = BigInt(nonce);
  const shl = 2n ** 96n;
  if (bnonce / shl !== 0n) {
    throw new Error("Space already encoded");
  }
  return bnonce + bspace * shl;
}
function decodeNonce(nonce) {
  const bnonce = BigInt(nonce);
  const shr = 2n ** 96n;
  return [bnonce / shr, bnonce % shr];
}
function fromTransactionish(wallet, transaction2) {
  if (Array.isArray(transaction2)) {
    if (hasSequenceTransactions(transaction2)) {
      return transaction2;
    } else {
      const stx = toSequenceTransactions(wallet, transaction2);
      return stx.map((t2) => t2.transaction);
    }
  } else if (isSequenceTransaction(transaction2)) {
    return [transaction2];
  } else {
    return [toSequenceTransaction(wallet, transaction2).transaction];
  }
}
function isTransactionBundle(cand) {
  return cand !== void 0 && cand.entrypoint !== void 0 && cand.chainId !== void 0 && cand.transactions !== void 0 && cand.nonce !== void 0 && cand.intent !== void 0 && cand.intent.id !== void 0 && cand.intent.wallet !== void 0 && Array.isArray(cand.transactions) && cand.transactions.reduce((p2, c2) => p2 && isSequenceTransaction(c2), true);
}
function isSignedTransactionBundle(cand) {
  return cand !== void 0 && cand.signature !== void 0 && cand.signature !== "" && isTransactionBundle(cand);
}
function encodeBundleExecData(bundle) {
  const walletInterface = new Interface(walletContracts.mainModule.abi);
  return walletInterface.encodeFunctionData(walletInterface.getFunction("execute"), isSignedTransactionBundle(bundle) ? [
    // Signed transaction bundle has all 3 parameters
    sequenceTxAbiEncode(bundle.transactions),
    bundle.nonce,
    bundle.signature
  ] : [
    // Unsigned bundle may be a GuestModule call, so signature and nonce are missing
    sequenceTxAbiEncode(bundle.transactions),
    0,
    new Uint8Array([])
  ]);
}
const selfExecuteSelector = "0x61c2926c";
const selfExecuteAbi = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
const unwind = (wallet, transactions2) => {
  const unwound = [];
  const walletInterface = new Interface(walletContracts.mainModule.abi);
  for (const tx of transactions2) {
    const txData = getBytes(tx.data || "0x");
    if (tx.to === wallet && hexlify(txData.slice(0, 4)) === selfExecuteSelector) {
      const data = txData.slice(4);
      const decoded = AbiCoder.defaultAbiCoder().decode([selfExecuteAbi], data)[0];
      unwound.push(...unwind(tx.to, decoded.map((d2) => _extends$e({}, d2, {
        to: d2.target
      }))));
    } else {
      try {
        const innerTransactions = walletInterface.decodeFunctionData("execute", txData)[0];
        const unwoundTransactions = unwind(wallet, innerTransactions.map((tx2) => _extends$e({}, tx2.toObject(), {
          to: tx2.target
        })));
        unwound.push(...unwoundTransactions);
      } catch (_unused) {
        unwound.push(tx);
      }
    }
  }
  return unwound;
};
const isNullish = (value) => value === null || value === void 0;
var transaction = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MetaTransactionsType,
  intendTransactionBundle,
  intendedTransactionID,
  unpackMetaTransactionsData,
  packMetaTransactionsData,
  digestOfTransactions,
  subdigestOfTransactions,
  subdigestOfGuestModuleTransactions,
  toSequenceTransactions,
  toSequenceTransaction,
  isSequenceTransaction,
  hasSequenceTransactions,
  sequenceTxAbiEncode,
  fromTxAbiEncode,
  encodeNonce,
  decodeNonce,
  fromTransactionish,
  isTransactionBundle,
  isSignedTransactionBundle,
  encodeBundleExecData,
  selfExecuteSelector,
  selfExecuteAbi,
  unwind
});
const EIP_6492_OFFCHAIN_DEPLOY_CODE = "0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033";
const EIP_6492_SUFFIX = "0x6492649264926492649264926492649264926492649264926492649264926492";
async function validateEIP6492Offchain(provider2, signer2, hash2, signature2) {
  try {
    const result = await provider2.call({
      data: concat([EIP_6492_OFFCHAIN_DEPLOY_CODE, AbiCoder.defaultAbiCoder().encode(["address", "bytes32", "bytes"], [signer2, hash2, signature2])])
    });
    return result === "0x01";
  } catch (err) {
    return false;
  }
}
var validateEIP6492 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EIP_6492_OFFCHAIN_DEPLOY_CODE,
  EIP_6492_SUFFIX,
  validateEIP6492Offchain
});
class OnChainReader {
  constructor(provider2) {
    this.provider = provider2;
    this.isDeployedCache = /* @__PURE__ */ new Set();
  }
  module(address) {
    return new Contract(address, [...walletContracts.mainModuleUpgradable.abi, ...walletContracts.mainModule.abi, ...walletContracts.erc1271.abi], this.provider);
  }
  async isDeployed(wallet) {
    if (this.isDeployedCache.has(wallet)) {
      return true;
    }
    const code2 = await this.provider.getCode(wallet).then((c2) => getBytes(c2));
    const isDeployed = code2.length !== 0;
    if (isDeployed) {
      this.isDeployedCache.add(wallet);
    }
    return isDeployed;
  }
  async implementation(wallet) {
    const position = AbiCoder.defaultAbiCoder().encode(["address"], [wallet]);
    const val = await this.provider.getStorage(wallet, position).then((c2) => getBytes(c2));
    if (val.length === 20) {
      return getAddress(hexlify(val));
    }
    if (val.length === 32) {
      return AbiCoder.defaultAbiCoder().decode(["address"], val)[0];
    }
    return void 0;
  }
  async imageHash(wallet) {
    try {
      const imageHash2 = await this.module(wallet).imageHash();
      return imageHash2;
    } catch (_unused) {
    }
    return void 0;
  }
  async nonce(wallet, space = 0) {
    try {
      const nonce = await this.module(wallet).readNonce(space);
      return nonce;
    } catch (e2) {
      if (!await this.isDeployed(wallet)) {
        return 0;
      }
      throw e2;
    }
  }
  // We use the EIP-6492 validator contract to check the signature
  // this means that if the wallet is not deployed, then the signature
  // must be prefixed with a transaction that deploys the wallet
  async isValidSignature(wallet, digest, signature2) {
    return validateEIP6492Offchain(this.provider, wallet, digest, signature2);
  }
}
var reader = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  OnChainReader
});
function isWalletSignRequestMetadata(obj) {
  return obj && obj.address && obj.digest && obj.chainId !== void 0 && obj.config;
}
var index$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: config$3,
  signature: signature$2,
  context,
  signer,
  EIP1271: validateEIP1271,
  transaction,
  reader,
  EIP6492: validateEIP6492,
  isWalletSignRequestMetadata
});
const ALL_CODERS = [{
  config: ConfigCoder$1,
  signature: SignatureCoder$1
}, {
  config: ConfigCoder,
  signature: SignatureCoder
}];
function coderFor(version2) {
  const index2 = version2 - 1;
  if (index2 < 0 || index2 >= ALL_CODERS.length) {
    throw new Error(`No coder for version: ${version2}`);
  }
  return ALL_CODERS[index2];
}
function genericCoderFor(version2) {
  return coderFor(version2);
}
var index$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALL_CODERS,
  coderFor,
  genericCoderFor
});
const VERSION$1 = "2.0.20";
const allVersions = [v1, v2];
const core$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: VERSION$1,
  allVersions,
  commons: index$1$1,
  universal: index$6,
  v1,
  v2
}, Symbol.toStringTag, { value: "Module" }));
function counterfactualVersion(address, firstImageHash, versions) {
  for (let i = 0; i < versions.length; i++) {
    if (index$1$1.context.addressOf(versions[i], firstImageHash) === address) {
      return versions[i].version;
    }
  }
  throw new Error("Could not find version for counterfactual address");
}
var version$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  counterfactualVersion
});
class Migration_v1v2 {
  constructor() {
    this.version = 2;
    this.configCoder = v2.config.ConfigCoder;
    this.signatureCoder = v2.signature.SignatureCoder;
  }
  buildTransaction(address, contexts, newConfig) {
    if (!v2.config.ConfigCoder.isWalletConfig(newConfig)) {
      const v2Config = v2.config.toWalletConfig({
        threshold: newConfig.threshold,
        members: newConfig.signers,
        checkpoint: 0
      });
      return this.buildTransaction(address, contexts, v2Config);
    }
    const context2 = contexts[2];
    const contract = new Interface(walletContracts.mainModule.abi);
    const updateBundle = v2.config.ConfigCoder.update.buildTransaction(address, newConfig, context2, "first");
    const tx = {
      entrypoint: address,
      nonce: index$1$1.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0),
      transactions: [{
        to: address,
        value: 0,
        gasLimit: 0,
        revertOnError: true,
        delegateCall: false,
        data: contract.encodeFunctionData(contract.getFunction("updateImplementation"), [context2.mainModuleUpgradable])
      }, ...updateBundle.transactions]
    };
    return {
      tx,
      fromVersion: this.version - 1,
      toVersion: this.version,
      toConfig: newConfig
    };
  }
  decodeTransaction(tx, contexts) {
    const address = tx.entrypoint;
    if (tx.transactions.length < 2) {
      throw new Error("Invalid transaction bundle size");
    }
    if (!tx.nonce || index$1$1.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0) !== BigInt(tx.nonce)) {
      throw new Error("Invalid transaction bundle nonce");
    }
    if (tx.transactions[0].to !== address || tx.transactions[1].to !== address || tx.transactions[0].delegateCall || tx.transactions[1].delegateCall || !tx.transactions[0].revertOnError || !tx.transactions[1].revertOnError || tx.transactions[0].value && BigInt(tx.transactions[0].value) !== 0n || tx.transactions[1].value && BigInt(tx.transactions[1].value) !== 0n || tx.transactions[0].gasLimit && BigInt(tx.transactions[0].gasLimit) !== 0n || tx.transactions[1].gasLimit && BigInt(tx.transactions[1].gasLimit) !== 0n) {
      throw new Error("Invalid transaction bundle format");
    }
    const context2 = contexts[2];
    const contract = new Interface(walletContracts.mainModule.abi);
    const data1 = hexlify(tx.transactions[0].data || new Uint8Array());
    const expectData1 = hexlify(contract.encodeFunctionData(contract.getFunction("updateImplementation"), [context2.mainModuleUpgradable]));
    if (data1 !== expectData1) {
      throw new Error("Invalid new implementation on transaction");
    }
    const decoded2 = v2.config.ConfigCoder.update.decodeTransaction({
      entrypoint: address,
      transactions: [tx.transactions[1]]
    });
    if (decoded2.address !== address) {
      throw new Error("Invalid transaction bundle address");
    }
    return decoded2;
  }
}
const MIGRATION_NONCE_SPACE = "0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb";
const v1v2 = new Migration_v1v2();
var index$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MIGRATION_NONCE_SPACE,
  v1v2
});
function _extends$d() {
  return _extends$d = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$d.apply(null, arguments);
}
function validateMigrations(migrations) {
  for (const [version2, migration2] of Object.entries(migrations)) {
    if (version2 !== String(migration2.version - 1)) {
      throw new Error(`Migration with key ${version2} has version ${migration2.version}, expected version to be key + 1`);
    }
  }
}
class Migrator {
  constructor(tracker2, migrations, contexts) {
    this.tracker = tracker2;
    this.migrations = migrations;
    this.contexts = contexts;
    validateMigrations(migrations);
  }
  lastMigration() {
    let last;
    for (const migration2 of Object.values(this.migrations)) {
      if (last === void 0 || migration2.version > last.version) {
        last = migration2;
      }
    }
    if (last === void 0) {
      throw new Error("No migrations");
    }
    return last;
  }
  async getAllMigratePresignedTransaction(args) {
    const {
      address,
      fromImageHash,
      fromVersion,
      chainId
    } = args;
    let fih = fromImageHash;
    let fversion = fromVersion;
    const versions = Object.values(this.contexts);
    const migs = [];
    for (let i = 1; i < versions.length; i++) {
      const mig = await this.tracker.getMigration(address, fih, fversion, chainId);
      if (!mig) return {
        signedMigrations: migs,
        missing: true,
        lastImageHash: fih,
        lastVersion: fversion
      };
      migs.push(mig);
      const migration2 = this.migrations[fversion];
      if (!migration2) {
        throw new Error(`No migration found for version ${fversion}`);
      }
      const decoded = migration2.decodeTransaction(mig.tx, this.contexts);
      if (decoded.address !== address) {
        throw new Error(`Migration transaction address does not match expected address`);
      }
      fih = decoded.newImageHash;
      fversion += 1;
    }
    return {
      signedMigrations: migs,
      missing: false,
      lastImageHash: fih,
      lastVersion: fversion
    };
  }
  async signNextMigration(address, fromVersion, wallet, nextConfig) {
    const migration2 = this.migrations[fromVersion];
    if (!migration2) {
      return void 0;
    }
    const unsignedMigration = migration2.buildTransaction(address, this.contexts, nextConfig);
    const signedBundle = await wallet.signTransactionBundle(unsignedMigration.tx);
    return _extends$d({}, unsignedMigration, {
      tx: signedBundle
    });
  }
}
var migrator = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Migrator
});
const DefaultMigrations = {
  1: v1v2
};
var defaults$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DefaultMigrations
});
const migration$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaults: defaults$1,
  migration: index$5,
  migrator,
  version: version$2
}, Symbol.toStringTag, { value: "Module" }));
function _extends$c() {
  return _extends$c = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$c.apply(null, arguments);
}
const DEFAULT_GAS_LIMIT = 800000n;
const ProviderRelayerDefaults = {
  waitPollRate: 1e3,
  deltaBlocksLog: 12,
  fromBlockLog: -1024
};
function isProviderRelayerOptions(obj) {
  return typeof obj === "object" && isAbstractProvider$1(obj.provider);
}
class ProviderRelayer {
  constructor(options) {
    this.provider = void 0;
    this.waitPollRate = void 0;
    this.deltaBlocksLog = void 0;
    this.fromBlockLog = void 0;
    const opts = _extends$c({}, ProviderRelayerDefaults, options);
    this.provider = opts.provider;
    this.waitPollRate = opts.waitPollRate;
    this.deltaBlocksLog = opts.deltaBlocksLog;
    this.fromBlockLog = opts.fromBlockLog;
  }
  async simulate(wallet, ...transactions2) {
    var _this = this;
    return (await Promise.all(transactions2.map(async function(tx) {
      if (tx.gasLimit && BigInt(tx.gasLimit || 0) !== 0n) {
        return tx.gasLimit;
      }
      if (tx.delegateCall) {
        return DEFAULT_GAS_LIMIT;
      }
      if (tx.to === wallet && await _this.provider.getCode(wallet).then((code2) => getBytes(code2).length === 0)) {
        return DEFAULT_GAS_LIMIT;
      }
      if (!_this.provider) {
        throw new Error("signer.provider is not set, but is required");
      }
      return _this.provider.estimateGas({
        from: wallet,
        to: tx.to,
        data: tx.data,
        value: tx.value
      });
    }))).map((gasLimit) => ({
      executed: true,
      succeeded: true,
      gasUsed: Number(gasLimit),
      gasLimit: Number(gasLimit)
    }));
  }
  async getNonce(address, space, blockTag) {
    if (!this.provider) {
      throw new Error("provider is not set");
    }
    if (await this.provider.getCode(address) === "0x") {
      return 0;
    }
    if (space === void 0) {
      space = 0;
    }
    const module2 = new Contract(address, walletContracts.mainModule.abi, this.provider);
    const nonce = await module2.readNonce(space, {
      blockTag
    });
    return index$1$1.transaction.encodeNonce(space, nonce);
  }
  async wait(metaTxnId, timeoutDuration, delay2 = this.waitPollRate, maxFails = 5) {
    var _this2 = this;
    if (typeof metaTxnId !== "string") {
      metaTxnId = index$1$1.transaction.intendedTransactionID(metaTxnId);
    }
    let timedOut = false;
    const retry = async function retry2(f2, errorMessage) {
      let fails = 0;
      while (!timedOut) {
        try {
          return await f2();
        } catch (error) {
          fails++;
          if (maxFails !== void 0 && fails >= maxFails) {
            logger.error(`giving up after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ""}`, error);
            throw error;
          } else {
            logger.warn(`attempt #${fails} failed${errorMessage ? `: ${errorMessage}` : ""}`, error);
          }
        }
        if (delay2 > 0) {
          await new Promise((resolve) => setTimeout(resolve, delay2));
        }
      }
      throw new Error(`timed out after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ""}`);
    };
    const waitReceipt = async function waitReceipt2() {
      let lastBlock = _this2.fromBlockLog;
      if (lastBlock < 0) {
        const block = await retry(() => _this2.provider.getBlockNumber(), "unable to get latest block number");
        lastBlock = block + lastBlock;
      }
      if (typeof metaTxnId !== "string") {
        throw new Error("impossible");
      }
      const normalMetaTxnId = metaTxnId.replace("0x", "");
      while (!timedOut) {
        const block = await retry(() => _this2.provider.getBlockNumber(), "unable to get latest block number");
        const logs = await retry(() => _this2.provider.getLogs({
          fromBlock: Math.max(0, lastBlock - _this2.deltaBlocksLog),
          toBlock: block,
          // Nonce change event topic
          topics: ["0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881"]
        }), `unable to get NonceChange logs for blocks ${Math.max(0, lastBlock - _this2.deltaBlocksLog)} to ${block}`);
        lastBlock = block;
        const txs = await Promise.all(logs.map((l2) => retry(() => _this2.provider.getTransactionReceipt(l2.transactionHash), `unable to get receipt for transaction ${l2.transactionHash}`)));
        const found = txs.find((tx) => tx == null ? void 0 : tx.logs.find((l2) => l2.topics.length === 0 && l2.data.replace("0x", "") === normalMetaTxnId || l2.topics.length === 1 && // TxFailed event topic
        l2.topics[0] === "0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7" && l2.data.length >= 64 && l2.data.replace("0x", "").startsWith(normalMetaTxnId)));
        if (found) {
          const response = await retry(() => _this2.provider.getTransaction(found.hash), `unable to get transaction ${found.hash}`);
          if (!response) {
            throw new Error(`Transaction response not found for  ${metaTxnId}`);
          }
          const out = response;
          out.receipt = found;
          return out;
        }
        if (!timedOut) {
          await new Promise((r2) => setTimeout(r2, delay2));
        }
      }
      throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);
    };
    if (timeoutDuration !== void 0) {
      return Promise.race([waitReceipt(), new Promise((_, reject) => setTimeout(() => {
        timedOut = true;
        reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
      }, timeoutDuration))]);
    } else {
      return waitReceipt();
    }
  }
}
function isAbstractProvider$1(provider2) {
  return provider2 && typeof provider2 === "object" && typeof provider2.getNetwork === "function" && typeof provider2.getBlockNumber === "function";
}
function isLocalRelayerOptions(obj) {
  return typeof obj === "object" && isAbstractSigner(obj.signer);
}
class LocalRelayer extends ProviderRelayer {
  constructor(options) {
    super(isAbstractSigner(options) ? {
      provider: options.provider
    } : _extends$c({}, options, {
      provider: options.signer.provider
    }));
    this.signer = void 0;
    this.txnOptions = void 0;
    this.signer = isAbstractSigner(options) ? options : options.signer;
    if (!this.signer.provider) throw new Error("Signer must have a provider");
  }
  async getFeeOptions(_address, ..._transactions2) {
    return {
      options: []
    };
  }
  async getFeeOptionsRaw(_entrypoint, _data6, _options4) {
    return {
      options: []
    };
  }
  async gasRefundOptions(address, ...transactions2) {
    const {
      options
    } = await this.getFeeOptions(address, ...transactions2);
    return options;
  }
  setTransactionOptions(transactionRequest) {
    this.txnOptions = transactionRequest;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    if (quote !== void 0) {
      logger.warn(`LocalRelayer doesn't accept fee quotes`);
    }
    const data = index$1$1.transaction.encodeBundleExecData(signedTxs);
    const responsePromise = this.signer.sendTransaction(_extends$c({
      to: signedTxs.entrypoint,
      data
    }, this.txnOptions, {
      gasLimit: 9e6
    }));
    if (waitForReceipt) {
      const response = await responsePromise;
      response.receipt = await response.wait();
      return response;
    } else {
      return responsePromise;
    }
  }
}
function isAbstractSigner(signer2) {
  return signer2 && typeof signer2 === "object" && typeof signer2.provider === "object" && typeof signer2.getAddress === "function" && typeof signer2.connect === "function";
}
const WebRPCVersion$2 = "v1";
const WebRPCSchemaVersion$2 = "v0.4.1";
const WebRPCSchemaHash$2 = "1e27d0fd295aa5897878939595ef0c6adc54b1a3";
let ETHTxnStatus = /* @__PURE__ */ function(ETHTxnStatus2) {
  ETHTxnStatus2["UNKNOWN"] = "UNKNOWN";
  ETHTxnStatus2["DROPPED"] = "DROPPED";
  ETHTxnStatus2["QUEUED"] = "QUEUED";
  ETHTxnStatus2["SENT"] = "SENT";
  ETHTxnStatus2["SUCCEEDED"] = "SUCCEEDED";
  ETHTxnStatus2["PARTIALLY_FAILED"] = "PARTIALLY_FAILED";
  ETHTxnStatus2["FAILED"] = "FAILED";
  return ETHTxnStatus2;
}({});
let TransferType = /* @__PURE__ */ function(TransferType2) {
  TransferType2["SEND"] = "SEND";
  TransferType2["RECEIVE"] = "RECEIVE";
  TransferType2["BRIDGE_DEPOSIT"] = "BRIDGE_DEPOSIT";
  TransferType2["BRIDGE_WITHDRAW"] = "BRIDGE_WITHDRAW";
  TransferType2["BURN"] = "BURN";
  TransferType2["UNKNOWN"] = "UNKNOWN";
  return TransferType2;
}({});
let FeeTokenType$1 = /* @__PURE__ */ function(FeeTokenType2) {
  FeeTokenType2["UNKNOWN"] = "UNKNOWN";
  FeeTokenType2["ERC20_TOKEN"] = "ERC20_TOKEN";
  FeeTokenType2["ERC1155_TOKEN"] = "ERC1155_TOKEN";
  return FeeTokenType2;
}({});
let SortOrder$1 = /* @__PURE__ */ function(SortOrder2) {
  SortOrder2["DESC"] = "DESC";
  SortOrder2["ASC"] = "ASC";
  return SortOrder2;
}({});
class Relayer {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Relayer/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            version: _data6.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSequenceContext = (headers, signal) => {
      return this.fetch(this.url("GetSequenceContext"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            data: _data6.data
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getChainID = (headers, signal) => {
      return this.fetch(this.url("GetChainID"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            chainID: _data6.chainID
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sendMetaTxn = (args, headers, signal) => {
      return this.fetch(this.url("SendMetaTxn"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status,
            txnHash: _data6.txnHash
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTxnNonce = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTxnNonce"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            nonce: _data6.nonce
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTxnReceipt = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTxnReceipt"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            receipt: _data6.receipt
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.simulate = (args, headers, signal) => {
      return this.fetch(this.url("Simulate"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            results: _data6.results
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateMetaTxnGasLimits = (args, headers, signal) => {
      return this.fetch(this.url("UpdateMetaTxnGasLimits"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            payload: _data6.payload
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.feeTokens = (headers, signal) => {
      return this.fetch(this.url("FeeTokens"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            isFeeRequired: _data6.isFeeRequired,
            tokens: _data6.tokens
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.feeOptions = (args, headers, signal) => {
      return this.fetch(this.url("FeeOptions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            options: _data6.options,
            sponsored: _data6.sponsored,
            quote: _data6.quote
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTxnNetworkFeeOptions = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTxnNetworkFeeOptions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            options: _data6.options
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTransactions = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTransactions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            page: _data6.page,
            transactions: _data6.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sentTransactions = (args, headers, signal) => {
      return this.fetch(this.url("SentTransactions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            page: _data6.page,
            transactions: _data6.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.pendingTransactions = (args, headers, signal) => {
      return this.fetch(this.url("PendingTransactions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            page: _data6.page,
            transactions: _data6.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getGasTank = (args, headers, signal) => {
      return this.fetch(this.url("GetGasTank"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            gasTank: _data6.gasTank
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addGasTank = (args, headers, signal) => {
      return this.fetch(this.url("AddGasTank"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status,
            gasTank: _data6.gasTank
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateGasTank = (args, headers, signal) => {
      return this.fetch(this.url("UpdateGasTank"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status,
            gasTank: _data6.gasTank
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("GetGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            gasSponsor: _data6.gasSponsor
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addressGasSponsors = (args, headers, signal) => {
      return this.fetch(this.url("AddressGasSponsors"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            page: _data6.page,
            gasSponsors: _data6.gasSponsors
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listGasSponsors = (args, headers, signal) => {
      return this.fetch(this.url("ListGasSponsors"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            page: _data6.page,
            gasSponsors: _data6.gasSponsors
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("AddGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status,
            gasSponsor: _data6.gasSponsor
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("UpdateGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status,
            gasSponsor: _data6.gasSponsor
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("RemoveGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.reportGasSponsorUsage = (args, headers, signal) => {
      return this.fetch(this.url("ReportGasSponsorUsage"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            gasSponsorUsage: _data6.gasSponsorUsage
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.nextGasTankBalanceAdjustmentNonce = (args, headers, signal) => {
      return this.fetch(this.url("NextGasTankBalanceAdjustmentNonce"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            nonce: _data6.nonce
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.adjustGasTankBalance = (args, headers, signal) => {
      return this.fetch(this.url("AdjustGasTankBalance"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            status: _data6.status,
            adjustment: _data6.adjustment
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getGasTankBalanceAdjustment = (args, headers, signal) => {
      return this.fetch(this.url("GetGasTankBalanceAdjustment"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            adjustment: _data6.adjustment
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listGasTankBalanceAdjustments = (args, headers, signal) => {
      return this.fetch(this.url("ListGasTankBalanceAdjustments"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data6) => {
          return {
            page: _data6.page,
            adjustments: _data6.adjustments
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$6 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$c({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$6 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$6.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$6[code2] || WebrpcError$6).new(data);
    }
    return data;
  });
};
let WebrpcError$6 = class WebrpcError2 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError2.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$6 = class WebrpcEndpointError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError2.prototype);
  }
};
let WebrpcRequestFailedError$6 = class WebrpcRequestFailedError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError2.prototype);
  }
};
let WebrpcBadRouteError$6 = class WebrpcBadRouteError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError2.prototype);
  }
};
let WebrpcBadMethodError$6 = class WebrpcBadMethodError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError2.prototype);
  }
};
let WebrpcBadRequestError$6 = class WebrpcBadRequestError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError2.prototype);
  }
};
let WebrpcBadResponseError$6 = class WebrpcBadResponseError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError2.prototype);
  }
};
let WebrpcServerPanicError$6 = class WebrpcServerPanicError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError2.prototype);
  }
};
let WebrpcInternalErrorError$6 = class WebrpcInternalErrorError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError2.prototype);
  }
};
let WebrpcClientDisconnectedError$6 = class WebrpcClientDisconnectedError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError2.prototype);
  }
};
let WebrpcStreamLostError$6 = class WebrpcStreamLostError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError2.prototype);
  }
};
let WebrpcStreamFinishedError$6 = class WebrpcStreamFinishedError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError2.prototype);
  }
};
let UnauthorizedError$5 = class UnauthorizedError2 extends WebrpcError$6 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError2.prototype);
  }
};
let PermissionDeniedError$3 = class PermissionDeniedError2 extends WebrpcError$6 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError2.prototype);
  }
};
let MethodNotFoundError$2 = class MethodNotFoundError extends WebrpcError$6 {
  constructor(name2 = "MethodNotFound", code2 = 1003, message = "Method not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError.prototype);
  }
};
let AbortedError$2 = class AbortedError2 extends WebrpcError$6 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError2.prototype);
  }
};
let InvalidArgumentError$4 = class InvalidArgumentError2 extends WebrpcError$6 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError2.prototype);
  }
};
let UnavailableError$2 = class UnavailableError2 extends WebrpcError$6 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError2.prototype);
  }
};
let QueryFailedError$4 = class QueryFailedError2 extends WebrpcError$6 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError2.prototype);
  }
};
let NotFoundError$5 = class NotFoundError2 extends WebrpcError$6 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError2.prototype);
  }
};
let errors$2 = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["MethodNotFound"] = "MethodNotFound";
  errors2["Aborted"] = "Aborted";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["Unavailable"] = "Unavailable";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["NotFound"] = "NotFound";
  return errors2;
}({});
const webrpcErrorByCode$6 = {
  [0]: WebrpcEndpointError$6,
  [-1]: WebrpcRequestFailedError$6,
  [-2]: WebrpcBadRouteError$6,
  [-3]: WebrpcBadMethodError$6,
  [-4]: WebrpcBadRequestError$6,
  [-5]: WebrpcBadResponseError$6,
  [-6]: WebrpcServerPanicError$6,
  [-7]: WebrpcInternalErrorError$6,
  [-8]: WebrpcClientDisconnectedError$6,
  [-9]: WebrpcStreamLostError$6,
  [-10]: WebrpcStreamFinishedError$6,
  [1e3]: UnauthorizedError$5,
  [1001]: PermissionDeniedError$3,
  [1003]: MethodNotFoundError$2,
  [1005]: AbortedError$2,
  [2001]: InvalidArgumentError$4,
  [2002]: UnavailableError$2,
  [2003]: QueryFailedError$4,
  [3e3]: NotFoundError$5
};
var relayer_gen = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WebRPCVersion: WebRPCVersion$2,
  WebRPCSchemaVersion: WebRPCSchemaVersion$2,
  WebRPCSchemaHash: WebRPCSchemaHash$2,
  ETHTxnStatus,
  TransferType,
  FeeTokenType: FeeTokenType$1,
  SortOrder: SortOrder$1,
  Relayer,
  WebrpcError: WebrpcError$6,
  WebrpcEndpointError: WebrpcEndpointError$6,
  WebrpcRequestFailedError: WebrpcRequestFailedError$6,
  WebrpcBadRouteError: WebrpcBadRouteError$6,
  WebrpcBadMethodError: WebrpcBadMethodError$6,
  WebrpcBadRequestError: WebrpcBadRequestError$6,
  WebrpcBadResponseError: WebrpcBadResponseError$6,
  WebrpcServerPanicError: WebrpcServerPanicError$6,
  WebrpcInternalErrorError: WebrpcInternalErrorError$6,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$6,
  WebrpcStreamLostError: WebrpcStreamLostError$6,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$6,
  UnauthorizedError: UnauthorizedError$5,
  PermissionDeniedError: PermissionDeniedError$3,
  MethodNotFoundError: MethodNotFoundError$2,
  AbortedError: AbortedError$2,
  InvalidArgumentError: InvalidArgumentError$4,
  UnavailableError: UnavailableError$2,
  QueryFailedError: QueryFailedError$4,
  NotFoundError: NotFoundError$5,
  errors: errors$2
});
const FINAL_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.SUCCEEDED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
const FAILED_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
function isRpcRelayerOptions(obj) {
  return obj.url !== void 0 && typeof obj.url === "string" && obj.provider !== void 0 && isAbstractProvider(obj.provider);
}
const fetch$5 = globalThis.fetch;
class RpcRelayer {
  constructor(options) {
    this.options = options;
    this.service = void 0;
    this.provider = void 0;
    this._fetch = (input2, init2) => {
      const headers = {};
      const {
        jwtAuth,
        projectAccessKey: projectAccessKey2
      } = this.options;
      if (jwtAuth && jwtAuth.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth}`;
      }
      if (projectAccessKey2 && projectAccessKey2.length > 0) {
        headers["X-Access-Key"] = projectAccessKey2;
      }
      init2.headers = _extends$c({}, init2.headers, headers);
      return fetch$5(input2, init2);
    };
    this.service = new Relayer(options.url, this._fetch);
    if (isAbstractProvider(options.provider)) {
      this.provider = options.provider;
    } else {
      const {
        jwtAuth,
        projectAccessKey: projectAccessKey2
      } = this.options;
      const fetchRequest = getFetchRequest(options.provider.url, projectAccessKey2, jwtAuth);
      this.provider = new JsonRpcProvider$1(fetchRequest, void 0, {
        staticNetwork: true
      });
    }
  }
  async waitReceipt(metaTxnId, delay2 = 1e3, maxFails = 5, isCancelled) {
    if (typeof metaTxnId !== "string") {
      metaTxnId = index$1$1.transaction.intendedTransactionID(metaTxnId);
    }
    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnId}`);
    let fails = 0;
    while (isCancelled === void 0 || !isCancelled()) {
      try {
        const {
          receipt
        } = await this.service.getMetaTxnReceipt({
          metaTxID: metaTxnId
        });
        if (receipt && receipt.txnReceipt && receipt.txnReceipt !== "null" && FINAL_STATUSES.includes(receipt.status)) {
          return {
            receipt
          };
        }
      } catch (e2) {
        fails++;
        if (fails === maxFails) {
          throw e2;
        }
      }
      if (isCancelled === void 0 || !isCancelled()) {
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
    }
    throw new Error(`Cancelled waiting for transaction receipt ${metaTxnId}`);
  }
  async simulate(wallet, ...transactions2) {
    const coder = AbiCoder.defaultAbiCoder();
    const encoded = coder.encode([index$1$1.transaction.MetaTransactionsType], [index$1$1.transaction.sequenceTxAbiEncode(transactions2)]);
    return (await this.service.simulate({
      wallet,
      transactions: encoded
    })).results;
  }
  async getFeeOptions(address, ...transactions2) {
    const feeTokens = await this.service.feeTokens();
    if (feeTokens.isFeeRequired) {
      const symbols = feeTokens.tokens.map((token) => token.symbol).join(", ");
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);
      const nonce = await this.getNonce(address);
      if (!this.provider) {
        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);
        throw new Error("provider is not set");
      }
      const {
        options,
        quote
      } = await this.service.feeOptions({
        wallet: address,
        to: address,
        data: index$1$1.transaction.encodeBundleExecData({
          entrypoint: address,
          transactions: transactions2,
          nonce
        })
      });
      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options, bigintReplacer)}`);
      return {
        options,
        quote: {
          _tag: "FeeQuote",
          _quote: quote
        }
      };
    } else {
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);
      return {
        options: []
      };
    }
  }
  async getFeeOptionsRaw(entrypoint, data, options) {
    const {
      options: feeOptions2,
      quote
    } = await this.service.feeOptions({
      wallet: entrypoint,
      to: entrypoint,
      data: hexlify(data),
      simulate: options == null ? void 0 : options.simulate
    });
    return {
      options: feeOptions2,
      quote: {
        _tag: "FeeQuote",
        _quote: quote
      }
    };
  }
  async gasRefundOptions(address, ...transactions2) {
    const {
      options
    } = await this.getFeeOptions(address, ...transactions2);
    return options;
  }
  async getNonce(address, space) {
    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${address} space: ${space}`);
    const encodedNonce = space !== void 0 ? toHexString(BigInt(space)) : void 0;
    const resp = await this.service.getMetaTxnNonce({
      walletContractAddress: address,
      space: encodedNonce
    });
    const nonce = BigInt(resp.nonce);
    const [decodedSpace, decodedNonce] = index$1$1.transaction.decodeNonce(nonce);
    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${address} ${decodedNonce} space: ${decodedSpace}`);
    return nonce;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    var _this = this;
    logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs, bigintReplacer)} with quote ${JSON.stringify(quote, bigintReplacer)}`);
    let typecheckedQuote;
    if (quote !== void 0) {
      if (typeof quote._quote === "string") {
        typecheckedQuote = quote._quote;
      } else {
        logger.warn("[rpc-relayer/relay] ignoring invalid fee quote");
      }
    }
    if (!this.provider) {
      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);
      throw new Error("provider is not set");
    }
    const data = index$1$1.transaction.encodeBundleExecData(signedTxs);
    const metaTxn = await this.service.sendMetaTxn({
      call: {
        walletAddress: signedTxs.intent.wallet,
        contract: signedTxs.entrypoint,
        input: data
      },
      quote: typecheckedQuote
    });
    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn, bigintReplacer)}`);
    if (waitForReceipt) {
      return this.wait(signedTxs.intent.id);
    } else {
      const response = {
        hash: signedTxs.intent.id,
        confirmations: 0,
        from: signedTxs.intent.wallet,
        wait: (_confirmations) => Promise.reject(new Error("impossible"))
      };
      const wait2 = async function wait3(confirmations) {
        var _waitResponse$receipt;
        if (!_this.provider) {
          throw new Error("cannot wait for receipt, relayer has no provider set");
        }
        const waitResponse = await _this.wait(signedTxs.intent.id);
        const transactionHash = (_waitResponse$receipt = waitResponse.receipt) == null ? void 0 : _waitResponse$receipt.transactionHash;
        if (!transactionHash) {
          throw new Error("cannot wait for receipt, unknown native transaction hash");
        }
        Object.assign(response, waitResponse);
        return _this.provider.waitForTransaction(transactionHash, confirmations);
      };
      response.wait = wait2;
      return response;
    }
  }
  async wait(metaTxnId, timeout, delay2 = 1e3, maxFails = 5) {
    var _this2 = this;
    let timedOut = false;
    const {
      receipt
    } = await (timeout !== void 0 ? Promise.race([this.waitReceipt(metaTxnId, delay2, maxFails, () => timedOut), new Promise((_, reject) => setTimeout(() => {
      timedOut = true;
      reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
    }, timeout))]) : this.waitReceipt(metaTxnId, delay2, maxFails));
    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {
      throw new MetaTransactionResponseException(receipt);
    }
    const txReceipt = JSON.parse(receipt.txnReceipt);
    return {
      blockHash: txReceipt.blockHash,
      blockNumber: Number(txReceipt.blockNumber),
      confirmations: 1,
      from: typeof metaTxnId === "string" ? void 0 : metaTxnId.intent.wallet,
      hash: txReceipt.transactionHash,
      raw: receipt.txnReceipt,
      receipt: txReceipt,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function(confirmations) {
        return _this2.provider.waitForTransaction(txReceipt.transactionHash, confirmations);
      }
    };
  }
}
class MetaTransactionResponseException {
  constructor(receipt) {
    this.receipt = receipt;
  }
}
function isAbstractProvider(provider2) {
  return provider2 && typeof provider2 === "object" && typeof provider2.getNetwork === "function" && typeof provider2.getBlockNumber === "function";
}
function isRelayer(cand) {
  return typeof cand === "object" && typeof cand.simulate === "function" && typeof cand.getFeeOptions === "function" && typeof cand.gasRefundOptions === "function" && typeof cand.getNonce === "function" && typeof cand.relay === "function" && typeof cand.wait === "function";
}
const relayer$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LocalRelayer,
  ProviderRelayer,
  ProviderRelayerDefaults,
  RpcRelayer,
  RpcRelayerProto: relayer_gen,
  isLocalRelayerOptions,
  isProviderRelayerOptions,
  isRelayer,
  isRpcRelayerOptions,
  proto: relayer_gen
}, Symbol.toStringTag, { value: "Module" }));
function isSapientSigner(signer2) {
  return signer2.getAddress !== void 0 && signer2.buildDeployTransaction !== void 0 && signer2.predecorateSignedTransactions !== void 0 && signer2.decorateTransactions !== void 0 && signer2.sign !== void 0 && signer2.notifyStatusChange !== void 0;
}
class SignerWrapper {
  constructor(signer2, eoa = true) {
    this.signer = signer2;
    this.eoa = eoa;
  }
  getAddress() {
    return this.signer.getAddress();
  }
  async buildDeployTransaction(_metadata) {
    return;
  }
  async predecorateSignedTransactions(_metadata) {
    return [];
  }
  async decorateTransactions(bundle, _metadata) {
    return bundle;
  }
  sign(message) {
    return this.signer.signMessage(message);
  }
  notifyStatusChange(_i2, _s2, _m2) {
  }
  suffix() {
    return new Uint8Array([2]);
  }
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isSapientSigner,
  SignerWrapper
});
let SignerState = /* @__PURE__ */ function(SignerState2) {
  SignerState2[SignerState2["INITIAL"] = 0] = "INITIAL";
  SignerState2[SignerState2["SIGNING"] = 1] = "SIGNING";
  SignerState2[SignerState2["SIGNED"] = 2] = "SIGNED";
  SignerState2[SignerState2["ERROR"] = 3] = "ERROR";
  return SignerState2;
}({});
function isSignerStatusPending(status) {
  return status === void 0 || status.state === SignerState.INITIAL || status.state === SignerState.SIGNING;
}
class Orchestrator {
  constructor(signers, tag = Orchestrator.randomTag()) {
    this.tag = tag;
    this.observers = [];
    this.signers = [];
    this.count = 0;
    this.setSigners(signers);
  }
  static randomTag() {
    return `default-${hexlify(randomBytes(8)).slice(2)}`;
  }
  pullId() {
    return `${this.tag}-${this.count++}`;
  }
  setSigners(signers) {
    this.signers = signers.map((s2) => isSapientSigner(s2) ? s2 : new SignerWrapper(s2));
  }
  async getSigners() {
    return Promise.all(this.signers.map(async function(s2) {
      return s2.getAddress();
    }));
  }
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter((o2) => o2 !== observer);
    };
  }
  async notifyObservers(id2, status, metadata2) {
    await Promise.all([...this.signers.map(async function(signer2) {
      return signer2.notifyStatusChange(id2, status, metadata2);
    }), ...this.observers.map(async function(observer) {
      return observer(status, metadata2);
    })]);
  }
  async buildDeployTransaction(metadata2) {
    let bundle;
    for (const signer2 of this.signers) {
      const newBundle = await signer2.buildDeployTransaction(metadata2);
      if (bundle === void 0) {
        bundle = newBundle;
      } else if (newBundle != null && newBundle.transactions) {
        bundle.transactions = newBundle.transactions.concat(bundle.transactions);
      }
    }
    return bundle;
  }
  async predecorateSignedTransactions(metadata2) {
    const output2 = [];
    for (const signer2 of this.signers) {
      output2.push(...await signer2.predecorateSignedTransactions(metadata2 != null ? metadata2 : {}));
    }
    return output2;
  }
  async decorateTransactions(bundle, metadata2) {
    for (const signer2 of this.signers) {
      bundle = await signer2.decorateTransactions(bundle, metadata2 != null ? metadata2 : {});
    }
    return bundle;
  }
  signMessage(args) {
    var _this = this;
    const id2 = this.pullId();
    return new Promise(async function(resolve) {
      const {
        message,
        metadata: metadata2,
        callback,
        candidates
      } = args;
      const status = {
        ended: false,
        message,
        signers: {}
      };
      let lastMetadata = metadata2 != null ? metadata2 : {};
      const onNewMetadata = (newMetadata) => {
        lastMetadata = newMetadata;
        _this.notifyObservers(id2, status, lastMetadata);
      };
      const onStatusUpdate = () => {
        try {
          _this.notifyObservers(id2, status, lastMetadata);
          const pending = Object.entries(status.signers).filter(([_, s2]) => isSignerStatusPending(s2));
          if (callback && callback(status, onNewMetadata) || pending.length === 0) {
            status.ended = true;
            resolve(status);
            _this.notifyObservers(id2, status, lastMetadata);
            return;
          }
        } catch (e2) {
          console.error("Error while notifying observers", e2);
        }
      };
      let signers = _this.signers;
      if (candidates) {
        const addresses = await Promise.all(_this.signers.map(async function(s2) {
          return s2.getAddress();
        }));
        signers = _this.signers.filter((_, i) => candidates.includes(addresses[i]));
      }
      const accepted = await Promise.allSettled(signers.map(async function(s2) {
        const saddr = await s2.getAddress();
        status.signers[saddr] = {
          state: SignerState.SIGNING,
          request: s2.sign(message, metadata2 != null ? metadata2 : {}).then((signature2) => {
            const suffix = s2.suffix();
            status.signers[saddr] = {
              state: SignerState.SIGNED,
              signature: signature2,
              suffix
            };
            onStatusUpdate();
            return signature2;
          }).catch((error) => {
            status.signers[saddr] = {
              state: SignerState.ERROR,
              error
            };
            onStatusUpdate();
            throw error;
          })
        };
      }));
      for (let i = 0; i < accepted.length; i++) {
        const signer2 = _this.signers[i];
        const promise = accepted[i];
        if (promise.status === "rejected") {
          const address = await signer2.getAddress();
          console.warn(`signer ${address} rejected the request: ${promise.reason}`);
          status.signers[address] = {
            state: SignerState.ERROR,
            error: new Error(`signer ${address} rejected the request: ${promise.reason}`)
          };
        }
      }
      onStatusUpdate();
    });
  }
}
const signhub$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Orchestrator,
  SignerState,
  isSignerStatusPending,
  signers: index$4
}, Symbol.toStringTag, { value: "Module" }));
function _extends$b() {
  return _extends$b = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$b.apply(null, arguments);
}
async function resolveArrayProperties$1(object2) {
  if (Array.isArray(object2)) {
    return Promise.all(object2.map((o2) => resolveProperties$1(o2)));
  }
  return resolveProperties$1(object2);
}
const statusToSignatureParts = (status) => {
  const parts = /* @__PURE__ */ new Map();
  for (const signer2 of Object.keys(status.signers)) {
    const value = status.signers[signer2];
    if (value.state === SignerState.SIGNED) {
      const suffix = getBytes(value.suffix);
      const suffixed = solidityPacked(["bytes", "bytes"], [value.signature, suffix]);
      parts.set(signer2, {
        signature: suffixed,
        isDynamic: suffix.length !== 1 || suffix[0] !== 2
      });
    }
  }
  return parts;
};
class Wallet extends AbstractSigner {
  constructor(options) {
    var _options$provider;
    if (BigInt(options.chainId) === 0n && !options.coders.signature.supportsNoChainId) {
      throw new Error(`Sequence version ${options.config.version} doesn't support chainId 0`);
    }
    super((_options$provider = options.provider) != null ? _options$provider : null);
    this.context = void 0;
    this.config = void 0;
    this.address = void 0;
    this.chainId = void 0;
    this.relayer = void 0;
    this.coders = void 0;
    this.orchestrator = void 0;
    this._reader = void 0;
    this.context = options.context;
    this.config = options.config;
    this.orchestrator = options.orchestrator;
    this.coders = options.coders;
    this.address = options.address;
    this.chainId = options.chainId;
    this.relayer = options.relayer;
    this._reader = options.reader;
  }
  static newWallet(options) {
    const address = index$1$1.context.addressOf(options.context, options.coders.config.imageHashOf(options.config));
    return new Wallet(_extends$b({}, options, {
      address
    }));
  }
  reader() {
    if (this._reader) return this._reader;
    if (!this.provider) throw new Error("Wallet status provider requires a provider");
    return new index$1$1.reader.OnChainReader(this.provider);
  }
  setConfig(config2) {
    this.config = config2;
  }
  setOrchestrator(orchestrator) {
    this.orchestrator = orchestrator;
  }
  setAddress(address) {
    this.address = address;
  }
  getSigners() {
    return this.orchestrator.getSigners();
  }
  async getAddress() {
    return this.address;
  }
  async decorateTransactions(bundle) {
    const decorated = await this.orchestrator.decorateTransactions(bundle);
    if (await this.reader().isDeployed(this.address)) {
      return decorated;
    }
    const transactions2 = [{
      to: decorated.entrypoint,
      data: index$1$1.transaction.encodeBundleExecData(decorated),
      revertOnError: true
    }];
    const deployTx = await this.buildDeployTransaction();
    if (deployTx) {
      transactions2.unshift(...deployTx.transactions);
    }
    return {
      entrypoint: this.context.guestModule,
      chainId: this.chainId,
      intent: decorated.intent,
      transactions: transactions2
    };
  }
  async buildDeployTransaction(metadata2) {
    if (metadata2 != null && metadata2.ignoreDeployed && await this.reader().isDeployed(this.address)) {
      return;
    }
    const imageHash2 = this.coders.config.imageHashOf(this.config);
    if (index$1$1.context.addressOf(this.context, imageHash2) !== this.address) {
      throw new Error(`First address of config ${imageHash2} doesn't match wallet address ${this.address}`);
    }
    const bundle = Wallet.buildDeployTransaction(this.context, imageHash2);
    if (metadata2 != null && metadata2.includeChildren) {
      const childBundle = await this.orchestrator.buildDeployTransaction(metadata2);
      if (childBundle) {
        bundle.transactions = childBundle.transactions.concat(bundle.transactions);
      }
    }
    return bundle;
  }
  async deploy(metadata2) {
    const deployTx = await this.buildDeployTransaction(metadata2);
    if (deployTx === void 0) {
      return;
    }
    if (!this.relayer) throw new Error("Wallet deploy requires a relayer");
    return this.relayer.relay(_extends$b({}, deployTx, {
      chainId: this.chainId,
      intent: {
        id: hexlify(randomBytes(32)),
        wallet: this.address
      }
    }));
  }
  static buildDeployTransaction(context2, imageHash2) {
    const factoryInterface = new Interface(walletContracts.factory.abi);
    return {
      entrypoint: context2.guestModule,
      transactions: [{
        to: context2.factory,
        data: factoryInterface.encodeFunctionData(factoryInterface.getFunction("deploy"), [context2.mainModule, imageHash2]),
        gasLimit: 1e5,
        delegateCall: false,
        revertOnError: true,
        value: 0
      }]
    };
  }
  async buildUpdateConfigurationTransaction(config2) {
    if (this.coders.config.update.isKindUsed) {
      const implementation = await this.reader().implementation(this.address);
      const isLaterUpdate = implementation && implementation === this.context.mainModuleUpgradable;
      return this.coders.config.update.buildTransaction(this.address, config2, this.context, isLaterUpdate ? "later" : "first");
    }
    return this.coders.config.update.buildTransaction(this.address, config2, this.context);
  }
  async getNonce(space = 0) {
    const nonce = await this.reader().nonce(this.address, space);
    if (nonce === void 0) throw new Error("Unable to determine nonce");
    return Number(nonce);
  }
  async signDigest(digest, metadata2) {
    const subdigest = subDigestOf(this.address, this.chainId, digest);
    if (this.coders.config.hasSubdigest(this.config, subdigest)) {
      return this.coders.signature.encodeSigners(this.config, /* @__PURE__ */ new Map(), [subdigest], this.chainId).encoded;
    }
    const childMetadata = _extends$b({}, metadata2, {
      // Keep other metadata fields
      digest,
      chainId: this.chainId,
      address: this.address,
      config: this.config
    });
    const subdigestBytes = getBytes(subdigest);
    const signature2 = await this.orchestrator.signMessage({
      candidates: this.coders.config.signersOf(this.config).map((s2) => s2.address),
      message: subdigestBytes,
      metadata: childMetadata,
      callback: (status, onNewMetadata) => {
        const parts2 = statusToSignatureParts(status);
        const newMetadata = _extends$b({}, childMetadata, {
          parts: parts2
        });
        onNewMetadata(newMetadata);
        return this.coders.signature.hasEnoughSigningPower(this.config, parts2);
      }
    });
    const parts = statusToSignatureParts(signature2);
    return this.coders.signature.encodeSigners(this.config, parts, [], this.chainId).encoded;
  }
  signMessage(message) {
    return this.signDigest(keccak256(message), {
      message
    });
  }
  // XXX This method is not implemented in the original code but required by the AbstractSigner interface
  signTypedData(domain2, types2, value) {
    const digest = encodeTypedDataDigest({
      domain: domain2,
      types: types2,
      message: value
    });
    return this.signDigest(digest);
  }
  signTransactionBundle(bundle) {
    if (bundle.entrypoint !== this.address) {
      throw new Error(`Invalid entrypoint: ${bundle.entrypoint} !== ${this.address}`);
    }
    return this.signTransactions(bundle.transactions, bundle.nonce);
  }
  async fetchNonceOrSpace(nonce) {
    let spaceValue;
    if (nonce && nonce.space !== void 0) {
      spaceValue = BigInt(nonce.space);
    } else if (nonce === void 0) {
      return this.randomNonce();
    } else if (nonce && nonce.serial === true) {
      spaceValue = 0;
    } else {
      return nonce;
    }
    const resultNonce = await this.reader().nonce(this.address, spaceValue);
    if (resultNonce === void 0) throw new Error("Unable to determine nonce");
    return index$1$1.transaction.encodeNonce(spaceValue, resultNonce);
  }
  // Generate nonce with random space
  randomNonce() {
    const randomNonceSpace = BigInt(hexlify(randomBytes(12)));
    const randomNonce = index$1$1.transaction.encodeNonce(randomNonceSpace, 0);
    return randomNonce;
  }
  async signTransactions(txs, nonce, metadata2) {
    const transaction2 = await resolveArrayProperties$1(txs);
    const transactions2 = index$1$1.transaction.fromTransactionish(this.address, transaction2);
    if (transactions2.length === 0) {
      transactions2.push({
        to: this.address,
        data: "0x",
        value: 0,
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true
      });
    }
    const defaultedNonce = await this.fetchNonceOrSpace(nonce);
    const digest = index$1$1.transaction.digestOfTransactions(defaultedNonce, transactions2);
    const meta = _extends$b({
      digest,
      transactions: transactions2
    }, metadata2);
    const signature2 = await this.signDigest(digest, meta);
    return {
      intent: {
        // Maybe is better if signDigest returns the subdigest directly
        id: subDigestOf(this.address, this.chainId, digest),
        wallet: this.address
      },
      chainId: this.chainId,
      transactions: transactions2,
      entrypoint: this.address,
      nonce: defaultedNonce,
      signature: signature2
    };
  }
  async sendSignedTransaction(signedBundle, quote) {
    if (!this.relayer) throw new Error("Wallet sendTransaction requires a relayer");
    return this.relayer.relay(signedBundle, quote);
  }
  // sendTransaction will dispatch the transaction to the relayer for submission to the network.
  // This method is able to send transactions in serial or parallel (default). You can specify
  // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).
  //
  // By default, nonces are generated randomly and assigned so transactioned can be executed
  // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.
  async sendTransaction(txs, options) {
    let nonce;
    if ((options == null ? void 0 : options.nonce) !== void 0) {
      nonce = options.nonce;
    } else if (options != null && options.serial) {
      nonce = {
        serial: true
      };
    } else {
      nonce = this.randomNonce();
    }
    const signed2 = await this.signTransactions(txs, nonce);
    const decorated = await this.decorateTransactions(signed2);
    return this.sendSignedTransaction(decorated, options == null ? void 0 : options.quote);
  }
  async fillGasLimits(txs) {
    const transaction2 = await resolveArrayProperties$1(txs);
    const transactions2 = index$1$1.transaction.fromTransactionish(this.address, transaction2);
    const relayer2 = this.relayer;
    if (!relayer2) throw new Error("Wallet fillGasLimits requires a relayer");
    const simulations = await relayer2.simulate(this.address, ...transactions2);
    return transactions2.map((tx, i) => {
      const gasLimit = tx.gasLimit ? Number(tx.gasLimit) : simulations[i].gasLimit;
      return _extends$b({}, tx, simulations[i], {
        gasLimit
      });
    });
  }
  connect(provider2, relayer2) {
    return new Wallet({
      // Sequence version configurator
      coders: this.coders,
      context: this.context,
      config: this.config,
      chainId: this.chainId,
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this._reader,
      provider: provider2,
      relayer: relayer2 != null ? relayer2 : this.relayer
    });
  }
  signTransaction(transaction2) {
    throw new Error("Method not implemented.");
  }
}
function _extends$a() {
  return _extends$a = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$a.apply(null, arguments);
}
function encodeGasRefundTransaction(option) {
  if (!option) return [];
  const value = BigInt(option.value);
  switch (option.token.type) {
    case relayer_gen.FeeTokenType.UNKNOWN:
      return [{
        delegateCall: false,
        revertOnError: true,
        gasLimit: option.gasLimit,
        to: option.to,
        value: toHexString(value),
        data: "0x"
      }];
    case relayer_gen.FeeTokenType.ERC20_TOKEN:
      if (!option.token.contractAddress) {
        throw new Error(`No contract address for ERC-20 fee option`);
      }
      return [{
        delegateCall: false,
        revertOnError: true,
        gasLimit: option.gasLimit,
        to: option.token.contractAddress,
        value: 0,
        data: new Interface([{
          constant: false,
          inputs: [{
            type: "address"
          }, {
            type: "uint256"
          }],
          name: "transfer",
          outputs: [],
          type: "function"
        }]).encodeFunctionData("transfer", [option.to, toHexString(value)])
      }];
    default:
      throw new Error(`Unhandled fee token type ${option.token.type}`);
  }
}
class AccountSigner {
  constructor(account2, chainId, options) {
    this.account = account2;
    this.chainId = chainId;
    this.options = options;
  }
  get provider() {
    return this.account.providerFor(this.chainId);
  }
  async getAddress() {
    return this.account.address;
  }
  signMessage(message) {
    var _this$options$cantVal, _this$options;
    return this.account.signMessage(message, this.chainId, (_this$options$cantVal = (_this$options = this.options) == null ? void 0 : _this$options.cantValidateBehavior) != null ? _this$options$cantVal : "throw");
  }
  signTypedData(domain2, types2, value) {
    var _this$options$cantVal2, _this$options2;
    return this.account.signTypedData(domain2, types2, value, this.chainId, (_this$options$cantVal2 = (_this$options2 = this.options) == null ? void 0 : _this$options2.cantValidateBehavior) != null ? _this$options$cantVal2 : "throw");
  }
  async defaultSelectFee(_txs, options) {
    if (options.length === 0) return void 0;
    const balanceOfAbi = [{
      constant: true,
      inputs: [{
        type: "address"
      }],
      name: "balanceOf",
      outputs: [{
        type: "uint256"
      }],
      type: "function"
    }];
    for (const option of options) {
      if (option.token.type === relayer_gen.FeeTokenType.UNKNOWN) {
        const balance = await this.getBalance();
        if (balance >= BigInt(option.value)) {
          return option;
        }
      } else if (option.token.contractAddress && option.token.type === relayer_gen.FeeTokenType.ERC20_TOKEN) {
        const token = new Contract(option.token.contractAddress, balanceOfAbi, this.provider);
        const balance = await token.balanceOf(this.account.address);
        if (balance >= BigInt(option.value)) {
          return option;
        }
      } else ;
    }
    throw new Error("No fee option available - not enough balance");
  }
  async sendTransaction(txs, options) {
    var _this$options$stubSig, _this$options3, _this$options$selectF, _this$options4, _this$options5;
    const prepare = await this.account.prepareTransactions({
      txs,
      chainId: this.chainId,
      stubSignatureOverrides: (_this$options$stubSig = (_this$options3 = this.options) == null ? void 0 : _this$options3.stubSignatureOverrides) != null ? _this$options$stubSig : /* @__PURE__ */ new Map(),
      simulateForFeeOptions: options == null ? void 0 : options.simulateForFeeOptions
    });
    const selectMethod = (_this$options$selectF = (_this$options4 = this.options) == null ? void 0 : _this$options4.selectFee) != null ? _this$options$selectF : this.defaultSelectFee.bind(this);
    const feeOption = await selectMethod(txs, prepare.feeOptions);
    const finalTransactions = [...prepare.transactions, ...encodeGasRefundTransaction(feeOption)];
    return this.account.sendTransaction(finalTransactions, this.chainId, prepare.feeQuote, void 0, void 0, ((_this$options5 = this.options) == null ? void 0 : _this$options5.nonceSpace) !== void 0 ? {
      nonceSpace: this.options.nonceSpace
    } : void 0);
  }
  getBalance(blockTag) {
    return this.provider.getBalance(this.account.address, blockTag);
  }
  call(transaction2, blockTag) {
    return this.provider.call(_extends$a({}, transaction2, {
      blockTag
    }));
  }
  async resolveName(name2) {
    const res = await this.provider.resolveName(name2);
    if (!res) throw new Error(`Could not resolve name ${name2}`);
    return res;
  }
  connect(_provider6) {
    throw new Error("Method not implemented.");
  }
  signTransaction(transaction2) {
    throw new Error("Method not implemented.");
  }
  getTransactionCount(blockTag) {
    throw new Error("Method not implemented.");
  }
  estimateGas(transaction2) {
    throw new Error("Method not implemented.");
  }
  getChainId() {
    return Promise.resolve(Number(this.chainId));
  }
  getGasPrice() {
    throw new Error("Method not implemented.");
  }
  getFeeData() {
    throw new Error("Method not implemented.");
  }
  getNonce(blockTag) {
    throw new Error("Method not implemented.");
  }
  populateCall(tx) {
    throw new Error("Method not implemented.");
  }
  checkTransaction(transaction2) {
    throw new Error("Method not implemented.");
  }
  async populateTransaction(tx) {
    throw new Error("Method not implemented.");
  }
  _checkProvider(operation) {
    throw new Error("Method not implemented.");
  }
}
class Chain0Reader {
  async isDeployed(_wallet) {
    return false;
  }
  async implementation(_wallet) {
    return void 0;
  }
  async imageHash(_wallet) {
    return void 0;
  }
  async nonce(_wallet, _space) {
    return 0n;
  }
  async isValidSignature(_wallet, _digest, _signature) {
    throw new Error("Method not supported.");
  }
}
class Account {
  constructor(options) {
    this.address = void 0;
    this.networks = void 0;
    this.tracker = void 0;
    this.contexts = void 0;
    this.migrator = void 0;
    this.migrations = void 0;
    this.orchestrator = void 0;
    this.jwt = void 0;
    this.projectAccessKey = void 0;
    this.address = getAddress(options.address);
    this.contexts = options.contexts;
    this.tracker = options.tracker;
    this.networks = options.networks;
    this.orchestrator = options.orchestrator;
    this.jwt = options.jwt;
    this.projectAccessKey = options.projectAccessKey;
    this.migrations = options.migrations || defaults$1.DefaultMigrations;
    this.migrator = new migrator.Migrator(options.tracker, this.migrations, this.contexts);
  }
  getSigner(chainId, options) {
    return new AccountSigner(this, chainId, options);
  }
  static async new(options) {
    var _options$migrations;
    const mig = new migrator.Migrator(options.tracker, (_options$migrations = options.migrations) != null ? _options$migrations : defaults$1.DefaultMigrations, options.contexts);
    const lastMigration = mig.lastMigration();
    const lastCoder = lastMigration.configCoder;
    const config2 = lastCoder.fromSimple(options.config);
    const imageHash2 = lastCoder.imageHashOf(config2);
    const context2 = options.contexts[lastMigration.version];
    const address = index$1$1.context.addressOf(context2, imageHash2);
    await options.tracker.saveCounterfactualWallet({
      config: config2,
      context: Object.values(options.contexts)
    });
    return new Account({
      address,
      tracker: options.tracker,
      contexts: options.contexts,
      networks: options.networks,
      orchestrator: options.orchestrator,
      migrations: options.migrations,
      projectAccessKey: options.projectAccessKey
    });
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  get version() {
    return this.migrator.lastMigration().version;
  }
  get coders() {
    const lastMigration = this.migrator.lastMigration();
    return {
      signature: lastMigration.signatureCoder,
      config: lastMigration.configCoder
    };
  }
  network(chainId) {
    const tcid = BigInt(chainId);
    const found = this.networks.find((n2) => tcid === BigInt(n2.chainId));
    if (!found) throw new Error(`Network not found for chainId ${chainId}`);
    return found;
  }
  providerFor(chainId) {
    const found = this.network(chainId);
    if (!found.provider && !found.rpcUrl) {
      throw new Error(`Provider not found for chainId ${chainId}`);
    }
    const network2 = new Network(found.name, found.chainId);
    return found.provider || new JsonRpcProvider$1(getFetchRequest(found.rpcUrl, this.projectAccessKey, this.jwt), network2, {
      staticNetwork: network2
    });
  }
  reader(chainId) {
    if (BigInt(chainId) === 0n) {
      return new Chain0Reader();
    }
    return new index$1$1.reader.OnChainReader(this.providerFor(chainId));
  }
  relayer(chainId) {
    const found = this.network(chainId);
    if (!found.relayer) throw new Error(`Relayer not found for chainId ${chainId}`);
    if (isRelayer(found.relayer)) return found.relayer;
    return new RpcRelayer(_extends$a({}, found.relayer, this.projectAccessKey ? {
      projectAccessKey: this.projectAccessKey
    } : {
      jwtAuth: this.jwt
    }));
  }
  setOrchestrator(orchestrator) {
    this.orchestrator = orchestrator;
  }
  setJwt(jwt) {
    this.jwt = jwt;
  }
  contextFor(version2) {
    const ctx = this.contexts[version2];
    if (!ctx) throw new Error(`Context not found for version ${version2}`);
    return ctx;
  }
  walletForStatus(chainId, status) {
    const coder = index$6.coderFor(status.version);
    return this.walletFor(chainId, this.contextFor(status.version), status.config, coder);
  }
  walletFor(chainId, context2, config2, coders2) {
    const isNetworkZero = BigInt(chainId) === 0n;
    return new Wallet({
      config: config2,
      context: context2,
      chainId,
      coders: coders2,
      relayer: isNetworkZero ? void 0 : this.relayer(chainId),
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this.reader(chainId)
    });
  }
  // Get the status of the account on a given network
  // this does the following process:
  // 1. Get the current on-chain status of the wallet (version + imageHash)
  // 2. Get any pending migrations that have been signed by the wallet
  // 3. Get any pending configuration updates that have been signed by the wallet
  // 4. Fetch reverse lookups for both on-chain and pending configurations
  async status(chainId, longestPath = false) {
    var _this = this;
    const isDeployedPromise = this.reader(chainId).isDeployed(this.address);
    const counterfactualImageHashPromise = this.tracker.imageHashOfCounterfactualWallet({
      wallet: this.address
    }).then((r2) => {
      if (!r2) throw new Error(`Counterfactual imageHash not found for wallet ${this.address}`);
      return r2;
    });
    const counterFactualVersionPromise = counterfactualImageHashPromise.then((r2) => {
      return version$2.counterfactualVersion(this.address, r2.imageHash, Object.values(this.contexts));
    });
    const onChainVersionPromise = async function() {
      const isDeployed2 = await isDeployedPromise;
      if (!isDeployed2) return counterFactualVersionPromise;
      const implementation = await _this.reader(chainId).implementation(_this.address);
      if (!implementation) throw new Error(`Implementation not found for wallet ${_this.address}`);
      const versions = Object.values(_this.contexts);
      for (let i = 0; i < versions.length; i++) {
        if (versions[i].mainModule === implementation || versions[i].mainModuleUpgradable === implementation) {
          return versions[i].version;
        }
      }
      throw new Error(`Version not found for implementation ${implementation}`);
    }();
    const onChainImageHashPromise = async function() {
      const deployedImageHash = await _this.reader(chainId).imageHash(_this.address);
      if (deployedImageHash) return deployedImageHash;
      const counterfactualImageHash2 = await counterfactualImageHashPromise;
      if (counterfactualImageHash2) return counterfactualImageHash2.imageHash;
      throw new Error(`On-chain imageHash not found for wallet ${_this.address}`);
    }();
    const onChainConfigPromise = async function() {
      const onChainImageHash2 = await onChainImageHashPromise;
      const onChainConfig = await _this.tracker.configOfImageHash({
        imageHash: onChainImageHash2
      });
      if (onChainConfig) return onChainConfig;
      throw new Error(`On-chain config not found for imageHash ${onChainImageHash2}`);
    }();
    const onChainVersion = await onChainVersionPromise;
    const onChainImageHash = await onChainImageHashPromise;
    let fromImageHash = onChainImageHash;
    let lastVersion = onChainVersion;
    let signedMigrations = [];
    if (onChainVersion !== this.version) {
      const presignedMigrate = await this.migrator.getAllMigratePresignedTransaction({
        address: this.address,
        fromImageHash: onChainImageHash,
        fromVersion: onChainVersion,
        chainId
      });
      fromImageHash = presignedMigrate.lastImageHash;
      lastVersion = presignedMigrate.lastVersion;
      signedMigrations = presignedMigrate.signedMigrations;
    }
    const presigned = await this.tracker.loadPresignedConfiguration({
      wallet: this.address,
      fromImageHash,
      longestPath
    });
    const imageHash2 = presigned && presigned.length > 0 ? presigned[presigned.length - 1].nextImageHash : fromImageHash;
    const config2 = await this.tracker.configOfImageHash({
      imageHash: imageHash2
    });
    if (!config2) {
      throw new Error(`Config not found for imageHash ${imageHash2}`);
    }
    const isDeployed = await isDeployedPromise;
    const counterfactualImageHash = await counterfactualImageHashPromise;
    const checkpoint = index$6.coderFor(lastVersion).config.checkpointOf(config2);
    return {
      original: _extends$a({}, counterfactualImageHash, {
        version: await counterFactualVersionPromise
      }),
      onChain: {
        imageHash: onChainImageHash,
        config: await onChainConfigPromise,
        version: onChainVersion,
        deployed: isDeployed
      },
      fullyMigrated: lastVersion === this.version,
      signedMigrations,
      version: lastVersion,
      presignedConfigurations: presigned,
      imageHash: imageHash2,
      config: config2,
      checkpoint,
      canOnchainValidate: onChainVersion === this.version && isDeployed
    };
  }
  mustBeFullyMigrated(status) {
    if (!status.fullyMigrated) {
      throw new Error(`Wallet ${this.address} is not fully migrated`);
    }
  }
  async predecorateSignedTransactions(status, chainId) {
    const bundles = await this.orchestrator.predecorateSignedTransactions({
      chainId
    });
    const predecorated = await this.predecorateTransactions([], status, chainId);
    if (index$1$1.transaction.fromTransactionish(this.address, predecorated).length > 0) {
      bundles.push(await this.signTransactions(predecorated, chainId));
    }
    return bundles;
  }
  async predecorateTransactions(txs, status, chainId) {
    if (status.onChain.imageHash !== status.imageHash) {
      const wallet = this.walletForStatus(chainId, status);
      const updateConfig = await wallet.buildUpdateConfigurationTransaction(status.config);
      return [Array.isArray(txs) ? txs : [txs], updateConfig.transactions].flat();
    }
    return txs;
  }
  async decorateTransactions(bundles, status, chainId) {
    var _chainId4, _bundles$;
    if (!Array.isArray(bundles)) {
      return this.decorateTransactions([bundles], status, chainId);
    }
    chainId = (_chainId4 = chainId) != null ? _chainId4 : bundles[0].chainId;
    const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId);
    const hasBootstrapTxs = bootstrapBundle.transactions.length > 0;
    if (!hasBootstrapTxs && bundles.length === 1) {
      return bundles[0];
    }
    const {
      entrypoint
    } = hasBootstrapTxs ? bootstrapBundle : bundles[0];
    const decoratedBundle = {
      entrypoint,
      chainId,
      // Intent of the first bundle is used
      intent: (_bundles$ = bundles[0]) == null ? void 0 : _bundles$.intent,
      transactions: [...bootstrapBundle.transactions, ...bundles.map((bundle) => ({
        to: bundle.entrypoint,
        data: index$1$1.transaction.encodeBundleExecData(bundle),
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true,
        value: 0
      }))]
    };
    if (!status.onChain.deployed) {
      const id2 = index$1$1.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, chainId, decoratedBundle.transactions);
      if (decoratedBundle.intent === void 0) {
        decoratedBundle.intent = {
          id: id2,
          wallet: this.address
        };
      } else {
        decoratedBundle.intent.id = id2;
      }
    }
    return decoratedBundle;
  }
  async decorateSignature(signature2, status) {
    if (!status.presignedConfigurations || status.presignedConfigurations.length === 0) {
      return signature2;
    }
    const coder = this.coders.signature;
    const chain = status.presignedConfigurations.map((c2) => c2.signature);
    const chainedSignature = coder.chainSignatures(signature2, chain);
    return coder.trim(chainedSignature);
  }
  async publishWitness() {
    const digest = id$1(`This is a Sequence account woo! ${Date.now()}`);
    const signature2 = await this.signDigest(digest, 0, false);
    const decoded = this.coders.signature.decode(signature2);
    const signatures = this.coders.signature.signaturesOfDecoded(decoded);
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest,
      chainId: 0,
      signatures
    });
  }
  async signDigest(digest, chainId, decorate = true, cantValidateBehavior = "ignore", metadata2) {
    const chainRef = BigInt(chainId) === 0n ? this.networks[0].chainId : chainId;
    const status = await this.status(chainRef);
    this.mustBeFullyMigrated(status);
    if (!status.canOnchainValidate && cantValidateBehavior === "throw") {
      throw new Error("Wallet cannot validate onchain");
    }
    const wallet = this.walletForStatus(chainId, status);
    const signature2 = await wallet.signDigest(digest, metadata2);
    const decorated = decorate ? this.decorateSignature(signature2, status) : signature2;
    if (!status.canOnchainValidate) {
      switch (cantValidateBehavior) {
        case "ignore":
          return decorated;
        case "eip6492":
          return this.buildEIP6492Signature(await decorated, status, chainId);
      }
    }
    return decorated;
  }
  buildOnChainSignature(digest) {
    const subdigest = index$1$1.signature.subdigestOf({
      digest: hexlify(digest),
      chainId: 0,
      address: this.address
    });
    const hexSubdigest = hexlify(subdigest);
    const config2 = this.coders.config.fromSimple({
      // Threshold *only* needs to be > 0, this is not a magic number
      // we only use 2 ** 15 because it may lead to lower gas costs in some chains
      threshold: 32768,
      checkpoint: 0,
      signers: [],
      subdigests: [hexSubdigest]
    });
    const walletInterface = new Interface(walletContracts.mainModule.abi);
    const bundle = {
      entrypoint: this.address,
      transactions: [{
        to: this.address,
        data: walletInterface.encodeFunctionData(
          // *NEVER* use updateImageHash here, as it would effectively destroy the wallet
          // setExtraImageHash sets an additional imageHash, without changing the current one
          "setExtraImageHash",
          [
            this.coders.config.imageHashOf(config2),
            // 2 ** 255 instead of max uint256, to have more zeros in the calldata
            "57896044618658097711785492504343953926634992332820282019728792003956564819968"
          ]
        ),
        // Conservative gas limit, used because the current relayer
        // has trouble estimating gas for this transaction
        gasLimit: 25e4
      }]
    };
    this.tracker.saveWalletConfig({
      config: config2
    });
    const signature2 = this.coders.signature.encodeSigners(config2, /* @__PURE__ */ new Map(), [hexSubdigest], 0).encoded;
    return {
      bundle,
      signature: signature2
    };
  }
  async buildEIP6492Signature(signature2, status, chainId) {
    const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId);
    if (bootstrapBundle.transactions.length === 0) {
      throw new Error("Cannot build EIP-6492 signature without bootstrap transactions");
    }
    const encoded = AbiCoder.defaultAbiCoder().encode(["address", "bytes", "bytes"], [bootstrapBundle.entrypoint, index$1$1.transaction.encodeBundleExecData(bootstrapBundle), signature2]);
    return solidityPacked(["bytes", "bytes32"], [encoded, index$1$1.EIP6492.EIP_6492_SUFFIX]);
  }
  async editConfig(changes) {
    const currentConfig = await this.status(0).then((s2) => s2.config);
    const newConfig = this.coders.config.editConfig(currentConfig, _extends$a({}, changes, {
      checkpoint: this.coders.config.checkpointOf(currentConfig) + 1n
    }));
    return this.updateConfig(newConfig);
  }
  async updateConfig(config2) {
    if (!this.coders.config.isWalletConfig(config2)) {
      throw new Error(`Invalid config for wallet ${this.address}`);
    }
    const nextImageHash = this.coders.config.imageHashOf(config2);
    const updateStruct = this.coders.signature.hashSetImageHash(nextImageHash);
    const signature2 = await this.signDigest(updateStruct, 0, false);
    await this.tracker.savePresignedConfiguration({
      wallet: this.address,
      nextConfig: config2,
      signature: signature2
    });
    const reverseConfig = await this.tracker.configOfImageHash({
      imageHash: nextImageHash,
      noCache: true
    });
    if (!reverseConfig || this.coders.config.imageHashOf(reverseConfig) !== nextImageHash) {
      throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`);
    }
  }
  /**
   *  This method is used to bootstrap the wallet on a given chain.
   *  this deploys the wallets and executes all the necessary transactions
   *  for that wallet to start working with the given version.
   *
   *  This usually involves: (a) deploying the wallet, (b) executing migrations
   *
   *  Notice: It should NOT explicitly include chained signatures. Unless internally used
   *  by any of the migrations.
   *
   */
  async buildBootstrapTransactions(status, chainId) {
    var _bundle$transactions;
    const bundle = await this.orchestrator.buildDeployTransaction({
      chainId
    });
    const transactions2 = (_bundle$transactions = bundle == null ? void 0 : bundle.transactions) != null ? _bundle$transactions : [];
    if (!status.onChain.deployed) {
      const deployTransaction = Wallet.buildDeployTransaction(status.original.context, status.original.imageHash);
      transactions2.push(...deployTransaction.transactions);
    }
    transactions2.push(...status.signedMigrations.map((m2) => ({
      to: m2.tx.entrypoint,
      data: index$1$1.transaction.encodeBundleExecData(m2.tx),
      value: 0,
      gasLimit: 0,
      revertOnError: true,
      delegateCall: false
    })));
    const id2 = status.signedMigrations.length > 0 ? status.signedMigrations[0].tx.intent.id : index$1$1.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, chainId, transactions2);
    const {
      guestModule
    } = this.contextFor(status.version);
    return {
      entrypoint: guestModule,
      transactions: transactions2,
      chainId,
      intent: {
        id: id2,
        wallet: this.address
      }
    };
  }
  async bootstrapTransactions(chainId, prestatus) {
    const status = prestatus || await this.status(chainId);
    return this.buildBootstrapTransactions(status, chainId);
  }
  async doBootstrap(chainId, feeQuote, prestatus) {
    const bootstrapTxs = await this.bootstrapTransactions(chainId, prestatus);
    return this.relayer(chainId).relay(_extends$a({}, bootstrapTxs, {
      chainId
    }), feeQuote);
  }
  signMessage(message, chainId, cantValidateBehavior = "ignore") {
    return this.signDigest(keccak256(message), chainId, true, cantValidateBehavior);
  }
  async signTransactions(txs, chainId, pstatus, options) {
    const status = pstatus || await this.status(chainId);
    this.mustBeFullyMigrated(status);
    const wallet = this.walletForStatus(chainId, status);
    const metadata2 = {
      address: this.address,
      digest: "",
      // Set in wallet.signTransactions
      chainId,
      config: {
        version: this.version
      },
      decorate: true,
      cantValidateBehavior: "ignore"
    };
    const nonceOptions = options != null && options.serial ? {
      serial: true
    } : (options == null ? void 0 : options.nonceSpace) !== void 0 ? {
      space: options.nonceSpace
    } : void 0;
    const signed2 = await wallet.signTransactions(txs, nonceOptions, metadata2);
    return _extends$a({}, signed2, {
      signature: await this.decorateSignature(signed2.signature, status)
    });
  }
  async signMigrations(chainId, editConfig) {
    const status = await this.status(chainId);
    if (status.fullyMigrated) return false;
    const wallet = this.walletForStatus(chainId, status);
    const nextConfig = editConfig(wallet.config);
    const signed2 = await this.migrator.signNextMigration(this.address, status.version, wallet, nextConfig);
    if (!signed2) return false;
    await this.tracker.saveWalletConfig({
      config: nextConfig
    });
    const nextCoder = index$6.coderFor(nextConfig.version).config;
    const nextImageHash = nextCoder.imageHashOf(nextConfig);
    const reverseConfig = await this.tracker.configOfImageHash({
      imageHash: nextImageHash,
      noCache: true
    });
    if (!reverseConfig || nextCoder.imageHashOf(reverseConfig) !== nextImageHash) {
      throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`);
    }
    await this.tracker.saveMigration(this.address, signed2, this.contexts);
    return true;
  }
  async signAllMigrations(editConfig) {
    var _this2 = this;
    const failedChains = [];
    const signedMigrations = await Promise.all(this.networks.map(async function(n2) {
      try {
        return await _this2.signMigrations(n2.chainId, editConfig);
      } catch (error) {
        console.warn(`Failed to sign migrations for chain ${n2.chainId}`, error);
        failedChains.push(n2.chainId);
        return null;
      }
    }));
    const successfulSignedMigrations = signedMigrations.filter((migration2) => migration2 !== null);
    return {
      signedMigrations: successfulSignedMigrations,
      failedChains
    };
  }
  async isMigratedAllChains() {
    var _this3 = this;
    const failedChains = [];
    const statuses = await Promise.all(this.networks.map(async function(n2) {
      try {
        return await _this3.status(n2.chainId);
      } catch (error) {
        failedChains.push(n2.chainId);
        console.warn(`Failed to get status for chain ${n2.chainId}`, error);
        return {
          fullyMigrated: true
        };
      }
    }));
    const migratedAllChains = statuses.every((s2) => s2.fullyMigrated);
    return {
      migratedAllChains,
      failedChains
    };
  }
  async sendSignedTransactions(signedBundle, chainId, quote, pstatus, callback) {
    if (!Array.isArray(signedBundle)) {
      return this.sendSignedTransactions([signedBundle], chainId, quote, pstatus, callback);
    }
    const status = pstatus || await this.status(chainId);
    this.mustBeFullyMigrated(status);
    const decoratedBundle = await this.decorateTransactions(signedBundle, status, chainId);
    callback == null || callback(decoratedBundle);
    return this.relayer(chainId).relay(decoratedBundle, quote);
  }
  async fillGasLimits(txs, chainId, status) {
    const wallet = this.walletForStatus(chainId, status || await this.status(chainId));
    return wallet.fillGasLimits(txs);
  }
  async gasRefundQuotes(txs, chainId, stubSignatureOverrides, status, options) {
    const wstatus = status || await this.status(chainId);
    const wallet = this.walletForStatus(chainId, wstatus);
    const predecorated = await this.predecorateTransactions(txs, wstatus, chainId);
    const transactions2 = index$1$1.transaction.fromTransactionish(this.address, predecorated);
    const stubSignature = wallet.coders.config.buildStubSignature(wallet.config, stubSignatureOverrides);
    const intentId = hexlify(randomBytes(32));
    const signedBundle = {
      chainId,
      intent: {
        id: intentId,
        wallet: this.address
      },
      signature: stubSignature,
      transactions: transactions2,
      entrypoint: this.address,
      nonce: 0
      // The relayer also ignored the nonce
    };
    const decoratedBundle = await this.decorateTransactions(signedBundle, wstatus);
    const data = index$1$1.transaction.encodeBundleExecData(decoratedBundle);
    const res = await this.relayer(chainId).getFeeOptionsRaw(decoratedBundle.entrypoint, data, options);
    return _extends$a({}, res, {
      decorated: decoratedBundle
    });
  }
  async prepareTransactions(args) {
    const status = await this.status(args.chainId);
    const transactions2 = await this.fillGasLimits(args.txs, args.chainId, status);
    const gasRefundQuote = await this.gasRefundQuotes(transactions2, args.chainId, args.stubSignatureOverrides, status, {
      simulate: args.simulateForFeeOptions
    });
    const flatDecorated = index$1$1.transaction.unwind(this.address, gasRefundQuote.decorated.transactions);
    return {
      transactions: transactions2,
      flatDecorated,
      feeOptions: gasRefundQuote.options,
      feeQuote: gasRefundQuote.quote
    };
  }
  async sendTransaction(txs, chainId, quote, skipPreDecorate = false, callback, options) {
    const status = await this.status(chainId);
    const predecorated = skipPreDecorate ? txs : await this.predecorateTransactions(txs, status, chainId);
    const hasTxs = index$1$1.transaction.fromTransactionish(this.address, predecorated).length > 0;
    const signed2 = hasTxs ? await this.signTransactions(predecorated, chainId, void 0, options) : void 0;
    const childBundles = await this.orchestrator.predecorateSignedTransactions({
      chainId
    });
    const bundles = [];
    if (signed2 !== void 0 && signed2.transactions.length > 0) {
      bundles.push(signed2);
    }
    bundles.push(...childBundles.filter((b2) => b2.transactions.length > 0));
    return this.sendSignedTransactions(bundles, chainId, quote, void 0, callback);
  }
  async signTypedData(domain2, types2, message, chainId, cantValidateBehavior = "ignore") {
    const digest = encodeTypedDataDigest({
      domain: domain2,
      types: types2,
      message
    });
    return this.signDigest(digest, chainId, true, cantValidateBehavior);
  }
  async getSigners() {
    var _this4 = this;
    const last = (ts) => ts.length ? ts[ts.length - 1] : void 0;
    return (await Promise.all(this.networks.map(async function({
      chainId,
      name: name2
    }) {
      try {
        var _last;
        const status = await _this4.status(chainId);
        let latestImageHash = (_last = last(status.presignedConfigurations)) == null ? void 0 : _last.nextImageHash;
        if (!latestImageHash) {
          if (status.onChain.version !== status.version) {
            const migration2 = last(status.signedMigrations);
            if (migration2) {
              const {
                toVersion,
                toConfig
              } = migration2;
              const _coder = index$6.genericCoderFor(toVersion);
              latestImageHash = _coder.config.imageHashOf(toConfig);
            }
          }
        }
        if (!latestImageHash) {
          latestImageHash = status.onChain.imageHash;
        }
        const latestConfig = await _this4.tracker.configOfImageHash({
          imageHash: latestImageHash
        });
        if (!latestConfig) {
          throw new Error(`unable to find config for image hash ${latestImageHash}`);
        }
        const coder = index$6.genericCoderFor(latestConfig.version);
        const signers = coder.config.signersOf(latestConfig);
        return signers.map((signer2) => _extends$a({}, signer2, {
          network: chainId
        }));
      } catch (error) {
        console.warn(`unable to get signers on network ${chainId} ${name2}`, error);
        return [];
      }
    }))).flat();
  }
  async getAllSigners() {
    var _this5 = this;
    const allSigners = [];
    await Promise.all(this.networks.map(async function(network2) {
      const chainId = network2.chainId;
      const status = await _this5.status(chainId, true);
      const fullChain = [status.onChain.imageHash, ...status.onChain.version !== status.version ? status.signedMigrations.map((m2) => index$6.coderFor(m2.toVersion).config.imageHashOf(m2.toConfig)) : [], ...status.presignedConfigurations.map((update) => update.nextImageHash)];
      return Promise.all(fullChain.map(async function(nextImageHash, iconf) {
        const isLast = iconf === fullChain.length - 1;
        const config2 = await _this5.tracker.configOfImageHash({
          imageHash: nextImageHash
        });
        if (!config2) {
          console.warn(`AllSigners may be incomplete, config not found for imageHash ${nextImageHash}`);
          return;
        }
        const coder = index$6.genericCoderFor(config2.version);
        const signers = coder.config.signersOf(config2);
        signers.forEach((signer2) => {
          const exists2 = allSigners.find((s2) => s2.address === signer2.address && s2.network === chainId);
          if (exists2 && isLast && exists2.flaggedForRemoval) {
            exists2.flaggedForRemoval = false;
            return;
          }
          if (exists2) return;
          allSigners.push({
            address: signer2.address,
            weight: signer2.weight,
            network: chainId,
            flaggedForRemoval: !isLast
          });
        });
      }));
    }));
    return allSigners;
  }
}
function isAccount(value) {
  return value instanceof Account;
}
const account$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account,
  isAccount
}, Symbol.toStringTag, { value: "Module" }));
function _extends$9() {
  return _extends$9 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$9.apply(null, arguments);
}
const WebRPCVersion$1 = "v1";
const WebRPCSchemaVersion$1 = "v0.4.0";
const WebRPCSchemaHash$1 = "cae735346d8e5c3dce48dce9f85116989b6beffd";
let ContractType$1 = /* @__PURE__ */ function(ContractType2) {
  ContractType2["UNKNOWN"] = "UNKNOWN";
  ContractType2["NATIVE"] = "NATIVE";
  ContractType2["ERC20"] = "ERC20";
  ContractType2["ERC721"] = "ERC721";
  ContractType2["ERC1155"] = "ERC1155";
  ContractType2["SEQUENCE_WALLET"] = "SEQUENCE_WALLET";
  ContractType2["ERC20_BRIDGE"] = "ERC20_BRIDGE";
  ContractType2["ERC721_BRIDGE"] = "ERC721_BRIDGE";
  ContractType2["ERC1155_BRIDGE"] = "ERC1155_BRIDGE";
  ContractType2["SEQ_MARKETPLACE"] = "SEQ_MARKETPLACE";
  return ContractType2;
}({});
let EventLogType = /* @__PURE__ */ function(EventLogType2) {
  EventLogType2["UNKNOWN"] = "UNKNOWN";
  EventLogType2["BLOCK_ADDED"] = "BLOCK_ADDED";
  EventLogType2["BLOCK_REMOVED"] = "BLOCK_REMOVED";
  return EventLogType2;
}({});
let EventLogDataType = /* @__PURE__ */ function(EventLogDataType2) {
  EventLogDataType2["EVENT"] = "EVENT";
  EventLogDataType2["TOKEN_TRANSFER"] = "TOKEN_TRANSFER";
  EventLogDataType2["NATIVE_TOKEN_TRANSFER"] = "NATIVE_TOKEN_TRANSFER";
  EventLogDataType2["SEQUENCE_TXN"] = "SEQUENCE_TXN";
  return EventLogDataType2;
}({});
let OrderStatus = /* @__PURE__ */ function(OrderStatus2) {
  OrderStatus2["OPEN"] = "OPEN";
  OrderStatus2["CLOSED"] = "CLOSED";
  OrderStatus2["CANCELLED"] = "CANCELLED";
  return OrderStatus2;
}({});
let TxnTransferType = /* @__PURE__ */ function(TxnTransferType2) {
  TxnTransferType2["UNKNOWN"] = "UNKNOWN";
  TxnTransferType2["SEND"] = "SEND";
  TxnTransferType2["RECEIVE"] = "RECEIVE";
  return TxnTransferType2;
}({});
let TransactionStatus = /* @__PURE__ */ function(TransactionStatus2) {
  TransactionStatus2["FAILED"] = "FAILED";
  TransactionStatus2["SUCCESSFUL"] = "SUCCESSFUL";
  return TransactionStatus2;
}({});
let TransactionType = /* @__PURE__ */ function(TransactionType2) {
  TransactionType2["LegacyTxnType"] = "LegacyTxnType";
  TransactionType2["AccessListTxnType"] = "AccessListTxnType";
  TransactionType2["DynamicFeeTxnType"] = "DynamicFeeTxnType";
  return TransactionType2;
}({});
let SortOrder = /* @__PURE__ */ function(SortOrder2) {
  SortOrder2["DESC"] = "DESC";
  SortOrder2["ASC"] = "ASC";
  return SortOrder2;
}({});
let ContractVerificationStatus = /* @__PURE__ */ function(ContractVerificationStatus2) {
  ContractVerificationStatus2["VERIFIED"] = "VERIFIED";
  ContractVerificationStatus2["UNVERIFIED"] = "UNVERIFIED";
  ContractVerificationStatus2["ALL"] = "ALL";
  return ContractVerificationStatus2;
}({});
class Indexer {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Indexer/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            version: _data6.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getChainID = (headers, signal) => {
      return this.fetch(this.url("GetChainID"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            chainID: _data6.chainID
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getEtherBalance = (args, headers, signal) => {
      return this.fetch(this.url("GetEtherBalance"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            balance: _data6.balance
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getNativeTokenBalance = (args, headers, signal) => {
      return this.fetch(this.url("GetNativeTokenBalance"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            balance: _data6.balance
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenBalancesSummary = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenBalancesSummary"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            balances: _data6.balances
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenBalancesDetails = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenBalancesDetails"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            balances: _data6.balances
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenBalancesByContract = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenBalancesByContract"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            balances: _data6.balances
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenBalances = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenBalances"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            balances: _data6.balances
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenSupplies = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenSupplies"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            contractType: _data6.contractType,
            tokenIDs: _data6.tokenIDs
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenSuppliesMap = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenSuppliesMap"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            supplies: _data6.supplies
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getBalanceUpdates = (args, headers, signal) => {
      return this.fetch(this.url("GetBalanceUpdates"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            balances: _data6.balances
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTransactionHistory = (args, headers, signal) => {
      return this.fetch(this.url("GetTransactionHistory"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            transactions: _data6.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.syncBalance = (args, headers, signal) => {
      return this.fetch(this.url("SyncBalance"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.fetchTransactionReceipt = (args, headers, signal) => {
      return this.fetch(this.url("FetchTransactionReceipt"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            receipt: _data6.receipt
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getOrderbookOrders = (args, headers, signal) => {
      return this.fetch(this.url("GetOrderbookOrders"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            page: _data6.page,
            orders: _data6.orders
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTopOrders = (args, headers, signal) => {
      return this.fetch(this.url("GetTopOrders"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            orders: _data6.orders
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.fetchTransactionReceiptWithFilter = (args, headers, signal) => {
      return this.fetch(this.url("FetchTransactionReceiptWithFilter"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            receipt: _data6.receipt
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url("GetAllWebhookListeners"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            listeners: _data6.listeners
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("GetWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            listener: _data6.listener
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("AddWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            status: _data6.status,
            listener: _data6.listener
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("UpdateWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("RemoveWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.toggleWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("ToggleWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            webhookListener: _data6.webhookListener
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.pauseAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url("PauseAllWebhookListeners"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resumeAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url("ResumeAllWebhookListeners"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.subscribeReceipts = (args, options) => {
      const _fetch = () => this.fetch(this.url("SubscribeReceipts"), createHTTPRequest$5(args, options.headers, options.signal)).then(async function(res) {
        await sseResponse(res, options, _fetch);
      }, (error) => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.subscribeEvents = (args, options) => {
      const _fetch = () => this.fetch(this.url("SubscribeEvents"), createHTTPRequest$5(args, options.headers, options.signal)).then(async function(res) {
        await sseResponse(res, options, _fetch);
      }, (error) => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.subscribeBalanceUpdates = (args, options) => {
      const _fetch = () => this.fetch(this.url("SubscribeBalanceUpdates"), createHTTPRequest$5(args, options.headers, options.signal)).then(async function(res) {
        await sseResponse(res, options, _fetch);
      }, (error) => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.hostname = hostname.replace(/\/*$/, "");
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const sseResponse = async (res, options, retryFetch) => {
  const {
    onMessage,
    onOpen,
    onClose,
    onError
  } = options;
  if (!res.ok) {
    try {
      await buildResponse$5(res);
    } catch (error) {
      onError(error, retryFetch);
    }
    return;
  }
  if (!res.body) {
    onError(WebrpcBadResponseError$5.new({
      status: res.status,
      cause: "Invalid response, missing body"
    }), retryFetch);
    return;
  }
  onOpen && onOpen();
  const reader2 = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer2 = "";
  let lastReadTime = Date.now();
  const timeout = (10 + 1) * 1e3;
  let timeoutError = false;
  const intervalId = setInterval(() => {
    if (Date.now() - lastReadTime > timeout) {
      timeoutError = true;
      clearInterval(intervalId);
      reader2.releaseLock();
    }
  }, timeout);
  while (true) {
    let value;
    let done;
    try {
      ;
      ({
        value,
        done
      } = await reader2.read());
      if (timeoutError) throw new Error("Timeout, no data or heartbeat received");
      lastReadTime = Date.now();
      buffer2 += decoder.decode(value, {
        stream: true
      });
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      if (error instanceof DOMException && error.name === "AbortError") {
        onError(WebrpcRequestFailedError$5.new({
          message: "AbortError",
          cause: `AbortError: ${message}`
        }), () => {
          throw new Error("Abort signal cannot be used to reconnect");
        });
      } else {
        onError(WebrpcStreamLostError$5.new({
          cause: `reader.read(): ${message}`
        }), retryFetch);
      }
      return;
    }
    let lines = buffer2.split("\n");
    for (let i = 0; i < lines.length - 1; i++) {
      if (lines[i].length == 0) {
        continue;
      }
      let data;
      try {
        data = JSON.parse(lines[i]);
        if (data.hasOwnProperty("webrpcError")) {
          const error = data.webrpcError;
          const code2 = typeof error.code === "number" ? error.code : 0;
          onError((webrpcErrorByCode$5[code2] || WebrpcError$5).new(error), retryFetch);
          return;
        }
      } catch (error) {
        if (error instanceof Error && error.message === "Abort signal cannot be used to reconnect") {
          throw error;
        }
        onError(WebrpcBadResponseError$5.new({
          status: res.status,
          // @ts-ignore
          cause: `JSON.parse(): ${error.message}`
        }), retryFetch);
      }
      onMessage(data);
    }
    if (!done) {
      buffer2 = lines[lines.length - 1];
      continue;
    }
    onClose && onClose();
    return;
  }
};
const createHTTPRequest$5 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$9({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$5 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$5.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$5[code2] || WebrpcError$5).new(data);
    }
    return data;
  });
};
let WebrpcError$5 = class WebrpcError3 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError3.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$5 = class WebrpcEndpointError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError3.prototype);
  }
};
let WebrpcRequestFailedError$5 = class WebrpcRequestFailedError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError3.prototype);
  }
};
let WebrpcBadRouteError$5 = class WebrpcBadRouteError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError3.prototype);
  }
};
let WebrpcBadMethodError$5 = class WebrpcBadMethodError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError3.prototype);
  }
};
let WebrpcBadRequestError$5 = class WebrpcBadRequestError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError3.prototype);
  }
};
let WebrpcBadResponseError$5 = class WebrpcBadResponseError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError3.prototype);
  }
};
let WebrpcServerPanicError$5 = class WebrpcServerPanicError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError3.prototype);
  }
};
let WebrpcInternalErrorError$5 = class WebrpcInternalErrorError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError3.prototype);
  }
};
let WebrpcClientDisconnectedError$5 = class WebrpcClientDisconnectedError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError3.prototype);
  }
};
let WebrpcStreamLostError$5 = class WebrpcStreamLostError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError3.prototype);
  }
};
let WebrpcStreamFinishedError$5 = class WebrpcStreamFinishedError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError3.prototype);
  }
};
let UnauthorizedError$4 = class UnauthorizedError3 extends WebrpcError$5 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError3.prototype);
  }
};
let PermissionDeniedError$2 = class PermissionDeniedError3 extends WebrpcError$5 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError3.prototype);
  }
};
let SessionExpiredError$3 = class SessionExpiredError2 extends WebrpcError$5 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError2.prototype);
  }
};
let MethodNotFoundError$1 = class MethodNotFoundError2 extends WebrpcError$5 {
  constructor(name2 = "MethodNotFound", code2 = 1003, message = "Method not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError2.prototype);
  }
};
let RequestConflictError$1 = class RequestConflictError extends WebrpcError$5 {
  constructor(name2 = "RequestConflict", code2 = 1004, message = "Conflict with target resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RequestConflictError.prototype);
  }
};
let AbortedError$1 = class AbortedError3 extends WebrpcError$5 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError3.prototype);
  }
};
let TimeoutError$1 = class TimeoutError2 extends WebrpcError$5 {
  constructor(name2 = "Timeout", code2 = 2e3, message = "Request timed out", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TimeoutError2.prototype);
  }
};
let InvalidArgumentError$3 = class InvalidArgumentError3 extends WebrpcError$5 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError3.prototype);
  }
};
let UnavailableError$1 = class UnavailableError3 extends WebrpcError$5 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError3.prototype);
  }
};
let QueryFailedError$3 = class QueryFailedError3 extends WebrpcError$5 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError3.prototype);
  }
};
class ResourceExhaustedError extends WebrpcError$5 {
  constructor(name2 = "ResourceExhausted", code2 = 2004, message = "Resource exhausted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ResourceExhaustedError.prototype);
  }
}
let NotFoundError$4 = class NotFoundError3 extends WebrpcError$5 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError3.prototype);
  }
};
let ProjectNotFoundError$1 = class ProjectNotFoundError extends WebrpcError$5 {
  constructor(name2 = "ProjectNotFound", code2 = 3002, message = "Project not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype);
  }
};
class MetadataCallFailedError extends WebrpcError$5 {
  constructor(name2 = "MetadataCallFailed", code2 = 3003, message = "Metadata service call failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MetadataCallFailedError.prototype);
  }
}
let errors$1 = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["SessionExpired"] = "SessionExpired";
  errors2["MethodNotFound"] = "MethodNotFound";
  errors2["RequestConflict"] = "RequestConflict";
  errors2["Aborted"] = "Aborted";
  errors2["Timeout"] = "Timeout";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["Unavailable"] = "Unavailable";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["ResourceExhausted"] = "ResourceExhausted";
  errors2["NotFound"] = "NotFound";
  errors2["ProjectNotFound"] = "ProjectNotFound";
  errors2["MetadataCallFailed"] = "MetadataCallFailed";
  return errors2;
}({});
const webrpcErrorByCode$5 = {
  [0]: WebrpcEndpointError$5,
  [-1]: WebrpcRequestFailedError$5,
  [-2]: WebrpcBadRouteError$5,
  [-3]: WebrpcBadMethodError$5,
  [-4]: WebrpcBadRequestError$5,
  [-5]: WebrpcBadResponseError$5,
  [-6]: WebrpcServerPanicError$5,
  [-7]: WebrpcInternalErrorError$5,
  [-8]: WebrpcClientDisconnectedError$5,
  [-9]: WebrpcStreamLostError$5,
  [-10]: WebrpcStreamFinishedError$5,
  [1e3]: UnauthorizedError$4,
  [1001]: PermissionDeniedError$2,
  [1002]: SessionExpiredError$3,
  [1003]: MethodNotFoundError$1,
  [1004]: RequestConflictError$1,
  [1005]: AbortedError$1,
  [2e3]: TimeoutError$1,
  [2001]: InvalidArgumentError$3,
  [2002]: UnavailableError$1,
  [2003]: QueryFailedError$3,
  [2004]: ResourceExhaustedError,
  [3e3]: NotFoundError$4,
  [3002]: ProjectNotFoundError$1,
  [3003]: MetadataCallFailedError
};
const fetch$4 = globalThis.fetch;
class SequenceIndexer extends Indexer {
  constructor(hostname, projectAccessKey2, jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$4);
    this.projectAccessKey = projectAccessKey2;
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init2) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      const projectAccessKey3 = this.projectAccessKey;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      if (projectAccessKey3 && projectAccessKey3.length > 0) {
        headers["X-Access-Key"] = projectAccessKey3;
      }
      init2.headers = _extends$9({}, init2.headers, headers);
      return fetch$4(input2, init2);
    };
    this.fetch = this._fetch;
  }
}
const indexer$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortedError: AbortedError$1,
  ContractType: ContractType$1,
  ContractVerificationStatus,
  EventLogDataType,
  EventLogType,
  Indexer,
  InvalidArgumentError: InvalidArgumentError$3,
  MetadataCallFailedError,
  MethodNotFoundError: MethodNotFoundError$1,
  NotFoundError: NotFoundError$4,
  OrderStatus,
  PermissionDeniedError: PermissionDeniedError$2,
  ProjectNotFoundError: ProjectNotFoundError$1,
  QueryFailedError: QueryFailedError$3,
  RequestConflictError: RequestConflictError$1,
  ResourceExhaustedError,
  SequenceIndexer,
  SessionExpiredError: SessionExpiredError$3,
  SortOrder,
  TimeoutError: TimeoutError$1,
  TransactionStatus,
  TransactionType,
  TxnTransferType,
  UnauthorizedError: UnauthorizedError$4,
  UnavailableError: UnavailableError$1,
  WebRPCSchemaHash: WebRPCSchemaHash$1,
  WebRPCSchemaVersion: WebRPCSchemaVersion$1,
  WebRPCVersion: WebRPCVersion$1,
  WebrpcBadMethodError: WebrpcBadMethodError$5,
  WebrpcBadRequestError: WebrpcBadRequestError$5,
  WebrpcBadResponseError: WebrpcBadResponseError$5,
  WebrpcBadRouteError: WebrpcBadRouteError$5,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$5,
  WebrpcEndpointError: WebrpcEndpointError$5,
  WebrpcError: WebrpcError$5,
  WebrpcInternalErrorError: WebrpcInternalErrorError$5,
  WebrpcRequestFailedError: WebrpcRequestFailedError$5,
  WebrpcServerPanicError: WebrpcServerPanicError$5,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$5,
  WebrpcStreamLostError: WebrpcStreamLostError$5,
  errors: errors$1
}, Symbol.toStringTag, { value: "Module" }));
function _extends$8() {
  return _extends$8 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$8.apply(null, arguments);
}
const WebRPCVersion = "v1";
const WebRPCSchemaVersion = "v0.4.0";
const WebRPCSchemaHash = "9d0976f6ff345b6a688b69cff647454e7fd0e3a6";
let ContractType = /* @__PURE__ */ function(ContractType2) {
  ContractType2["UNKNOWN"] = "UNKNOWN";
  ContractType2["ERC20"] = "ERC20";
  ContractType2["ERC721"] = "ERC721";
  ContractType2["ERC1155"] = "ERC1155";
  return ContractType2;
}({});
let PropertyType = /* @__PURE__ */ function(PropertyType2) {
  PropertyType2["INT"] = "INT";
  PropertyType2["STRING"] = "STRING";
  PropertyType2["ARRAY"] = "ARRAY";
  PropertyType2["GENERIC"] = "GENERIC";
  return PropertyType2;
}({});
let SwapType = /* @__PURE__ */ function(SwapType2) {
  SwapType2["UNKNOWN"] = "UNKNOWN";
  SwapType2["BUY"] = "BUY";
  SwapType2["SELL"] = "SELL";
  return SwapType2;
}({});
let TaskStatus = /* @__PURE__ */ function(TaskStatus2) {
  TaskStatus2["PENDING"] = "PENDING";
  TaskStatus2["PAUSED"] = "PAUSED";
  TaskStatus2["FAILED"] = "FAILED";
  TaskStatus2["COMPLETED"] = "COMPLETED";
  TaskStatus2["DISABLED"] = "DISABLED";
  return TaskStatus2;
}({});
class Metadata {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Metadata/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$4({}, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$4({}, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            version: _data6.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$4({}, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenMetadata = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            tokenMetadata: _data6.tokenMetadata
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.refreshTokenMetadata = (args, headers, signal) => {
      return this.fetch(this.url("RefreshTokenMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            taskId: _data6.taskId
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.enqueueTokensForRefresh = (args, headers, signal) => {
      return this.fetch(this.url("EnqueueTokensForRefresh"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            taskId: _data6.taskId
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenRefreshStatus = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenRefreshStatus"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenRefreshResult = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenRefreshResult"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            status: _data6.status,
            tokens: _data6.tokens,
            failureReasons: _data6.failureReasons
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.cancelRefreshJob = (args, headers, signal) => {
      return this.fetch(this.url("CancelRefreshJob"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenMetadataBatch = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenMetadataBatch"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractTokenMetadata: _data6.contractTokenMetadata
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchTokenMetadata = (args, headers, signal) => {
      return this.fetch(this.url("SearchTokenMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            page: _data6.page,
            tokenMetadata: _data6.tokenMetadata
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchTokenIDs = (args, headers, signal) => {
      return this.fetch(this.url("SearchTokenIDs"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            page: _data6.page,
            tokenIds: _data6.tokenIds
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.tokenCollectionFilters = (args, headers, signal) => {
      return this.fetch(this.url("TokenCollectionFilters"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            filters: _data6.filters
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getContractInfo = (args, headers, signal) => {
      return this.fetch(this.url("GetContractInfo"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractInfo: _data6.contractInfo
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getContractInfoBatch = (args, headers, signal) => {
      return this.fetch(this.url("GetContractInfoBatch"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractInfoMap: _data6.contractInfoMap
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchContractInfo = (args, headers, signal) => {
      return this.fetch(this.url("SearchContractInfo"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractInfoList: _data6.contractInfoList
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchContractInfoBatch = (args, headers, signal) => {
      return this.fetch(this.url("SearchContractInfoBatch"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractInfoByChain: _data6.contractInfoByChain
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchMetadata = (args, headers, signal) => {
      return this.fetch(this.url("SearchMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            tokenMetadata: _data6.tokenMetadata,
            contractInfo: _data6.contractInfo
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchTokens = (args, headers, signal) => {
      return this.fetch(this.url("SearchTokens"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            tokenMetadata: _data6.tokenMetadata,
            nextPage: _data6.nextPage
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchContracts = (args, headers, signal) => {
      return this.fetch(this.url("SearchContracts"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractInfo: _data6.contractInfo,
            nextPage: _data6.nextPage
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getNiftyswapTokenQuantity = (args, headers, signal) => {
      return this.fetch(this.url("GetNiftyswapTokenQuantity"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            quantity: _data6.quantity
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getNiftyswapUnitPrices = (args, headers, signal) => {
      return this.fetch(this.url("GetNiftyswapUnitPrices"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            prices: _data6.prices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getNiftyswapUnitPricesWithQuantities = (args, headers, signal) => {
      return this.fetch(this.url("GetNiftyswapUnitPricesWithQuantities"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            prices: _data6.prices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addContractToMintMonitor = (args, headers, signal) => {
      return this.fetch(this.url("AddContractToMintMonitor"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeContractFromMintMonitor = (args, headers, signal) => {
      return this.fetch(this.url("RemoveContractFromMintMonitor"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.mintMonitorJobStatus = (args, headers, signal) => {
      return this.fetch(this.url("MintMonitorJobStatus"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            task: _data6.task
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.mintMonitorTriggerJob = (args, headers, signal) => {
      return this.fetch(this.url("MintMonitorTriggerJob"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.syncContractTokens = (args, headers, signal) => {
      return this.fetch(this.url("SyncContractTokens"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            taskID: _data6.taskID
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.abortContractSync = (args, headers, signal) => {
      return this.fetch(this.url("AbortContractSync"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.contractSyncJobStatus = (args, headers, signal) => {
      return this.fetch(this.url("ContractSyncJobStatus"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            refreshTask: _data6.refreshTask,
            syncTask: _data6.syncTask
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.directoryGetNetworks = (args, headers, signal) => {
      return this.fetch(this.url("DirectoryGetNetworks"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            networks: _data6.networks
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.directoryGetCollections = (args, headers, signal) => {
      return this.fetch(this.url("DirectoryGetCollections"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            collections: _data6.collections,
            page: _data6.page
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.directorySearchCollections = (args, headers, signal) => {
      return this.fetch(this.url("DirectorySearchCollections"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            collections: _data6.collections,
            page: _data6.page
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
class Collections {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Collections/";
    this.createCollection = (args, headers, signal) => {
      return this.fetch(this.url("CreateCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            collection: _data6.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getCollection = (args, headers, signal) => {
      return this.fetch(this.url("GetCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            collection: _data6.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listCollections = (args, headers, signal) => {
      return this.fetch(this.url("ListCollections"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            page: _data6.page,
            collections: _data6.collections
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateCollection = (args, headers, signal) => {
      return this.fetch(this.url("UpdateCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            collection: _data6.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteCollection = (args, headers, signal) => {
      return this.fetch(this.url("DeleteCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.publishCollection = (args, headers, signal) => {
      return this.fetch(this.url("PublishCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            collection: _data6.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.unpublishCollection = (args, headers, signal) => {
      return this.fetch(this.url("UnpublishCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            collection: _data6.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.createContractCollection = (args, headers, signal) => {
      return this.fetch(this.url("CreateContractCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractCollection: _data6.contractCollection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getContractCollection = (args, headers, signal) => {
      return this.fetch(this.url("GetContractCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractCollection: _data6.contractCollection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listContractCollections = (args, headers, signal) => {
      return this.fetch(this.url("ListContractCollections"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            contractCollections: _data6.contractCollections,
            collections: _data6.collections,
            page: _data6.page
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateContractCollection = (args, headers, signal) => {
      return this.fetch(this.url("UpdateContractCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteContractCollection = (args, headers, signal) => {
      return this.fetch(this.url("DeleteContractCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.createToken = (args, headers, signal) => {
      return this.fetch(this.url("CreateToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            token: _data6.token,
            assets: _data6.assets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getToken = (args, headers, signal) => {
      return this.fetch(this.url("GetToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            token: _data6.token,
            assets: _data6.assets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listTokens = (args, headers, signal) => {
      return this.fetch(this.url("ListTokens"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            page: _data6.page,
            tokens: _data6.tokens
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateToken = (args, headers, signal) => {
      return this.fetch(this.url("UpdateToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            token: _data6.token
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteToken = (args, headers, signal) => {
      return this.fetch(this.url("DeleteToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.createAsset = (args, headers, signal) => {
      return this.fetch(this.url("CreateAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            asset: _data6.asset
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAsset = (args, headers, signal) => {
      return this.fetch(this.url("GetAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            asset: _data6.asset
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateAsset = (args, headers, signal) => {
      return this.fetch(this.url("UpdateAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            asset: _data6.asset
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteAsset = (args, headers, signal) => {
      return this.fetch(this.url("DeleteAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
class Admin {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Admin/";
    this.addContractsToTokenDirectory = (args, headers, signal) => {
      return this.fetch(this.url("AddContractsToTokenDirectory"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeContractsFromTokenDirectory = (args, headers, signal) => {
      return this.fetch(this.url("RemoveContractsFromTokenDirectory"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.modifyFeatureIndex = (args, headers, signal) => {
      return this.fetch(this.url("ModifyFeatureIndex"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getFeatureIndex = (args, headers, signal) => {
      return this.fetch(this.url("GetFeatureIndex"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            featured: _data6.featured
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listTokenDirectory = (args, headers, signal) => {
      return this.fetch(this.url("ListTokenDirectory"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data6) => {
          return {
            page: _data6.page,
            collections: _data6.collections
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$4 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$8({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$4 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$4.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$4[code2] || WebrpcError$4).new(data);
    }
    return data;
  });
};
let WebrpcError$4 = class WebrpcError4 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError4.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$4 = class WebrpcEndpointError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError4.prototype);
  }
};
let WebrpcRequestFailedError$4 = class WebrpcRequestFailedError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError4.prototype);
  }
};
let WebrpcBadRouteError$4 = class WebrpcBadRouteError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError4.prototype);
  }
};
let WebrpcBadMethodError$4 = class WebrpcBadMethodError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError4.prototype);
  }
};
let WebrpcBadRequestError$4 = class WebrpcBadRequestError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError4.prototype);
  }
};
let WebrpcBadResponseError$4 = class WebrpcBadResponseError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError4.prototype);
  }
};
let WebrpcServerPanicError$4 = class WebrpcServerPanicError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError4.prototype);
  }
};
let WebrpcInternalErrorError$4 = class WebrpcInternalErrorError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError4.prototype);
  }
};
let WebrpcClientDisconnectedError$4 = class WebrpcClientDisconnectedError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError4.prototype);
  }
};
let WebrpcStreamLostError$4 = class WebrpcStreamLostError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError4.prototype);
  }
};
let WebrpcStreamFinishedError$4 = class WebrpcStreamFinishedError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError4.prototype);
  }
};
let UnauthorizedError$3 = class UnauthorizedError4 extends WebrpcError$4 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError4.prototype);
  }
};
let PermissionDeniedError$1 = class PermissionDeniedError4 extends WebrpcError$4 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError4.prototype);
  }
};
let SessionExpiredError$2 = class SessionExpiredError3 extends WebrpcError$4 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError3.prototype);
  }
};
class MethodNotFoundError3 extends WebrpcError$4 {
  constructor(name2 = "MethodNotFound", code2 = 1003, message = "Method not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError3.prototype);
  }
}
class RequestConflictError2 extends WebrpcError$4 {
  constructor(name2 = "RequestConflict", code2 = 1004, message = "Conflict with target resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RequestConflictError2.prototype);
  }
}
class FailError extends WebrpcError$4 {
  constructor(name2 = "Fail", code2 = 1005, message = "Request Failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, FailError.prototype);
  }
}
class GeoblockedError2 extends WebrpcError$4 {
  constructor(name2 = "Geoblocked", code2 = 1006, message = "Geoblocked region", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, GeoblockedError2.prototype);
  }
}
class TimeoutError3 extends WebrpcError$4 {
  constructor(name2 = "Timeout", code2 = 2e3, message = "Request timed out", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TimeoutError3.prototype);
  }
}
let InvalidArgumentError$2 = class InvalidArgumentError4 extends WebrpcError$4 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError4.prototype);
  }
};
class RequiredArgumentError extends WebrpcError$4 {
  constructor(name2 = "RequiredArgument", code2 = 2002, message = "Required argument missing", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RequiredArgumentError.prototype);
  }
}
let QueryFailedError$2 = class QueryFailedError4 extends WebrpcError$4 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError4.prototype);
  }
};
let ValidationFailedError$1 = class ValidationFailedError extends WebrpcError$4 {
  constructor(name2 = "ValidationFailed", code2 = 2004, message = "Validation failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ValidationFailedError.prototype);
  }
};
class RateLimitedError extends WebrpcError$4 {
  constructor(name2 = "RateLimited", code2 = 2005, message = "Rate limited", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RateLimitedError.prototype);
  }
}
let NotFoundError$3 = class NotFoundError4 extends WebrpcError$4 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError4.prototype);
  }
};
class ProjectNotFoundError2 extends WebrpcError$4 {
  constructor(name2 = "ProjectNotFound", code2 = 3002, message = "Project not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ProjectNotFoundError2.prototype);
  }
}
class ChainNotFoundError2 extends WebrpcError$4 {
  constructor(name2 = "ChainNotFound", code2 = 3003, message = "Chain not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ChainNotFoundError2.prototype);
  }
}
class TokenDirectoryDisabledError extends WebrpcError$4 {
  constructor(name2 = "TokenDirectoryDisabled", code2 = 4001, message = "Token Directory is disabled", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TokenDirectoryDisabledError.prototype);
  }
}
let errors = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["SessionExpired"] = "SessionExpired";
  errors2["MethodNotFound"] = "MethodNotFound";
  errors2["RequestConflict"] = "RequestConflict";
  errors2["Fail"] = "Fail";
  errors2["Geoblocked"] = "Geoblocked";
  errors2["Timeout"] = "Timeout";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["RequiredArgument"] = "RequiredArgument";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["ValidationFailed"] = "ValidationFailed";
  errors2["RateLimited"] = "RateLimited";
  errors2["NotFound"] = "NotFound";
  errors2["ProjectNotFound"] = "ProjectNotFound";
  errors2["ChainNotFound"] = "ChainNotFound";
  errors2["TokenDirectoryDisabled"] = "TokenDirectoryDisabled";
  return errors2;
}({});
const webrpcErrorByCode$4 = {
  [0]: WebrpcEndpointError$4,
  [-1]: WebrpcRequestFailedError$4,
  [-2]: WebrpcBadRouteError$4,
  [-3]: WebrpcBadMethodError$4,
  [-4]: WebrpcBadRequestError$4,
  [-5]: WebrpcBadResponseError$4,
  [-6]: WebrpcServerPanicError$4,
  [-7]: WebrpcInternalErrorError$4,
  [-8]: WebrpcClientDisconnectedError$4,
  [-9]: WebrpcStreamLostError$4,
  [-10]: WebrpcStreamFinishedError$4,
  [1e3]: UnauthorizedError$3,
  [1001]: PermissionDeniedError$1,
  [1002]: SessionExpiredError$2,
  [1003]: MethodNotFoundError3,
  [1004]: RequestConflictError2,
  [1005]: FailError,
  [1006]: GeoblockedError2,
  [2e3]: TimeoutError3,
  [2001]: InvalidArgumentError$2,
  [2002]: RequiredArgumentError,
  [2003]: QueryFailedError$2,
  [2004]: ValidationFailedError$1,
  [2005]: RateLimitedError,
  [3e3]: NotFoundError$3,
  [3002]: ProjectNotFoundError2,
  [3003]: ChainNotFoundError2,
  [4001]: TokenDirectoryDisabledError
};
const fetch$3 = globalThis.fetch;
class SequenceMetadata extends Metadata {
  constructor(hostname = "https://metadata.sequence.app", projectAccessKey2, jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$3);
    this.projectAccessKey = projectAccessKey2;
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init2) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      const projectAccessKey3 = this.projectAccessKey;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      if (projectAccessKey3 && projectAccessKey3.length > 0) {
        headers["X-Access-Key"] = projectAccessKey3;
      }
      init2.headers = _extends$8({}, init2.headers, headers);
      return fetch$3(input2, init2);
    };
    this.fetch = this._fetch;
  }
}
class SequenceCollections extends Collections {
  constructor(hostname = "https://metadata.sequence.app", jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$3);
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init2) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      init2.headers = _extends$8({}, init2.headers, headers);
      return fetch$3(input2, init2);
    };
    this.fetch = this._fetch;
  }
  // TODO: add uploadAsset() method similar to,
  // https://github.com/0xsequence/go-sequence/blob/master/metadata/collections.go#L52
}
const metadata$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Admin,
  ChainNotFoundError: ChainNotFoundError2,
  Collections,
  ContractType,
  FailError,
  GeoblockedError: GeoblockedError2,
  InvalidArgumentError: InvalidArgumentError$2,
  Metadata,
  MethodNotFoundError: MethodNotFoundError3,
  NotFoundError: NotFoundError$3,
  PermissionDeniedError: PermissionDeniedError$1,
  ProjectNotFoundError: ProjectNotFoundError2,
  PropertyType,
  QueryFailedError: QueryFailedError$2,
  RateLimitedError,
  RequestConflictError: RequestConflictError2,
  RequiredArgumentError,
  SequenceCollections,
  SequenceMetadata,
  SessionExpiredError: SessionExpiredError$2,
  SwapType,
  TaskStatus,
  TimeoutError: TimeoutError3,
  TokenDirectoryDisabledError,
  UnauthorizedError: UnauthorizedError$3,
  ValidationFailedError: ValidationFailedError$1,
  WebRPCSchemaHash,
  WebRPCSchemaVersion,
  WebRPCVersion,
  WebrpcBadMethodError: WebrpcBadMethodError$4,
  WebrpcBadRequestError: WebrpcBadRequestError$4,
  WebrpcBadResponseError: WebrpcBadResponseError$4,
  WebrpcBadRouteError: WebrpcBadRouteError$4,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$4,
  WebrpcEndpointError: WebrpcEndpointError$4,
  WebrpcError: WebrpcError$4,
  WebrpcInternalErrorError: WebrpcInternalErrorError$4,
  WebrpcRequestFailedError: WebrpcRequestFailedError$4,
  WebrpcServerPanicError: WebrpcServerPanicError$4,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$4,
  WebrpcStreamLostError: WebrpcStreamLostError$4,
  errors
}, Symbol.toStringTag, { value: "Module" }));
function useGateway(uri, gateway) {
  const clean = uri.replace("ipfs://ipfs/", "").replace("ipfs://", "");
  if (uri.startsWith("ipfs://")) return `${gateway}${clean}`;
  return uri;
}
function isIPFS(uri) {
  return uri.startsWith("ipfs://");
}
class CachedEIP5719 {
  constructor(provider2, solver, window2 = 1e3) {
    this.provider = provider2;
    this.solver = solver;
    this.window = window2;
    this.pending = /* @__PURE__ */ new Map();
  }
  async runByEIP5719(address, digest, signature2) {
    const key = `${address}-${digest}-${signature2}`;
    const now = Date.now();
    if (this.pending.has(key) && now - this.pending.get(key).timestamp < this.window) {
      return this.pending.get(key).promise;
    }
    const promise = runByEIP5719(address, this.provider, digest, signature2, this.solver);
    this.pending.set(key, {
      timestamp: now,
      promise
    });
    return promise;
  }
}
function eip5719Contract(address, provider2) {
  const abi2 = [{
    inputs: [{
      internalType: "bytes32",
      type: "bytes32"
    }],
    name: "getAlternativeSignature",
    outputs: [{
      internalType: "string",
      type: "string"
    }],
    stateMutability: "view",
    type: "function"
  }];
  return new Contract(address, abi2, provider2);
}
async function tryAwait(promise) {
  try {
    return await promise;
  } catch (_unused3) {
    return void 0;
  }
}
async function runByEIP5719(address, provider2, digest, signature2, solver, tries = 0) {
  if (tries > 10) throw new Error("EIP5719 - Too many tries");
  if (index$1$1.signer.canRecover(signature2)) {
    const recoveredAddr = index$1$1.signer.recoverSigner(digest, signature2);
    if (recoveredAddr && recoveredAddr.toLowerCase() === address.toLowerCase()) return signature2;
  }
  try {
    if (await index$1$1.signer.isValidSignature(address, digest, signature2, provider2)) {
      return signature2;
    }
  } catch (_unused4) {
  }
  const altUri = await tryAwait(eip5719Contract(address, provider2).getAlternativeSignature(digest));
  if (!altUri || altUri === "") throw new Error("EIP5719 - Invalid signature and no alternative signature");
  const altSignature = hexlify(await (solver || new URISolverIPFS()).resolve(altUri));
  if (!altSignature || altSignature === "") throw new Error("EIP5719 - Empty alternative signature");
  if (altSignature === hexlify(signature2)) {
    throw new Error("EIP5719 - Alternative signature is invalid or the same");
  }
  return runByEIP5719(address, provider2, digest, altSignature, solver, tries + 1);
}
class URISolverIPFS {
  constructor(gateway = "https://cloudflare-ipfs.com/ipfs/") {
    var _this = this;
    this.gateway = gateway;
    this.uri = (uri) => {
      if (isIPFS(uri)) return useGateway(uri, this.gateway);
      return uri;
    };
    this.resolve = async function(uri) {
      const url = _this.uri(uri);
      const res = await fetch(url);
      if (!res.ok) throw new Error(`URISolverIPFS - Failed to fetch ${url}`);
      return await res.text();
    };
  }
}
const instanceOfAny = (object2, constructors) => constructors.some((c2) => object2 instanceof c2);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db2) => {
    if (terminated)
      db2.addEventListener("close", () => terminated());
    if (blocking) {
      db2.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
var tracker = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
function _extends$7() {
  return _extends$7 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$7.apply(null, arguments);
}
const MAIN_MODULE_ABI = ["function execute((bool delegateCall, bool revertOnError, uint256 gasLimit, address target, uint256 value, bytes data)[] calldata transactions, uint256 nonce, bytes calldata signature)"];
const defaults = {
  namespace: "Sequence-Sessions",
  owners: ["AZ6R2mG8zxW9q7--iZXGrBknjegHoPzmG5IG-nxvMaM"],
  graphqlUrl: "https://arweave.net/graphql",
  eip5719Provider: void 0,
  rateLimitRetryDelayMs: 5 * 60 * 1e3
};
class ArweaveReader {
  constructor(options = defaults) {
    this.options = options;
    this.configs = /* @__PURE__ */ new Map();
    this.eip5719 = void 0;
    if (options.eip5719Provider) {
      this.eip5719 = new CachedEIP5719(options.eip5719Provider);
    }
  }
  async loadPresignedConfiguration(args) {
    var _this = this;
    const wallet = getAddress(args.wallet);
    const fromConfig = await this.configOfImageHash({
      imageHash: args.fromImageHash
    });
    if (!fromConfig) {
      throw new Error(`unable to find from config ${args.fromImageHash}`);
    }
    if (!v2.config.isWalletConfig(fromConfig)) {
      throw new Error(`from config ${args.fromImageHash} is not v2`);
    }
    const fromCheckpoint = BigInt(fromConfig.checkpoint);
    const items = Object.entries(await findItems({
      Type: "config update",
      Wallet: wallet
    }, this.options)).flatMap(([id2, tags]) => {
      try {
        const {
          Signer: signer2,
          Subdigest: subdigest,
          Digest: digest,
          "To-Config": toImageHash
        } = tags;
        let signatureType;
        switch (tags["Signature-Type"]) {
          case "eip-712":
          case "eth_sign":
          case "erc-1271":
            signatureType = tags["Signature-Type"];
            break;
          default:
            throw new Error(`unknown signature type ${tags["Signature-Type"]}`);
        }
        let toCheckpoint;
        try {
          toCheckpoint = BigInt(tags["To-Checkpoint"]);
        } catch (_unused) {
          throw new Error(`to checkpoint is not a number: ${tags["To-Checkpoint"]}`);
        }
        if (toCheckpoint <= fromCheckpoint) {
          return [];
        }
        if (!isAddress(signer2)) {
          throw new Error(`signer is not an address: ${signer2}`);
        }
        if (!isHexString(subdigest, 32)) {
          throw new Error(`subdigest is not a hash: ${subdigest}`);
        }
        if (!isHexString(digest, 32)) {
          throw new Error(`digest is not a hash: ${digest}`);
        }
        let chainId;
        try {
          chainId = BigInt(tags["Chain-ID"]);
        } catch (_unused2) {
          throw new Error(`chain id is not a number: ${tags["Chain-ID"]}`);
        }
        if (!isHexString(toImageHash, 32)) {
          throw new Error(`to config is not a hash: ${toImageHash}`);
        }
        return [{
          id: id2,
          signatureType,
          signer: signer2,
          subdigest,
          digest,
          chainId,
          toImageHash,
          toCheckpoint
        }];
      } catch (error) {
        console.warn(`invalid wallet ${wallet} config update ${id2}:`, error);
        return [];
      }
    });
    const signatures = /* @__PURE__ */ new Map();
    let candidates = [];
    for (const item2 of items) {
      let imageHashSignatures = signatures.get(item2.toImageHash);
      if (!imageHashSignatures) {
        imageHashSignatures = /* @__PURE__ */ new Map();
        signatures.set(item2.toImageHash, imageHashSignatures);
        candidates.push(item2);
      }
      imageHashSignatures.set(item2.signer, item2);
    }
    if (args.longestPath) {
      candidates.sort(({
        toCheckpoint: a2
      }, {
        toCheckpoint: b2
      }) => a2 === b2 ? 0 : a2 < b2 ? -1 : 1);
    } else {
      candidates.sort(({
        toCheckpoint: a2
      }, {
        toCheckpoint: b2
      }) => a2 === b2 ? 0 : a2 < b2 ? 1 : -1);
    }
    const updates = [];
    for (let currentConfig = fromConfig; candidates.length; ) {
      const currentImageHash = v2.config.imageHash(currentConfig);
      let nextCandidate;
      let nextCandidateItems;
      let nextCandidateSigners = [];
      for (const candidate of candidates) {
        nextCandidateItems = signatures.get(candidate.toImageHash);
        nextCandidateSigners = Array.from(nextCandidateItems.keys());
        const {
          weight
        } = v2.signature.encodeSigners(currentConfig, new Map(nextCandidateSigners.map((signer2) => [signer2, {
          signature: "0x",
          isDynamic: false
        }])), [], 0);
        if (weight >= BigInt(currentConfig.threshold)) {
          nextCandidate = candidate;
          break;
        }
      }
      if (!nextCandidate) {
        console.warn(`unreachable configs with checkpoint > ${currentConfig.checkpoint} from config ${currentImageHash}`);
        break;
      }
      const nextImageHash = nextCandidate.toImageHash;
      try {
        const nextConfig = await this.configOfImageHash({
          imageHash: nextImageHash
        });
        if (!nextConfig) {
          throw new Error(`unable to find config ${nextImageHash}`);
        }
        if (!v2.config.isWalletConfig(nextConfig)) {
          throw new Error(`config ${nextImageHash} is not v2`);
        }
        const nextCandidateSignatures = new Map((await Promise.all(nextCandidateSigners.map(async function(signer2) {
          const {
            id: id2,
            subdigest,
            signatureType
          } = nextCandidateItems.get(signer2);
          try {
            let signature3 = await (await fetchItem(id2, _this.options.rateLimitRetryDelayMs)).text();
            switch (signatureType) {
              case "eip-712":
                signature3 += "01";
                break;
              case "eth_sign":
                signature3 += "02";
                break;
              case "erc-1271":
                signature3 += "03";
                break;
            }
            if (_this.eip5719) {
              try {
                signature3 = hexlify(await _this.eip5719.runByEIP5719(signer2, subdigest, signature3));
              } catch (error) {
                console.warn(`unable to run eip-5719 on config update ${id2}`);
              }
            }
            const recovered = index$1$1.signer.tryRecoverSigner(subdigest, signature3);
            return [[signer2, {
              signature: signature3,
              isDynamic: recovered !== signer2
            }]];
          } catch (error) {
            console.warn(`unable to fetch signer ${signer2} config update ${id2}:`, error);
            return [];
          }
        }))).flat());
        const {
          encoded: signature2,
          weight
        } = v2.signature.encodeSigners(currentConfig, nextCandidateSignatures, [], 0);
        if (weight < BigInt(currentConfig.threshold)) {
          throw new Error(`insufficient signing power ${weight.toString()} < ${currentConfig.threshold}`);
        }
        updates.push({
          wallet,
          signature: signature2,
          nextImageHash
        });
        currentConfig = nextConfig;
        candidates = candidates.filter(({
          toCheckpoint
        }) => toCheckpoint > BigInt(currentConfig.checkpoint));
      } catch (error) {
        console.warn(`unable to reconstruct wallet ${wallet} update from config ${currentImageHash} to config ${nextImageHash}:`, error);
        candidates = candidates.filter(({
          toImageHash
        }) => toImageHash !== nextImageHash);
      }
    }
    return updates;
  }
  savePresignedConfiguration(_args) {
    throw new Error("arweave backend does not support saving config updates");
  }
  saveWitnesses(_args) {
    throw new Error("arweave backend does not support saving signatures");
  }
  async configOfImageHash(args) {
    var _this2 = this;
    if (!args.noCache) {
      const _config = this.configs.get(args.imageHash);
      if (_config) {
        try {
          return await _config;
        } catch (_unused3) {
          const _config2 = this.configs.get(args.imageHash);
          if (_config2) {
            return _config2;
          }
        }
      }
    }
    const config2 = async function(imageHash2) {
      const items = Object.entries(await findItems({
        Type: "config",
        Config: imageHash2
      }, _this2.options)).flatMap(([id2, tags]) => {
        try {
          const version2 = Number(tags.Version);
          if (!version2) {
            throw new Error(`invalid version: ${tags.Version}`);
          }
          return [{
            id: id2,
            version: version2
          }];
        } catch (error) {
          console.warn(`config ${imageHash2} at ${id2} invalid:`, error);
          return [];
        }
      });
      switch (items.length) {
        case 0:
          _this2.configs.set(imageHash2, Promise.resolve(void 0));
          return;
        case 1:
          break;
        default:
          console.warn(`multiple configs ${imageHash2} at ${items.map(({
            id: id2
          }) => id2).join(", ")}`);
          break;
      }
      for (const {
        id: id2,
        version: version2
      } of items) {
        try {
          const config3 = _extends$7({}, await (await fetchItem(id2, _this2.options.rateLimitRetryDelayMs)).json(), {
            version: version2
          });
          if (config3.tree) {
            config3.tree = toTopology(config3.tree);
          }
          const actual = index$6.coderFor(version2).config.imageHashOf(config3);
          if (actual !== imageHash2) {
            throw new Error(`image hash is ${actual}, expected ${imageHash2}`);
          }
          _this2.configs.set(imageHash2, Promise.resolve(config3));
          return config3;
        } catch (error) {
          console.warn(`config at ${id2} invalid:`, error);
        }
      }
      _this2.configs.set(imageHash2, Promise.resolve(void 0));
      return;
    }(args.imageHash);
    if (!args.noCache) {
      this.configs.set(args.imageHash, config2);
    }
    return config2;
  }
  saveWalletConfig(_args) {
    throw new Error("arweave backend does not support saving configs");
  }
  async imageHashOfCounterfactualWallet(args) {
    const wallet = getAddress(args.wallet);
    const items = Object.entries(await findItems({
      Type: "wallet",
      Wallet: wallet
    }, this.options)).flatMap(([id2, tags]) => {
      try {
        const {
          "Deploy-Config": imageHash2
        } = tags;
        const version2 = Number(tags["Deploy-Version"]);
        if (!version2) {
          throw new Error(`invalid version: ${tags["Deploy-Version"]}`);
        }
        if (!imageHash2) {
          throw new Error("no deploy config");
        }
        const context2 = index$1$1.context.defaultContexts[version2];
        if (!context2) {
          throw new Error(`unknown version: ${version2}`);
        }
        if (index$1$1.context.addressOf(context2, imageHash2) !== wallet) {
          throw new Error(`incorrect v${version2} deploy config: ${imageHash2}`);
        }
        return [{
          id: id2,
          imageHash: imageHash2,
          context: context2
        }];
      } catch (error) {
        console.warn(`wallet ${wallet} at ${id2} invalid:`, error);
        return [];
      }
    });
    switch (items.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple deploy configs for wallet ${wallet} at ${items.map(({
          id: id2
        }) => id2).join(", ")}, using first`);
        break;
    }
    return items[0];
  }
  saveCounterfactualWallet(_args) {
    throw new Error("arweave backend does not support saving wallets");
  }
  async walletsOfSigner(args) {
    var _this3 = this;
    const signer2 = getAddress(args.signer);
    const proofs = /* @__PURE__ */ new Map();
    for (const [id2, tags] of Object.entries(await findItems({
      Type: ["signature", "config update"],
      Signer: signer2,
      Witness: args.allSignatures ? void 0 : "true"
    }, this.options))) {
      const {
        Wallet: wallet,
        Subdigest: subdigest,
        Digest: digest,
        "Chain-ID": chainId
      } = tags;
      try {
        if (proofs.has(wallet)) {
          continue;
        }
        let signatureType;
        switch (tags["Signature-Type"]) {
          case "eip-712":
            signatureType = "01";
            break;
          case "eth_sign":
            signatureType = "02";
            break;
          case "erc-1271":
            signatureType = "03";
            break;
          default:
            throw new Error(`unknown signature type ${tags["Signature-Type"]}`);
        }
        if (subdigest !== index$1$1.signature.subdigestOf({
          digest,
          chainId,
          address: wallet
        })) {
          throw new Error("incorrect subdigest");
        }
        const signature2 = fetchItem(id2, this.options.rateLimitRetryDelayMs).then(async function(response) {
          const signature3 = await response.text() + signatureType;
          if (_this3.eip5719) {
            try {
              return hexlify(await _this3.eip5719.runByEIP5719(signer2, subdigest, signature3));
            } catch (error) {
              console.warn(`unable to run eip-5719 on signature ${id2}`);
            }
          }
          return signature3;
        });
        proofs.set(wallet, {
          digest,
          chainId: BigInt(chainId),
          signature: signature2
        });
      } catch (error) {
        console.warn(`signer ${signer2} signature ${id2} of wallet ${wallet} invalid:`, error);
      }
    }
    return Promise.all([...proofs.entries()].map(async function([wallet, {
      digest,
      chainId,
      signature: signature2
    }]) {
      return {
        wallet,
        proof: {
          digest,
          chainId,
          signature: await signature2
        }
      };
    }));
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    const wallet = getAddress(address);
    const items = Object.entries(await findItems({
      Type: "migration",
      Migration: wallet,
      "Chain-ID": BigInt(chainId).toString(),
      "From-Version": `${fromVersion}`,
      "From-Config": fromImageHash
    }, this.options)).flatMap(([id3, tags]) => {
      try {
        const {
          "To-Config": toImageHash2,
          Executor: executor2
        } = tags;
        const toVersion2 = Number(tags["To-Version"]);
        if (!toVersion2) {
          throw new Error(`invalid version: ${tags["To-Version"]}`);
        }
        if (!isHexString(toImageHash2, 32)) {
          throw new Error(`to config is not a hash: ${toImageHash2}`);
        }
        if (!isAddress(executor2)) {
          throw new Error(`executor is not an address: ${executor2}`);
        }
        return {
          id: id3,
          toVersion: toVersion2,
          toImageHash: toImageHash2,
          executor: executor2
        };
      } catch (error) {
        console.warn(`chain ${chainId} migration ${id3} for v${fromVersion} wallet ${wallet} from config ${fromImageHash} invalid:`, error);
        return [];
      }
    });
    switch (items.length) {
      case 0:
        return;
      case 1:
        break;
      default:
        console.warn(`multiple chain ${chainId} migrations for v${fromVersion} wallet ${wallet} from config ${fromImageHash} at ${items.map(({
          id: id3
        }) => id3).join(", ")}, using first`);
        break;
    }
    const {
      id: id2,
      toVersion,
      toImageHash,
      executor
    } = items[0];
    const [data, toConfig] = await Promise.all([fetchItem(id2, this.options.rateLimitRetryDelayMs).then((response) => response.text()), this.configOfImageHash({
      imageHash: toImageHash
    })]);
    if (!toConfig) {
      throw new Error(`unable to find to config ${toImageHash} for migration`);
    }
    const mainModule2 = new Interface(MAIN_MODULE_ABI);
    const [encoded, nonce, signature2] = mainModule2.decodeFunctionData("execute", data);
    const transactions2 = index$1$1.transaction.fromTxAbiEncode(encoded);
    const subdigest = index$1$1.transaction.subdigestOfTransactions(wallet, chainId, nonce, transactions2);
    return {
      tx: {
        entrypoint: executor,
        transactions: transactions2,
        nonce,
        chainId,
        intent: {
          id: subdigest,
          wallet
        },
        signature: signature2
      },
      fromVersion,
      toVersion: Number(toVersion),
      toConfig
    };
  }
  saveMigration(_address, _signed, _contexts) {
    throw new Error("arweave backend does not support saving migrations");
  }
}
async function findItems(filter2, options) {
  var _options$namespace, _options$graphqlUrl, _options$rateLimitRet, _options$pageSize;
  const namespace = (_options$namespace = options == null ? void 0 : options.namespace) != null ? _options$namespace : defaults.namespace;
  const owners = options == null ? void 0 : options.owners;
  const graphqlUrl = (_options$graphqlUrl = options == null ? void 0 : options.graphqlUrl) != null ? _options$graphqlUrl : defaults.graphqlUrl;
  const rateLimitRetryDelayMs = (_options$rateLimitRet = options == null ? void 0 : options.rateLimitRetryDelayMs) != null ? _options$rateLimitRet : defaults.rateLimitRetryDelayMs;
  const pageSize = (_options$pageSize = options == null ? void 0 : options.pageSize) != null ? _options$pageSize : 100;
  const maxResults = options == null ? void 0 : options.maxResults;
  const tags = Object.entries(filter2).flatMap(([name2, values]) => values === void 0 ? [] : [`{ name: "${namespace ? `${namespace}-${name2}` : name2}", values: [${typeof values === "string" ? `"${values}"` : values.map((value) => `"${value}"`).join(", ")}] }`]);
  const edges = [];
  for (let hasNextPage2 = true; hasNextPage2 && (maxResults === void 0 || edges.length < maxResults); ) {
    const query = `
      query {
        transactions(sort: HEIGHT_DESC, ${edges.length ? `first: ${pageSize}, after: "${edges[edges.length - 1].cursor}"` : `first: ${pageSize}`}, tags: [${tags.join(", ")}]${owners === void 0 ? "" : `, owners: [${owners.map((owner) => `"${owner}"`).join(", ")}]`}) {
          pageInfo {
            hasNextPage
          }
          edges {
            cursor
            node {
              id
              tags {
                name
                value
              }
            }
          }
        }
      }
    `;
    let response;
    while (true) {
      response = await fetch(graphqlUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query
        }),
        redirect: "follow"
      });
      if (response.status !== 429) {
        break;
      }
      console.warn(`rate limited by arweave.net, trying again in ${rateLimitRetryDelayMs / 1e3} seconds at ${new Date(Date.now() + rateLimitRetryDelayMs).toLocaleTimeString()}`);
      await new Promise((resolve) => setTimeout(resolve, rateLimitRetryDelayMs));
    }
    const {
      data: {
        transactions: transactions2
      }
    } = await response.json();
    edges.push(...transactions2.edges);
    hasNextPage2 = transactions2.pageInfo.hasNextPage;
  }
  return Object.fromEntries(edges.map(({
    node: {
      id: id2,
      tags: tags2
    }
  }) => [id2, Object.fromEntries(tags2.map(({
    name: name2,
    value
  }) => [namespace && name2.startsWith(`${namespace}-`) ? name2.slice(namespace.length + 1) : name2, value]))]));
}
async function fetchItem(id2, rateLimitRetryDelayMs = defaults.rateLimitRetryDelayMs) {
  while (true) {
    const response = await fetch(`https://arweave.net/${id2}`, {
      redirect: "follow"
    });
    if (response.status !== 429) {
      return response;
    }
    console.warn(`rate limited by arweave.net, trying again in ${rateLimitRetryDelayMs / 1e3} seconds at ${new Date(Date.now() + rateLimitRetryDelayMs).toLocaleTimeString()}`);
    await new Promise((resolve) => setTimeout(resolve, rateLimitRetryDelayMs));
  }
}
function toTopology(topology) {
  if (typeof topology === "string") {
    return {
      nodeHash: topology
    };
  }
  if (typeof topology === "object" && (topology == null ? void 0 : topology.node) !== void 0) {
    return {
      nodeHash: topology.node
    };
  }
  if (topology instanceof Array && topology.length === 2) {
    return {
      left: toTopology(topology[0]),
      right: toTopology(topology[1])
    };
  }
  if (v2.config.isNode(topology)) {
    return {
      left: toTopology(topology.left),
      right: toTopology(topology.right)
    };
  }
  if (v2.config.isNestedLeaf(topology)) {
    return _extends$7({}, topology, {
      tree: toTopology(topology.tree)
    });
  }
  return topology;
}
var arweave = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaults,
  ArweaveReader
});
class DebugConfigTracker {
  constructor(tracker2) {
    this.tracker = tracker2;
  }
  async loadPresignedConfiguration(args) {
    console.debug("? loadPresignedConfiguration");
    debug(args, "? ");
    return debug(await this.tracker.loadPresignedConfiguration(args), "! ");
  }
  savePresignedConfiguration(args) {
    console.debug("? savePresignedConfiguration");
    debug(args, "? ");
    return this.tracker.savePresignedConfiguration(args);
  }
  saveWitnesses(args) {
    console.debug("? saveWitnesses");
    debug(args, "? ");
    return this.tracker.saveWitnesses(args);
  }
  async configOfImageHash(args) {
    console.debug("? configOfImageHash");
    debug(args, "? ");
    return debug(await this.tracker.configOfImageHash(args), "! ");
  }
  saveWalletConfig(args) {
    console.debug("? saveWalletConfig");
    debug(args, "? ");
    return this.tracker.saveWalletConfig(args);
  }
  async imageHashOfCounterfactualWallet(args) {
    console.debug("? imageHashOfCounterfactualWallet");
    debug(args, "? ");
    return debug(await this.tracker.imageHashOfCounterfactualWallet(args), "! ");
  }
  saveCounterfactualWallet(args) {
    console.debug("? saveCounterfactualWallet");
    debug(args, "? ");
    return this.tracker.saveCounterfactualWallet(args);
  }
  async walletsOfSigner(args) {
    console.debug("? walletsOfSigner");
    debug(args, "? ");
    return debug(await this.tracker.walletsOfSigner(args), "! ");
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    console.debug("? getMigration");
    debug({
      address,
      fromImageHash,
      fromVersion,
      chainId
    }, "? ");
    return debug(await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId), "! ");
  }
  saveMigration(address, signed2, contexts) {
    console.debug("? saveMigration");
    debug({
      address,
      signed: signed2,
      contexts
    }, "? ");
    return this.tracker.saveMigration(address, signed2, contexts);
  }
}
function debug(value, prefix = "") {
  switch (value) {
    case void 0:
      console.debug(prefix + "undefined");
      break;
    default:
      JSON.stringify(value, bigintReplacer, 2).split("\n").map((line) => prefix + line).forEach((line) => console.debug(line));
      break;
  }
  return value;
}
var debug$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DebugConfigTracker
});
class MemoryTrackerStore {
  constructor() {
    this.configs = {};
    this.v2Nodes = {};
    this.counterfactualWallets = {};
    this.payloads = {};
    this.signatures = {};
    this.migrations = {};
    this.loadConfig = (imageHash2) => {
      return Promise.resolve(this.configs[imageHash2]);
    };
    this.saveConfig = (imageHash2, config2) => {
      this.configs[imageHash2] = config2;
      return Promise.resolve();
    };
    this.loadV2Node = (nodeHash) => {
      return Promise.resolve(this.v2Nodes[nodeHash]);
    };
    this.saveV2Node = (nodeHash, node) => {
      this.v2Nodes[nodeHash] = node;
      return Promise.resolve();
    };
    this.loadCounterfactualWallet = (wallet) => {
      return Promise.resolve(this.counterfactualWallets[wallet]);
    };
    this.saveCounterfactualWallet = (wallet, imageHash2, context2) => {
      this.counterfactualWallets[wallet] = {
        imageHash: imageHash2,
        context: context2
      };
      return Promise.resolve();
    };
    this.loadPayloadOfSubdigest = (subdigest) => {
      return Promise.resolve(this.payloads[subdigest]);
    };
    this.savePayloadOfSubdigest = (subdigest, payload) => {
      this.payloads[subdigest] = payload;
      return Promise.resolve();
    };
    this.loadSubdigestsOfSigner = (signer2) => {
      return Promise.resolve(Object.keys(this.signatures[signer2] || {}));
    };
    this.loadSignatureOfSubdigest = (signer2, subdigest) => {
      var _this$signatures$sign;
      return Promise.resolve((_this$signatures$sign = this.signatures[signer2]) == null ? void 0 : _this$signatures$sign[subdigest]);
    };
    this.saveSignatureOfSubdigest = (signer2, subdigest, payload) => {
      if (!this.signatures[signer2]) this.signatures[signer2] = {};
      this.signatures[signer2][subdigest] = payload;
      return Promise.resolve();
    };
    this.loadMigrationsSubdigest = (wallet, fromVersion, toVersion) => {
      var _this$migrations$wall;
      return Promise.resolve(((_this$migrations$wall = this.migrations[wallet]) == null || (_this$migrations$wall = _this$migrations$wall[fromVersion]) == null ? void 0 : _this$migrations$wall[toVersion]) || []);
    };
    this.saveMigrationsSubdigest = (wallet, fromVersion, toVersion, subdigest, toImageHash) => {
      if (!this.migrations[wallet]) this.migrations[wallet] = {};
      if (!this.migrations[wallet][fromVersion]) this.migrations[wallet][fromVersion] = {};
      if (!this.migrations[wallet][fromVersion][toVersion]) this.migrations[wallet][fromVersion][toVersion] = [];
      this.migrations[wallet][fromVersion][toVersion].push({
        subdigest,
        toImageHash
      });
      return Promise.resolve();
    };
  }
}
function recreateBigNumbers(object2) {
  if (object2 === void 0) return void 0;
  const result = {};
  for (const key of Object.keys(object2)) {
    const val = object2[key];
    if (val._isBigNumber === true && val._hex !== void 0 && typeof val._hex === "string" && val._hex.length !== "") {
      result[key] = BigInt(val._hex);
    } else if (Array.isArray(val)) {
      result[key] = val.map((v3) => recreateBigNumbers(v3));
    } else if (typeof val === "object" && val !== null) {
      result[key] = recreateBigNumbers(val);
    } else {
      result[key] = val;
    }
  }
  return result;
}
class IndexedDBStore {
  constructor(dbName) {
    var _this = this;
    this.dbName = dbName;
    this._lazyDb = void 0;
    this.loadConfig = async function(imageHash2) {
      const db2 = await _this.getDb();
      return db2.get("configs", imageHash2).then((c2) => recreateBigNumbers(c2));
    };
    this.saveConfig = async function(imageHash2, config2) {
      const db2 = await _this.getDb();
      await db2.put("configs", config2, imageHash2);
    };
    this.loadV2Node = async function(nodeHash) {
      const db2 = await _this.getDb();
      return db2.get("v2Nodes", nodeHash).then((c2) => recreateBigNumbers(c2));
    };
    this.saveV2Node = async function(nodeHash, node) {
      const db2 = await _this.getDb();
      await db2.put("v2Nodes", node, nodeHash);
    };
    this.loadCounterfactualWallet = async function(wallet) {
      const db2 = await _this.getDb();
      return db2.get("counterfactualWallets", wallet);
    };
    this.saveCounterfactualWallet = async function(wallet, imageHash2, context2) {
      const db2 = await _this.getDb();
      await db2.put("counterfactualWallets", {
        imageHash: imageHash2,
        context: context2
      }, wallet);
    };
    this.loadPayloadOfSubdigest = async function(subdigest) {
      const db2 = await _this.getDb();
      return db2.get("payloads", subdigest).then((c2) => recreateBigNumbers(c2));
    };
    this.savePayloadOfSubdigest = async function(subdigest, payload) {
      const db2 = await _this.getDb();
      await db2.put("payloads", payload, subdigest);
    };
    this.loadSubdigestsOfSigner = async function(signer2) {
      const db2 = await _this.getDb();
      const index2 = await db2.getAllKeysFromIndex("signatures", "signer", IDBKeyRange.only(signer2));
      return index2.map((key) => key.split("-")[0]);
    };
    this.loadSignatureOfSubdigest = async function(signer2, subdigest) {
      const db2 = await _this.getDb();
      const signature2 = await db2.get("signatures", [subdigest, signer2].join("-"));
      return signature2 == null ? void 0 : signature2.signature;
    };
    this.saveSignatureOfSubdigest = async function(signer2, subdigest, payload) {
      const db2 = await _this.getDb();
      await db2.put("signatures", {
        signature: payload,
        signer: signer2
      }, [subdigest, signer2].join("-"));
    };
    this.loadMigrationsSubdigest = async function(wallet, fromVersion, toVersion) {
      const db2 = await _this.getDb();
      const index2 = await db2.getAllFromIndex("migrations", "jump", IDBKeyRange.only([wallet, fromVersion, toVersion]));
      return index2.map((key) => ({
        subdigest: key.subdigest,
        toImageHash: key.toImageHash
      }));
    };
    this.saveMigrationsSubdigest = async function(wallet, fromVersion, toVersion, subdigest, toImageHash) {
      const db2 = await _this.getDb();
      await db2.put("migrations", {
        wallet,
        fromVersion,
        toVersion,
        subdigest,
        toImageHash
      }, subdigest);
    };
  }
  async getDb() {
    if (this._lazyDb) return this._lazyDb;
    const dbName = this.dbName;
    this._lazyDb = await openDB(dbName, 1, {
      upgrade(db2, oldVersion, newVersion, transaction2) {
        console.log(`upgrading ${dbName} from ${oldVersion} to ${newVersion} - ${transaction2}`);
        if (oldVersion === 0) {
          db2.createObjectStore("configs");
          db2.createObjectStore("v2Nodes");
          db2.createObjectStore("counterfactualWallets");
          db2.createObjectStore("payloads");
          const signatures = db2.createObjectStore("signatures");
          signatures.createIndex("signer", "signer", {
            unique: false
          });
          const migrations = db2.createObjectStore("migrations");
          migrations.createIndex("jump", ["wallet", "fromVersion", "toVersion"]);
        }
      }
    });
    return this._lazyDb;
  }
}
function isPlainNode(node) {
  return node.left !== void 0 && node.right !== void 0;
}
function isPlainNested(node) {
  return node.weight !== void 0 && node.threshold !== void 0 && node.tree !== void 0;
}
function isPlainV2Config(config2) {
  return config2.version === 2 && config2.threshold !== void 0 && config2.checkpoint !== void 0 && config2.tree !== void 0 && typeof config2.tree === "string";
}
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isPlainNode,
  isPlainNested,
  isPlainV2Config,
  MemoryTrackerStore,
  recreateBigNumbers,
  IndexedDBStore
});
class LocalConfigTracker {
  constructor(provider2, store = new MemoryTrackerStore(), useEIP5719 = false) {
    var _this = this;
    this.provider = provider2;
    this.store = store;
    this.useEIP5719 = useEIP5719;
    this.cachedEIP5719 = void 0;
    this.loadTopology = async function(hash2) {
      const node = await _this.store.loadV2Node(hash2);
      if (!node) return {
        nodeHash: hash2
      };
      if (isPlainNode(node)) {
        const [left, right] = await Promise.all([_this.loadTopology(node.left), _this.loadTopology(node.right)]);
        return {
          left,
          right
        };
      }
      if (isPlainNested(node)) {
        return {
          weight: BigInt(node.weight),
          threshold: BigInt(node.threshold),
          tree: await _this.loadTopology(node.tree)
        };
      }
      return node;
    };
    this.saveTopology = async function(node) {
      if (v2.config.isNodeLeaf(node)) {
        return;
      }
      const hash2 = v2.config.hashNode(node);
      if (v2.config.isNode(node)) {
        const saveLeft = _this.saveTopology(node.left);
        const saveRight = _this.saveTopology(node.right);
        const saveThis = _this.store.saveV2Node(hash2, {
          left: v2.config.hashNode(node.left),
          right: v2.config.hashNode(node.right)
        });
        await Promise.all([saveLeft, saveRight, saveThis]);
        return;
      }
      if (v2.config.isNestedLeaf(node)) {
        const saveTree = _this.saveTopology(node.tree);
        const saveThis = _this.store.saveV2Node(hash2, {
          weight: BigInt(node.weight).toString(),
          threshold: BigInt(node.threshold).toString(),
          tree: v2.config.hashNode(node.tree)
        });
        await Promise.all([saveTree, saveThis]);
        return;
      }
      if (v2.config.isSignerLeaf(node)) {
        return _this.store.saveV2Node(hash2, {
          address: node.address,
          weight: node.weight
        });
      }
      if (v2.config.isSubdigestLeaf(node)) {
        return _this.store.saveV2Node(hash2, {
          subdigest: node.subdigest
        });
      }
      throw new Error(`Unknown topology type: ${node}`);
    };
    this.saveWalletConfig = async function(args) {
      const {
        config: config2
      } = args;
      if (v1.config.ConfigCoder.isWalletConfig(config2)) {
        const imageHash2 = v1.config.ConfigCoder.imageHashOf(config2);
        return _this.store.saveConfig(imageHash2, config2);
      }
      if (v2.config.ConfigCoder.isWalletConfig(config2)) {
        const imageHash2 = v2.config.ConfigCoder.imageHashOf(config2);
        if (v2.config.isComplete(config2.tree)) {
          return _this.store.saveConfig(imageHash2, config2);
        }
      }
      return;
    };
    this.configOfImageHashCache = {};
    this.configOfImageHash = async function(args) {
      const {
        imageHash: imageHash2
      } = args;
      if (_this.configOfImageHashCache[args.imageHash]) {
        return _this.configOfImageHashCache[args.imageHash];
      }
      const config2 = await _this.store.loadConfig(imageHash2);
      if (!config2) {
        return void 0;
      }
      if (config2.version === 1 || config2.version === 2 && !isPlainV2Config(config2)) {
        _this.configOfImageHashCache[args.imageHash] = config2;
        return config2;
      }
      if (isPlainV2Config(config2)) {
        const fullConfig = {
          version: 2,
          threshold: BigInt(config2.threshold),
          checkpoint: BigInt(config2.checkpoint),
          tree: await _this.loadTopology(config2.tree)
        };
        _this.configOfImageHashCache[args.imageHash] = fullConfig;
        return fullConfig;
      }
      throw new Error(`Unknown config type: ${config2}`);
    };
    this.saveCounterfactualWallet = async function(args) {
      const {
        config: config2,
        context: context2
      } = args;
      const imageHash2 = index$6.genericCoderFor(config2.version).config.imageHashOf(config2);
      await Promise.all([_this.saveWalletConfig({
        config: config2
      }), ...context2.map((ctx) => {
        const address = index$1$1.context.addressOf(ctx, imageHash2);
        return _this.store.saveCounterfactualWallet(address, imageHash2, ctx);
      })]);
    };
    this.imageHashOfCounterfactualWallet = async function(args) {
      const {
        wallet
      } = args;
      const result = await _this.store.loadCounterfactualWallet(wallet);
      if (!result) return void 0;
      return {
        imageHash: result.imageHash,
        context: result.context
      };
    };
    this.savePayload = async function(args) {
      const {
        payload
      } = args;
      const subdigest = index$1$1.signature.subdigestOf(payload);
      await _this.store.savePayloadOfSubdigest(subdigest, payload);
    };
    this.payloadOfSubdigestCache = {};
    this.payloadOfSubdigest = async function(args) {
      if (_this.payloadOfSubdigestCache[args.subdigest]) {
        return _this.payloadOfSubdigestCache[args.subdigest];
      }
      const {
        subdigest
      } = args;
      const res = await _this.store.loadPayloadOfSubdigest(subdigest);
      if (res) {
        _this.payloadOfSubdigestCache[subdigest] = res;
      }
      return res;
    };
    this.savePresignedConfiguration = async function(args) {
      const decoded = v2.signature.SignatureCoder.decode(args.signature);
      const nextImageHash = index$6.genericCoderFor(args.nextConfig.version).config.imageHashOf(args.nextConfig);
      const message = v2.chained.messageSetImageHash(nextImageHash);
      const digest = keccak256(message);
      const payload = {
        message,
        address: args.wallet,
        chainId: 0,
        digest
      };
      const savePayload = _this.savePayload({
        payload
      });
      const saveNextConfig = _this.saveWalletConfig({
        config: args.nextConfig
      });
      const recovered = await v2.signature.SignatureCoder.recover(decoded, payload, _this.provider);
      const signatures = v2.signature.signaturesOf(recovered.config.tree);
      await Promise.all([savePayload, saveNextConfig, _this.saveWalletConfig({
        config: recovered.config
      }), ...signatures.map((sig) => _this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))]);
    };
    this.loadPresignedConfiguration = async function(args) {
      const {
        wallet,
        fromImageHash,
        longestPath
      } = args;
      const fromConfig = await _this.configOfImageHash({
        imageHash: fromImageHash
      });
      if (!fromConfig || !v2.config.ConfigCoder.isWalletConfig(fromConfig)) {
        return [];
      }
      const signers = v2.config.signersOf(fromConfig.tree).map((s2) => s2.address);
      const subdigestsOfSigner = await Promise.all(signers.map((s2) => _this.store.loadSubdigestsOfSigner(s2)));
      const subdigests = [...new Set(subdigestsOfSigner.flat())];
      const payloads = await Promise.all([...new Set(subdigests)].map(async function(s2) {
        return _extends$7({}, await _this.payloadOfSubdigest({
          subdigest: s2
        }), {
          subdigest: s2
        });
      }));
      const nextImageHashes = payloads.filter((p2) => (p2 == null ? void 0 : p2.message) && (p2 == null ? void 0 : p2.address) && p2.address === wallet).map((p2) => ({
        payload: p2,
        nextImageHash: v2.chained.decodeMessageSetImageHash(p2.message)
      })).filter((p2) => p2 == null ? void 0 : p2.nextImageHash);
      let bestCandidate;
      const nextConfigsAndCheckpoints = await Promise.all(nextImageHashes.map(async function({
        nextImageHash,
        payload
      }) {
        const nextConfig = await _this.configOfImageHash({
          imageHash: nextImageHash
        });
        if (!nextConfig || !v2.config.isWalletConfig(nextConfig)) return void 0;
        const nextCheckpoint = BigInt(nextConfig.checkpoint);
        return {
          nextConfig,
          nextCheckpoint,
          nextImageHash,
          payload
        };
      }));
      const sortedNextConfigsAndCheckpoints = nextConfigsAndCheckpoints.filter((c2) => c2 !== void 0).filter((c2) => c2.nextCheckpoint > BigInt(fromConfig.checkpoint)).sort((a2, b2) => (
        // If we are looking for the longest path, sort by ascending checkpoint
        // because we want to find the smalles jump, and we should start with the
        // closest one. If we are not looking for the longest path, sort by
        // descending checkpoint, because we want to find the largest jump.
        //
        // We don't have a guarantee that all "next configs" will be valid
        // so worst case scenario we will need to try all of them.
        // But we can try to optimize for the most common case.
        a2.nextCheckpoint > b2.nextCheckpoint ? longestPath ? 1 : -1 : longestPath ? -1 : 1
      ));
      for (const entry of sortedNextConfigsAndCheckpoints) {
        const {
          nextConfig,
          nextCheckpoint,
          nextImageHash,
          payload
        } = entry;
        if (bestCandidate) {
          const bestCheckpoint = bestCandidate.checkpoint;
          if (longestPath) {
            if (nextCheckpoint >= bestCheckpoint) continue;
          } else {
            if (nextCheckpoint <= bestCheckpoint) continue;
          }
        }
        const signatures = new Map((await Promise.all(signers.map(async function(signer2) {
          const signature2 = await _this.store.loadSignatureOfSubdigest(signer2, payload.subdigest);
          if (!signature2) {
            return [signer2, void 0];
          }
          const replacedSignature = hexlify(_this.useEIP5719 ? await _this.cachedEIP5719.runByEIP5719(signer2, payload.subdigest, signature2) : signature2);
          const isDynamic = index$1$1.signer.tryRecoverSigner(payload.subdigest, replacedSignature) !== signer2;
          return [signer2, {
            isDynamic,
            signature: replacedSignature
          }];
        }))).filter((signature2) => Boolean(signature2[1])));
        if (signatures.size === 0) continue;
        const encoded = v2.signature.SignatureCoder.encodeSigners(fromConfig, signatures, [], 0);
        if (encoded.weight < BigInt(fromConfig.threshold)) continue;
        bestCandidate = {
          nextImageHash,
          checkpoint: BigInt(nextConfig.checkpoint),
          signature: encoded.encoded
        };
      }
      if (!bestCandidate) {
        return [];
      }
      const nextStep = await _this.loadPresignedConfiguration({
        wallet,
        fromImageHash: bestCandidate.nextImageHash,
        longestPath
      });
      return [{
        wallet,
        nextImageHash: bestCandidate.nextImageHash,
        signature: bestCandidate.signature
      }, ...nextStep];
    };
    this.saveWitnesses = async function(args) {
      const payload = {
        digest: args.digest,
        address: args.wallet,
        chainId: args.chainId
      };
      const subdigest = index$1$1.signature.subdigestOf(payload);
      await Promise.all([_this.savePayload({
        payload
      }), ...args.signatures.filter((signature2) => {
        return index$1$1.signer.canRecover(signature2);
      }).map((signature2) => {
        const signer2 = index$1$1.signer.recoverSigner(subdigest, signature2);
        return _this.store.saveSignatureOfSubdigest(signer2, subdigest, signature2);
      })]);
    };
    this.walletsOfSigner = async function(args) {
      const subdigests = await _this.store.loadSubdigestsOfSigner(args.signer);
      const payloads = await Promise.all(subdigests.map((s2) => _this.payloadOfSubdigest({
        subdigest: s2
      }))).then((p2) => p2.filter((p3) => p3 !== void 0));
      const result = [];
      for (const payload of payloads) {
        const wallet = payload.address;
        if (result.find((r2) => r2.wallet === wallet)) continue;
        const subdigest = index$1$1.signature.subdigestOf(payload);
        const signature2 = await _this.store.loadSignatureOfSubdigest(args.signer, subdigest);
        if (!signature2) continue;
        result.push({
          wallet,
          proof: {
            digest: payload.digest,
            chainId: BigInt(payload.chainId),
            signature: hexlify(signature2)
          }
        });
      }
      return result;
    };
    this.cachedEIP5719 = new CachedEIP5719(provider2);
  }
  async saveMigration(address, signed2, contexts) {
    const fromVersion = signed2.fromVersion;
    if (fromVersion !== 1) throw new Error("Migration not supported");
    if (!v2.config.isWalletConfig(signed2.toConfig)) throw new Error("Invalid to config");
    const {
      newImageHash,
      address: decodedAddress
    } = index$5.v1v2.decodeTransaction(signed2.tx, contexts);
    if (decodedAddress !== address) throw new Error("Invalid migration transaction - address");
    if (v2.config.ConfigCoder.imageHashOf(signed2.toConfig) != newImageHash) throw new Error("Invalid migration transaction - config");
    const message = index$1$1.transaction.packMetaTransactionsData(signed2.tx.nonce, signed2.tx.transactions);
    const digest = keccak256(message);
    const payload = {
      chainId: signed2.tx.chainId,
      message,
      address,
      digest
    };
    const subdigest = index$1$1.signature.subdigestOf(payload);
    const savePayload = this.savePayload({
      payload
    });
    const saveToConfig = this.saveWalletConfig({
      config: signed2.toConfig
    });
    const decoded = v1.signature.SignatureCoder.decode(signed2.tx.signature);
    const recovered = await v1.signature.SignatureCoder.recover(decoded, payload, this.provider);
    const signatures = v1.signature.SignatureCoder.signaturesOf(recovered.config);
    await Promise.all([savePayload, saveToConfig, this.saveWalletConfig({
      config: recovered.config
    }), this.store.saveMigrationsSubdigest(address, fromVersion, fromVersion + 1, subdigest, newImageHash), ...signatures.map((sig) => this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))]);
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    var _this2 = this;
    const [currentConfig, txs] = await Promise.all([this.configOfImageHash({
      imageHash: fromImageHash
    }), this.store.loadMigrationsSubdigest(address, fromVersion, fromVersion + 1)]);
    const coder = index$6.coderFor(fromVersion);
    if (!currentConfig) {
      return void 0;
    }
    if (!coder.config.isWalletConfig(currentConfig)) {
      return void 0;
    }
    const candidates = await Promise.all(txs.map(async function(tx) {
      const {
        subdigest,
        toImageHash
      } = tx;
      const payload = await _this2.payloadOfSubdigest({
        subdigest
      });
      if (!payload || !payload.message) return void 0;
      if (BigInt(chainId) !== BigInt(payload.chainId)) return void 0;
      const signers = coder.config.signersOf(currentConfig).map((s2) => s2.address);
      const signatures = new Map((await Promise.all(signers.map(async function(signer2) {
        const signature2 = await _this2.store.loadSignatureOfSubdigest(signer2, subdigest);
        if (!signature2) {
          return [signer2, void 0];
        }
        const replacedSignature = hexlify(_this2.useEIP5719 ? await _this2.cachedEIP5719.runByEIP5719(signer2, subdigest, signature2) : signature2);
        const isDynamic = index$1$1.signer.tryRecoverSigner(subdigest, replacedSignature) !== signer2;
        return [signer2, {
          isDynamic,
          signature: replacedSignature
        }];
      }))).filter((signature2) => Boolean(signature2[1])));
      const encoded = coder.signature.encodeSigners(currentConfig, signatures, [], chainId);
      if (!encoded || encoded.weight < BigInt(currentConfig.threshold)) return void 0;
      const [nonce, transactions2] = index$1$1.transaction.unpackMetaTransactionsData(payload.message);
      return {
        tx: {
          entrypoint: address,
          transactions: index$1$1.transaction.fromTxAbiEncode(transactions2),
          chainId,
          nonce,
          signature: encoded.encoded,
          intent: {
            id: subdigest,
            wallet: address
          }
        },
        toConfig: await _this2.configOfImageHash({
          imageHash: toImageHash
        }),
        fromVersion,
        toVersion: fromVersion + 1
      };
    })).then((c2) => c2.filter((c3) => c3 !== void 0));
    return candidates[0];
  }
  updateProvider(provider2) {
    this.provider = provider2;
  }
}
var local = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LocalConfigTracker
});
let SignatureType = /* @__PURE__ */ function(SignatureType2) {
  SignatureType2["EIP712"] = "EIP712";
  SignatureType2["EthSign"] = "EthSign";
  SignatureType2["EIP1271"] = "EIP1271";
  return SignatureType2;
}({});
class Sessions {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Sessions/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$3({}, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.config = (args, headers, signal) => {
      return this.fetch(this.url("Config"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {
            version: _data6.version,
            config: _data6.config
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.wallets = (args, headers, signal) => {
      return this.fetch(this.url("Wallets"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {
            wallets: _data6.wallets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deployHash = (args, headers, signal) => {
      return this.fetch(this.url("DeployHash"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {
            deployHash: _data6.deployHash,
            context: _data6.context
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.configUpdates = (args, headers, signal) => {
      return this.fetch(this.url("ConfigUpdates"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {
            updates: _data6.updates
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.migrations = (args, headers, signal) => {
      return this.fetch(this.url("Migrations"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {
            migrations: _data6.migrations
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveConfig = (args, headers, signal) => {
      return this.fetch(this.url("SaveConfig"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveWallet = (args, headers, signal) => {
      return this.fetch(this.url("SaveWallet"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveSignature = (args, headers, signal) => {
      return this.fetch(this.url("SaveSignature"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveSignerSignatures = (args, headers, signal) => {
      return this.fetch(this.url("SaveSignerSignatures"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveMigration = (args, headers, signal) => {
      return this.fetch(this.url("SaveMigration"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$3 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$7({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$3 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$3.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$3[code2] || WebrpcError$3).new(data);
    }
    return data;
  });
};
let WebrpcError$3 = class WebrpcError5 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError5.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$3 = class WebrpcEndpointError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError5.prototype);
  }
};
let WebrpcRequestFailedError$3 = class WebrpcRequestFailedError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError5.prototype);
  }
};
let WebrpcBadRouteError$3 = class WebrpcBadRouteError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError5.prototype);
  }
};
let WebrpcBadMethodError$3 = class WebrpcBadMethodError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError5.prototype);
  }
};
let WebrpcBadRequestError$3 = class WebrpcBadRequestError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError5.prototype);
  }
};
let WebrpcBadResponseError$3 = class WebrpcBadResponseError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError5.prototype);
  }
};
let WebrpcServerPanicError$3 = class WebrpcServerPanicError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError5.prototype);
  }
};
let WebrpcInternalErrorError$3 = class WebrpcInternalErrorError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError5.prototype);
  }
};
let WebrpcClientDisconnectedError$3 = class WebrpcClientDisconnectedError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError5.prototype);
  }
};
let WebrpcStreamLostError$3 = class WebrpcStreamLostError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError5.prototype);
  }
};
let WebrpcStreamFinishedError$3 = class WebrpcStreamFinishedError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError5.prototype);
  }
};
let InvalidArgumentError$1 = class InvalidArgumentError5 extends WebrpcError$3 {
  constructor(name2 = "InvalidArgument", code2 = 1, message = "invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError5.prototype);
  }
};
let NotFoundError$2 = class NotFoundError5 extends WebrpcError$3 {
  constructor(name2 = "NotFound", code2 = 2, message = "not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError5.prototype);
  }
};
const webrpcErrorByCode$3 = {
  [0]: WebrpcEndpointError$3,
  [-1]: WebrpcRequestFailedError$3,
  [-2]: WebrpcBadRouteError$3,
  [-3]: WebrpcBadMethodError$3,
  [-4]: WebrpcBadRequestError$3,
  [-5]: WebrpcBadResponseError$3,
  [-6]: WebrpcServerPanicError$3,
  [-7]: WebrpcInternalErrorError$3,
  [-8]: WebrpcClientDisconnectedError$3,
  [-9]: WebrpcStreamLostError$3,
  [-10]: WebrpcStreamFinishedError$3,
  [1]: InvalidArgumentError$1,
  [2]: NotFoundError$2
};
class RemoteConfigTracker {
  constructor(hostname, onlyRecoverable = true) {
    this.onlyRecoverable = onlyRecoverable;
    this.sessions = void 0;
    this.sessions = new Sessions(hostname, fetch);
  }
  async loadPresignedConfiguration(args) {
    try {
      const {
        updates
      } = await this.sessions.configUpdates({
        wallet: args.wallet,
        fromImageHash: args.fromImageHash,
        allUpdates: args.longestPath
      });
      return updates.map(({
        toImageHash,
        signature: signature2
      }) => ({
        wallet: args.wallet,
        nextImageHash: toImageHash,
        signature: signature2
      }));
    } catch (error) {
      if (is404NotFound(error)) {
        return [];
      } else {
        throw error;
      }
    }
  }
  async savePresignedConfiguration(args) {
    const config2 = args.nextConfig;
    const imageHash2 = index$6.genericCoderFor(config2.version).config.imageHashOf(config2);
    const message = v2.signature.setImageHashStruct(imageHash2);
    const digest = keccak256(message);
    await this.sessions.saveSignature({
      wallet: args.wallet,
      digest,
      chainID: "0",
      signature: args.signature,
      toConfig: encodeConfig(config2)
    });
  }
  async saveWitnesses(args) {
    let filteredSignatures = args.signatures;
    if (this.onlyRecoverable) {
      filteredSignatures = filteredSignatures.filter((signature2) => {
        return index$1$1.signer.canRecover(signature2);
      });
    }
    await this.sessions.saveSignerSignatures({
      wallet: args.wallet,
      digest: args.digest,
      chainID: numberString(args.chainId),
      signatures: filteredSignatures
    });
  }
  async configOfImageHash(args) {
    try {
      const {
        version: version2,
        config: config2
      } = await this.sessions.config(args);
      return decodeConfig(version2, config2);
    } catch (error) {
      if (is404NotFound(error)) {
        return;
      } else {
        throw error;
      }
    }
  }
  async saveWalletConfig(args) {
    const config2 = encodeConfig(args.config);
    await this.sessions.saveConfig({
      version: args.config.version,
      config: config2
    });
  }
  async imageHashOfCounterfactualWallet(args) {
    try {
      const {
        deployHash,
        context: context2
      } = await this.sessions.deployHash(args);
      return {
        imageHash: deployHash,
        context: context2
      };
    } catch (error) {
      if (is404NotFound(error)) {
        return;
      } else {
        throw error;
      }
    }
  }
  async saveCounterfactualWallet(args) {
    const deployConfig = encodeConfig(args.config);
    await this.sessions.saveWallet({
      version: args.config.version,
      deployConfig
    });
  }
  async walletsOfSigner(args) {
    const {
      wallets
    } = await this.sessions.wallets(args);
    return Object.entries(wallets).map(([wallet, {
      digest,
      chainID,
      type,
      signature: signature2
    }]) => {
      switch (type) {
        case SignatureType.EIP712:
          signature2 += toBeHex(index$1$1.signer.SigType.EIP712).slice(2);
          break;
        case SignatureType.EthSign:
          signature2 += toBeHex(index$1$1.signer.SigType.ETH_SIGN).slice(2);
          break;
        case SignatureType.EIP1271:
          signature2 += toBeHex(index$1$1.signer.SigType.WALLET_BYTES32).slice(2);
          break;
      }
      return {
        wallet,
        proof: {
          digest,
          signature: signature2,
          chainId: BigInt(chainID)
        }
      };
    });
  }
  async getMigration(wallet, fromImageHash, fromVersion, chainId) {
    var _this = this;
    const chainIdString = numberString(chainId);
    const {
      migrations
    } = await this.sessions.migrations({
      wallet,
      fromVersion,
      fromImageHash,
      chainID: chainIdString
    });
    const chooseMigration = async function chooseMigration2(chainId2) {
      const migrations_ = migrations[chainId2];
      if (migrations_) {
        const toVersions = Object.keys(migrations_).map(Number).sort((a2, b2) => b2 - a2);
        for (const toVersion of toVersions) {
          for (const [toHash, transactions2] of Object.entries(migrations_[toVersion])) {
            try {
              const toConfig = await _this.configOfImageHash({
                imageHash: toHash
              });
              if (toConfig) {
                return {
                  fromVersion,
                  toVersion,
                  toConfig,
                  tx: {
                    entrypoint: transactions2.executor,
                    transactions: transactions2.transactions,
                    nonce: transactions2.nonce,
                    signature: transactions2.signature,
                    chainId: chainId2,
                    intent: {
                      id: index$1$1.transaction.subdigestOfTransactions(wallet, chainId2, transactions2.nonce, transactions2.transactions),
                      wallet
                    }
                  }
                };
              }
            } catch (error) {
              console.error(error);
            }
          }
        }
      }
      return;
    };
    const migration2 = await chooseMigration(chainIdString);
    if (migration2) {
      return migration2;
    }
    for (const _chainId4 in migrations) {
      if (_chainId4 !== chainIdString) {
        const _migration = await chooseMigration(_chainId4);
        if (_migration) {
          return _migration;
        }
      }
    }
    return;
  }
  async saveMigration(wallet, signed2, _contexts) {
    await this.sessions.saveMigration({
      wallet,
      fromVersion: signed2.fromVersion,
      toVersion: signed2.toVersion,
      toConfig: encodeConfig(signed2.toConfig),
      executor: signed2.tx.entrypoint,
      transactions: signed2.tx.transactions.map(encodeTransaction),
      nonce: numberString(signed2.tx.nonce),
      signature: signed2.tx.signature,
      chainID: numberString(signed2.tx.chainId)
    });
  }
}
function encodeConfig(config2) {
  switch (config2.version) {
    case 1:
      if (v1.config.ConfigCoder.isWalletConfig(config2)) {
        return {
          threshold: numberNumber(config2.threshold),
          signers: config2.signers.map(({
            weight,
            address
          }) => ({
            weight: numberNumber(weight),
            address
          }))
        };
      } else {
        throw new Error(`not a v${config2.version} config: ${config2}`);
      }
    case 2:
      if (v2.config.ConfigCoder.isWalletConfig(config2)) {
        return {
          threshold: numberNumber(config2.threshold),
          checkpoint: numberNumber(config2.checkpoint),
          tree: encodeV2ConfigTree(config2.tree)
        };
      } else {
        throw new Error(`not a v${config2.version} config: ${config2}`);
      }
    default:
      throw new Error(`unknown version ${config2.version}`);
  }
}
function encodeV2ConfigTree(tree) {
  if (v2.config.isNode(tree)) {
    return {
      left: encodeV2ConfigTree(tree.left),
      right: encodeV2ConfigTree(tree.right)
    };
  } else if (v2.config.isSignerLeaf(tree)) {
    return {
      weight: numberNumber(tree.weight),
      address: tree.address
    };
  } else if (v2.config.isNestedLeaf(tree)) {
    return {
      weight: numberNumber(tree.weight),
      threshold: numberNumber(tree.threshold),
      tree: encodeV2ConfigTree(tree.tree)
    };
  } else if (v2.config.isNodeLeaf(tree)) {
    return {
      node: tree.nodeHash
    };
  } else {
    return _extends$7({}, tree);
  }
}
function decodeConfig(version2, config2) {
  switch (version2) {
    case 1:
      return _extends$7({}, config2, {
        version: version2
      });
    case 2:
      return _extends$7({}, config2, {
        version: version2,
        tree: decodeV2ConfigTree(config2.tree)
      });
    default:
      throw new Error(`unknown version ${version2}`);
  }
}
function decodeV2ConfigTree(tree) {
  switch (typeof tree) {
    case "object":
      const tree_ = _extends$7({}, tree);
      if (tree_.left !== void 0) {
        tree_.left = decodeV2ConfigTree(tree_.left);
      }
      if (tree_.right !== void 0) {
        tree_.right = decodeV2ConfigTree(tree_.right);
      }
      if (tree_.tree !== void 0) {
        tree_.tree = decodeV2ConfigTree(tree_.tree);
      }
      if (tree_.node !== void 0) {
        tree_.nodeHash = tree_.node;
        delete tree_.node;
      }
      return tree_;
    default:
      throw new Error(`v2 config tree ${tree} is not an object`);
  }
}
function encodeTransaction(transaction2) {
  return {
    to: transaction2.to,
    value: transaction2.value !== void 0 ? numberString(transaction2.value) : void 0,
    data: transaction2.data !== void 0 ? hexlify(transaction2.data) : void 0,
    gasLimit: transaction2.gasLimit !== void 0 ? numberString(transaction2.gasLimit) : void 0,
    delegateCall: transaction2.delegateCall,
    revertOnError: transaction2.revertOnError
  };
}
function numberNumber(n2) {
  return Number(n2);
}
function numberString(n2) {
  return BigInt(n2).toString();
}
function is404NotFound(error) {
  return typeof error === "object" && error.status === 404;
}
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  RemoteConfigTracker
});
function raceUntil(promises, fallback2, evalRes) {
  return new Promise((resolve) => {
    let count2 = 0;
    promises.forEach((p2) => p2.then((val) => {
      if (evalRes(val)) {
        resolve(val);
      } else {
        count2++;
        if (count2 === promises.length) {
          resolve(fallback2);
        }
      }
    }).catch(() => {
      count2++;
      if (count2 === promises.length) {
        resolve(fallback2);
      }
    }));
  });
}
async function allSafe(promises, fallback2) {
  return Promise.all(promises.map((promise) => promise.catch(() => fallback2)));
}
class MultipleTracker {
  constructor(trackers) {
    this.trackers = trackers;
  }
  async configOfImageHash(args) {
    const requests = this.trackers.map(async function(t2, i) {
      return {
        res: await t2.configOfImageHash(args),
        i
      };
    });
    const result1 = await raceUntil(requests, void 0, (val) => {
      if ((val == null ? void 0 : val.res) === void 0) return false;
      return index$6.genericCoderFor(val.res.version).config.isComplete(val.res);
    });
    if (result1 != null && result1.res) {
      this.saveWalletConfig({
        config: result1.res,
        skipTracker: result1.i
      });
      return result1.res;
    }
    const tmptracker = new LocalConfigTracker(void 0);
    const results2 = await allSafe(requests, void 0);
    for (const r2 of results2) {
      if (r2 != null && r2.res) await tmptracker.saveWalletConfig({
        config: r2.res
      });
    }
    const result2 = await tmptracker.configOfImageHash(args);
    if (result2) this.saveWalletConfig({
      config: result2
    });
    return result2;
  }
  async saveWalletConfig(args) {
    await Promise.all(this.trackers.map((t2, i) => {
      if (i === args.skipTracker) return;
      return t2.saveWalletConfig(args);
    }));
  }
  async imageHashOfCounterfactualWallet(args) {
    const imageHash2 = await raceUntil(this.trackers.map((t2) => t2.imageHashOfCounterfactualWallet(args)), void 0, (result) => Boolean(result));
    if (imageHash2) {
      this.configOfImageHash({
        imageHash: imageHash2.imageHash
      }).then((config2) => {
        if (config2) {
          this.saveCounterfactualWallet({
            config: config2,
            context: [imageHash2.context]
          });
        }
      });
    }
    return imageHash2;
  }
  async saveCounterfactualWallet(args) {
    await Promise.all(this.trackers.map((t2, i) => {
      if (i === args.skipTracker) return;
      return t2.saveCounterfactualWallet(args);
    }));
  }
  async walletsOfSigner(args) {
    const results2 = await allSafe(this.trackers.map((t2) => t2.walletsOfSigner(args)), []).then((r2) => r2.flat());
    const wallets = {};
    for (const r2 of results2) {
      wallets[r2.wallet] = r2.proof;
    }
    const result = Object.keys(wallets).map((w2) => ({
      wallet: w2,
      proof: wallets[w2]
    }));
    const witnesses = /* @__PURE__ */ new Map();
    result.forEach(({
      wallet,
      proof: {
        digest,
        chainId,
        signature: signature2
      }
    }) => {
      const key = `${wallet}-${digest}-${chainId}`;
      let signatures = witnesses.get(key);
      if (!signatures) {
        signatures = {
          wallet,
          digest,
          chainId,
          signatures: []
        };
        witnesses.set(key, signatures);
      }
      signatures.signatures.push(signature2);
    });
    witnesses.forEach((witnesses2) => this.saveWitnesses(witnesses2));
    return result;
  }
  async saveWitnesses(args) {
    await Promise.all(this.trackers.map((t2) => t2.saveWitnesses(args)));
  }
  async loadPresignedConfiguration(args) {
    var _this = this;
    const results2 = await allSafe(this.trackers.map((t2) => t2.loadPresignedConfiguration(args)), []);
    const checkpoints = await allSafe(results2.map(async function(r2) {
      const last = r2[r2.length - 1];
      const config3 = await _this.configOfImageHash({
        imageHash: last.nextImageHash
      });
      if (!config3) return void 0;
      return {
        checkpoint: index$6.genericCoderFor(config3.version).config.checkpointOf(config3),
        result: r2
      };
    }), void 0);
    const best = checkpoints.reduce((acc, val) => {
      if (!val) return acc;
      if (!acc) return val;
      if (val.checkpoint > acc.checkpoint) return val;
      return acc;
    });
    if (!best) return [];
    const configs = /* @__PURE__ */ new Map();
    const config2 = (imageHash2) => {
      if (!configs.has(imageHash2)) {
        configs.set(imageHash2, this.configOfImageHash({
          imageHash: imageHash2
        }));
      }
      return configs.get(imageHash2);
    };
    best.result.forEach(async function(res) {
      const nextConfig = await config2(res.nextImageHash);
      if (nextConfig) {
        _this.savePresignedConfiguration({
          wallet: args.wallet,
          nextConfig,
          signature: res.signature
        });
      }
    });
    return best.result;
  }
  async savePresignedConfiguration(args) {
    await Promise.all(this.trackers.map((t2) => t2.savePresignedConfiguration(args)));
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    const results2 = await Promise.all(this.trackers.map((t2) => t2.getMigration(address, fromImageHash, fromVersion, chainId)));
    return results2.find((r2) => !!r2);
  }
  async saveMigration(address, signed2, contexts) {
    await Promise.all(this.trackers.map((t2) => t2.saveMigration(address, signed2, contexts)));
  }
}
class CachedTracker {
  constructor(tracker2, cache2, contexts) {
    this.tracker = tracker2;
    this.cache = cache2;
    this.contexts = contexts;
  }
  async loadPresignedConfiguration(args) {
    var _this = this;
    const results2 = [this.tracker.loadPresignedConfiguration(args), this.cache.loadPresignedConfiguration(args)];
    let best;
    const [result1, result2] = await Promise.all(results2);
    if (result1.length > 0 && result2.length > 0 && result1[result1.length - 1].nextImageHash === result2[result2.length - 1].nextImageHash) {
      best = args.longestPath === true ? result1.length > result2.length ? result1 : result2 : result1.length < result2.length ? result1 : result2;
    } else {
      var _checkpoints$reduce$r, _checkpoints$reduce;
      const checkpoints = await Promise.all(results2.map(async function(result) {
        const r2 = await result;
        const last = r2[r2.length - 1];
        if (!last) return void 0;
        const config2 = await _this.configOfImageHash({
          imageHash: last.nextImageHash
        });
        if (!config2) return void 0;
        return {
          checkpoint: index$6.genericCoderFor(config2.version).config.checkpointOf(config2),
          result: r2
        };
      }));
      best = (_checkpoints$reduce$r = (_checkpoints$reduce = checkpoints.reduce((acc, val) => {
        if (!val) return acc;
        if (!acc) return val;
        if (val.checkpoint > acc.checkpoint) return val;
        return acc;
      })) == null ? void 0 : _checkpoints$reduce.result) != null ? _checkpoints$reduce$r : [];
    }
    if (!best) return [];
    return best;
  }
  async savePresignedConfiguration(args) {
    await Promise.all([this.tracker.savePresignedConfiguration(args), this.cache.savePresignedConfiguration(args)]);
  }
  async configOfImageHash(args) {
    if (args.noCache !== true) {
      const config3 = await this.cache.configOfImageHash(args);
      if (config3) return config3;
    }
    const config2 = await this.tracker.configOfImageHash(args);
    if (config2) {
      await this.cache.saveWalletConfig({
        config: config2
      });
    }
    return config2;
  }
  async saveWalletConfig(args) {
    await Promise.all([this.tracker.saveWalletConfig(args), this.cache.saveWalletConfig(args)]);
  }
  async imageHashOfCounterfactualWallet(args) {
    if (args.noCache !== true) {
      const result1 = await this.cache.imageHashOfCounterfactualWallet(args);
      if (result1) return result1;
    }
    const result2 = await this.tracker.imageHashOfCounterfactualWallet(args);
    if (result2) {
      const config2 = await this.configOfImageHash({
        imageHash: result2.imageHash
      });
      if (config2) {
        await this.cache.saveCounterfactualWallet({
          config: config2,
          context: [result2.context]
        });
      }
    }
    return result2;
  }
  async saveCounterfactualWallet(args) {
    await Promise.all([this.tracker.saveCounterfactualWallet(args), this.cache.saveCounterfactualWallet(args)]);
  }
  async walletsOfSigner(args) {
    if (args.noCache) {
      return this.tracker.walletsOfSigner(args);
    }
    const results2 = await Promise.all([this.tracker.walletsOfSigner(args), this.cache.walletsOfSigner(args)]);
    const wallets = /* @__PURE__ */ new Map();
    for (const result of results2) {
      for (const wallet of result) {
        wallets.set(wallet.wallet, wallet);
      }
    }
    return Array.from(wallets.values());
  }
  async saveWitnesses(args) {
    await Promise.all([this.tracker.saveWitnesses(args), this.cache.saveWitnesses(args)]);
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    const migration1 = await this.cache.getMigration(address, fromImageHash, fromVersion, chainId);
    if (migration1) return migration1;
    const migration2 = await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId);
    if (migration2) {
      await this.cache.saveMigration(address, migration2, this.contexts);
    }
    return migration2;
  }
  async saveMigration(address, signed2, contexts) {
    await Promise.all([this.tracker.saveMigration(address, signed2, contexts), this.cache.saveMigration(address, signed2, contexts)]);
  }
}
class PromiseCache2 {
  constructor() {
    this.cache = void 0;
    this.cache = /* @__PURE__ */ new Map();
  }
  do(key, validMilliseconds, task, ...args) {
    key = `${key}:${id$1(JSON.stringify(args, deterministically))}`;
    let entry = this.cache.get(key);
    if (entry) {
      if (entry.expiration) {
        if (/* @__PURE__ */ new Date() >= entry.expiration) {
          entry = void 0;
          this.cache.delete(key);
        }
      }
    }
    if (!entry) {
      const entry_ = {
        promise: task(...args)
      };
      if (validMilliseconds !== void 0) {
        entry_.promise = entry_.promise.then((result) => {
          entry_.expiration = new Date(Date.now() + validMilliseconds);
          return result;
        });
      }
      entry = entry_;
      this.cache.set(key, entry);
    }
    return entry.promise;
  }
}
function deterministically(_key, value) {
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    return Object.fromEntries(Object.entries(value).sort());
  } else if (typeof value === "bigint") {
    return value.toString();
  }
  return value;
}
function isDedupedTracker(tracker2) {
  return tracker2 instanceof DedupedTracker;
}
class DedupedTracker {
  constructor(tracker2, window2 = 50, verbose = false) {
    this.tracker = tracker2;
    this.window = window2;
    this.verbose = verbose;
    this.cache = new PromiseCache2();
  }
  invalidateCache() {
    this.cache = new PromiseCache2();
  }
  configOfImageHash(args) {
    return this.cache.do("configOfImageHash", this.window, (args2) => this.tracker.configOfImageHash(args2), args);
  }
  getMigration(address, fromImageHash, fromVersion, chainId) {
    return this.cache.do("getMigration", this.window, (...args) => this.tracker.getMigration(...args), address, fromImageHash, fromVersion, chainId);
  }
  saveMigration(address, signed2, contexts) {
    return this.cache.do("saveMigration", void 0, (...args) => this.tracker.saveMigration(...args), address, signed2, contexts);
  }
  loadPresignedConfiguration(args) {
    return this.cache.do("loadPresignedConfiguration", this.window, (args2) => this.tracker.loadPresignedConfiguration(args2), args);
  }
  savePresignedConfiguration(args) {
    return this.cache.do("savePresignedConfiguration", void 0, (args2) => this.tracker.savePresignedConfiguration(args2), args);
  }
  saveWitnesses(args) {
    return this.cache.do("saveWitnesses", void 0, (args2) => this.tracker.saveWitnesses(args2), args);
  }
  saveWalletConfig(args) {
    return this.cache.do("saveWalletConfig", void 0, (args2) => this.tracker.saveWalletConfig(args2), args);
  }
  imageHashOfCounterfactualWallet(args) {
    return this.cache.do("imageHashOfCounterfactualWallet", void 0, (args2) => this.tracker.imageHashOfCounterfactualWallet(args2), args);
  }
  saveCounterfactualWallet(args) {
    return this.cache.do("saveCounterfactualWallet", void 0, (args2) => this.tracker.saveCounterfactualWallet(args2), args);
  }
  walletsOfSigner(args) {
    return this.cache.do("walletsOfSigner", this.window, (args2) => this.tracker.walletsOfSigner(args2), args);
  }
  updateProvider(provider2) {
    if (this.tracker instanceof LocalConfigTracker) {
      this.tracker.updateProvider(provider2);
    }
  }
}
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arweave,
  debug: debug$1,
  local,
  remote: index$1,
  stores: index$2,
  raceUntil,
  allSafe,
  MultipleTracker,
  CachedTracker,
  isDedupedTracker,
  DedupedTracker
});
const sessions$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  tracker,
  trackers: index$3
}, Symbol.toStringTag, { value: "Module" }));
const DEFAULT_SESSION_EXPIRATION$1 = 60 * 60 * 24 * 7;
const EXPIRATION_JWT_MARGIN = 60;
class Services {
  constructor(account2, settings, status = {}, projectAccessKey2) {
    this.account = account2;
    this.settings = settings;
    this.status = status;
    this._initialAuthRequest = void 0;
    this.proofStrings = /* @__PURE__ */ new Map();
    this.onAuthCallbacks = [];
    this.apiClient = void 0;
    this.metadataClient = void 0;
    this.indexerClients = /* @__PURE__ */ new Map();
    this.projectAccessKey = void 0;
    this.projectAccessKey = projectAccessKey2;
  }
  now() {
    return Math.floor(Date.now() / 1e3);
  }
  get expiration() {
    var _this$settings$metada;
    return Math.max((_this$settings$metada = this.settings.metadata.expiration) != null ? _this$settings$metada : DEFAULT_SESSION_EXPIRATION$1, 120);
  }
  onAuth(cb2) {
    this.onAuthCallbacks.push(cb2);
    return () => this.onAuthCallbacks = this.onAuthCallbacks.filter((c2) => c2 !== cb2);
  }
  async dump() {
    if (!this.status.jwt) return {
      metadata: this.settings.metadata
    };
    return {
      jwt: {
        token: await this.status.jwt.token,
        expiration: this.status.jwt.expiration
      },
      metadata: this.status.metadata
    };
  }
  auth(maxTries = 5) {
    var _this = this;
    if (this._initialAuthRequest) return this._initialAuthRequest;
    this._initialAuthRequest = async function() {
      const url = _this.settings.sequenceApiUrl;
      if (!url) throw Error("No sequence api url");
      let jwtAuth;
      for (let i = 1; ; i++) {
        try {
          jwtAuth = (await _this.getJWT(true)).token;
          break;
        } catch (error) {
          if (i === maxTries) {
            console.error(`couldn't authenticate after ${maxTries} attempts`, error);
            throw error;
          }
        }
      }
      return new SequenceAPIClient(url, void 0, jwtAuth);
    }();
    return this._initialAuthRequest;
  }
  async getJWT(tryAuth) {
    var _this2 = this;
    const url = this.settings.sequenceApiUrl;
    if (!url) throw Error("No sequence api url");
    if (this.status.jwt) {
      const _jwt = this.status.jwt;
      const _token = await _jwt.token;
      if (this.now() < _jwt.expiration) {
        return {
          token: _token,
          expiration: _jwt.expiration
        };
      }
      this.status.jwt = void 0;
    }
    if (!tryAuth) {
      throw new Error("no auth token in memory");
    }
    const proofStringKey = this.getProofStringKey();
    const {
      proofString,
      expiration
    } = this.getProofString(proofStringKey);
    const jwt = {
      token: proofString.then(async function(proofString2) {
        const api2 = new SequenceAPIClient(url);
        const authResp = await api2.getAuthToken({
          ewtString: proofString2
        });
        if ((authResp == null ? void 0 : authResp.status) === true && authResp.jwtToken.length !== 0) {
          return authResp.jwtToken;
        } else {
          if (!await _this2.isProofStringValid(proofString2)) {
            _this2.proofStrings.delete(proofStringKey);
          }
          throw new Error("no auth token from server");
        }
      }).catch((reason) => {
        this.status.jwt = void 0;
        throw reason;
      }),
      expiration
    };
    this.status.jwt = jwt;
    jwt.token.then((token2) => {
      this.onAuthCallbacks.forEach((cb2) => {
        try {
          cb2({
            status: "fulfilled",
            value: token2
          });
        } catch (_unused) {
        }
      });
    }).catch((reason) => {
      this.onAuthCallbacks.forEach((cb2) => {
        try {
          cb2({
            status: "rejected",
            reason
          });
        } catch (_unused2) {
        }
      });
    });
    const token = await jwt.token;
    return {
      token,
      expiration
    };
  }
  getProofStringKey() {
    return `${this.account.address} - ${this.settings.metadata.name}`;
  }
  async isProofStringValid(proofString) {
    try {
      const ethAuth = new ETHAuth();
      const chainId = BigInt(this.settings.sequenceApiChainId);
      const found = findNetworkConfig(this.account.networks, chainId);
      if (!found) {
        throw Error("No network found");
      }
      ethAuth.chainId = Number(chainId);
      const network2 = new Network(found.name, chainId);
      ethAuth.provider = new JsonRpcProvider$1(getFetchRequest(found.rpcUrl, this.projectAccessKey), network2, {
        staticNetwork: network2
      });
      await ethAuth.decodeProof(proofString);
      return true;
    } catch (_unused3) {
      return false;
    }
  }
  async getAPIClient(tryAuth = true) {
    if (!this.apiClient) {
      const url = this.settings.sequenceApiUrl;
      if (!url) throw Error("No sequence api url");
      const jwtAuth = (await this.getJWT(tryAuth)).token;
      this.apiClient = new SequenceAPIClient(url, void 0, jwtAuth);
    }
    return this.apiClient;
  }
  async getMetadataClient(tryAuth = true) {
    if (!this.metadataClient) {
      const jwtAuth = (await this.getJWT(tryAuth)).token;
      this.metadataClient = new SequenceMetadata(this.settings.sequenceMetadataUrl, void 0, jwtAuth);
    }
    return this.metadataClient;
  }
  async getIndexerClient(chainId, tryAuth = true) {
    const network2 = findNetworkConfig(this.account.networks, chainId);
    if (!network2) {
      throw Error(`No network for chain ${chainId}`);
    }
    if (!this.indexerClients.has(network2.chainId)) {
      if (network2.indexer) {
        this.indexerClients.set(network2.chainId, network2.indexer);
      } else if (network2.indexerUrl) {
        const jwtAuth = (await this.getJWT(tryAuth)).token;
        this.indexerClients.set(network2.chainId, new SequenceIndexer(network2.indexerUrl, void 0, jwtAuth));
      } else {
        throw Error(`No indexer url for chain ${chainId}`);
      }
    }
    return this.indexerClients.get(network2.chainId);
  }
  getProofString(key) {
    if (this.proofStrings.has(key)) {
      const _proofString = this.proofStrings.get(key);
      if (this.now() < _proofString.expiration) {
        return _proofString;
      }
      this.proofStrings.delete(key);
    }
    const proof = new Proof({
      address: this.account.address
    });
    proof.claims.app = this.settings.metadata.name;
    if (typeof window === "object") {
      proof.claims.ogn = window.location.origin;
    }
    proof.setExpiryIn(this.expiration);
    const ethAuth = new ETHAuth();
    const chainId = BigInt(this.settings.sequenceApiChainId);
    const found = findNetworkConfig(this.account.networks, chainId);
    if (!found) {
      throw Error("No network found");
    }
    ethAuth.chainId = Number(chainId);
    const network2 = new Network(found.name, chainId);
    ethAuth.provider = new JsonRpcProvider$1(getFetchRequest(found.rpcUrl, this.projectAccessKey), network2, {
      staticNetwork: network2
    });
    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN;
    const proofString = {
      proofString: Promise.resolve(
        // NOTICE: TODO: Here we ask the account to sign the message
        // using whatever configuration we have ON-CHAIN, this means
        // that the account will still use the v1 wallet, even if the migration
        // was signed.
        //
        // This works for Sequence webapp v1 -> v2 because all v1 configurations share the same formula
        // (torus + guard), but if we ever decide to allow cross-device login, then it will not work, because
        // those other signers may not be part of the configuration.
        //
        this.account.signDigest(proof.messageDigest(), this.settings.sequenceApiChainId, true, "eip6492")
      ).then((s2) => {
        proof.signature = s2;
        return ethAuth.encodeProof(proof, true);
      }).catch((reason) => {
        this.proofStrings.delete(key);
        throw reason;
      }),
      expiration
    };
    this.proofStrings.set(key, proofString);
    return proofString;
  }
}
const signAuthorization = async (signer2, chainId, options) => {
  const address = getAddress(await signer2.getAddress());
  if (!address || address === "" || address === "0x") {
    throw ErrAccountIsRequired;
  }
  const proof = new Proof();
  proof.address = address;
  if (!options || !options.app || options.app === "") {
    throw new AuthError("authorization options requires app to be set");
  }
  proof.claims.app = options.app;
  proof.claims.ogn = options.origin;
  proof.claims.n = options.nonce;
  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION$1);
  const typedData = proof.messageTypedData();
  const chainIdNumber = toChainIdNumber(chainId);
  proof.signature = await (signer2 instanceof Account ? (
    // Account can sign EIP-6492 signatures, so it doesn't require deploying the wallet
    signer2.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber, "eip6492")
  ) : signer2.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber));
  const ethAuth = new ETHAuth();
  const proofString = await ethAuth.encodeProof(proof, true);
  return {
    typedData,
    proofString
  };
};
class AuthError extends Error {
  constructor(message) {
    super(message);
    this.name = "AuthError";
  }
}
const ErrAccountIsRequired = new AuthError("auth error: account address is empty");
function _extends$6() {
  return _extends$6 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$6.apply(null, arguments);
}
function isSessionDumpV1(obj) {
  return obj.config && obj.metadata && obj.version === void 0;
}
function isSessionDumpV2(obj) {
  return obj.version === 2 && obj.address;
}
const CRITICAL_CHAINS = [1, 137];
const SessionSettingsDefault = {
  contexts: index$1$1.context.defaultContexts,
  networks: allNetworks$1,
  tracker: new index$3.remote.RemoteConfigTracker("https://sessions.sequence.app")
};
class Session {
  constructor(networks2, contexts, account2, services) {
    this.networks = networks2;
    this.contexts = contexts;
    this.account = account2;
    this.services = services;
  }
  async dump() {
    const base = {
      version: 2,
      address: this.account.address
    };
    if (this.services) {
      return _extends$6({}, base, await this.services.dump());
    }
    return base;
  }
  static async singleSigner(args) {
    let {
      signer: signer2
    } = args;
    if (typeof signer2 === "string") {
      signer2 = new Wallet$1(signer2);
    }
    const orchestrator = new Orchestrator([signer2]);
    const referenceSigner = await signer2.getAddress();
    const threshold = 1;
    const addSigners = [{
      weight: 1,
      address: referenceSigner
    }];
    const selectWallet = args.selectWallet || async function(wallets) {
      var _args$settings$tracke, _args$settings;
      if (wallets.length === 0) return void 0;
      const tracker2 = (_args$settings$tracke = (_args$settings = args.settings) == null ? void 0 : _args$settings.tracker) != null ? _args$settings$tracke : SessionSettingsDefault.tracker;
      const configs = await Promise.all(wallets.map(async function(wallet) {
        const imageHash2 = await tracker2.imageHashOfCounterfactualWallet({
          wallet
        });
        return {
          wallet,
          config: imageHash2 && await tracker2.configOfImageHash({
            imageHash: imageHash2.imageHash
          })
        };
      }));
      for (const config2 of configs) {
        if (!config2.config) {
          continue;
        }
        const coder = index$6.genericCoderFor(config2.config.version);
        const signers = coder.config.signersOf(config2.config);
        if (signers.length === 1 && signers[0].address === referenceSigner) {
          return config2.wallet;
        }
      }
      return void 0;
    };
    return Session.open(_extends$6({}, args, {
      orchestrator,
      referenceSigner,
      threshold,
      addSigners,
      selectWallet
    }));
  }
  static async open(args) {
    var _findNetworkConfig$ch, _findNetworkConfig, _settings$services$se, _settings$services, _networks$;
    const {
      referenceSigner,
      threshold,
      addSigners,
      selectWallet,
      onAccountAddress,
      settings,
      editConfigOnMigration,
      onMigration,
      orchestrator,
      projectAccessKey: projectAccessKey2
    } = args;
    const {
      contexts,
      networks: networks2,
      tracker: tracker2,
      services
    } = _extends$6({}, SessionSettingsDefault, settings);
    const referenceChainId = (_findNetworkConfig$ch = (_findNetworkConfig = findNetworkConfig(networks2, (_settings$services$se = settings == null || (_settings$services = settings.services) == null ? void 0 : _settings$services.sequenceApiChainId) != null ? _settings$services$se : ChainId$1.MAINNET)) == null ? void 0 : _findNetworkConfig.chainId) != null ? _findNetworkConfig$ch : (_networks$ = networks2[0]) == null ? void 0 : _networks$.chainId;
    if (!referenceChainId) throw Error("No reference chain found");
    const foundWallets = await tracker2.walletsOfSigner({
      signer: referenceSigner
    });
    const selectedWallet = await selectWallet(foundWallets.map((w2) => w2.wallet));
    let account2;
    if (selectedWallet) {
      onAccountAddress == null || onAccountAddress(selectedWallet);
      account2 = new Account({
        address: selectedWallet,
        tracker: tracker2,
        networks: networks2,
        contexts,
        orchestrator,
        projectAccessKey: projectAccessKey2
      });
      if (addSigners && addSigners.length > 0) {
        let status = await account2.status(referenceChainId);
        if (status.original.version !== status.version || account2.version !== status.version) {
          const {
            migratedAllChains: isFullyMigrated,
            failedChains
          } = await account2.isMigratedAllChains();
          if (failedChains.some((c2) => CRITICAL_CHAINS.includes(c2))) {
            throw Error(`Failed to fetch account status on ${failedChains.join(", ")}`);
          }
          if (!isFullyMigrated) {
            if (onMigration && !await onMigration(account2)) {
              throw Error("Migration cancelled, cannot open session");
            }
            const {
              failedChains: _failedChains
            } = await account2.signAllMigrations(editConfigOnMigration || ((c2) => c2));
            if (_failedChains.some((c2) => CRITICAL_CHAINS.includes(c2))) {
              throw Error(`Failed to sign migrations on ${_failedChains.join(", ")}`);
            }
            if (index$3.isDedupedTracker(tracker2)) {
              tracker2.invalidateCache();
            }
            let isFullyMigrated2;
            [isFullyMigrated2, status] = await Promise.all([account2.isMigratedAllChains().then((r2) => r2.migratedAllChains), account2.status(referenceChainId)]);
            if (!isFullyMigrated2) throw Error("Failed to migrate account");
          }
        }
        if (status.onChain.version !== status.version) {
          await account2.doBootstrap(referenceChainId, void 0, status);
        }
        const prevConfig = status.config;
        const nextConfig = account2.coders.config.editConfig(prevConfig, {
          add: addSigners,
          threshold
        });
        if (account2.coders.config.imageHashOf(prevConfig) !== account2.coders.config.imageHashOf(nextConfig)) {
          const newConfig = account2.coders.config.editConfig(nextConfig, {
            checkpoint: account2.coders.config.checkpointOf(prevConfig) + 1n
          });
          await account2.updateConfig(newConfig);
        }
      }
    } else {
      if (!addSigners || addSigners.length === 0) {
        throw Error("Cannot create new account without signers");
      }
      if (!threshold) {
        throw Error("Cannot create new account without threshold");
      }
      account2 = await Account.new({
        config: {
          threshold,
          checkpoint: 0,
          signers: addSigners
        },
        tracker: tracker2,
        contexts,
        orchestrator,
        networks: networks2,
        projectAccessKey: projectAccessKey2
      });
      onAccountAddress == null || onAccountAddress(account2.address);
      await account2.publishWitness();
      const _foundWallets = await tracker2.walletsOfSigner({
        signer: referenceSigner,
        noCache: true
      });
      if (!_foundWallets.some((w2) => w2.wallet === account2.address)) {
        throw Error("Account not found on tracker");
      }
    }
    let servicesObj;
    if (services) {
      servicesObj = new Services(account2, services);
      servicesObj.auth();
      servicesObj.onAuth((result) => {
        if (result.status === "fulfilled") {
          account2.setJwt(result.value);
        }
      });
    }
    return new Session(networks2, contexts, account2, servicesObj);
  }
  static async load(args) {
    const {
      dump,
      settings,
      editConfigOnMigration,
      onMigration,
      orchestrator
    } = args;
    const {
      contexts,
      networks: networks2,
      tracker: tracker2,
      services
    } = _extends$6({}, SessionSettingsDefault, settings);
    let account2;
    if (isSessionDumpV1(dump)) {
      var _dump$jwt$expiration, _dump$jwt, _dump$jwt2;
      const oldAddress = dump.config.address || index$1$1.context.addressOf(contexts[1], v1.config.ConfigCoder.imageHashOf(_extends$6({}, dump.config, {
        version: 1
      })));
      const jwtExpired = ((_dump$jwt$expiration = (_dump$jwt = dump.jwt) == null ? void 0 : _dump$jwt.expiration) != null ? _dump$jwt$expiration : 0) < Math.floor(Date.now() / 1e3);
      account2 = new Account({
        address: oldAddress,
        tracker: tracker2,
        networks: networks2,
        contexts,
        orchestrator,
        jwt: jwtExpired ? void 0 : (_dump$jwt2 = dump.jwt) == null ? void 0 : _dump$jwt2.token
      });
      if (!await account2.isMigratedAllChains().then((r2) => r2.migratedAllChains)) {
        if (onMigration && !await onMigration(account2)) {
          throw Error("Migration cancelled, cannot open session");
        }
        console.log("Migrating account...");
        await account2.signAllMigrations(editConfigOnMigration);
        if (!await account2.isMigratedAllChains().then((r2) => r2.migratedAllChains)) throw Error("Failed to migrate account");
      }
    } else if (isSessionDumpV2(dump)) {
      var _dump$jwt$expiration2, _dump$jwt3, _dump$jwt4;
      const jwtExpired = ((_dump$jwt$expiration2 = (_dump$jwt3 = dump.jwt) == null ? void 0 : _dump$jwt3.expiration) != null ? _dump$jwt$expiration2 : 0) < Math.floor(Date.now() / 1e3);
      account2 = new Account({
        address: dump.address,
        tracker: tracker2,
        networks: networks2,
        contexts,
        orchestrator,
        jwt: jwtExpired ? void 0 : (_dump$jwt4 = dump.jwt) == null ? void 0 : _dump$jwt4.token
      });
    } else {
      throw Error("Invalid dump format");
    }
    let servicesObj;
    if (services) {
      var _dump$jwt$expiration3;
      servicesObj = new Services(account2, services, dump.jwt && {
        jwt: {
          token: Promise.resolve(dump.jwt.token),
          expiration: (_dump$jwt$expiration3 = dump.jwt.expiration) != null ? _dump$jwt$expiration3 : jwtDecodeClaims(dump.jwt.token).exp
        },
        metadata: dump.metadata
      });
    }
    return new Session(networks2, contexts, account2, servicesObj);
  }
}
const ValidateSequenceWalletProof = (readerFor, tracker2, context2) => {
  return async (_provider6, chainId, proof) => {
    const digest = proof.messageDigest();
    const isValid2 = await readerFor(chainId).isValidSignature(proof.address, digest, proof.signature);
    return {
      isValid: isValid2
    };
  };
};
const auth$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AuthError,
  CRITICAL_CHAINS,
  ErrAccountIsRequired,
  Session,
  SessionSettingsDefault,
  ValidateSequenceWalletProof,
  isSessionDumpV1,
  isSessionDumpV2,
  signAuthorization
}, Symbol.toStringTag, { value: "Module" }));
function _extends$5() {
  return _extends$5 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$5.apply(null, arguments);
}
class Guard {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Guard/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$2({}, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$2({}, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            version: _data6.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$2({}, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSignerConfig = (args, headers, signal) => {
      return this.fetch(this.url("GetSignerConfig"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            signerConfig: _data6.signerConfig
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sign = (args, headers, signal) => {
      return this.fetch(this.url("Sign"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            sig: _data6.sig
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.signWith = (args, headers, signal) => {
      return this.fetch(this.url("SignWith"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            sig: _data6.sig
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.patch = (args, headers, signal) => {
      return this.fetch(this.url("Patch"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            txs: _data6.txs
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.authMethods = (args, headers, signal) => {
      return this.fetch(this.url("AuthMethods"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            methods: _data6.methods,
            active: _data6.active
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.setPIN = (args, headers, signal) => {
      return this.fetch(this.url("SetPIN"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resetPIN = (args, headers, signal) => {
      return this.fetch(this.url("ResetPIN"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.createTOTP = (args, headers, signal) => {
      return this.fetch(this.url("CreateTOTP"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            uri: _data6.uri
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.commitTOTP = (args, headers, signal) => {
      return this.fetch(this.url("CommitTOTP"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            codes: _data6.codes
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resetTOTP = (args, headers, signal) => {
      return this.fetch(this.url("ResetTOTP"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.reset2FA = (args, headers, signal) => {
      return this.fetch(this.url("Reset2FA"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.recoveryCodes = (args, headers, signal) => {
      return this.fetch(this.url("RecoveryCodes"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            codes: _data6.codes
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resetRecoveryCodes = (args, headers, signal) => {
      return this.fetch(this.url("ResetRecoveryCodes"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data6) => {
          return {
            codes: _data6.codes
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$2 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$5({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$2 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$2.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$2[code2] || WebrpcError$2).new(data);
    }
    return data;
  });
};
let WebrpcError$2 = class WebrpcError6 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError6.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$2 = class WebrpcEndpointError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError6.prototype);
  }
};
let WebrpcRequestFailedError$2 = class WebrpcRequestFailedError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError6.prototype);
  }
};
let WebrpcBadRouteError$2 = class WebrpcBadRouteError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError6.prototype);
  }
};
let WebrpcBadMethodError$2 = class WebrpcBadMethodError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError6.prototype);
  }
};
let WebrpcBadRequestError$2 = class WebrpcBadRequestError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError6.prototype);
  }
};
let WebrpcBadResponseError$2 = class WebrpcBadResponseError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError6.prototype);
  }
};
let WebrpcServerPanicError$2 = class WebrpcServerPanicError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError6.prototype);
  }
};
let WebrpcInternalErrorError$2 = class WebrpcInternalErrorError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError6.prototype);
  }
};
let WebrpcClientDisconnectedError$2 = class WebrpcClientDisconnectedError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError6.prototype);
  }
};
let WebrpcStreamLostError$2 = class WebrpcStreamLostError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError6.prototype);
  }
};
let WebrpcStreamFinishedError$2 = class WebrpcStreamFinishedError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError6.prototype);
  }
};
let UnauthorizedError$2 = class UnauthorizedError5 extends WebrpcError$2 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError5.prototype);
  }
};
let SessionExpiredError$1 = class SessionExpiredError4 extends WebrpcError$2 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError4.prototype);
  }
};
class AbortedError4 extends WebrpcError$2 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError4.prototype);
  }
}
class InvalidArgumentError6 extends WebrpcError$2 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError6.prototype);
  }
}
class UnavailableError4 extends WebrpcError$2 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError4.prototype);
  }
}
let QueryFailedError$1 = class QueryFailedError5 extends WebrpcError$2 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError5.prototype);
  }
};
class ValidationFailedError2 extends WebrpcError$2 {
  constructor(name2 = "ValidationFailed", code2 = 2004, message = "Validation Failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ValidationFailedError2.prototype);
  }
}
let NotFoundError$1 = class NotFoundError6 extends WebrpcError$2 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError6.prototype);
  }
};
const webrpcErrorByCode$2 = {
  [0]: WebrpcEndpointError$2,
  [-1]: WebrpcRequestFailedError$2,
  [-2]: WebrpcBadRouteError$2,
  [-3]: WebrpcBadMethodError$2,
  [-4]: WebrpcBadRequestError$2,
  [-5]: WebrpcBadResponseError$2,
  [-6]: WebrpcServerPanicError$2,
  [-7]: WebrpcInternalErrorError$2,
  [-8]: WebrpcClientDisconnectedError$2,
  [-9]: WebrpcStreamLostError$2,
  [-10]: WebrpcStreamFinishedError$2,
  [1e3]: UnauthorizedError$2,
  [1002]: SessionExpiredError$1,
  [1005]: AbortedError4,
  [2001]: InvalidArgumentError6,
  [2002]: UnavailableError4,
  [2003]: QueryFailedError$1,
  [2004]: ValidationFailedError2,
  [3e3]: NotFoundError$1
};
const fetch$2 = globalThis.fetch;
class GuardSigner {
  constructor(address, url, appendSuffix = false) {
    this.address = address;
    this.url = url;
    this.appendSuffix = appendSuffix;
    this.guard = void 0;
    this.guard = new Guard(url, fetch$2);
  }
  async getAddress() {
    return this.address;
  }
  async buildDeployTransaction(_metadata) {
    return void 0;
  }
  async predecorateSignedTransactions(_metadata) {
    return [];
  }
  async decorateTransactions(bundle, _metadata) {
    return bundle;
  }
  async sign(message, metadata2) {
    var _metadata$parts;
    if (!index$1$1.isWalletSignRequestMetadata(metadata2)) {
      throw new Error("expected sequence signature request metadata");
    }
    const guardTotpCode = metadata2.guardTotpCode;
    const coder = index$6.genericCoderFor(metadata2.config.version);
    const {
      encoded
    } = coder.signature.encodeSigners(metadata2.config, (_metadata$parts = metadata2.parts) != null ? _metadata$parts : /* @__PURE__ */ new Map(), [], metadata2.chainId);
    return (await this.guard.signWith({
      signer: this.address,
      request: {
        msg: hexlify(message),
        auxData: this.packMsgAndSig(metadata2.address, metadata2.digest, encoded, metadata2.chainId),
        chainId: Number(metadata2.chainId)
      },
      token: guardTotpCode ? {
        id: AuthMethod.TOTP,
        token: guardTotpCode
      } : void 0
    })).sig;
  }
  notifyStatusChange(_id, _status, _metadata) {
  }
  async getAuthMethods(proof) {
    let response;
    if ("jwt" in proof) {
      response = await this.guard.authMethods({}, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      const signedProof = await signOwnershipProof(proof);
      response = await this.guard.authMethods({
        proof: {
          wallet: signedProof.walletAddress,
          timestamp: signedProof.timestamp.getTime(),
          signer: signedProof.signerAddress,
          signature: signedProof.signature
        }
      });
    }
    return _extends$5({}, response, {
      methods: response.methods.map(parseAuthMethod)
    });
  }
  async setPin(pin, proof) {
    const signedProof = await signAuthUpdateProof(proof);
    if (pin === void 0) {
      await this.guard.resetPIN({
        timestamp: signedProof.timestamp.getTime(),
        signature: signedProof.signature
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      await this.guard.setPIN({
        pin,
        timestamp: signedProof.timestamp.getTime(),
        signature: signedProof.signature
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    }
  }
  resetPin(proof) {
    return this.setPin(void 0, proof);
  }
  async createTotp(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      uri
    } = await this.guard.createTOTP({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return new URL(uri);
  }
  async commitTotp(token, jwt) {
    const {
      codes
    } = await this.guard.commitTOTP({
      token
    }, {
      Authorization: `BEARER ${jwt}`
    });
    return codes;
  }
  async resetTotp(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    await this.guard.resetTOTP({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
  }
  async reset2fa(recoveryCode, proof) {
    if ("jwt" in proof) {
      await this.guard.reset2FA({
        code: recoveryCode
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      const signedProof = await signOwnershipProof(proof);
      await this.guard.reset2FA({
        code: recoveryCode,
        proof: {
          wallet: signedProof.walletAddress,
          timestamp: signedProof.timestamp.getTime(),
          signer: signedProof.signerAddress,
          signature: signedProof.signature
        }
      });
    }
  }
  async getRecoveryCodes(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      codes
    } = await this.guard.recoveryCodes({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return codes;
  }
  async resetRecoveryCodes(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      codes
    } = await this.guard.resetRecoveryCodes({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return codes;
  }
  packMsgAndSig(address, msg, sig, chainId) {
    return AbiCoder.defaultAbiCoder().encode(["address", "uint256", "bytes", "bytes"], [address, chainId, msg, sig]);
  }
  suffix() {
    return new Uint8Array(this.appendSuffix ? [3] : []);
  }
}
let AuthMethod = /* @__PURE__ */ function(AuthMethod2) {
  AuthMethod2["PIN"] = "PIN";
  AuthMethod2["TOTP"] = "TOTP";
  return AuthMethod2;
}({});
function parseAuthMethod(method) {
  switch (method) {
    case AuthMethod.PIN:
    case AuthMethod.TOTP:
      return method;
    default:
      throw new Error(`unknown auth method '${method}'`);
  }
}
function isSignedOwnershipProof(proof) {
  return "signerAddress" in proof && typeof proof.signerAddress === "string";
}
async function signOwnershipProof(proof) {
  if (isSignedOwnershipProof(proof)) {
    return proof;
  } else {
    const signer2 = index$4.isSapientSigner(proof.signer) ? proof.signer : new index$4.SignerWrapper(proof.signer);
    const signerAddress = await signer2.getAddress();
    const timestamp = /* @__PURE__ */ new Date();
    const typedData = getOwnershipProofTypedData(proof.walletAddress, timestamp);
    const digest = encodeTypedDataDigest(typedData);
    return {
      walletAddress: proof.walletAddress,
      timestamp,
      signerAddress,
      signature: hexlify(await signer2.sign(digest, {}))
    };
  }
}
async function signAuthUpdateProof(proof) {
  if ("wallet" in proof) {
    var _typedData$domain$cha;
    const timestamp = /* @__PURE__ */ new Date();
    const typedData = getAuthUpdateProofTypedData(timestamp);
    const signature2 = await proof.wallet.signTypedData(typedData.domain, typedData.types, typedData.message, (_typedData$domain$cha = typedData.domain.chainId) != null ? _typedData$domain$cha : 1, "eip6492");
    return {
      jwt: proof.jwt,
      timestamp,
      signature: signature2
    };
  } else {
    return proof;
  }
}
function getOwnershipProofTypedData(wallet, timestamp) {
  return {
    domain,
    types: {
      AuthMethods: [{
        name: "wallet",
        type: "address"
      }, {
        name: "timestamp",
        type: "string"
      }]
    },
    message: {
      wallet: getAddress(wallet),
      timestamp: toUTCString(timestamp)
    }
  };
}
function getAuthUpdateProofTypedData(timestamp) {
  return {
    domain,
    types: {
      AuthUpdate: [{
        name: "timestamp",
        type: "string"
      }]
    },
    message: {
      timestamp: toUTCString(timestamp)
    }
  };
}
const domain = {
  name: "Sequence Guard",
  version: "1",
  chainId: 1
};
function toUTCString(date) {
  return date.toUTCString().replace("GMT", "UTC");
}
const guard$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AuthMethod,
  Guard,
  GuardSigner,
  getAuthUpdateProofTypedData,
  getOwnershipProofTypedData,
  isSignedOwnershipProof,
  signOwnershipProof
}, Symbol.toStringTag, { value: "Module" }));
var eventemitter2 = { exports: {} };
(function(module2, exports) {
  !function(undefined$1) {
    var hasOwnProperty = Object.hasOwnProperty;
    var isArray2 = Array.isArray ? Array.isArray : function _isArray(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    var defaultMaxListeners = 10;
    var nextTickSupported = typeof process$1 == "object" && typeof process$1.nextTick == "function";
    var symbolsSupported = typeof Symbol === "function";
    var reflectSupported = typeof Reflect === "object";
    var setImmediateSupported = typeof setImmediate === "function";
    var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
    var ownKeys2 = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
      var arr = Object.getOwnPropertyNames(obj);
      arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
      return arr;
    } : Object.keys;
    function init2() {
      this._events = {};
      if (this._conf) {
        configure.call(this, this._conf);
      }
    }
    function configure(conf) {
      if (conf) {
        this._conf = conf;
        conf.delimiter && (this.delimiter = conf.delimiter);
        if (conf.maxListeners !== undefined$1) {
          this._maxListeners = conf.maxListeners;
        }
        conf.wildcard && (this.wildcard = conf.wildcard);
        conf.newListener && (this._newListener = conf.newListener);
        conf.removeListener && (this._removeListener = conf.removeListener);
        conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
        conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
        if (this.wildcard) {
          this.listenerTree = {};
        }
      }
    }
    function logPossibleMemoryLeak(count2, eventName) {
      var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count2 + " listeners added. Use emitter.setMaxListeners() to increase limit.";
      if (this.verboseMemoryLeak) {
        errorMsg += " Event name: " + eventName + ".";
      }
      if (typeof process$1 !== "undefined" && process$1.emitWarning) {
        var e2 = new Error(errorMsg);
        e2.name = "MaxListenersExceededWarning";
        e2.emitter = this;
        e2.count = count2;
        process$1.emitWarning(e2);
      } else {
        console.error(errorMsg);
        if (console.trace) {
          console.trace();
        }
      }
    }
    var toArray = function(a2, b2, c2) {
      var n2 = arguments.length;
      switch (n2) {
        case 0:
          return [];
        case 1:
          return [a2];
        case 2:
          return [a2, b2];
        case 3:
          return [a2, b2, c2];
        default:
          var arr = new Array(n2);
          while (n2--) {
            arr[n2] = arguments[n2];
          }
          return arr;
      }
    };
    function toObject2(keys, values) {
      var obj = {};
      var key;
      var len = keys.length;
      var valuesCount = 0;
      for (var i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = i < valuesCount ? values[i] : undefined$1;
      }
      return obj;
    }
    function TargetObserver(emitter, target, options) {
      this._emitter = emitter;
      this._target = target;
      this._listeners = {};
      this._listenersCount = 0;
      var on, off;
      if (options.on || options.off) {
        on = options.on;
        off = options.off;
      }
      if (target.addEventListener) {
        on = target.addEventListener;
        off = target.removeEventListener;
      } else if (target.addListener) {
        on = target.addListener;
        off = target.removeListener;
      } else if (target.on) {
        on = target.on;
        off = target.off;
      }
      if (!on && !off) {
        throw Error("target does not implement any known event API");
      }
      if (typeof on !== "function") {
        throw TypeError("on method must be a function");
      }
      if (typeof off !== "function") {
        throw TypeError("off method must be a function");
      }
      this._on = on;
      this._off = off;
      var _observers2 = emitter._observers;
      if (_observers2) {
        _observers2.push(this);
      } else {
        emitter._observers = [this];
      }
    }
    Object.assign(TargetObserver.prototype, {
      subscribe: function(event, localEvent, reducer) {
        var observer = this;
        var target = this._target;
        var emitter = this._emitter;
        var listeners = this._listeners;
        var handler = function() {
          var args = toArray.apply(null, arguments);
          var eventObj = {
            data: args,
            name: localEvent,
            original: event
          };
          if (reducer) {
            var result = reducer.call(target, eventObj);
            if (result !== false) {
              emitter.emit.apply(emitter, [eventObj.name].concat(args));
            }
            return;
          }
          emitter.emit.apply(emitter, [localEvent].concat(args));
        };
        if (listeners[event]) {
          throw Error("Event '" + event + "' is already listening");
        }
        this._listenersCount++;
        if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
          this._onNewListener = function(_event2) {
            if (_event2 === localEvent && listeners[event] === null) {
              listeners[event] = handler;
              observer._on.call(target, event, handler);
            }
          };
          emitter.on("newListener", this._onNewListener);
          this._onRemoveListener = function(_event2) {
            if (_event2 === localEvent && !emitter.hasListeners(_event2) && listeners[event]) {
              listeners[event] = null;
              observer._off.call(target, event, handler);
            }
          };
          listeners[event] = null;
          emitter.on("removeListener", this._onRemoveListener);
        } else {
          listeners[event] = handler;
          observer._on.call(target, event, handler);
        }
      },
      unsubscribe: function(event) {
        var observer = this;
        var listeners = this._listeners;
        var emitter = this._emitter;
        var handler;
        var events;
        var off = this._off;
        var target = this._target;
        var i;
        if (event && typeof event !== "string") {
          throw TypeError("event must be a string");
        }
        function clearRefs() {
          if (observer._onNewListener) {
            emitter.off("newListener", observer._onNewListener);
            emitter.off("removeListener", observer._onRemoveListener);
            observer._onNewListener = null;
            observer._onRemoveListener = null;
          }
          var index2 = findTargetIndex.call(emitter, observer);
          emitter._observers.splice(index2, 1);
        }
        if (event) {
          handler = listeners[event];
          if (!handler) return;
          off.call(target, event, handler);
          delete listeners[event];
          if (!--this._listenersCount) {
            clearRefs();
          }
        } else {
          events = ownKeys2(listeners);
          i = events.length;
          while (i-- > 0) {
            event = events[i];
            off.call(target, event, listeners[event]);
          }
          this._listeners = {};
          this._listenersCount = 0;
          clearRefs();
        }
      }
    });
    function resolveOptions(options, schema, reducers, allowUnknown) {
      var computedOptions = Object.assign({}, schema);
      if (!options) return computedOptions;
      if (typeof options !== "object") {
        throw TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var length = keys.length;
      var option, value;
      var reducer;
      function reject(reason) {
        throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
      }
      for (var i = 0; i < length; i++) {
        option = keys[i];
        if (!hasOwnProperty.call(schema, option)) {
          throw Error('Unknown "' + option + '" option');
        }
        value = options[option];
        if (value !== undefined$1) {
          reducer = reducers[option];
          computedOptions[option] = reducer ? reducer(value, reject) : value;
        }
      }
      return computedOptions;
    }
    function constructorReducer(value, reject) {
      if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
        reject("value must be a constructor");
      }
      return value;
    }
    function makeTypeReducer(types2) {
      var message = "value must be type of " + types2.join("|");
      var len = types2.length;
      var firstType = types2[0];
      var secondType = types2[1];
      if (len === 1) {
        return function(v3, reject) {
          if (typeof v3 === firstType) {
            return v3;
          }
          reject(message);
        };
      }
      if (len === 2) {
        return function(v3, reject) {
          var kind = typeof v3;
          if (kind === firstType || kind === secondType) return v3;
          reject(message);
        };
      }
      return function(v3, reject) {
        var kind = typeof v3;
        var i = len;
        while (i-- > 0) {
          if (kind === types2[i]) return v3;
        }
        reject(message);
      };
    }
    var functionReducer = makeTypeReducer(["function"]);
    var objectFunctionReducer = makeTypeReducer(["object", "function"]);
    function makeCancelablePromise(Promise2, executor, options) {
      var isCancelable;
      var callbacks;
      var timer = 0;
      var subscriptionClosed;
      var promise = new Promise2(function(resolve, reject, onCancel) {
        options = resolveOptions(options, {
          timeout: 0,
          overload: false
        }, {
          timeout: function(value, reject2) {
            value *= 1;
            if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
              reject2("timeout must be a positive number");
            }
            return value;
          }
        });
        isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
        function cleanup() {
          if (callbacks) {
            callbacks = null;
          }
          if (timer) {
            clearTimeout(timer);
            timer = 0;
          }
        }
        var _resolve = function(value) {
          cleanup();
          resolve(value);
        };
        var _reject = function(err) {
          cleanup();
          reject(err);
        };
        if (isCancelable) {
          executor(_resolve, _reject, onCancel);
        } else {
          callbacks = [function(reason) {
            _reject(reason || Error("canceled"));
          }];
          executor(_resolve, _reject, function(cb2) {
            if (subscriptionClosed) {
              throw Error("Unable to subscribe on cancel event asynchronously");
            }
            if (typeof cb2 !== "function") {
              throw TypeError("onCancel callback must be a function");
            }
            callbacks.push(cb2);
          });
          subscriptionClosed = true;
        }
        if (options.timeout > 0) {
          timer = setTimeout(function() {
            var reason = Error("timeout");
            reason.code = "ETIMEDOUT";
            timer = 0;
            promise.cancel(reason);
            reject(reason);
          }, options.timeout);
        }
      });
      if (!isCancelable) {
        promise.cancel = function(reason) {
          if (!callbacks) {
            return;
          }
          var length = callbacks.length;
          for (var i = 1; i < length; i++) {
            callbacks[i](reason);
          }
          callbacks[0](reason);
          callbacks = null;
        };
      }
      return promise;
    }
    function findTargetIndex(observer) {
      var observers2 = this._observers;
      if (!observers2) {
        return -1;
      }
      var len = observers2.length;
      for (var i = 0; i < len; i++) {
        if (observers2[i]._target === observer) return i;
      }
      return -1;
    }
    function searchListenerTree(handlers, type, tree, i, typeLength) {
      if (!tree) {
        return null;
      }
      if (i === 0) {
        var kind = typeof type;
        if (kind === "string") {
          var ns, n2, l2 = 0, j2 = 0, delimiter = this.delimiter, dl2 = delimiter.length;
          if ((n2 = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[l2++] = type.slice(j2, n2);
              j2 = n2 + dl2;
            } while ((n2 = type.indexOf(delimiter, j2)) !== -1);
            ns[l2++] = type.slice(j2);
            type = ns;
            typeLength = l2;
          } else {
            type = [type];
            typeLength = 1;
          }
        } else if (kind === "object") {
          typeLength = type.length;
        } else {
          type = [type];
          typeLength = 1;
        }
      }
      var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners2;
      if (i === typeLength) {
        if (tree._listeners) {
          if (typeof tree._listeners === "function") {
            handlers && handlers.push(tree._listeners);
            listeners = [tree];
          } else {
            handlers && handlers.push.apply(handlers, tree._listeners);
            listeners = [tree];
          }
        }
      } else {
        if (currentType === "*") {
          branches = ownKeys2(tree);
          n2 = branches.length;
          while (n2-- > 0) {
            branch = branches[n2];
            if (branch !== "_listeners") {
              _listeners2 = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
              if (_listeners2) {
                if (listeners) {
                  listeners.push.apply(listeners, _listeners2);
                } else {
                  listeners = _listeners2;
                }
              }
            }
          }
          return listeners;
        } else if (currentType === "**") {
          endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
          if (endReached && tree._listeners) {
            listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
          }
          branches = ownKeys2(tree);
          n2 = branches.length;
          while (n2-- > 0) {
            branch = branches[n2];
            if (branch !== "_listeners") {
              if (branch === "*" || branch === "**") {
                if (tree[branch]._listeners && !endReached) {
                  _listeners2 = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                  if (_listeners2) {
                    if (listeners) {
                      listeners.push.apply(listeners, _listeners2);
                    } else {
                      listeners = _listeners2;
                    }
                  }
                }
                _listeners2 = searchListenerTree(handlers, type, tree[branch], i, typeLength);
              } else if (branch === nextType) {
                _listeners2 = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
              } else {
                _listeners2 = searchListenerTree(handlers, type, tree[branch], i, typeLength);
              }
              if (_listeners2) {
                if (listeners) {
                  listeners.push.apply(listeners, _listeners2);
                } else {
                  listeners = _listeners2;
                }
              }
            }
          }
          return listeners;
        } else if (tree[currentType]) {
          listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
        }
      }
      xTree = tree["*"];
      if (xTree) {
        searchListenerTree(handlers, type, xTree, i + 1, typeLength);
      }
      xxTree = tree["**"];
      if (xxTree) {
        if (i < typeLength) {
          if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          }
          branches = ownKeys2(xxTree);
          n2 = branches.length;
          while (n2-- > 0) {
            branch = branches[n2];
            if (branch !== "_listeners") {
              if (branch === nextType) {
                searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
              } else if (branch === currentType) {
                searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
              } else {
                isolatedBranch = {};
                isolatedBranch[branch] = xxTree[branch];
                searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
              }
            }
          }
        } else if (xxTree._listeners) {
          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
        } else if (xxTree["*"] && xxTree["*"]._listeners) {
          searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
        }
      }
      return listeners;
    }
    function growListenerTree(type, listener, prepend) {
      var len = 0, j2 = 0, i, delimiter = this.delimiter, dl2 = delimiter.length, ns;
      if (typeof type === "string") {
        if ((i = type.indexOf(delimiter)) !== -1) {
          ns = new Array(5);
          do {
            ns[len++] = type.slice(j2, i);
            j2 = i + dl2;
          } while ((i = type.indexOf(delimiter, j2)) !== -1);
          ns[len++] = type.slice(j2);
        } else {
          ns = [type];
          len = 1;
        }
      } else {
        ns = type;
        len = type.length;
      }
      if (len > 1) {
        for (i = 0; i + 1 < len; i++) {
          if (ns[i] === "**" && ns[i + 1] === "**") {
            return;
          }
        }
      }
      var tree = this.listenerTree, name2;
      for (i = 0; i < len; i++) {
        name2 = ns[i];
        tree = tree[name2] || (tree[name2] = {});
        if (i === len - 1) {
          if (!tree._listeners) {
            tree._listeners = listener;
          } else {
            if (typeof tree._listeners === "function") {
              tree._listeners = [tree._listeners];
            }
            if (prepend) {
              tree._listeners.unshift(listener);
            } else {
              tree._listeners.push(listener);
            }
            if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
              tree._listeners.warned = true;
              logPossibleMemoryLeak.call(this, tree._listeners.length, name2);
            }
          }
          return true;
        }
      }
      return true;
    }
    function collectTreeEvents(tree, events, root2, asArray) {
      var branches = ownKeys2(tree);
      var i = branches.length;
      var branch, branchName, path;
      var hasListeners = tree["_listeners"];
      var isArrayPath;
      while (i-- > 0) {
        branchName = branches[i];
        branch = tree[branchName];
        if (branchName === "_listeners") {
          path = root2;
        } else {
          path = root2 ? root2.concat(branchName) : [branchName];
        }
        isArrayPath = asArray || typeof branchName === "symbol";
        hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
        if (typeof branch === "object") {
          collectTreeEvents.call(this, branch, events, path, isArrayPath);
        }
      }
      return events;
    }
    function recursivelyGarbageCollect(root2) {
      var keys = ownKeys2(root2);
      var i = keys.length;
      var obj, key, flag;
      while (i-- > 0) {
        key = keys[i];
        obj = root2[key];
        if (obj) {
          flag = true;
          if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
            delete root2[key];
          }
        }
      }
      return flag;
    }
    function Listener(emitter, event, listener) {
      this.emitter = emitter;
      this.event = event;
      this.listener = listener;
    }
    Listener.prototype.off = function() {
      this.emitter.off(this.event, this.listener);
      return this;
    };
    function setupListener(event, listener, options) {
      if (options === true) {
        promisify2 = true;
      } else if (options === false) {
        async = true;
      } else {
        if (!options || typeof options !== "object") {
          throw TypeError("options should be an object or true");
        }
        var async = options.async;
        var promisify2 = options.promisify;
        var nextTick2 = options.nextTick;
        var objectify = options.objectify;
      }
      if (async || nextTick2 || promisify2) {
        var _listener2 = listener;
        var _origin = listener._origin || listener;
        if (nextTick2 && !nextTickSupported) {
          throw Error("process.nextTick is not supported");
        }
        if (promisify2 === undefined$1) {
          promisify2 = listener.constructor.name === "AsyncFunction";
        }
        listener = function() {
          var args = arguments;
          var context2 = this;
          var event2 = this.event;
          return promisify2 ? nextTick2 ? Promise.resolve() : new Promise(function(resolve) {
            _setImmediate(resolve);
          }).then(function() {
            context2.event = event2;
            return _listener2.apply(context2, args);
          }) : (nextTick2 ? process$1.nextTick : _setImmediate)(function() {
            context2.event = event2;
            _listener2.apply(context2, args);
          });
        };
        listener._async = true;
        listener._origin = _origin;
      }
      return [listener, objectify ? new Listener(this, event, listener) : this];
    }
    function EventEmitter2(conf) {
      this._events = {};
      this._newListener = false;
      this._removeListener = false;
      this.verboseMemoryLeak = false;
      configure.call(this, conf);
    }
    EventEmitter2.EventEmitter2 = EventEmitter2;
    EventEmitter2.prototype.listenTo = function(target, events, options) {
      if (typeof target !== "object") {
        throw TypeError("target musts be an object");
      }
      var emitter = this;
      options = resolveOptions(options, {
        on: undefined$1,
        off: undefined$1,
        reducers: undefined$1
      }, {
        on: functionReducer,
        off: functionReducer,
        reducers: objectFunctionReducer
      });
      function listen(events2) {
        if (typeof events2 !== "object") {
          throw TypeError("events must be an object");
        }
        var reducers = options.reducers;
        var index2 = findTargetIndex.call(emitter, target);
        var observer;
        if (index2 === -1) {
          observer = new TargetObserver(emitter, target, options);
        } else {
          observer = emitter._observers[index2];
        }
        var keys = ownKeys2(events2);
        var len = keys.length;
        var event;
        var isSingleReducer = typeof reducers === "function";
        for (var i = 0; i < len; i++) {
          event = keys[i];
          observer.subscribe(
            event,
            events2[event] || event,
            isSingleReducer ? reducers : reducers && reducers[event]
          );
        }
      }
      isArray2(events) ? listen(toObject2(events)) : typeof events === "string" ? listen(toObject2(events.split(/\s+/))) : listen(events);
      return this;
    };
    EventEmitter2.prototype.stopListeningTo = function(target, event) {
      var observers2 = this._observers;
      if (!observers2) {
        return false;
      }
      var i = observers2.length;
      var observer;
      var matched = false;
      if (target && typeof target !== "object") {
        throw TypeError("target should be an object");
      }
      while (i-- > 0) {
        observer = observers2[i];
        if (!target || observer._target === target) {
          observer.unsubscribe(event);
          matched = true;
        }
      }
      return matched;
    };
    EventEmitter2.prototype.delimiter = ".";
    EventEmitter2.prototype.setMaxListeners = function(n2) {
      if (n2 !== undefined$1) {
        this._maxListeners = n2;
        if (!this._conf) this._conf = {};
        this._conf.maxListeners = n2;
      }
    };
    EventEmitter2.prototype.getMaxListeners = function() {
      return this._maxListeners;
    };
    EventEmitter2.prototype.event = "";
    EventEmitter2.prototype.once = function(event, fn, options) {
      return this._once(event, fn, false, options);
    };
    EventEmitter2.prototype.prependOnceListener = function(event, fn, options) {
      return this._once(event, fn, true, options);
    };
    EventEmitter2.prototype._once = function(event, fn, prepend, options) {
      return this._many(event, 1, fn, prepend, options);
    };
    EventEmitter2.prototype.many = function(event, ttl, fn, options) {
      return this._many(event, ttl, fn, false, options);
    };
    EventEmitter2.prototype.prependMany = function(event, ttl, fn, options) {
      return this._many(event, ttl, fn, true, options);
    };
    EventEmitter2.prototype._many = function(event, ttl, fn, prepend, options) {
      var self2 = this;
      if (typeof fn !== "function") {
        throw new Error("many only accepts instances of Function");
      }
      function listener() {
        if (--ttl === 0) {
          self2.off(event, listener);
        }
        return fn.apply(this, arguments);
      }
      listener._origin = fn;
      return this._on(event, listener, prepend, options);
    };
    EventEmitter2.prototype.emit = function() {
      if (!this._events && !this._all) {
        return false;
      }
      this._events || init2.call(this);
      var type = arguments[0], ns, wildcard = this.wildcard;
      var args, l2, i, j2, containsSymbol;
      if (type === "newListener" && !this._newListener) {
        if (!this._events.newListener) {
          return false;
        }
      }
      if (wildcard) {
        ns = type;
        if (type !== "newListener" && type !== "removeListener") {
          if (typeof type === "object") {
            l2 = type.length;
            if (symbolsSupported) {
              for (i = 0; i < l2; i++) {
                if (typeof type[i] === "symbol") {
                  containsSymbol = true;
                  break;
                }
              }
            }
            if (!containsSymbol) {
              type = type.join(this.delimiter);
            }
          }
        }
      }
      var al2 = arguments.length;
      var handler;
      if (this._all && this._all.length) {
        handler = this._all.slice();
        for (i = 0, l2 = handler.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              handler[i].call(this, type);
              break;
            case 2:
              handler[i].call(this, type, arguments[1]);
              break;
            case 3:
              handler[i].call(this, type, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, arguments);
          }
        }
      }
      if (wildcard) {
        handler = [];
        searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l2);
      } else {
        handler = this._events[type];
        if (typeof handler === "function") {
          this.event = type;
          switch (al2) {
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            default:
              args = new Array(al2 - 1);
              for (j2 = 1; j2 < al2; j2++) args[j2 - 1] = arguments[j2];
              handler.apply(this, args);
          }
          return true;
        } else if (handler) {
          handler = handler.slice();
        }
      }
      if (handler && handler.length) {
        if (al2 > 3) {
          args = new Array(al2 - 1);
          for (j2 = 1; j2 < al2; j2++) args[j2 - 1] = arguments[j2];
        }
        for (i = 0, l2 = handler.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              handler[i].call(this);
              break;
            case 2:
              handler[i].call(this, arguments[1]);
              break;
            case 3:
              handler[i].call(this, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, args);
          }
        }
        return true;
      } else if (!this.ignoreErrors && !this._all && type === "error") {
        if (arguments[1] instanceof Error) {
          throw arguments[1];
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
      }
      return !!this._all;
    };
    EventEmitter2.prototype.emitAsync = function() {
      if (!this._events && !this._all) {
        return false;
      }
      this._events || init2.call(this);
      var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
      var args, l2, i, j2;
      if (type === "newListener" && !this._newListener) {
        if (!this._events.newListener) {
          return Promise.resolve([false]);
        }
      }
      if (wildcard) {
        ns = type;
        if (type !== "newListener" && type !== "removeListener") {
          if (typeof type === "object") {
            l2 = type.length;
            if (symbolsSupported) {
              for (i = 0; i < l2; i++) {
                if (typeof type[i] === "symbol") {
                  containsSymbol = true;
                  break;
                }
              }
            }
            if (!containsSymbol) {
              type = type.join(this.delimiter);
            }
          }
        }
      }
      var promises = [];
      var al2 = arguments.length;
      var handler;
      if (this._all) {
        for (i = 0, l2 = this._all.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              promises.push(this._all[i].call(this, type));
              break;
            case 2:
              promises.push(this._all[i].call(this, type, arguments[1]));
              break;
            case 3:
              promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
              break;
            default:
              promises.push(this._all[i].apply(this, arguments));
          }
        }
      }
      if (wildcard) {
        handler = [];
        searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
      } else {
        handler = this._events[type];
      }
      if (typeof handler === "function") {
        this.event = type;
        switch (al2) {
          case 1:
            promises.push(handler.call(this));
            break;
          case 2:
            promises.push(handler.call(this, arguments[1]));
            break;
          case 3:
            promises.push(handler.call(this, arguments[1], arguments[2]));
            break;
          default:
            args = new Array(al2 - 1);
            for (j2 = 1; j2 < al2; j2++) args[j2 - 1] = arguments[j2];
            promises.push(handler.apply(this, args));
        }
      } else if (handler && handler.length) {
        handler = handler.slice();
        if (al2 > 3) {
          args = new Array(al2 - 1);
          for (j2 = 1; j2 < al2; j2++) args[j2 - 1] = arguments[j2];
        }
        for (i = 0, l2 = handler.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              promises.push(handler[i].call(this));
              break;
            case 2:
              promises.push(handler[i].call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler[i].call(this, arguments[1], arguments[2]));
              break;
            default:
              promises.push(handler[i].apply(this, args));
          }
        }
      } else if (!this.ignoreErrors && !this._all && type === "error") {
        if (arguments[1] instanceof Error) {
          return Promise.reject(arguments[1]);
        } else {
          return Promise.reject("Uncaught, unspecified 'error' event.");
        }
      }
      return Promise.all(promises);
    };
    EventEmitter2.prototype.on = function(type, listener, options) {
      return this._on(type, listener, false, options);
    };
    EventEmitter2.prototype.prependListener = function(type, listener, options) {
      return this._on(type, listener, true, options);
    };
    EventEmitter2.prototype.onAny = function(fn) {
      return this._onAny(fn, false);
    };
    EventEmitter2.prototype.prependAny = function(fn) {
      return this._onAny(fn, true);
    };
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prototype._onAny = function(fn, prepend) {
      if (typeof fn !== "function") {
        throw new Error("onAny only accepts instances of Function");
      }
      if (!this._all) {
        this._all = [];
      }
      if (prepend) {
        this._all.unshift(fn);
      } else {
        this._all.push(fn);
      }
      return this;
    };
    EventEmitter2.prototype._on = function(type, listener, prepend, options) {
      if (typeof type === "function") {
        this._onAny(type, listener);
        return this;
      }
      if (typeof listener !== "function") {
        throw new Error("on only accepts instances of Function");
      }
      this._events || init2.call(this);
      var returnValue = this, temp;
      if (options !== undefined$1) {
        temp = setupListener.call(this, type, listener, options);
        listener = temp[0];
        returnValue = temp[1];
      }
      if (this._newListener) {
        this.emit("newListener", type, listener);
      }
      if (this.wildcard) {
        growListenerTree.call(this, type, listener, prepend);
        return returnValue;
      }
      if (!this._events[type]) {
        this._events[type] = listener;
      } else {
        if (typeof this._events[type] === "function") {
          this._events[type] = [this._events[type]];
        }
        if (prepend) {
          this._events[type].unshift(listener);
        } else {
          this._events[type].push(listener);
        }
        if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
          this._events[type].warned = true;
          logPossibleMemoryLeak.call(this, this._events[type].length, type);
        }
      }
      return returnValue;
    };
    EventEmitter2.prototype.off = function(type, listener) {
      if (typeof listener !== "function") {
        throw new Error("removeListener only takes instances of Function");
      }
      var handlers, leafs = [];
      if (this.wildcard) {
        var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
        leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
        if (!leafs) return this;
      } else {
        if (!this._events[type]) return this;
        handlers = this._events[type];
        leafs.push({ _listeners: handlers });
      }
      for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        handlers = leaf._listeners;
        if (isArray2(handlers)) {
          var position = -1;
          for (var i = 0, length = handlers.length; i < length; i++) {
            if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
              position = i;
              break;
            }
          }
          if (position < 0) {
            continue;
          }
          if (this.wildcard) {
            leaf._listeners.splice(position, 1);
          } else {
            this._events[type].splice(position, 1);
          }
          if (handlers.length === 0) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
          }
          if (this._removeListener)
            this.emit("removeListener", type, listener);
          return this;
        } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
          if (this.wildcard) {
            delete leaf._listeners;
          } else {
            delete this._events[type];
          }
          if (this._removeListener)
            this.emit("removeListener", type, listener);
        }
      }
      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
      return this;
    };
    EventEmitter2.prototype.offAny = function(fn) {
      var i = 0, l2 = 0, fns;
      if (fn && this._all && this._all.length > 0) {
        fns = this._all;
        for (i = 0, l2 = fns.length; i < l2; i++) {
          if (fn === fns[i]) {
            fns.splice(i, 1);
            if (this._removeListener)
              this.emit("removeListenerAny", fn);
            return this;
          }
        }
      } else {
        fns = this._all;
        if (this._removeListener) {
          for (i = 0, l2 = fns.length; i < l2; i++)
            this.emit("removeListenerAny", fns[i]);
        }
        this._all = [];
      }
      return this;
    };
    EventEmitter2.prototype.removeListener = EventEmitter2.prototype.off;
    EventEmitter2.prototype.removeAllListeners = function(type) {
      if (type === undefined$1) {
        !this._events || init2.call(this);
        return this;
      }
      if (this.wildcard) {
        var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
        if (!leafs) return this;
        for (i = 0; i < leafs.length; i++) {
          leaf = leafs[i];
          leaf._listeners = null;
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
      } else if (this._events) {
        this._events[type] = null;
      }
      return this;
    };
    EventEmitter2.prototype.listeners = function(type) {
      var _events2 = this._events;
      var keys, listeners, allListeners;
      var i;
      var listenerTree;
      if (type === undefined$1) {
        if (this.wildcard) {
          throw Error("event name required for wildcard emitter");
        }
        if (!_events2) {
          return [];
        }
        keys = ownKeys2(_events2);
        i = keys.length;
        allListeners = [];
        while (i-- > 0) {
          listeners = _events2[keys[i]];
          if (typeof listeners === "function") {
            allListeners.push(listeners);
          } else {
            allListeners.push.apply(allListeners, listeners);
          }
        }
        return allListeners;
      } else {
        if (this.wildcard) {
          listenerTree = this.listenerTree;
          if (!listenerTree) return [];
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, listenerTree, 0);
          return handlers;
        }
        if (!_events2) {
          return [];
        }
        listeners = _events2[type];
        if (!listeners) {
          return [];
        }
        return typeof listeners === "function" ? [listeners] : listeners;
      }
    };
    EventEmitter2.prototype.eventNames = function(nsAsArray) {
      var _events2 = this._events;
      return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events2 ? ownKeys2(_events2) : [];
    };
    EventEmitter2.prototype.listenerCount = function(type) {
      return this.listeners(type).length;
    };
    EventEmitter2.prototype.hasListeners = function(type) {
      if (this.wildcard) {
        var handlers = [];
        var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
        searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
        return handlers.length > 0;
      }
      var _events2 = this._events;
      var _all = this._all;
      return !!(_all && _all.length || _events2 && (type === undefined$1 ? ownKeys2(_events2).length : _events2[type]));
    };
    EventEmitter2.prototype.listenersAny = function() {
      if (this._all) {
        return this._all;
      } else {
        return [];
      }
    };
    EventEmitter2.prototype.waitFor = function(event, options) {
      var self2 = this;
      var type = typeof options;
      if (type === "number") {
        options = { timeout: options };
      } else if (type === "function") {
        options = { filter: options };
      }
      options = resolveOptions(options, {
        timeout: 0,
        filter: undefined$1,
        handleError: false,
        Promise,
        overload: false
      }, {
        filter: functionReducer,
        Promise: constructorReducer
      });
      return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
        function listener() {
          var filter2 = options.filter;
          if (filter2 && !filter2.apply(self2, arguments)) {
            return;
          }
          self2.off(event, listener);
          if (options.handleError) {
            var err = arguments[0];
            err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
          } else {
            resolve(toArray.apply(null, arguments));
          }
        }
        onCancel(function() {
          self2.off(event, listener);
        });
        self2._on(event, listener, false);
      }, {
        timeout: options.timeout,
        overload: options.overload
      });
    };
    function once(emitter, name2, options) {
      options = resolveOptions(options, {
        Promise,
        timeout: 0,
        overload: false
      }, {
        Promise: constructorReducer
      });
      var _Promise = options.Promise;
      return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
        var handler;
        if (typeof emitter.addEventListener === "function") {
          handler = function() {
            resolve(toArray.apply(null, arguments));
          };
          onCancel(function() {
            emitter.removeEventListener(name2, handler);
          });
          emitter.addEventListener(
            name2,
            handler,
            { once: true }
          );
          return;
        }
        var eventListener = function() {
          errorListener && emitter.removeListener("error", errorListener);
          resolve(toArray.apply(null, arguments));
        };
        var errorListener;
        if (name2 !== "error") {
          errorListener = function(err) {
            emitter.removeListener(name2, eventListener);
            reject(err);
          };
          emitter.once("error", errorListener);
        }
        onCancel(function() {
          errorListener && emitter.removeListener("error", errorListener);
          emitter.removeListener(name2, eventListener);
        });
        emitter.once(name2, eventListener);
      }, {
        timeout: options.timeout,
        overload: options.overload
      });
    }
    var prototype = EventEmitter2.prototype;
    Object.defineProperties(EventEmitter2, {
      defaultMaxListeners: {
        get: function() {
          return prototype._maxListeners;
        },
        set: function(n2) {
          if (typeof n2 !== "number" || n2 < 0 || Number.isNaN(n2)) {
            throw TypeError("n must be a non-negative number");
          }
          prototype._maxListeners = n2;
        },
        enumerable: true
      },
      once: {
        value: once,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperties(prototype, {
      _maxListeners: {
        value: defaultMaxListeners,
        writable: true,
        configurable: true
      },
      _observers: { value: null, writable: true, configurable: true }
    });
    {
      module2.exports = EventEmitter2;
    }
  }();
})(eventemitter2);
var eventemitter2Exports = eventemitter2.exports;
function isBytes(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function bytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift2) => word << 32 - shift2 | word >>> shift2;
new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes$12) {
  bytes(bytes$12);
  let hex2 = "";
  for (let i = 0; i < bytes$12.length; i++) {
    hex2 += hexes[bytes$12[i]];
  }
  return hex2;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
class Hash3 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
class HashMD2 extends Hash3 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA2563 extends HashMD2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T12 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T22 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T12 + T22 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA2563());
var Databeat = class {
  constructor(hostname, fetch2) {
    __publicField(this, "hostname");
    __publicField(this, "fetch");
    __publicField(this, "path", "/rpc/Databeat/");
    __publicField(this, "ping", (headers, signal) => {
      return this.fetch(
        this.url("Ping"),
        createHTTPRequest$1({}, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "version", (headers, signal) => {
      return this.fetch(
        this.url("Version"),
        createHTTPRequest$1({}, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data6) => {
          return {
            version: _data6.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "runtimeStatus", (headers, signal) => {
      return this.fetch(
        this.url("RuntimeStatus"),
        createHTTPRequest$1({}, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data6) => {
          return {
            status: _data6.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "tick", (args, headers, signal) => {
      return this.fetch(
        this.url("Tick"),
        createHTTPRequest$1(args, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "rawEvents", (args, headers, signal) => {
      return this.fetch(
        this.url("RawEvents"),
        createHTTPRequest$1(args, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data6) => {
          return {
            ok: _data6.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
};
var createHTTPRequest$1 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: { ...headers, "Content-Type": "application/json" },
    body: JSON.stringify(body || {}),
    signal
  };
};
var buildResponse$1 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$1.new(
        {
          status: res.status,
          cause: `JSON.parse(): ${message}: response text: ${text2}`
        }
      );
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$1[code2] || WebrpcError$1).new(data);
    }
    return data;
  });
};
var WebrpcError$1 = class _WebrpcError extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "message");
    __publicField(this, "status");
    __publicField(this, "cause");
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    __publicField(this, "msg");
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, _WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
var WebrpcEndpointError$1 = class _WebrpcEndpointError extends WebrpcError$1 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcEndpointError.prototype);
  }
};
var WebrpcRequestFailedError$1 = class _WebrpcRequestFailedError extends WebrpcError$1 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcRequestFailedError.prototype);
  }
};
var WebrpcBadRouteError$1 = class _WebrpcBadRouteError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadRouteError.prototype);
  }
};
var WebrpcBadMethodError$1 = class _WebrpcBadMethodError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadMethodError.prototype);
  }
};
var WebrpcBadRequestError$1 = class _WebrpcBadRequestError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadRequestError.prototype);
  }
};
var WebrpcBadResponseError$1 = class _WebrpcBadResponseError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadResponseError.prototype);
  }
};
var WebrpcServerPanicError$1 = class _WebrpcServerPanicError extends WebrpcError$1 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcServerPanicError.prototype);
  }
};
var WebrpcInternalErrorError$1 = class _WebrpcInternalErrorError extends WebrpcError$1 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcInternalErrorError.prototype);
  }
};
var WebrpcClientDisconnectedError$1 = class _WebrpcClientDisconnectedError extends WebrpcError$1 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcClientDisconnectedError.prototype);
  }
};
var WebrpcStreamLostError$1 = class _WebrpcStreamLostError extends WebrpcError$1 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcStreamLostError.prototype);
  }
};
var WebrpcStreamFinishedError$1 = class _WebrpcStreamFinishedError extends WebrpcError$1 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcStreamFinishedError.prototype);
  }
};
var UnauthorizedError$1 = class _UnauthorizedError extends WebrpcError$1 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _UnauthorizedError.prototype);
  }
};
var PermissionDeniedError5 = class _PermissionDeniedError extends WebrpcError$1 {
  constructor(name2 = "PermissionDenied", code2 = 2e3, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _PermissionDeniedError.prototype);
  }
};
var SessionExpiredError5 = class _SessionExpiredError extends WebrpcError$1 {
  constructor(name2 = "SessionExpired", code2 = 2001, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _SessionExpiredError.prototype);
  }
};
var NotFoundError7 = class _NotFoundError extends WebrpcError$1 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _NotFoundError.prototype);
  }
};
var InvalidAppKeyError = class _InvalidAppKeyError extends WebrpcError$1 {
  constructor(name2 = "InvalidAppKey", code2 = 4e3, message = "Invalid app key", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _InvalidAppKeyError.prototype);
  }
};
var QueryFailedError6 = class _QueryFailedError extends WebrpcError$1 {
  constructor(name2 = "QueryFailed", code2 = 4001, message = "DB query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _QueryFailedError.prototype);
  }
};
var InvalidProjectIdError = class _InvalidProjectIdError extends WebrpcError$1 {
  constructor(name2 = "InvalidProjectId", code2 = 4002, message = "Invalid project id", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _InvalidProjectIdError.prototype);
  }
};
var webrpcErrorByCode$1 = {
  [0]: WebrpcEndpointError$1,
  [-1]: WebrpcRequestFailedError$1,
  [-2]: WebrpcBadRouteError$1,
  [-3]: WebrpcBadMethodError$1,
  [-4]: WebrpcBadRequestError$1,
  [-5]: WebrpcBadResponseError$1,
  [-6]: WebrpcServerPanicError$1,
  [-7]: WebrpcInternalErrorError$1,
  [-8]: WebrpcClientDisconnectedError$1,
  [-9]: WebrpcStreamLostError$1,
  [-10]: WebrpcStreamFinishedError$1,
  [1e3]: UnauthorizedError$1,
  [2e3]: PermissionDeniedError5,
  [2001]: SessionExpiredError5,
  [3e3]: NotFoundError7,
  [4e3]: InvalidAppKeyError,
  [4001]: QueryFailedError6,
  [4002]: InvalidProjectIdError
};
var DatabeatRpcClient = class extends Databeat {
  constructor(hostname, auth2) {
    const globalFetch = globalThis.fetch.bind(globalThis);
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, globalFetch);
    __publicField(this, "_globalFetch");
    __publicField(this, "_fetch", (input2, init2) => {
      var _a2;
      if (this.auth) {
        let headers = {};
        if (((_a2 = this.auth.jwt) == null ? void 0 : _a2.length) > 0) {
          headers["Authorization"] = `BEARER ${this.auth.jwt}`;
        }
        if (this.auth.headers) {
          headers = { ...headers, ...this.auth.headers };
        }
        init2.headers = { ...init2.headers, ...headers };
      }
      return this._globalFetch(input2, init2);
    });
    this.auth = auth2;
    this._globalFetch = globalFetch;
    this.fetch = this._fetch;
  }
};
var MAX_QUEUE_SIZE = 150;
var defaultDatabeatOptions = {
  defaultEnabled: true,
  noop: false,
  privacy: { userIdHash: true, userAgentSalt: false },
  userIdentTracking: false,
  strictMode: false,
  flushInterval: 500,
  initProps: () => {
    return {};
  }
};
var Databeat2 = class {
  constructor(host, auth2, options) {
    __publicField(this, "rpc");
    __publicField(this, "auth");
    __publicField(this, "options");
    __publicField(this, "enabled");
    __publicField(this, "ident");
    __publicField(this, "userId");
    __publicField(this, "sessionId");
    __publicField(this, "allowUserTracking");
    __publicField(this, "projectId");
    __publicField(this, "queue");
    __publicField(this, "flushTimeout");
    __publicField(this, "defaultProps");
    __publicField(this, "dedupeIdentKey");
    __publicField(this, "dedupeViewKey");
    __publicField(this, "ts");
    __publicField(this, "flush", async () => {
      if (this.flushTimeout !== null) {
        clearTimeout(this.flushTimeout);
        this.flushTimeout = null;
      }
      if (!this.enabled) return;
      if (this.options.noop) return;
      if (this.options.strictMode && !this.allowUserTracking) return;
      if (this.queue.length === 0) return;
      const events = this.dedupedQueue();
      this.queue = [];
      try {
        await this.rpc.tick({ events });
      } catch (err) {
        console.warn(`databeat flush failed: ${err}`);
      }
    });
    __publicField(this, "dedupedQueue", () => {
      const uniqEvents = /* @__PURE__ */ new Map();
      for (let i = 0; i < this.queue.length; i++) {
        const ev = this.queue[i];
        const key = `${ev.event}:${ev.source}:${ev.userId}:${ev.sessionId}:${JSON.stringify(ev.props)}:${JSON.stringify(ev.nums)}`;
        if (!uniqEvents.has(key)) {
          uniqEvents.set(key, ev);
        }
      }
      return Array.from(uniqEvents.values());
    });
    if (typeof auth2 === "string") {
      this.auth = { jwt: auth2 };
    } else {
      this.auth = auth2;
    }
    this.rpc = new DatabeatRpcClient(host, this.auth);
    this.options = defaultDatabeatOptions;
    if (options) {
      this.options = {
        defaultEnabled: options.defaultEnabled || defaultDatabeatOptions.defaultEnabled,
        projectId: options.projectId || null,
        privacy: options.privacy || defaultDatabeatOptions.privacy,
        userIdentTracking: options.userIdentTracking || defaultDatabeatOptions.userIdentTracking,
        strictMode: options.strictMode || defaultDatabeatOptions.strictMode,
        flushInterval: options.flushInterval || defaultDatabeatOptions.flushInterval,
        noop: options.noop || false,
        initProps: options.initProps || defaultDatabeatOptions.initProps
      };
    }
    this.init();
  }
  // init is called on load by the constructor and also by reset().
  init() {
    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);
    this.projectId = this.options.projectId || null;
    this.userId = null;
    this.sessionId = genSessionId();
    this.queue = [];
    this.flushTimeout = null;
    this.defaultProps = { ...getDefaultProps(), ...this.options.initProps() };
    this.identify();
  }
  // reset will reset the user_id and session_id details. Similar to a "logout" action.
  reset(skipInit) {
    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);
    if (this.userId && !this.isAnon()) {
      this.userId = null;
    }
    this.ident = 0;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    if (skipInit === true) {
      return;
    }
    this.init();
  }
  // identify can be called to seed the userId, where the behaviour changes
  // depending on privacy or strict modes. identify is also called on init,
  // where we load the data from localStorage.
  identify(userId, options) {
    if (!isBrowser()) return;
    if (options && options.allowTracking !== void 0) {
      this.allowTracking(options.allowTracking);
    }
    if (!userId) {
      const val = getStorageVal();
      if (val !== null && val.id !== null) {
        this.userId = val.id;
        this.ident = val.it;
        this.allowUserTracking = val.ut;
        if (val.it === void 0) {
          if (this.userId.startsWith("anon:")) {
            this.ident = 0;
          } else {
            this.ident = 1;
          }
          this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
        } else {
          this.ident = val.it;
        }
      }
    }
    if (userId || this.userId === null) {
      const v3 = genUserId(userId, this.allowUserTracking, this.options);
      this.userId = v3.userId;
      this.ident = v3.ident;
      this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    }
    const dedupeIdentKey = `${this.userId}:${this.sessionId}`;
    if (this.dedupeIdentKey === dedupeIdentKey) return;
    this.dedupeIdentKey = dedupeIdentKey;
    this.track({ event: "INIT", source: getPagePath(), props: this.defaultProps });
    this.flush();
  }
  // allowTracking is used by strict mode to enable/disable tracking.
  allowTracking(allowTracking) {
    this.allowUserTracking = allowTracking;
    setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    if (this.options.strictMode) {
      if (allowTracking) {
        this.enable();
      } else {
        this.disable();
      }
    }
  }
  async track(events, options) {
    if (isBrowser() && this.userId === null) {
      throw new Error("databeat: init first");
    }
    if (Array.isArray(events)) {
      for (let i = 0; i < events.length; i++) {
        events[i].ident = this.ident;
        events[i].userId = this.userId;
        events[i].sessionId = this.sessionId;
        if (!events[i].projectId && this.projectId) {
          events[i].projectId = this.projectId;
        }
      }
      this.queue.push(...events);
    } else {
      events.ident = this.ident;
      events.userId = this.userId;
      events.sessionId = this.sessionId;
      if (!events.projectId && this.projectId) {
        events.projectId = this.projectId;
      }
      this.queue.push(events);
    }
    if (this.queue.length > MAX_QUEUE_SIZE) {
      this.queue = this.queue.splice(this.queue.length - MAX_QUEUE_SIZE);
    }
    if (!this.enabled) return;
    if (options && options.flush) {
      await this.flush();
    } else if (this.flushTimeout === null) {
      this.flushTimeout = setTimeout(() => {
        this.flush();
      }, this.options.flushInterval);
    }
  }
  trackView(props = {}) {
    const eventProps = { ...this.defaultProps, ...props };
    const eventSource = getPagePath();
    const pageKey = `${eventSource}:${JSON.stringify(eventProps)}:${this.userId}:${this.sessionId}`;
    if (this.dedupeViewKey === pageKey) return;
    this.dedupeViewKey = pageKey;
    this.track({ event: "VIEW", source: eventSource, props: eventProps });
  }
  isEnabled() {
    return this.enabled;
  }
  isAnon() {
    return this.ident === 0;
  }
  getIdent() {
    return this.ident;
  }
  getUserId() {
    return this.userId;
  }
  getSessionId() {
    return this.sessionId;
  }
  getStorageTS() {
    if (this.ts) {
      return this.ts;
    }
    const val = getStorageVal();
    if (val === void 0 || val === null || val.id === null) {
      return void 0;
    }
    this.ts = val.ts;
    return this.ts;
  }
  enable() {
    if (!isAuthEnabled(this.auth)) {
      this.enabled = false;
      return;
    }
    if (!isBrowser()) return;
    this.enabled = true;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    this.identify();
  }
  disable() {
    if (!isBrowser()) return;
    this.enabled = false;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
  }
};
var isBrowser = () => {
  return typeof window === "object" && typeof window.localStorage === "object" && typeof window.localStorage.getItem === "function" && typeof window.localStorage.setItem === "function";
};
var isEnabled = (defaultEnabled, auth2) => {
  if (!isAuthEnabled(auth2)) {
    return false;
  }
  if (!isBrowser()) {
    return true;
  }
  const val = getStorageVal();
  if (val === null) {
    if (defaultEnabled !== null && defaultEnabled !== void 0) {
      return defaultEnabled;
    } else {
      return true;
    }
  } else {
    return val.on;
  }
};
var isAuthEnabled = (auth2) => {
  var _a2;
  if (((_a2 = auth2 == null ? void 0 : auth2.jwt) == null ? void 0 : _a2.length) > 0) {
    return true;
  }
  if ((auth2 == null ? void 0 : auth2.headers) && Object.keys(auth2.headers).length > 0) {
    return true;
  }
  return false;
};
var getPagePath = () => {
  try {
    return window.location.pathname;
  } catch (err) {
    return "";
  }
};
var getDefaultProps = () => {
  if (!isBrowser()) return {};
  const params = new URL(window.location.href).searchParams;
  const props = {};
  props["origin"] = window.location.origin;
  if (params.get("ref") && params.get("ref") !== "") {
    props["ref"] = params.get("ref") || "";
  }
  if (params.get("source") && params.get("source") !== "") {
    props["source"] = params.get("source") || "";
  }
  if (params.get("utm_source") && params.get("utm_source") !== "") {
    props["utmSource"] = params.get("utm_source") || "";
  }
  if (params.get("utm_campaign") && params.get("utm_campaign") !== "") {
    props["utmCampaign"] = params.get("utm_campaign") || "";
  }
  if (params.get("utm_medium") && params.get("utm_medium") !== "") {
    props["utmMedium"] = params.get("utm_medium") || "";
  }
  if (params.get("utm_content") && params.get("utm_content") !== "") {
    props["utmContent"] = params.get("utm_content") || "";
  }
  if (params.get("utm_term") && params.get("utm_term") !== "") {
    props["utmTerm"] = params.get("utm_term") || "";
  }
  if (document.referrer && document.referrer !== "") {
    props["referrer"] = document.referrer;
  }
  if (params.get("gclid") && params.get("gclid") !== "") {
    props["gclid"] = params.get("gclid") || "";
  }
  if (params.get("wbraid") && params.get("wbraid") !== "") {
    props["wbraid"] = params.get("wbraid") || "";
  }
  return props;
};
var storageKey = "_dbeat";
var getStorageVal = () => {
  try {
    return JSON.parse(window.localStorage.getItem(storageKey));
  } catch (err) {
    return null;
  }
};
var setStorageVal = (val) => {
  try {
    if (!val.ts) {
      val.ts = Math.floor(Date.now() / 1e3);
    }
    window.localStorage.setItem(storageKey, JSON.stringify(val));
    return val.ts;
  } catch (err) {
    return;
  }
};
var genUserId = (seed, allowUserTracking, options) => {
  if (!seed || seed === null || seed === "") {
    const id2 = Math.floor(Math.random() * 1e14);
    return {
      userId: `${id2}`,
      ident: 0
      /* ANON */
    };
  }
  if (options.userIdentTracking && allowUserTracking) {
    return {
      userId: seed,
      ident: 2
      /* USER */
    };
  }
  if (options.privacy.userIdHash === true || !options.userIdentTracking || !allowUserTracking) {
    if (isBrowser() && options.privacy.userAgentSalt === true) {
      seed = seed + ":" + navigator.userAgent;
    }
    if (options.privacy.extraSalt && options.privacy.extraSalt.length > 0) {
      seed = seed + ":" + options.privacy.extraSalt;
    }
    return {
      userId: bytesToHex(sha256(seed)).substring(0, 50),
      ident: 1
      /* PRIVATE */
    };
  } else {
    throw new Error("invalid configuration");
  }
};
var genSessionId = () => {
  const isSessionStorageAvail = isBrowser() && typeof window.sessionStorage === "object" && typeof window.sessionStorage.getItem === "function" && typeof window.sessionStorage.setItem === "function";
  if (!isSessionStorageAvail) {
    return genRandHex(16);
  } else {
    const sid = window.sessionStorage.getItem(storageKey);
    if (!!sid && sid.length > 0) {
      return sid;
    } else {
      const sid2 = genRandHex(16);
      window.sessionStorage.setItem(storageKey, sid2);
      return sid2;
    }
  }
};
var genRandHex = (n2) => {
  let hexString = "";
  for (let i = 0; i < n2; i++) {
    hexString += Math.floor(Math.random() * 16).toString(16);
  }
  return "0x" + hexString;
};
if (typeof process$1 === "object" && process$1.version && process$1.version < "v18") {
  console.error(`ERROR! expecting node v18+ but your node version is reporting ${process$1.version}`);
  if (process$1 && process$1.exit) {
    process$1.exit(1);
  }
}
const PROHIBITED_FUNCTIONS = new Map(["addHook(bytes4,address)", "clearExtraImageHashes(bytes32[])", "removeHook(bytes4)", "setExtraImageHash(bytes32,uint256)", "updateIPFSRoot(bytes32)", "updateImageHash(bytes32)", "updateImageHashAndIPFS(bytes32,bytes32)", "updateImplementation(address)"].map((signature2) => [id$1(signature2).slice(0, 10), signature2]));
function validateTransactionRequest(wallet, transaction2) {
  const transactions2 = index$1$1.transaction.fromTransactionish(wallet, transaction2);
  const unwound = index$1$1.transaction.unwind(wallet, transactions2);
  unwound.forEach((transaction22) => validateTransaction(wallet, transaction22));
}
function validateTransaction(wallet, transaction2) {
  if (transaction2.to.toLowerCase() === wallet.toLowerCase()) {
    if (transaction2.data) {
      const data = getBytes(transaction2.data);
      if (data.length >= 4 && !isCreateContractCall(data)) {
        throw new Error("self calls are forbidden");
      }
    }
  }
  if (transaction2.delegateCall) {
    throw new Error("delegate calls are forbidden");
  }
  if (transaction2.data) {
    const data = hexlify(transaction2.data);
    const selector2 = data.slice(0, 10);
    const signature2 = PROHIBITED_FUNCTIONS.get(selector2);
    if (signature2) {
      const name2 = signature2.slice(0, signature2.indexOf("("));
      throw new Error(`${name2} calls are forbidden`);
    }
  }
}
function isCreateContractCall(data) {
  const walletInterface = new Interface(walletContracts.mainModule.abi);
  try {
    walletInterface.decodeFunctionData("createContract", data);
    return true;
  } catch (_unused) {
    return false;
  }
}
function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$4.apply(null, arguments);
}
function isProviderTransport(transport) {
  return transport && typeof transport === "object" && typeof transport.register === "function" && typeof transport.unregister === "function" && typeof transport.openWallet === "function" && typeof transport.closeWallet === "function" && typeof transport.isOpened === "function" && typeof transport.isConnected === "function" && typeof transport.on === "function";
}
class WindowSessionParams extends URLSearchParams {
  static new(init2) {
    return new URLSearchParams(init2);
  }
}
let EventType = /* @__PURE__ */ function(EventType2) {
  EventType2["OPEN"] = "open";
  EventType2["CLOSE"] = "close";
  EventType2["MESSAGE"] = "message";
  EventType2["CONNECT"] = "connect";
  EventType2["DISCONNECT"] = "disconnect";
  EventType2["ACCOUNTS_CHANGED"] = "accountsChanged";
  EventType2["CHAIN_CHANGED"] = "chainChanged";
  EventType2["NETWORKS"] = "networks";
  EventType2["WALLET_CONTEXT"] = "walletContext";
  EventType2["INIT"] = "init";
  EventType2["DEBUG"] = "_debug";
  return EventType2;
}({});
let OpenState = /* @__PURE__ */ function(OpenState2) {
  OpenState2[OpenState2["CLOSED"] = 0] = "CLOSED";
  OpenState2[OpenState2["OPENING"] = 1] = "OPENING";
  OpenState2[OpenState2["OPENED"] = 2] = "OPENED";
  return OpenState2;
}({});
let InitState = /* @__PURE__ */ function(InitState2) {
  InitState2[InitState2["NIL"] = 0] = "NIL";
  InitState2[InitState2["SENT_NONCE"] = 1] = "SENT_NONCE";
  InitState2[InitState2["OK"] = 2] = "OK";
  return InitState2;
}({});
class ProviderError extends Error {
  constructor(message) {
    super(message);
    this.name = "ProviderError";
  }
}
const ErrSignedInRequired = new ProviderError("Wallet is not signed in. Connect a wallet and try again.");
const PROVIDER_OPEN_TIMEOUT = 3e4;
let _messageIdx = 0;
const nextMessageIdx = () => ++_messageIdx;
class BaseProviderTransport {
  constructor() {
    var _this = this;
    this.pendingMessageRequests = [];
    this.responseCallbacks = /* @__PURE__ */ new Map();
    this.state = void 0;
    this.confirmationOnly = false;
    this.events = new eventemitter2Exports.EventEmitter2();
    this.openPayload = void 0;
    this.connectPayload = void 0;
    this.accountsChangedPayload = void 0;
    this.networksPayload = void 0;
    this.walletContextPayload = void 0;
    this._sessionId = void 0;
    this._init = void 0;
    this._registered = void 0;
    this.sendMessageRequest = async function(message) {
      return new Promise((resolve, reject) => {
        if ((!message.idx || message.idx <= 0) && message.type !== "init") {
          reject(new Error("message idx not set"));
        }
        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error("no valid response to return");
          }
        };
        const idx = message.idx;
        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error("duplicate message idx, should never happen"));
        }
        if (!_this.isOpened()) {
          logger.debug("pushing to pending requests", message);
          _this.pendingMessageRequests.push(message);
        } else {
          _this.sendMessage(message);
        }
      });
    };
    this.waitUntilOpened = async function(openTimeout = PROVIDER_OPEN_TIMEOUT) {
      let opened = false;
      return Promise.race([new Promise((_, reject) => {
        const timeout = setTimeout(() => {
          clearTimeout(timeout);
          if (!opened) {
            _this.state = OpenState.CLOSED;
            _this.events.emit("close", {
              code: 1005,
              message: "opening wallet timed out"
            });
          }
          reject(new Error("opening wallet timed out"));
        }, openTimeout);
      }), new Promise((resolve) => {
        if (_this.isOpened()) {
          var _this$openPayload;
          opened = true;
          resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);
          return;
        }
        _this.events.once("open", (openInfo) => {
          _this.openPayload = openInfo;
          opened = true;
          resolve(openInfo.session);
        });
      })]);
    };
    this.waitUntilConnected = async function() {
      await _this.waitUntilOpened();
      const connect2 = new Promise((resolve) => {
        if (_this.connectPayload) {
          resolve(_this.connectPayload);
          return;
        }
        _this.events.once("connect", (connectDetails) => {
          _this.connectPayload = connectDetails;
          resolve(connectDetails);
        });
      });
      const closeWallet = new Promise((_, reject) => {
        _this.events.once("close", (error) => {
          if (error) {
            reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));
          } else {
            reject(new Error(`user closed the wallet`));
          }
        });
      });
      return Promise.race([connect2, closeWallet]);
    };
    this.state = OpenState.CLOSED;
    this._registered = false;
    this._init = InitState.NIL;
  }
  get registered() {
    return this._registered;
  }
  register() {
    throw new Error("abstract method");
  }
  unregister() {
    throw new Error("abstract method");
  }
  openWallet(path, intent, networkId) {
    throw new Error("abstract method");
  }
  closeWallet() {
    throw new Error("abstract method");
  }
  isOpened() {
    return this.registered && this.state === OpenState.OPENED;
  }
  isConnected() {
    var _this$openPayload2;
    const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;
    return this.registered && session !== void 0 && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;
  }
  async request(request) {
    if (this.state === OpenState.CLOSED) {
      this.confirmationOnly = true;
    }
    this.openWallet(void 0, {
      type: "jsonRpcRequest",
      method: request.method
    }, request.chainId);
    if (!this.isOpened()) {
      await this.waitUntilOpened();
    }
    const response = await this.sendMessageRequest({
      idx: nextMessageIdx(),
      type: EventType.MESSAGE,
      data: request,
      chainId: request.chainId,
      clientVersion: VERSION$1
    });
    return response.data;
  }
  // handleMessage will handle message received from the remote wallet
  handleMessage(message) {
    var _this2 = this;
    if (message.type === EventType.INIT) {
      logger.debug("MessageProvider, received INIT message", message);
      const {
        nonce
      } = message.data;
      if (!nonce || nonce.length == 0) {
        logger.error("invalid init nonce");
        return;
      }
      this._init = InitState.OK;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          sessionId: this._sessionId,
          nonce
        },
        clientVersion: VERSION$1
      });
    }
    if (this._init !== InitState.OK) {
      return;
    }
    logger.debug("RECEIVED MESSAGE FROM WALLET", message.idx, message);
    const requestIdx = message.idx;
    const responseCallback = this.responseCallbacks.get(requestIdx);
    if (requestIdx) {
      this.responseCallbacks.delete(requestIdx);
    }
    if (message.type === EventType.OPEN && !this.isOpened()) {
      var _message$data, _message$data2;
      if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {
        logger.debug("open event received from wallet, but does not match sessionId", this._sessionId);
        return;
      }
      if ((_message$data2 = message.data) != null && _message$data2.error) {
        var _message$data3;
        const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);
        logger.error(err);
        this.close();
        throw err;
      }
      this.state = OpenState.OPENED;
      this.openPayload = message.data;
      this.events.emit("open", this.openPayload);
      if (this.pendingMessageRequests.length !== 0) {
        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);
        pendingMessageRequests.forEach(async function(pendingMessageRequest) {
          _this2.sendMessage(pendingMessageRequest);
        });
      }
      return;
    }
    if (message.type === EventType.MESSAGE) {
      if (this.confirmationOnly) {
        setTimeout(() => {
          if (this.responseCallbacks.size === 0) {
            this.closeWallet();
          }
        }, 500);
      }
      if (!responseCallback) {
        throw new Error("impossible state");
      }
      if (responseCallback) {
        this.events.emit("message", message);
        responseCallback(message.data.error, message);
        return;
      }
    }
    if (message.type === EventType.ACCOUNTS_CHANGED) {
      this.accountsChangedPayload = {
        accounts: []
      };
      if (message.data && message.data.length > 0) {
        this.accountsChangedPayload = {
          accounts: [getAddress(message.data[0])],
          origin: message.origin
        };
        this.events.emit("accountsChanged", this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);
      } else {
        this.events.emit("accountsChanged", [], message.origin);
      }
      return;
    }
    if (message.type === EventType.CHAIN_CHANGED) {
      this.events.emit("chainChanged", message.data, message.origin);
      return;
    }
    if (message.type === EventType.NETWORKS) {
      this.networksPayload = message.data;
      this.events.emit("networks", this.networksPayload);
      return;
    }
    if (message.type === EventType.WALLET_CONTEXT) {
      this.walletContextPayload = message.data;
      this.events.emit("walletContext", this.walletContextPayload);
      return;
    }
    if (message.type === EventType.CLOSE) {
      if (this.state !== OpenState.CLOSED) {
        this.close(message.data);
      }
    }
    if (message.type === EventType.CONNECT) {
      this.connectPayload = message.data;
      this.events.emit("connect", this.connectPayload);
    }
    if (message.type === EventType.DISCONNECT) {
      if (this.isConnected()) {
        this.events.emit("disconnect", message.data, message.origin);
        this.close();
      }
    }
  }
  sendMessage(message) {
    throw new Error("abstract method");
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
  emit(event, ...args) {
    return this.events.emit(event, ...args);
  }
  close(error) {
    if (this.state === OpenState.CLOSED) return;
    this.state = OpenState.CLOSED;
    this.confirmationOnly = false;
    this._sessionId = void 0;
    logger.info("closing wallet and flushing!");
    this.pendingMessageRequests.length = 0;
    this.responseCallbacks.forEach((responseCallback) => {
      responseCallback(_extends$4({}, new Error("wallet closed"), {
        code: 4001
      }));
    });
    this.responseCallbacks.clear();
    this.connectPayload = void 0;
    this.openPayload = void 0;
    this.accountsChangedPayload = void 0;
    this.networksPayload = void 0;
    this.walletContextPayload = void 0;
    this.events.emit("close", error);
  }
}
function messageIsExemptFromEIP191Prefix(message) {
  return EIP_191_PREFIX_EXCEPTIONS.some((e2) => e2.predicate(message));
}
const EIP_191_PREFIX_EXCEPTIONS = [
  // NOTE: Decentraland does not support 191 correctly.
  {
    name: "Decentraland Exception",
    predicate: isDecentralandLoginMessage
  },
  // NOTE: 0x v3 does not support 191 correctly.
  // See https://gov.0x.org/t/zeip-proposal-fix-v3-eip-191-non-compliance-when-validating-eip-1271-signatures/3396 for more info.
  {
    name: "0x v3 Exception",
    predicate: isZeroExV3Order
  }
];
const DCL_REGEX = /^Decentraland Login\nEphemeral address: 0x[a-fA-F0-9]{40}\nExpiration: (\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)((-(\d{2}):(\d{2})|Z)?)$/;
function isDecentralandLoginMessage(bytes2) {
  try {
    const stringified = toUtf8String(bytes2);
    return DCL_REGEX.test(stringified);
  } catch (_unused) {
    return false;
  }
}
function isZeroExV3Order(bytes2) {
  const abi2 = new Interface(ZeroXV3EIP1271OrderWithHashAbi);
  try {
    abi2.decodeFunctionData("OrderWithHash", bytes2);
    return true;
  } catch (err) {
    return false;
  }
}
const ZeroXV3EIP1271OrderWithHashAbi = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "makerAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "takerAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "feeRecipientAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "senderAddress",
      type: "address"
    }, {
      internalType: "uint256",
      name: "makerAssetAmount",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "takerAssetAmount",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "makerFee",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "takerFee",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "expirationTimeSeconds",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "salt",
      type: "uint256"
    }, {
      internalType: "bytes",
      name: "makerAssetData",
      type: "bytes"
    }, {
      internalType: "bytes",
      name: "takerAssetData",
      type: "bytes"
    }, {
      internalType: "bytes",
      name: "makerFeeAssetData",
      type: "bytes"
    }, {
      internalType: "bytes",
      name: "takerFeeAssetData",
      type: "bytes"
    }],
    internalType: "struct IEIP1271Data.Order",
    name: "order",
    type: "tuple"
  }, {
    internalType: "bytes32",
    name: "orderHash",
    type: "bytes32"
  }],
  name: "OrderWithHash",
  outputs: [],
  stateMutability: "pure",
  type: "function"
}];
const eip191prefix = toUtf8Bytes("Ethereum Signed Message:\n");
const messageToBytes = (message) => {
  if (isBytesLike(message)) {
    return getBytes(message);
  }
  return toUtf8Bytes(message);
};
const prefixEIP191Message = (message) => {
  const messageBytes = messageToBytes(message);
  if (messageIsExemptFromEIP191Prefix(messageBytes)) {
    return messageBytes;
  } else {
    return getBytes(concat([eip191prefix, toUtf8Bytes(String(messageBytes.length)), messageBytes]));
  }
};
const trimEIP191Prefix = (prefixedMessage) => {
  if (JSON.stringify(prefixedMessage.slice(0, eip191prefix.length)) !== JSON.stringify(eip191prefix)) {
    return prefixedMessage;
  }
  const ethereumSignedMessagePartSlicedArray = prefixedMessage.slice(eip191prefix.length);
  const maxPrefixCharLength = String(ethereumSignedMessagePartSlicedArray.length).length;
  let prefixCharLenght;
  let prefixAsNumber;
  try {
    prefixAsNumber = Number(toUtf8String(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
  } catch (_unused) {
    prefixAsNumber = Number(hexlify(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
  }
  if (prefixAsNumber > ethereumSignedMessagePartSlicedArray.length || !Number.isInteger(prefixAsNumber)) {
    prefixCharLenght = maxPrefixCharLength - 1;
  } else {
    prefixCharLenght = maxPrefixCharLength;
  }
  const prefixRevertedMessage = ethereumSignedMessagePartSlicedArray.slice(prefixCharLenght);
  return prefixRevertedMessage;
};
const isValidSignature = async (address, digest, sig, provider2) => {
  const reader2 = new index$1$1.reader.OnChainReader(provider2);
  return reader2.isValidSignature(address, digest, sig);
};
const isValidMessageSignature = async (address, message, signature2, provider2) => {
  const prefixed = prefixEIP191Message(message);
  const digest = encodeMessageDigest(prefixed);
  return isValidSignature(address, digest, signature2, provider2);
};
const isValidTypedDataSignature = (address, typedData, signature2, provider2) => {
  return isValidSignature(address, encodeTypedDataDigest(typedData), signature2, provider2);
};
const isBrowserExtension = () => window.location.protocol === "chrome-extension:" || window.location.protocol === "moz-extension:";
const isUnityPlugin = () => !!navigator.userAgent.match(/UnitySequence/i);
const isWalletUpToDate = (status) => {
  return status.onChain.deployed && status.fullyMigrated;
};
class MemoryItemStore {
  constructor() {
    this.callbacks = [];
    this.store = {};
  }
  getItem(key) {
    return this.store[key] || null;
  }
  setItem(key, value) {
    this.store[key] = value;
    this.callbacks.filter((c2) => c2.key === key).forEach((c2) => c2.cb(value));
  }
  removeItem(key) {
    delete this.store[key];
  }
  onItemChange(key, cb2) {
    this.callbacks.push({
      key,
      cb: cb2
    });
    return () => {
      this.callbacks = this.callbacks.filter((c2) => c2.cb !== cb2);
    };
  }
}
class LocalStorage {
  static isAvailable() {
    return typeof window === "object" && typeof window.localStorage === "object";
  }
  constructor() {
    this.callbacks = [];
    if (!LocalStorage.isAvailable()) {
      throw new Error("LocalStorage is not available");
    }
    window.addEventListener("storage", (e2) => {
      const {
        key
      } = e2;
      const cb2 = this.callbacks.filter((c2) => c2.key === key);
      cb2.forEach((c2) => c2.cb(this.getItem(key)));
    });
  }
  getItem(key) {
    return window.localStorage.getItem(key);
  }
  setItem(key, value) {
    window.localStorage.setItem(key, value);
    this.callbacks.filter((c2) => c2.key === key).forEach((c2) => c2.cb(value));
  }
  removeItem(key) {
    window.localStorage.removeItem(key);
    this.callbacks.filter((c2) => c2.key === key).forEach((c2) => c2.cb(null));
  }
  onItemChange(key, cb2) {
    this.callbacks.push({
      key,
      cb: cb2
    });
    return () => {
      this.callbacks = this.callbacks.filter((c2) => c2.cb !== cb2);
    };
  }
}
function useBestStore() {
  if (LocalStorage.isAvailable()) {
    return new LocalStorage();
  }
  return new MemoryItemStore();
}
async function resolveArrayProperties(object2) {
  if (Array.isArray(object2)) {
    return Promise.all(object2.map((o2) => resolveProperties$1(o2)));
  }
  return resolveProperties$1(object2);
}
const TRANSPORT_SESSION_LS_KEY = "@sequence.transportSession";
class BaseWalletTransport {
  constructor(walletRequestHandler) {
    var _this = this;
    this.walletRequestHandler = void 0;
    this._sessionId = void 0;
    this._registered = void 0;
    this._init = void 0;
    this._initNonce = void 0;
    this._initCallback = void 0;
    this.appOrigin = void 0;
    this.handleMessage = async function(message) {
      const request = message;
      if (_this._init !== InitState.OK) {
        if (request.type === EventType.INIT) {
          if (_this.isValidInitAck(message)) {
            if (_this._initCallback) _this._initCallback();
          } else {
            if (_this._initCallback) _this._initCallback("invalid init");
            return;
          }
        }
        return;
      }
      switch (request.type) {
        case EventType.OPEN: {
          if (_this._init !== InitState.OK) return;
          const session = {
            sessionId: request.data.sessionId,
            intent: request.data.intent,
            networkId: request.data.networkId
          };
          await _this.open(session);
          return;
        }
        case EventType.CLOSE: {
          if (_this._init !== InitState.OK) return;
          return;
        }
        case EventType.MESSAGE: {
          const response = await _this.walletRequestHandler.sendMessageRequest(request);
          _this.sendMessage(response);
          if (response.data.error) ;
          return;
        }
        default: {
          logger.error(`unexpected payload type ${request.type}`);
        }
      }
    };
    this.sendMessageRequest = async function(message) {
      return _this.walletRequestHandler.sendMessageRequest(message);
    };
    this.open = async function({
      sessionId,
      intent,
      networkId
    }) {
      if (sessionId) {
        _this._sessionId = sanitizeNumberString(sessionId);
        _this.saveTransportSession({
          sessionId,
          intent,
          networkId
        });
      }
      _this.walletRequestHandler.setOpenIntent(intent);
      await _this.init();
      let chainId = void 0;
      try {
        if (networkId) {
          const network2 = findSupportedNetwork(networkId);
          if (network2) {
            chainId = network2.chainId;
          } else {
            throw new Error(`unknown network ${networkId}`);
          }
        } else {
          chainId = _this.walletRequestHandler.defaultChainId();
        }
      } catch (err) {
        console.error(err);
      }
      if (intent && intent.type === "connect" && intent.options) {
        const connectOptions = intent.options;
        const authorizeOptions = connectOptions;
        if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          if (!isBrowserExtension()) {
            if (authorizeOptions.origin !== _this.appOrigin) {
              throw new Error("origin is invalid");
            }
          }
        } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          connectOptions.origin = sanitizeHost(authorizeOptions.origin);
        } else if (_this.appOrigin) {
          connectOptions.origin = _this.appOrigin;
        }
        if (connectOptions.app) {
          connectOptions.app = sanitizeAlphanumeric(connectOptions.app);
        }
        if (connectOptions.networkId) {
          networkId = connectOptions.networkId;
        } else if (networkId) {
          connectOptions.networkId = networkId;
        }
        _this.walletRequestHandler.setConnectOptions(connectOptions);
      } else {
        _this.walletRequestHandler.setConnectOptions(void 0);
      }
      await _this.walletRequestHandler.getAccount();
      if (!await _this.walletRequestHandler.isSignedIn()) {
        _this.notifyOpen({
          sessionId: _this._sessionId
        });
        return true;
      } else {
        if (intent && intent.type === "connect") {
          if (!chainId || chainId <= 0) {
            console.log("Failed to set default network on open");
          }
          _this.notifyOpen({
            sessionId: _this._sessionId
          });
          try {
            const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);
            if (connectDetails.connected) {
              _this.walletRequestHandler.notifyConnect(connectDetails);
            }
          } catch (err) {
            logger.warn("promptConnect not connected:", err);
          } finally {
            if (!intent.options || intent.options.keepWalletOpened !== true) {
              _this.notifyClose();
            }
          }
        } else {
          if (!chainId || chainId <= 0) {
            _this.notifyOpen({
              sessionId: _this._sessionId,
              error: `failed to open wallet on network ${networkId}`
            });
            return false;
          }
          _this.notifyOpen({
            sessionId: _this._sessionId,
            chainId: `${chainId}`,
            session: await _this.walletRequestHandler.walletSession(chainId)
          });
        }
      }
      return true;
    };
    this.saveTransportSession = (session) => {
      useBestStore().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));
    };
    this.getCachedTransportSession = async function() {
      const session = useBestStore().getItem(TRANSPORT_SESSION_LS_KEY);
      try {
        return session ? JSON.parse(session) : null;
      } catch (err) {
        console.error(`unable to parse transport session: ${session}`);
        return null;
      }
    };
    this.walletRequestHandler = walletRequestHandler;
    this._init = InitState.NIL;
    this.walletRequestHandler.on("connect", (connectDetails) => {
      if (!this.registered) return;
      this.notifyConnect(connectDetails);
    });
    this.walletRequestHandler.on("disconnect", (error, origin) => {
      if (!this.registered) return;
      this.notifyDisconnect(error, origin);
    });
    this.walletRequestHandler.on("accountsChanged", (accounts, origin) => {
      if (!this.registered) return;
      this.notifyAccountsChanged(accounts, origin);
    });
    this.walletRequestHandler.on("networks", (networks2) => {
      if (!this.registered) return;
      this.notifyNetworks(networks2);
      if (!networks2 || networks2.length === 0) {
        this.notifyChainChanged("0x0");
      } else {
        this.notifyChainChanged(toQuantity(networks2.find((network2) => network2.isDefaultChain).chainId));
      }
    });
    this.walletRequestHandler.on("chainChanged", (chainIdHex, origin) => {
      this.notifyChainChanged(chainIdHex, origin);
    });
    this.walletRequestHandler.on("walletContext", (walletContext) => {
      if (!this.registered || !walletContext) return;
      this.notifyWalletContext(walletContext);
    });
    this.walletRequestHandler.on("close", (error) => {
      if (!this.registered) return;
      this.notifyClose(error);
    });
  }
  get registered() {
    return this._registered;
  }
  register() {
    throw new Error("abstract method");
  }
  unregister() {
    throw new Error("abstract method");
  }
  request(request) {
    throw new Error("abstract method");
  }
  sendMessage(message) {
    throw new Error("abstract method");
  }
  notifyOpen(openInfo) {
    const {
      chainId,
      sessionId,
      session,
      error
    } = openInfo;
    this.sendMessage({
      idx: -1,
      type: EventType.OPEN,
      data: {
        chainId,
        sessionId,
        session,
        error
      },
      clientVersion: VERSION$1
    });
  }
  notifyClose(error) {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: error ? {
        error
      } : null,
      clientVersion: VERSION$1
    });
  }
  notifyConnect(connectDetails) {
    this.sendMessage({
      idx: -1,
      type: EventType.CONNECT,
      data: connectDetails,
      clientVersion: VERSION$1
    });
  }
  notifyDisconnect(error, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.DISCONNECT,
      data: error ? {
        error
      } : null,
      origin,
      clientVersion: VERSION$1
    });
  }
  notifyAccountsChanged(accounts, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.ACCOUNTS_CHANGED,
      data: accounts,
      origin,
      clientVersion: VERSION$1
    });
  }
  notifyChainChanged(chainIdHex, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.CHAIN_CHANGED,
      data: chainIdHex,
      origin,
      clientVersion: VERSION$1
    });
  }
  notifyNetworks(networks2) {
    this.sendMessage({
      idx: -1,
      type: EventType.NETWORKS,
      data: networks2,
      clientVersion: VERSION$1
    });
  }
  notifyWalletContext(walletContext) {
    this.sendMessage({
      idx: -1,
      type: EventType.WALLET_CONTEXT,
      data: walletContext,
      clientVersion: VERSION$1
    });
  }
  isValidInitAck(message) {
    if (this._init === InitState.OK) {
      logger.warn("isValidInitAck, already in init'd state, so inquiry is invalid.");
      return false;
    }
    if (message.type !== EventType.INIT) {
      logger.warn("isValidInitAck, invalid message type, expecting init");
      return false;
    }
    const {
      sessionId,
      nonce
    } = message.data;
    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {
      logger.error("invalid init ack");
      return false;
    }
    if (sessionId !== this._sessionId || nonce !== this._initNonce) {
      logger.error("invalid init ack match");
      return false;
    }
    return true;
  }
  init() {
    return new Promise((resolve, reject) => {
      if (this._init === InitState.OK) {
        resolve();
        return;
      }
      if (this._init !== InitState.NIL || this._initCallback) {
        reject("transport init is in progress");
        return;
      }
      const initTimeout = setTimeout(() => {
        logger.warn("transport init timed out");
        if (this._initCallback) {
          this._initCallback("transport init timed out");
        }
      }, PROVIDER_OPEN_TIMEOUT / 2);
      this._initCallback = (error) => {
        this._initCallback = void 0;
        clearTimeout(initTimeout);
        if (error) {
          reject(error);
        } else {
          this._init = InitState.OK;
          resolve();
        }
      };
      this._initNonce = `${performance.now()}`;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          nonce: this._initNonce
        },
        clientVersion: VERSION$1
      });
      this._init = InitState.SENT_NONCE;
    });
  }
}
class ProxyMessageChannel {
  constructor() {
    this.app = void 0;
    this.wallet = void 0;
    const port1 = new ProxyMessageChannelPort();
    const port2 = new ProxyMessageChannelPort();
    port1.conn = port2;
    port2.conn = port1;
    this.app = port1;
    this.wallet = port2;
  }
}
class ProxyMessageChannelPort {
  constructor() {
    this.conn = void 0;
    this.events = new eventemitter2Exports.EventEmitter2();
    this.handleMessage = (message) => {
      throw new Error("ProxyMessageChannelPort is not registered");
    };
    this.sendMessage = (message) => {
      this.conn.handleMessage(message);
      if (message.type === "open") {
        this.events.emit("open", message);
      }
      if (message.type === "close") {
        this.events.emit("close", message);
      }
      if (message.type === "connect") {
        this.events.emit("connect", message);
      }
      if (message.type === "disconnect") {
        this.events.emit("disconnect", message);
      }
    };
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
}
class ProxyMessageProvider extends BaseProviderTransport {
  constructor(port) {
    super();
    this.port = void 0;
    this.register = () => {
      this.port.handleMessage = (message) => {
        this.handleMessage(message);
      };
      this.on("open", (...args) => {
        this.port.events.emit("open", ...args);
      });
      this.on("close", (...args) => {
        this.port.events.emit("close", ...args);
      });
      this.on("connect", (...args) => {
        this.port.events.emit("connect", ...args);
      });
      this.on("disconnect", (...args) => {
        this.port.events.emit("disconnect", ...args);
      });
      this._registered = true;
    };
    this.unregister = () => {
      this._registered = false;
      this.closeWallet();
      this.events.removeAllListeners();
      this.port.handleMessage = void 0;
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.state === OpenState.CLOSED) {
        this.state = OpenState.OPENING;
        const sessionId = `${performance.now()}`;
        this._sessionId = sessionId;
        this.sendMessage({
          idx: -1,
          type: EventType.OPEN,
          data: {
            path,
            intent,
            networkId,
            sessionId
          },
          clientVersion: VERSION$1
        });
      }
    };
    this.state = OpenState.CLOSED;
    this.port = port;
    if (!port) {
      throw new Error("port argument cannot be empty");
    }
    this._init = InitState.OK;
  }
  closeWallet() {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: null,
      clientVersion: VERSION$1
    });
    this.close();
  }
  sendMessage(message) {
    if (!message.idx) {
      throw new Error("message idx is empty");
    }
    this.port.sendMessage(message);
  }
}
class ProxyMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, port) {
    super(walletRequestHandler);
    this.port = void 0;
    this.port = port;
    this._init = InitState.OK;
  }
  register() {
    this.port.handleMessage = (message) => {
      this.handleMessage(message);
    };
    this._registered = true;
  }
  // note: we can't decide whether to restore the session within register(), because session info is
  // received asyncronously via EventType.OPEN after register() is executed.
  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,
  // because the wallet is already open.
  //
  // call this method from wallet redirect hander when a session restore is needed
  async restoreSession() {
    const cachedSession = await this.getCachedTransportSession();
    if (cachedSession) {
      this.open(cachedSession);
    }
  }
  unregister() {
    this.port.handleMessage = void 0;
    this._registered = false;
  }
  sendMessage(message) {
    this.port.sendMessage(message);
  }
}
function overrideLogs(side) {
  var _window$ue;
  if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport && !window.logsOverriddenForUnreal) {
    var _window$ue2;
    const t2 = (_window$ue2 = window.ue) == null ? void 0 : _window$ue2.sequencewallettransport;
    console.log = (...args) => {
      t2.logfromjs(`${side}: ${stringify(args)}`);
    };
    console.warn = (...args) => {
      t2.warnfromjs(`${side}: ${stringify(args)}`);
    };
    console.error = (...args) => {
      t2.errorfromjs(`${side}: ${stringify(args)}`);
    };
    window.logsOverriddenForUnreal = true;
  }
}
function stringify(things) {
  return things.map((a2) => typeof a2 === "object" ? a2 instanceof Error ? a2.message : JSON.stringify(a2) : String(a2)).join(" ");
}
let registeredUnrealMessageProvider;
class UnrealMessageProvider extends BaseProviderTransport {
  constructor(walletAppURL) {
    super();
    this.walletURL = void 0;
    this.register = () => {
      var _window$ue;
      overrideLogs("dapp");
      if (registeredUnrealMessageProvider) {
        registeredUnrealMessageProvider.unregister();
        registeredUnrealMessageProvider = this;
      }
      if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport) {
        window.ue.sequencewallettransport.onmessagefromwallet = this.onUnrealCallback;
      }
      registeredUnrealMessageProvider = this;
      this._registered = true;
      console.log("registering transport!");
    };
    this.unregister = () => {
      var _window$ue2;
      this._registered = false;
      this.closeWallet();
      if (registeredUnrealMessageProvider === this) {
        registeredUnrealMessageProvider = void 0;
      }
      if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromwallet) === this.onUnrealCallback) {
        delete window.ue.sequencewallettransport.onmessagefromwallet;
      }
      this.events.removeAllListeners();
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.isOpened()) {
        console.log("wallet already open!");
        return;
      }
      console.log("opening wallet!");
      const walletURL = new URL(this.walletURL.href);
      const windowSessionParams = new WindowSessionParams();
      if (path) {
        walletURL.pathname = path.toLowerCase();
      }
      this._init = InitState.NIL;
      this._sessionId = `${performance.now()}`;
      windowSessionParams.set("sid", this._sessionId);
      if (intent) {
        windowSessionParams.set("intent", base64EncodeObject(intent));
      }
      if (networkId) {
        windowSessionParams.set("net", `${networkId}`);
      }
      walletURL.search = windowSessionParams.toString();
      console.log("opening wallet to", walletURL.href);
      window.open(walletURL.href);
    };
    this.onUnrealCallback = (message) => {
      if (!message) {
        throw new Error("ProviderMessage object is empty");
      }
      this.handleMessage(message);
    };
    this.walletURL = new URL(walletAppURL);
  }
  closeWallet() {
    this.close();
  }
  // all lowercase is an annoying limitation of Unreal CEF BindUObject
  sendMessage(message) {
    var _window$ue3;
    const postedMessage = typeof message !== "string" ? JSON.stringify(message, bigintReplacer) : message;
    console.log("Sending message to wallet:", postedMessage);
    (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetowallet(postedMessage);
  }
}
class UnrealMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler) {
    super(walletRequestHandler);
    this.onMessageFromUnreal = (request) => {
      logger.debug("RECEIVED MESSAGE", request);
      this.handleMessage(request);
    };
    this.getUnrealTransportSession = (windowParams) => {
      const params = new WindowSessionParams(windowParams);
      return {
        sessionId: params.get("sid"),
        networkId: params.get("net"),
        intent: base64DecodeObject(params.get("intent"))
      };
    };
    this._init = InitState.NIL;
  }
  async register(windowHref) {
    var _window$ue;
    if (((_window$ue = window.ue) == null ? void 0 : _window$ue.sequencewallettransport) === void 0) {
      return;
    }
    overrideLogs("wallet");
    const {
      search: rawParams
    } = new URL(windowHref || window.location.href);
    let session = this.getUnrealTransportSession(rawParams);
    const isNewWindowSession = !!session.sessionId;
    if (!isNewWindowSession) {
      session = await this.getCachedTransportSession();
    }
    if (!session) {
      logger.error("unreal session is undefined");
      return;
    }
    window.ue.sequencewallettransport.onmessagefromsequencejs = this.onMessageFromUnreal;
    this._registered = true;
    this.open(session).then((opened) => {
      if (!opened) {
        var _session;
        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
        logger.error(err);
        this.notifyClose({
          message: err
        });
        window.close();
      }
    }).catch((e2) => {
      var _session2;
      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e2}`;
      logger.error(err);
      this.notifyClose({
        message: err
      });
      window.close();
    });
  }
  unregister() {
    var _window$ue2;
    if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromsequencejs) === this.onMessageFromUnreal) {
      delete window.ue.sequencewallettransport.onmessagefromsequencejs;
    }
    this._registered = false;
  }
  // sendMessage sends message to the dapp window
  sendMessage(message) {
    var _window$ue3;
    if (message.type !== EventType.INIT && this._init !== InitState.OK) {
      logger.error("impossible state, should not be calling postMessage until inited");
      return;
    }
    const payload = JSON.stringify(message, bigintReplacer);
    (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetosequencejs(payload);
  }
}
const CHANNEL_ID = "sequence-extension-message-handler";
class ExtensionMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, runtime) {
    super(walletRequestHandler);
    this.runtime = runtime;
    this.port = void 0;
    this._init = InitState.OK;
  }
  register() {
    this._registered = true;
    this.port = this.runtime.connect({
      name: CHANNEL_ID
    });
  }
  sendMessage(message) {
    logger.info("[ExtensionMessageHandler send]", message);
    this.port.postMessage(message);
  }
}
class ExtensionMessageProvider extends BaseProviderTransport {
  constructor(runtime) {
    super();
    this.register = () => {
      this._registered = true;
    };
    runtime.onConnect.addListener((port) => {
      if (port.name === CHANNEL_ID) {
        this._init = InitState.OK;
        port.onMessage.addListener((message) => {
          this.handleMessage(message);
        });
      }
    });
  }
  sendMessage(message) {
  }
  unregister() {
  }
  openWallet(path, intent, networkId) {
  }
  closeWallet() {
  }
}
class BaseInjectedTransport extends eventemitter2Exports.EventEmitter2 {
  constructor(stream) {
    var _this;
    super();
    _this = this;
    this.stream = stream;
    this.responseCallbacks = /* @__PURE__ */ new Map();
    this._messageIdx = 0;
    this.nextMessageIdx = () => ++this._messageIdx;
    this.handleMessage = (message) => {
      if (!message.type || !message.data) {
        return;
      }
      logger.info("[received message]", message);
      const requestIdx = message.idx;
      const responseCallback = this.responseCallbacks.get(requestIdx);
      if (requestIdx) {
        this.responseCallbacks.delete(requestIdx);
      }
      switch (message.type) {
        case EventType.MESSAGE:
          if (responseCallback) {
            this.emit(EventType.MESSAGE, message);
            responseCallback(message.data.error, message);
          } else {
            throw new Error("impossible state");
          }
          break;
        case EventType.DISCONNECT:
        case EventType.ACCOUNTS_CHANGED:
        case EventType.CHAIN_CHANGED:
          this.emit(message.type, message.data);
          break;
        default:
          console.error("unknown message type", message);
          break;
      }
    };
    this.sendMessageRequest = async function(message) {
      return new Promise((resolve, reject) => {
        if (!message.idx || message.idx <= 0) {
          reject(new Error("message idx not set"));
        }
        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error("no valid response to return");
          }
        };
        const {
          idx
        } = message;
        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error("duplicate message idx, should never happen"));
        }
        _this.sendMessage(message);
      });
    };
    this.stream.on("data", this.handleMessage);
  }
  sendMessage(message) {
    if (!this.stream.writable) {
      console.error("window post message stream is not writable");
    }
    this.stream.write(message);
  }
}
let registeredWindowMessageProvider;
class WindowMessageProvider extends BaseProviderTransport {
  constructor(walletAppURL) {
    super();
    this.walletURL = void 0;
    this.walletWindow = void 0;
    this.register = () => {
      if (registeredWindowMessageProvider) {
        registeredWindowMessageProvider.unregister();
        registeredWindowMessageProvider = this;
      }
      window.addEventListener("message", this.onWindowEvent);
      registeredWindowMessageProvider = this;
      this.on("open", () => {
        const popup = this.walletWindow;
        const interval = setInterval(() => {
          if (popup && popup.closed) {
            clearInterval(interval);
            this.close();
          }
        }, 500);
      });
      this.on("close", () => {
        if (this.walletWindow) {
          this.walletWindow.close();
          this.walletWindow = null;
        }
      });
      this._registered = true;
    };
    this.unregister = () => {
      this._registered = false;
      this.closeWallet();
      if (registeredWindowMessageProvider === this) {
        registeredWindowMessageProvider = void 0;
      }
      window.removeEventListener("message", this.onWindowEvent);
      this.events.removeAllListeners();
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.walletWindow && this.isOpened()) {
        this.walletWindow.focus();
        return;
      }
      const walletURL = new URL(this.walletURL.href);
      const windowSessionParams = new WindowSessionParams();
      if (path && path !== "") {
        walletURL.pathname = path.toLowerCase();
      }
      this._init = InitState.NIL;
      this._sessionId = `${performance.now()}`;
      windowSessionParams.set("sid", this._sessionId);
      if (intent) {
        if (intent.type === "connect") {
          if (!intent.options) intent.options = {
            app: window.location.origin
          };
          if (!isBrowserExtension() && !isUnityPlugin() && intent.options) {
            intent.options.origin = window.location.origin;
          }
        }
        windowSessionParams.set("intent", base64EncodeObject(intent));
      }
      if (networkId) {
        windowSessionParams.set("net", `${networkId}`);
      }
      let windowSize;
      let windowPos;
      if (isBrowserExtension()) {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)];
      } else {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2), Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)];
      }
      const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes,width=${windowSize[0]},height=${windowSize[1]},left=${windowPos[0]},top=${windowPos[1]}`;
      walletURL.search = windowSessionParams.toString();
      this.walletWindow = window.open(walletURL.href, "sequence.app", windowFeatures);
    };
    this.onWindowEvent = (event) => {
      if (event.origin !== this.walletURL.origin) {
        return;
      }
      let message;
      try {
        message = JSON.parse(event.data, bigintReviver);
      } catch (err) {
        return;
      }
      if (!message) {
        throw new Error("ProviderMessage object is empty");
      }
      this.handleMessage(message);
    };
    this.walletURL = new URL(walletAppURL);
  }
  closeWallet() {
    var _this$walletWindow;
    this.close();
    (_this$walletWindow = this.walletWindow) == null || _this$walletWindow.close();
  }
  sendMessage(message) {
    if (!this.walletWindow) {
      logger.warn("WindowMessageProvider: sendMessage failed as walletWindow is unavailable");
      return;
    }
    const postedMessage = typeof message !== "string" ? JSON.stringify(message, bigintReplacer) : message;
    this.walletWindow.postMessage(postedMessage, this.walletURL.origin);
  }
}
class WindowMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler) {
    var _this;
    super(walletRequestHandler);
    _this = this;
    this.parentWindow = void 0;
    this._isPopup = false;
    this.onWindowEvent = async function(event) {
      if (!event.origin || event.origin === "") {
        return;
      }
      if (_this.appOrigin && event.origin !== _this.appOrigin) {
        return;
      }
      let request;
      try {
        request = JSON.parse(event.data, bigintReviver);
      } catch (err) {
        return;
      }
      logger.debug("RECEIVED MESSAGE", request);
      if (_this._init !== InitState.OK && _this.isValidInitAck(request)) {
        _this.appOrigin = event.origin;
      }
      if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {
        logger.error("impossible state, init.OK and appOrigin required");
        return;
      }
      _this.handleMessage(request);
    };
    this.getWindowTransportSession = (windowParams) => {
      const params = new WindowSessionParams(windowParams);
      return {
        sessionId: params.get("sid"),
        networkId: params.get("net"),
        intent: base64DecodeObject(params.get("intent"))
      };
    };
    this._init = InitState.NIL;
  }
  async register(windowHref) {
    const isPopup = parent.window.opener !== null;
    this._isPopup = isPopup;
    if (isPopup !== true) {
      return;
    }
    const {
      search: rawParams
    } = new URL(windowHref || window.location.href);
    let session = this.getWindowTransportSession(rawParams);
    const isNewWindowSession = !!session.sessionId;
    if (!isNewWindowSession) {
      session = await this.getCachedTransportSession();
    }
    if (!session) {
      logger.error("window session is undefined");
      return;
    }
    this.parentWindow = parent.window.opener;
    window.addEventListener("message", this.onWindowEvent, false);
    this._registered = true;
    this.open(session).then((opened) => {
      if (!opened) {
        var _session;
        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
        logger.error(err);
        this.notifyClose({
          message: err
        });
        window.close();
      }
    }).catch((e2) => {
      var _session2;
      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e2}`;
      logger.error(err);
      this.notifyClose({
        message: err
      });
      window.close();
    });
  }
  unregister() {
    window.removeEventListener("message", this.onWindowEvent);
    this._registered = false;
  }
  // postMessage sends message to the dapp window
  sendMessage(message) {
    const payload = JSON.stringify(message, bigintReplacer);
    if (message.type === EventType.INIT) {
      this.postMessage(payload, true);
    } else {
      this.postMessage(payload);
    }
  }
  get isPopup() {
    return this._isPopup;
  }
  postMessage(message, init2 = false) {
    if (init2 !== true && this._init !== InitState.OK) {
      logger.error("impossible state, should not be calling postMessage until inited");
      return;
    }
    if (init2) {
      this.parentWindow.postMessage(message, "*");
    } else {
      if (this.appOrigin && this.appOrigin.length > 4) {
        this.parentWindow.postMessage(message, this.appOrigin);
      } else {
        logger.error("unable to postMessage as parentOrigin is invalid");
      }
    }
  }
}
function isMuxTransportTemplate(obj) {
  return obj && typeof obj === "object" && (obj.windowTransport && typeof obj.windowTransport === "object" || obj.proxyTransport && typeof obj.proxyTransport === "object" || obj.extensionTransport && typeof obj.extensionTransport === "object" || obj.unrealTransport && typeof obj.unrealTransport === "object") && // One of the transports must be enabled
  (obj.windowTransport && obj.windowTransport.enabled || obj.proxyTransport && obj.proxyTransport.enabled || obj.extensionTransport && obj.extensionTransport.enabled || obj.unrealTransport && obj.unrealTransport.enabled);
}
class MuxMessageProvider {
  constructor(...messageProviders) {
    var _this = this;
    this.messageProviders = void 0;
    this.provider = void 0;
    this.register = () => {
      if (this.messageProviders.length === 1) {
        this.provider = this.messageProviders[0];
        this.provider.register();
        return;
      }
      this.messageProviders.forEach((m2) => {
        m2.register();
        m2.once("open", () => {
          if (!this.provider) {
            this.provider = m2;
            this.messageProviders.forEach((m22) => {
              if (this.provider !== m22) {
                m22.unregister();
              }
            });
          }
        });
      });
    };
    this.unregister = () => {
      this.messageProviders.forEach((m2) => m2.unregister());
      this.provider = void 0;
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.provider) {
        this.provider.openWallet(path, intent, networkId);
        return;
      }
      this.messageProviders.forEach((m2) => m2.openWallet(path, intent, networkId));
    };
    this.sendMessageRequest = async function(message) {
      if (_this.provider) {
        return _this.provider.sendMessageRequest(message);
      }
      throw new Error("impossible state, wallet must be opened first");
    };
    this.waitUntilOpened = async function() {
      if (_this.provider) {
        return _this.provider.waitUntilOpened();
      }
      return Promise.race(_this.messageProviders.map((p2) => p2.waitUntilOpened()));
    };
    this.waitUntilConnected = async function() {
      if (_this.provider) {
        return _this.provider.waitUntilConnected();
      }
      throw new Error("impossible state, wallet must be opened first");
    };
    this.messageProviders = messageProviders;
    this.provider = void 0;
  }
  static new(template) {
    var _template$windowTrans, _template$proxyTransp, _template$extensionTr, _template$unrealTrans;
    const muxMessageProvider = new MuxMessageProvider();
    if ((_template$windowTrans = template.windowTransport) != null && _template$windowTrans.enabled && typeof window === "object" && template.walletAppURL) {
      const windowMessageProvider = new WindowMessageProvider(template.walletAppURL);
      muxMessageProvider.add(windowMessageProvider);
    }
    if ((_template$proxyTransp = template.proxyTransport) != null && _template$proxyTransp.enabled) {
      const proxyMessageProvider = new ProxyMessageProvider(template.proxyTransport.appPort);
      muxMessageProvider.add(proxyMessageProvider);
    }
    if ((_template$extensionTr = template.extensionTransport) != null && _template$extensionTr.enabled) {
      const extensionMessageProvider = new ExtensionMessageProvider(template.extensionTransport.runtime);
      muxMessageProvider.add(extensionMessageProvider);
    }
    if ((_template$unrealTrans = template.unrealTransport) != null && _template$unrealTrans.enabled && template.windowTransport && template.walletAppURL) {
      const unrealMessageProvider = new UnrealMessageProvider(template.walletAppURL);
      muxMessageProvider.add(unrealMessageProvider);
    }
    muxMessageProvider.register();
    return muxMessageProvider;
  }
  add(...messageProviders) {
    this.messageProviders.push(...messageProviders);
  }
  closeWallet() {
    if (this.provider) {
      this.provider.closeWallet();
    }
  }
  isOpened() {
    if (this.provider) {
      return this.provider.isOpened();
    }
    return false;
  }
  isConnected() {
    if (this.provider) {
      return this.provider.isConnected();
    }
    return false;
  }
  on(event, fn) {
    if (this.provider) {
      this.provider.on(event, fn);
      return;
    }
    this.messageProviders.forEach((m2) => {
      m2.on(event, fn);
    });
  }
  once(event, fn) {
    if (this.provider) {
      this.provider.once(event, fn);
      return;
    }
    this.messageProviders.forEach((m2) => {
      m2.once(event, fn);
    });
  }
  emit(event, ...args) {
    if (this.provider) {
      return this.provider.emit(event, ...args);
    }
    for (let i = 0; i < this.messageProviders.length; i++) {
      this.messageProviders[i].emit(event, ...args);
    }
    return true;
  }
  request(request) {
    if (!this.provider) {
      throw new Error("impossible state, wallet must be opened first");
    }
    return this.provider.request(request);
  }
  sendMessage(message) {
    if (!message.idx || message.idx <= 0) {
      throw new Error("message idx is empty");
    }
    if (this.provider) {
      this.provider.sendMessage(message);
    } else {
      throw new Error("impossible state, wallet must be opened first");
    }
  }
  handleMessage(message) {
    if (this.provider) {
      this.provider.handleMessage(message);
      return;
    }
    throw new Error("impossible state, wallet must be opened first");
  }
}
function toExtended(transactions2) {
  if (transactions2.length === 0) {
    throw new Error("No transaction provided");
  }
  const [first, ...rest] = transactions2;
  return _extends$4({}, first, {
    auxiliary: rest
  });
}
function fromExtended(transaction2) {
  return [transaction2, ...transaction2.auxiliary || []];
}
const SIGNER_READY_TIMEOUT = 1e4;
class WalletRequestHandler {
  constructor(account2, prompter, networks2) {
    var _this = this;
    this.account = void 0;
    this.signerReadyCallbacks = [];
    this.prompter = void 0;
    this.networks = void 0;
    this._openIntent = void 0;
    this._connectOptions = void 0;
    this.events = new eventemitter2Exports.EventEmitter2();
    this.onConnectOptionsChange = void 0;
    this.promptConnect = async function(options) {
      if (!options && !_this._connectOptions) {
        throw new Error("prompter connect options are empty");
      }
      if (!_this.prompter) {
        return _this.connect(options);
      }
      const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch((_) => {
        return {
          connected: false
        };
      });
      const connectDetails = promptConnectDetails;
      if (connectDetails.connected && !connectDetails.session) {
        connectDetails.session = await _this.walletSession(options == null ? void 0 : options.networkId);
      }
      return promptConnectDetails;
    };
    this.isSignedIn = async function() {
      await _this.signerReady();
      return !!_this.account;
    };
    this.getAccount = async function() {
      await _this.signerReady();
      if (_this.account === void 0) {
        throw new Error("signerReady failed resolve");
      }
      return _this.account;
    };
    this.account = account2;
    this.prompter = prompter;
    this.networks = networks2;
  }
  defaultChainId() {
    var _this$prompter$getDef, _this$prompter;
    return (_this$prompter$getDef = (_this$prompter = this.prompter) == null ? void 0 : _this$prompter.getDefaultChainId()) != null ? _this$prompter$getDef : this.networks[0].chainId;
  }
  async signIn(account2, options = {}) {
    this.setAccount(account2);
    const {
      connect: connect2,
      defaultNetworkId
    } = options;
    if (connect2) {
      const connectOptions = this._connectOptions;
      let connectDetails;
      if (this.prompter !== null) {
        var _this$prompter2;
        connectDetails = await ((_this$prompter2 = this.prompter) == null ? void 0 : _this$prompter2.promptSignInConnect(connectOptions));
      } else {
        connectDetails = await this.connect(connectOptions);
      }
      this.notifyConnect(connectDetails);
      if (!connectOptions || connectOptions.keepWalletOpened !== true) {
        this.notifyClose();
      }
    }
    if (defaultNetworkId && this.defaultChainId() !== defaultNetworkId) {
      var _this$prompter3;
      await ((_this$prompter3 = this.prompter) == null ? void 0 : _this$prompter3.promptChangeNetwork(defaultNetworkId));
    }
  }
  signOut() {
    if (this.account) {
      this.notifyDisconnect();
    }
    this.setAccount(null);
  }
  signerReset() {
    this.account = void 0;
  }
  signerReady(timeout = SIGNER_READY_TIMEOUT) {
    return new Promise((resolve, reject) => {
      if (this.account !== void 0) {
        resolve();
      } else {
        setTimeout(() => {
          if (this.account === void 0) {
            this.signerReadyCallbacks = [];
            reject(`signerReady timed out`);
          }
        }, timeout);
        this.signerReadyCallbacks.push(resolve);
      }
    });
  }
  async connect(options) {
    var _ref, _options$networkId;
    if (!this.account) {
      return {
        connected: false,
        chainId: "0x0",
        error: "unable to connect without signed in account"
      };
    }
    const networkId = (_ref = (_options$networkId = options == null ? void 0 : options.networkId) != null ? _options$networkId : this.defaultChainId()) != null ? _ref : ChainId$1.MAINNET;
    const chainId = findSupportedNetwork(networkId).chainId;
    const connectDetails = {
      connected: true,
      chainId: toQuantity(chainId)
    };
    if (options && options.authorize) {
      const authOptions = {
        app: options.app,
        origin: options.origin,
        expiry: options.expiry,
        nonce: options.authorizeNonce
      };
      try {
        connectDetails.proof = await signAuthorization(this.account, chainId, authOptions);
      } catch (err) {
        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);
        return {
          connected: false,
          chainId: "0x0",
          error: `signAuthorization failed: ${err.message}`
        };
      }
    }
    connectDetails.session = this.walletSession(chainId);
    return connectDetails;
  }
  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler
  // (aka, the signer in this instance) and then responds with a wrapped response of
  // ProviderMessageResponse to be sent over the transport
  async sendMessageRequest(message) {
    var _message$clientVersio;
    const majorVersion = Number(((_message$clientVersio = message.clientVersion) == null ? void 0 : _message$clientVersio.split(".")[0]) || "0");
    const isJsonRpcResponse = majorVersion < 2;
    const jsonRpcResponse = {
      id: message.data.id,
      jsonrpc: "2.0",
      result: null,
      error: void 0
    };
    try {
      const result = await this.request({
        method: message.data.method,
        params: message.data.params,
        chainId: message.chainId
      });
      return _extends$4({}, message, {
        data: isJsonRpcResponse ? _extends$4({}, jsonRpcResponse, {
          result
        }) : result
      });
    } catch (error) {
      return _extends$4({}, message, {
        data: isJsonRpcResponse ? _extends$4({}, jsonRpcResponse, {
          error
        }) : {
          error
        }
      });
    }
  }
  async request(request) {
    await this.getAccount();
    try {
      var _this$account, _request$chainId;
      if ((!this.account || this.account === null) && !permittedJsonRpcMethods.includes(request.method)) {
        throw ErrSignedInRequired;
      }
      const account2 = this.account;
      if (!account2) {
        throw new Error("WalletRequestHandler: wallet account is not configured");
      }
      const provider2 = (_this$account = this.account) == null ? void 0 : _this$account.providerFor((_request$chainId = request.chainId) != null ? _request$chainId : this.defaultChainId());
      if (!provider2) {
        throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${request.chainId}`);
      }
      const jsonRpcProvider = isJsonRpcProvider(provider2) ? provider2 : void 0;
      switch (request.method) {
        case "net_version": {
          if (!jsonRpcProvider) {
            throw new Error(`Account provider doesn't support send method`);
          }
          return await jsonRpcProvider.send("net_version", []);
        }
        case "eth_chainId": {
          if (!jsonRpcProvider) {
            throw new Error(`Account provider doesn't support send method`);
          }
          return await jsonRpcProvider.send("eth_chainId", []);
        }
        case "eth_accounts": {
          return [account2.address];
        }
        case "eth_getBalance": {
          const [accountAddress, blockTag] = request.params;
          const walletBalance = await provider2.getBalance(accountAddress, blockTag);
          return toHexString(walletBalance);
        }
        case "sequence_sign":
        case "personal_sign":
        case "eth_sign": {
          let message;
          switch (request.method) {
            case "sequence_sign":
            case "personal_sign": {
              const [data, _address] = request.params;
              message = data;
              break;
            }
            case "eth_sign": {
              const [_address, data] = request.params;
              message = data;
              break;
            }
          }
          let sig = "";
          const prefixedMessage = prefixEIP191Message(message);
          const sequenceVerified = request.method === "sequence_sign";
          if (this.prompter === null) {
            var _request$chainId2;
            sig = await account2.signMessage(prefixedMessage, (_request$chainId2 = request.chainId) != null ? _request$chainId2 : this.defaultChainId(), sequenceVerified ? "eip6492" : "ignore");
          } else {
            sig = await this.prompter.promptSignMessage({
              chainId: request.chainId,
              message: getBytes(prefixedMessage),
              eip6492: sequenceVerified
            }, this.connectOptions);
          }
          if (sig && sig.length > 0) {
            return sig;
          } else {
            throw new Error("declined by user");
          }
        }
        case "sequence_signTypedData_v4":
        case "eth_signTypedData":
        case "eth_signTypedData_v4": {
          const [signingAddress, typedDataObject] = request.params;
          let typedData = void 0;
          if (typeof typedDataObject === "string") {
            try {
              typedData = JSON.parse(typedDataObject);
            } catch (e2) {
              console.warn("walletRequestHandler: error parsing typedData", e2);
            }
          } else {
            typedData = typedDataObject;
          }
          if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {
            throw new Error("invalid typedData object");
          }
          let sig = "";
          const sequenceVerified = request.method === "sequence_signTypedData_v4";
          if (this.prompter === null) {
            var _request$chainId3;
            sig = await account2.signTypedData(typedData.domain, typedData.types, typedData.message, (_request$chainId3 = request.chainId) != null ? _request$chainId3 : this.defaultChainId(), sequenceVerified ? "eip6492" : "ignore");
          } else {
            sig = await this.prompter.promptSignMessage({
              chainId: request.chainId,
              typedData,
              eip6492: sequenceVerified
            }, this.connectOptions);
          }
          if (sig && sig.length > 0) {
            return sig;
          } else {
            throw new Error("declined by user");
          }
        }
        case "eth_sendTransaction": {
          const transactionParams = fromExtended(request.params[0]).map((tx) => {
            if ("gas" in tx && tx.gasLimit === void 0) {
              tx.gasLimit = tx.gas;
              delete tx.gas;
            }
            return tx;
          });
          validateTransactionRequest(account2.address, transactionParams);
          let txnHash = "";
          if (this.prompter === null) {
            var _request$chainId4, _txnResponse$hash;
            const txnResponse = await account2.sendTransaction(transactionParams, (_request$chainId4 = request.chainId) != null ? _request$chainId4 : this.defaultChainId());
            txnHash = (_txnResponse$hash = txnResponse == null ? void 0 : txnResponse.hash) != null ? _txnResponse$hash : "";
          } else {
            txnHash = await this.prompter.promptSendTransaction(transactionParams, request.chainId, this.connectOptions);
          }
          if (txnHash) {
            return txnHash;
          } else {
            throw new Error("declined by user");
          }
        }
        case "eth_signTransaction": {
          const [transaction2] = request.params;
          const sender = getAddress(transaction2.from);
          if (sender !== account2.address) {
            throw new Error("sender address does not match wallet");
          }
          validateTransactionRequest(account2.address, transaction2);
          if (this.prompter === null) {
            var _request$chainId5;
            return await account2.signTransactions(transaction2, (_request$chainId5 = request.chainId) != null ? _request$chainId5 : this.defaultChainId());
          } else {
            return await this.prompter.promptSignTransaction(transaction2, request.chainId, this.connectOptions);
          }
        }
        case "eth_sendRawTransaction": {
          if (index$1$1.transaction.isSignedTransactionBundle(request.params[0])) {
            const txChainId = Number(request.params[0].chainId);
            const tx = await account2.relayer(txChainId).relay(request.params[0]);
            return tx.hash;
          } else {
            const tx = await provider2.broadcastTransaction(request.params[0]);
            return tx.hash;
          }
        }
        case "eth_getTransactionCount": {
          const address = getAddress(request.params[0]);
          const tag = request.params[1];
          const count2 = await provider2.getTransactionCount(address, tag);
          return toHexString(BigInt(count2));
        }
        case "eth_blockNumber": {
          return await provider2.getBlockNumber();
        }
        case "eth_getBlockByNumber": {
          return await provider2.getBlock(
            request.params[0]
            /* , jsonRpcRequest.params[1] */
          );
        }
        case "eth_getBlockByHash": {
          return await provider2.getBlock(
            request.params[0]
            /* , jsonRpcRequest.params[1] */
          );
        }
        case "eth_getTransactionByHash": {
          return await provider2.getTransaction(request.params[0]);
        }
        case "eth_call": {
          const [transactionObject, blockTag] = request.params;
          return await provider2.call(_extends$4({}, transactionObject, {
            blockTag
          }));
        }
        case "eth_getCode": {
          const [contractAddress, blockTag] = request.params;
          return await provider2.getCode(contractAddress, blockTag);
        }
        case "eth_estimateGas": {
          const [transactionObject] = request.params;
          return await provider2.estimateGas(transactionObject);
        }
        case "eth_gasPrice": {
          const feeData = await provider2.getFeeData();
          return feeData.gasPrice === null ? null : toHexString(feeData.gasPrice);
        }
        case "wallet_switchEthereumChain": {
          const [switchParams] = request.params;
          if (!switchParams.chainId || switchParams.chainId.length === 0) {
            throw new Error("invalid chainId");
          }
          const chainId = BigInt(switchParams.chainId);
          this.setDefaultChainId(Number(chainId));
          return null;
        }
        case "sequence_getWalletContext": {
          return account2.contexts;
        }
        case "sequence_getWalletConfig": {
          const [chainId] = request.params;
          if (chainId) {
            return [(await account2.status(chainId)).onChain.config];
          } else {
            return await Promise.all(account2.networks.map(async function(network2) {
              const status = await account2.status(network2.chainId);
              return status.onChain.config;
            }));
          }
        }
        case "sequence_getWalletState": {
          const [chainId] = request.params;
          if (chainId) {
            return [getLegacyWalletState(chainId, await account2.status(chainId))];
          } else {
            return await Promise.all(account2.networks.map(async function(network2) {
              const status = await account2.status(network2.chainId);
              return getLegacyWalletState(network2.chainId, status);
            }));
          }
        }
        case "sequence_getNetworks": {
          return await this.getNetworks(true);
        }
        case "sequence_isSequence": {
          return true;
        }
        case "sequence_updateConfig": {
          throw new Error("sequence_updateConfig method is not allowed from a dapp");
        }
        case "sequence_publishConfig": {
          throw new Error("sequence_publishConfig method is not allowed from a dapp");
        }
        case "sequence_gasRefundOptions": {
          break;
        }
        case "sequence_getNonce": {
          break;
        }
        case "sequence_relay": {
          break;
        }
        case "sequence_setDefaultNetwork": {
          const [defaultChainId] = request.params;
          if (!defaultChainId) {
            throw new Error("invalid request, method argument defaultChainId cannot be empty");
          }
          this.setDefaultChainId(defaultChainId);
          return await this.getNetworks(true);
        }
        default: {
          if (!jsonRpcProvider) {
            throw new Error(`Account provider doesn't support send method`);
          }
          return await jsonRpcProvider.send(request.method, request.params);
        }
      }
    } catch (err) {
      logger.error(err);
      throw {
        message: typeof err == "string" ? err : (err == null ? void 0 : err.message) || "unkown error",
        code: 4001
      };
    }
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
  async getAddress() {
    var _this$account$address, _this$account2;
    return (_this$account$address = (_this$account2 = this.account) == null ? void 0 : _this$account2.address) != null ? _this$account$address : "";
  }
  get openIntent() {
    return this._openIntent;
  }
  setOpenIntent(intent) {
    this._openIntent = intent;
  }
  get connectOptions() {
    return this._connectOptions;
  }
  setConnectOptions(options) {
    var _this$onConnectOption;
    this._connectOptions = options;
    (_this$onConnectOption = this.onConnectOptionsChange) == null || _this$onConnectOption.call(this, options);
  }
  async setDefaultChainId(chainId) {
    var _this$prompter4;
    await ((_this$prompter4 = this.prompter) == null ? void 0 : _this$prompter4.promptChangeNetwork(chainId));
    return this.defaultChainId();
  }
  async getNetworks(jsonRpcResponse) {
    if (!this.account) {
      logger.warn("signer not set: getNetworks is returning an empty list");
      return [];
    }
    if (jsonRpcResponse) {
      return this.account.networks.map((n2) => {
        const network2 = _extends$4({}, n2);
        network2.provider = void 0;
        network2.relayer = void 0;
        return network2;
      });
    } else {
      return this.account.networks;
    }
  }
  walletSession(networkId) {
    if (!this.account) {
      return void 0;
    }
    const session = {
      walletContext: this.account.contexts,
      accountAddress: this.account.address,
      // The dapp shouldn't access the relayer directly, and the provider (as an object) is not serializable.
      networks: this.account.networks.map((n2) => _extends$4({}, n2, {
        provider: void 0,
        relayer: void 0
      }))
    };
    if (networkId) {
      const network2 = findNetworkConfig(session.networks, networkId);
      if (network2) {
        var _session$networks;
        (_session$networks = session.networks) == null || _session$networks.forEach((n2) => delete n2.isDefaultChain);
        network2.isDefaultChain = true;
      }
    }
    return session;
  }
  notifyConnect(connectDetails, origin) {
    var _connectDetails$sessi;
    console.log("emit connect", connectDetails);
    this.events.emit("connect", connectDetails);
    if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
      var _connectDetails$sessi2;
      this.events.emit("accountsChanged", [(_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress], origin);
    }
  }
  notifyDisconnect(origin) {
    this.events.emit("accountsChanged", [], origin);
    this.events.emit("disconnect", void 0, origin);
  }
  notifyChainChanged(chainId, origin) {
    this.events.emit("chainChanged", toQuantity(chainId), origin);
  }
  async notifyNetworks(networks2) {
    const n2 = networks2 || await this.getNetworks(true);
    this.events.emit("networks", n2);
    if (n2.length > 0) {
      const defaultNetwork = n2.find((network2) => network2.chainId === this.defaultChainId());
      if (defaultNetwork) {
        this.events.emit("chainChanged", toQuantity(defaultNetwork.chainId));
      }
    } else {
      this.events.emit("chainChanged", "0x0");
    }
  }
  async notifyWalletContext() {
    if (!this.account) {
      logger.warn("signer not set: skipping to notify wallet context");
      return;
    }
    const walletContext = this.account.contexts;
    this.events.emit("walletContext", walletContext);
  }
  notifyClose(error) {
    this.events.emit("close", error);
  }
  setAccount(account2) {
    this.account = account2;
    if (account2 !== void 0) {
      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {
        this.signerReadyCallbacks[i]();
      }
      this.signerReadyCallbacks = [];
    }
  }
  async handleConfirmWalletDeployPrompt(prompter, account2, sequenceVerified, chainId) {
    if (!chainId) {
      return true;
    }
    const skipsDeploy = (status2) => {
      return status2.canOnchainValidate || status2.original.version === 2 && sequenceVerified;
    };
    const status = await account2.status(chainId);
    if (skipsDeploy(status)) {
      return true;
    }
    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions);
    if (promptResult) {
      const status2 = await account2.status(chainId);
      if (skipsDeploy(status2)) {
        return true;
      } else {
        logger.error("WalletRequestHandler: result for promptConfirmWalletDeploy is not correct");
        return false;
      }
    }
    return false;
  }
}
function getLegacyWalletState(chainId, status) {
  return {
    context: status.original.context,
    config: status.onChain.config,
    address: index$1$1.context.addressOf(status.original.context, status.original.imageHash),
    chainId,
    deployed: status.onChain.deployed,
    imageHash: status.imageHash,
    lastImageHash: status.onChain.imageHash,
    published: true,
    status
  };
}
const permittedJsonRpcMethods = ["net_version", "eth_chainId", "eth_getBalance", "eth_getTransactionCount", "eth_blockNumber", "eth_getBlockByNumber", "eth_getBlockByHash", "eth_getTransactionByHash", "eth_getCode", "eth_estimateGas", "eth_gasPrice", "sequence_getWalletContext", "sequence_getNetworks", "sequence_setDefaultNetwork"];
function isJsonRpcProvider(provider2) {
  return provider2 && typeof provider2 === "object" && typeof provider2.send === "function" && typeof provider2.getNetwork === "function";
}
function _objectWithoutPropertiesLoose$3(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (e2.includes(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
class SequenceSigner {
  get utils() {
    return this.provider.utils;
  }
  constructor(client2, provider2) {
    this.client = client2;
    this.provider = provider2;
    this.singleNetworkSigners = {};
    this._isSequenceSigner = true;
  }
  async getAddress() {
    return this.client.getAddress();
  }
  // This method shouldn't be used directly
  // it exists to maintain compatibility with ethers.Signer
  connect(provider2) {
    if (!SequenceProvider.is(provider2)) {
      throw new Error("SequenceSigner can only be connected to a SequenceProvider");
    }
    return new SequenceSigner(this.client, provider2);
  }
  getSigner(chainId) {
    if (!chainId) {
      return this;
    }
    const useChainId2 = this.provider.toChainId(chainId);
    if (!this.singleNetworkSigners[useChainId2]) {
      this.singleNetworkSigners[useChainId2] = new SingleNetworkSequenceSigner(this.client, this.provider, useChainId2);
    }
    return this.singleNetworkSigners[useChainId2];
  }
  /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */
  useChainId(chainId) {
    return this.provider.toChainId(chainId) || this.client.getChainId();
  }
  async signMessage(message, options) {
    const {
      eip6492 = true
    } = options || {};
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    return this.client.signMessage(message, {
      eip6492,
      chainId
    });
  }
  async signTypedData(domain2, types2, message, options) {
    const {
      eip6492 = true
    } = options || {};
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    return this.client.signTypedData({
      domain: domain2,
      types: types2,
      message
    }, {
      eip6492,
      chainId
    });
  }
  getProvider(chainId) {
    return this.provider.getProvider(chainId);
  }
  async sendTransaction(transaction2, options) {
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    const resolved = await resolveArrayProperties(transaction2);
    const txHash = await this.client.sendTransaction(resolved, {
      chainId
    });
    const provider2 = this.getProvider(chainId);
    try {
      const result = await new Promise((resolve) => {
        const check = async function check2() {
          const tx = await provider2.getTransaction(txHash);
          if (tx !== null) {
            return resolve(tx);
          }
          await provider2.once("block", check2);
        };
        check();
      });
      return result;
    } catch (err) {
      err.transactionHash = txHash;
      throw err;
    }
  }
  async getWalletConfig(chainId) {
    const useChainId2 = this.useChainId(chainId);
    return this.client.getOnchainWalletConfig({
      chainId: useChainId2
    });
  }
  getNetworks() {
    return this.client.getNetworks();
  }
  async getBalance(blockTag, optionals) {
    const provider2 = this.getProvider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBalance(this.getAddress(), blockTag);
  }
  async estimateGas(transaction2, optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).estimateGas(transaction2);
  }
  async call(transaction2, optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).call(transaction2);
  }
  getChainId() {
    return Promise.resolve(this.client.getChainId());
  }
  async getFeeData(optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).getFeeData();
  }
  async resolveName(name2) {
    const res = await this.provider.resolveName(name2);
    if (res === null) {
      throw new Error(`ENS name not found: ${name2}`);
    }
    return res;
  }
  _checkProvider(_operation) {
  }
  getNonce(_blockTag) {
    throw new Error("SequenceSigner does not support getNonce");
  }
  populateCall(_transaction) {
    throw new Error("SequenceSigner does not support populateCall");
  }
  populateTransaction(_transaction) {
    throw new Error("SequenceSigner does not support populateTransaction");
  }
  checkTransaction(_transaction) {
    throw new Error("SequenceSigner does not support checkTransaction");
  }
  getTransactionCount(_blockTag) {
    throw new Error("SequenceSigner does not support getTransactionCount");
  }
  signTransaction(_transaction) {
    throw new Error("SequenceWallet does not support signTransaction, use sendTransaction instead.");
  }
  static is(cand) {
    return cand && typeof cand === "object" && cand._isSequenceSigner === true;
  }
}
class SingleNetworkSequenceSigner extends SequenceSigner {
  constructor(client2, provider2, chainId) {
    super(client2, provider2.getProvider(chainId));
    this.chainId = chainId;
    this._isSingleNetworkSequenceSigner = true;
  }
  _useChainId(chainId) {
    const provided = this.provider.toChainId(chainId);
    if (provided && provided !== this.chainId) {
      throw new Error(`This signer only supports the network ${this.chainId}, but ${provided} was requested.`);
    }
    return provided || this.provider.toChainId(this.chainId);
  }
  useChainId(chainId) {
    return this._useChainId(chainId);
  }
  getChainId() {
    return Promise.resolve(this.provider.toChainId(this.chainId));
  }
  /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */
  getProvider(chainId) {
    return super.getProvider(this._useChainId(chainId));
  }
  getSigner(chainId) {
    if (this._useChainId(chainId) !== this.chainId) {
      throw new Error(`Unreachable code`);
    }
    return this;
  }
  static is(cand) {
    return cand && typeof cand === "object" && cand._isSingleNetworkSequenceSigner === true;
  }
}
class WalletUtils {
  constructor(signer2) {
    this.signer = signer2;
    if (SingleNetworkSequenceSigner.is(signer2)) {
      throw new Error("WalletUtils does not support SingleNetworkSequenceSigner");
    }
  }
  // Sign message on a specified chain, or DefaultChain by default
  signMessage(message, chainId, eip6492) {
    return this.signer.signMessage(message, {
      chainId,
      eip6492
    });
  }
  // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default
  signTypedData(domain2, types2, message, chainId, eip6492) {
    return this.signer.signTypedData(domain2, types2, message, {
      chainId,
      eip6492
    });
  }
  // Verify signature of a digest, one of a message, typedData or other
  async isValidSignature(address, digest, signature2, chainId) {
    return isValidSignature(address, digest, signature2, this.signer.getProvider(chainId));
  }
  // Verify message signature
  async isValidMessageSignature(address, message, signature2, chainId) {
    const provider2 = this.signer.getProvider(chainId);
    const prefixed = prefixEIP191Message(message);
    const digest = encodeMessageDigest(prefixed);
    return isValidSignature(address, digest, signature2, provider2);
  }
  // Verify typedData signature
  isValidTypedDataSignature(address, typedData, signature2, chainId) {
    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature2, chainId);
  }
  // sendTransaction()
  // sendTransactions()
  // sendETH()
  // sendToken()
  // sendCoin() -- sugar for sendToken()
  // sendCollectible() -- sugar for sendToken()
  // callContract()
  // transactionHistory()
  // getReceipt()
  // getLogs()
  // // ..
  // validateSignature()
  // recoverWalletConfig()
  // recoverAddress()
}
const _excluded$5 = ["method"];
const EIP1193EventTypes = ["connect", "disconnect", "chainChanged", "accountsChanged"];
class SequenceProvider extends AbstractProvider {
  constructor(client2, providerFor, networks2 = allNetworks$1, options) {
    super(client2.getChainId(), options);
    this.client = client2;
    this.providerFor = providerFor;
    this.networks = networks2;
    this.options = options;
    this.singleNetworkProviders = {};
    this._isSequenceProvider = true;
    this.utils = void 0;
    this.signer = void 0;
    this.eip1193EventListeners = /* @__PURE__ */ new Map();
    client2.onConnect((details) => {
      var _this$eip1193EventLis;
      (_this$eip1193EventLis = this.eip1193EventListeners.get("connect")) == null || _this$eip1193EventLis.forEach((listener) => listener(details));
    });
    client2.onDisconnect((error) => {
      var _this$eip1193EventLis2;
      (_this$eip1193EventLis2 = this.eip1193EventListeners.get("disconnect")) == null || _this$eip1193EventLis2.forEach((listener) => listener(error));
    });
    client2.onDefaultChainIdChanged((chainId) => {
      var _this$eip1193EventLis3;
      (_this$eip1193EventLis3 = this.eip1193EventListeners.get("chainChanged")) == null || _this$eip1193EventLis3.forEach((listener) => listener(chainId));
    });
    client2.onAccountsChanged((accounts) => {
      var _this$eip1193EventLis4;
      (_this$eip1193EventLis4 = this.eip1193EventListeners.get("accountsChanged")) == null || _this$eip1193EventLis4.forEach((listener) => listener(accounts));
    });
    this.signer = new SequenceSigner(this.client, this);
    this.utils = new WalletUtils(this.signer);
  }
  async on(event, listener) {
    if (EIP1193EventTypes.includes(event)) {
      const listeners = this.eip1193EventListeners.get(event) || /* @__PURE__ */ new Set();
      listeners.add(listener);
      this.eip1193EventListeners.set(event, listeners);
      return this;
    }
    return super.on(event, listener);
  }
  async off(event, listener) {
    if (EIP1193EventTypes.includes(event)) {
      const listeners = this.eip1193EventListeners.get(event);
      if (listeners) {
        if (listener) {
          listeners.delete(listener);
        } else {
          listeners.clear();
        }
      }
      return this;
    }
    return super.off(event, listener);
  }
  getSigner(chainId) {
    return this.signer.getSigner(chainId);
  }
  connect(options) {
    return this.client.connect(options);
  }
  disconnect() {
    return this.client.disconnect();
  }
  isConnected() {
    return this.client.isConnected();
  }
  getSession() {
    return this.client.getSession();
  }
  listAccounts() {
    return [this.client.getAddress()];
  }
  // @deprecated use getSigner() instead
  getAddress() {
    return this.client.getAddress();
  }
  getNetworks() {
    return this.client.getNetworks();
  }
  getChainId() {
    return this.client.getChainId();
  }
  setDefaultChainId(chainId) {
    return this.client.setDefaultChainId(this.toChainId(chainId));
  }
  isOpened() {
    return this.client.isOpened();
  }
  closeWallet() {
    return this.client.closeWallet();
  }
  getWalletContext() {
    return this.client.getWalletContext();
  }
  // @deprecated use getSigner() instead
  async getWalletConfig(chainId) {
    const useChainId2 = await this.useChainId(chainId);
    return this.client.getOnchainWalletConfig({
      chainId: useChainId2
    });
  }
  authorize(options) {
    return this.client.connect(_extends$4({}, options, {
      authorize: true
    }));
  }
  async openWallet(path, intent) {
    await this.client.openWallet(path, intent);
    return true;
  }
  toChainId(chainId) {
    if (chainId === void 0) {
      return void 0;
    }
    const resolved = findNetworkConfig(this.networks, chainId);
    if (!resolved) {
      throw new Error(`Unsupported network ${chainId}`);
    }
    return resolved.chainId;
  }
  /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */
  async useChainId(chainId) {
    return this.toChainId(chainId) || this.client.getChainId();
  }
  /**
   *  This generates a provider that ONLY works for the given chainId.
   *  the generated provider can't switch networks, and can't handle requests
   *  for other networks.
   */
  getProvider(chainId) {
    if (!chainId) {
      return this;
    }
    const useChainId2 = this.toChainId(chainId);
    if (!this.singleNetworkProviders[useChainId2]) {
      this.singleNetworkProviders[useChainId2] = new SingleNetworkSequenceProvider(this.client, this.providerFor, useChainId2, this.options);
    }
    return this.singleNetworkProviders[useChainId2];
  }
  /**
   *  This returns a subprovider, this is a regular non-sequence provider that
   *  can be used to fulfill read only requests on a given network.
   */
  async _getSubprovider(chainId) {
    const useChainId2 = await this.useChainId(chainId);
    const provider2 = this.providerFor(useChainId2);
    if (!provider2) {
      throw new Error(`Unsupported network ${useChainId2}`);
    }
    return provider2;
  }
  async _perform(req) {
    var _provider$getRpcReque;
    const {
      method
    } = req, args = _objectWithoutPropertiesLoose$3(req, _excluded$5);
    const provider2 = await this._getSubprovider();
    const prepared = (_provider$getRpcReque = provider2.getRpcRequest(req)) != null ? _provider$getRpcReque : {
      method,
      args: Object.values(args)
    };
    if (!prepared) {
      throw new Error(`Unsupported method ${req.method}`);
    }
    return provider2.send(prepared.method, prepared.args);
  }
  async perform(method, params) {
    if (method === "eth_chainId") {
      return toQuantity(await this.useChainId());
    }
    if (method === "eth_accounts") {
      return [this.client.getAddress()];
    }
    if (method === "wallet_switchEthereumChain") {
      const args = params[0];
      const chainId = normalizeChainId$2(args);
      return this.setDefaultChainId(chainId);
    }
    if (method === "eth_sendTransaction" || method === "eth_sign" || method === "eth_signTypedData" || method === "eth_signTypedData_v4" || method === "personal_sign" || // These methods will use EIP-6492
    // but this is handled directly by the wallet
    method === "sequence_sign" || method === "sequence_signTypedData_v4") {
      return this.client.request({
        method,
        params,
        chainId: this.getChainId()
      });
    }
    return this._perform(_extends$4({
      method
    }, params));
  }
  send(method, params) {
    return this.perform(method, params);
  }
  request(request) {
    return this.perform(request.method, request.params);
  }
  async _detectNetwork() {
    const chainId = this.client.getChainId();
    const found = findNetworkConfig(this.networks, chainId);
    if (!found) {
      throw new Error(`Unknown network ${chainId}`);
    }
    const network2 = new Network(found.name, found.chainId);
    return network2;
  }
  async detectNetwork() {
    return this._detectNetwork();
  }
  // Override most of the methods, so we add support for an optional chainId
  // argument, which is used to select the provider to use.
  //
  // NOTICE: We could use generics to avoid repeating the same code
  // but this would make the code harder to read, and it's not worth it
  // since we only have a few methods to override.
  async waitForTransaction(transactionHash, confirmations, timeout, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.waitForTransaction(transactionHash, confirmations, timeout);
  }
  async getBlockNumber(optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBlockNumber();
  }
  async getFeeData(optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getFeeData();
  }
  async getBalance(addressOrName, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBalance(addressOrName, blockTag);
  }
  async getTransactionCount(addressOrName, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getTransactionCount(addressOrName, blockTag);
  }
  async getCode(addressOrName, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getCode(addressOrName, blockTag);
  }
  async getStorage(addressOrName, position, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getStorage(addressOrName, position, blockTag);
  }
  async call(transaction2, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.call(transaction2);
  }
  async estimateGas(transaction2, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.estimateGas(transaction2);
  }
  async getBlock(blockHashOrBlockTag, prefetchTxs, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBlock(blockHashOrBlockTag, prefetchTxs);
  }
  async getTransaction(transactionHash, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getTransaction(transactionHash);
  }
  async getLogs(filter2, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getLogs(filter2);
  }
  // ENS methods
  async supportsENS() {
    const networks2 = await this.getNetworks();
    return networks2.some((n2) => n2.chainId === 1);
  }
  async getResolver(name2) {
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.getResolver(name2);
  }
  async resolveName(name2) {
    if (isAddress(name2)) {
      return name2;
    }
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.resolveName(name2);
  }
  async lookupAddress(address) {
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.lookupAddress(address);
  }
  async getAvatar(nameOrAddress) {
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.getAvatar(nameOrAddress);
  }
}
SequenceProvider.is = (provider2) => {
  return provider2 && typeof provider2 === "object" && provider2._isSequenceProvider === true;
};
function normalizeChainId$2(chainId) {
  if (typeof chainId === "object") return normalizeChainId$2(chainId.chainId);
  return Number(chainId);
}
class SingleNetworkSequenceProvider extends SequenceProvider {
  constructor(client2, providerFor, chainId, options) {
    super(client2, providerFor, void 0, options);
    this.chainId = chainId;
    this._isSingleNetworkSequenceProvider = true;
  }
  _useChainId(chainId) {
    const provided = this.toChainId(chainId);
    if (provided && provided !== this.chainId) {
      throw new Error(`This provider only supports the network ${this.chainId}, but ${provided} was requested.`);
    }
    return provided || super.toChainId(this.chainId);
  }
  useChainId(chainId) {
    return Promise.resolve(this._useChainId(chainId));
  }
  getChainId() {
    return super.toChainId(this.chainId);
  }
  async getNetwork() {
    const networks2 = await this.client.getNetworks();
    const found = findNetworkConfig(networks2, this.chainId);
    if (!found) {
      throw new Error(`Unsupported network ${this.chainId}`);
    }
    return new Network(found.name, found.chainId);
  }
  /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */
  getProvider(chainId) {
    if (this._useChainId(chainId) !== this.chainId) {
      throw new Error(`Unreachable code`);
    }
    return this;
  }
  getSigner(chainId) {
    return super.getSigner(this._useChainId(chainId));
  }
  setDefaultChainId(_chainId4) {
    throw new Error(`This provider only supports the network ${this.chainId}; use the parent provider to switch networks.`);
  }
  static is(cand) {
    return cand && typeof cand === "object" && cand._isSingleNetworkSequenceProvider === true;
  }
}
class Analytics extends Databeat2 {
}
const setupAnalytics = (projectAccessKey2, server) => {
  if (!server) {
    server = "https://nodes.sequence.app";
  }
  const noop2 = !projectAccessKey2;
  const auth2 = {};
  if (projectAccessKey2) {
    auth2.headers = {
      "X-Access-Key": projectAccessKey2
    };
  }
  return new Analytics(server, auth2, {
    noop: noop2,
    defaultEnabled: true,
    privacy: {
      userIdHash: true,
      userAgentSalt: false
    },
    initProps: () => {
      if (!isBrowser()) {
        return {};
      } else {
        return {
          origin: window.location.origin
        };
      }
    }
  });
};
class SequenceClientSession {
  constructor(store) {
    this.store = store;
  }
  connectedSession() {
    const session = this.getSession();
    if (session && session.accountAddress && session.walletContext && session.networks) {
      return {
        accountAddress: session.accountAddress,
        walletContext: session.walletContext,
        networks: session.networks
      };
    }
    throw new Error("Sequence session not connected");
  }
  hasSession() {
    var _this$getSession;
    return ((_this$getSession = this.getSession()) == null ? void 0 : _this$getSession.accountAddress) !== void 0;
  }
  setSession(session) {
    return this.store.setItem(SequenceClientSession.SESSION_LOCALSTORE_KEY, JSON.stringify(session));
  }
  getSession() {
    const session = this.store.getItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
    if (session) {
      return JSON.parse(session);
    }
    return void 0;
  }
  async clearSession() {
    return this.store.removeItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
  }
}
SequenceClientSession.SESSION_LOCALSTORE_KEY = "@sequence.session";
class DefaultChainIdTracker {
  constructor(store, startingChainId = 1) {
    this.store = store;
    this.startingChainId = startingChainId;
    this.callbacks = [];
    store.onItemChange(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, (value) => {
      if (value) {
        const chainId = parseInt(value);
        this.callbacks.forEach((cb2) => cb2(chainId));
      }
    });
  }
  onDefaultChainIdChanged(callback) {
    this.callbacks.push(callback);
    return () => {
      this.callbacks = this.callbacks.filter((cb2) => cb2 !== callback);
    };
  }
  setDefaultChainId(chainId) {
    if (chainId !== this.getDefaultChainId()) {
      this.store.setItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, chainId.toString());
    }
  }
  getDefaultChainId() {
    const read = this.store.getItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY);
    if (!read || read.length === 0) {
      return this.startingChainId;
    }
    return parseInt(read);
  }
}
DefaultChainIdTracker.SESSION_CHAIN_ID_KEY = "@sequence.session.defaultChainId";
class SequenceClient {
  constructor(transport, store, options) {
    var _options$defaultEIP, _this$session$getSess;
    this.session = void 0;
    this.defaultChainId = void 0;
    this.callbacks = {};
    this.transport = void 0;
    this.defaultEIP6492 = void 0;
    this.projectAccessKey = void 0;
    this.analytics = void 0;
    if (isMuxTransportTemplate(transport)) {
      this.transport = MuxMessageProvider.new(transport);
    } else if (isProviderTransport(transport)) {
      this.transport = transport;
    } else {
      throw new Error("Invalid transport");
    }
    const defaultChainId = options == null ? void 0 : options.defaultChainId;
    this.defaultEIP6492 = (_options$defaultEIP = options == null ? void 0 : options.defaultEIP6492) != null ? _options$defaultEIP : false;
    this.session = new SequenceClientSession(store);
    this.defaultChainId = new DefaultChainIdTracker(store, defaultChainId);
    this.transport.on("accountsChanged", (accounts) => {
      var _this$callbacks$accou;
      if (accounts.length > 1) {
        console.warn("SequenceClient: wallet-webapp returned more than one account");
      }
      (_this$callbacks$accou = this.callbacks.accountsChanged) == null || _this$callbacks$accou.forEach((cb2) => cb2(accounts));
    });
    this.transport.on("connect", (response) => {
      var _this$callbacks$conne;
      const chainIdHex = toQuantity(this.getChainId());
      (_this$callbacks$conne = this.callbacks.connect) == null || _this$callbacks$conne.forEach((cb2) => cb2(_extends$4({}, response, {
        // Ignore the full connect response
        // use the chainId defined locally
        chainId: chainIdHex
      })));
    });
    this.transport.on("disconnect", (error, origin) => {
      var _this$callbacks$disco;
      (_this$callbacks$disco = this.callbacks.disconnect) == null || _this$callbacks$disco.forEach((cb2) => cb2(error, origin));
    });
    this.transport.on("networks", (networks2) => {
      var _this$callbacks$netwo;
      (_this$callbacks$netwo = this.callbacks.networks) == null || _this$callbacks$netwo.forEach((cb2) => cb2(networks2));
    });
    this.transport.on("walletContext", (context2) => {
      var _this$callbacks$walle;
      (_this$callbacks$walle = this.callbacks.walletContext) == null || _this$callbacks$walle.forEach((cb2) => cb2(context2));
    });
    this.transport.on("open", (info) => {
      var _this$callbacks$open;
      (_this$callbacks$open = this.callbacks.open) == null || _this$callbacks$open.forEach((cb2) => cb2(info));
    });
    this.transport.on("close", () => {
      var _this$callbacks$close;
      (_this$callbacks$close = this.callbacks.close) == null || _this$callbacks$close.forEach((cb2) => cb2());
    });
    this.transport.on("chainChanged", (chainIdHex, origin) => {
      var _this$callbacks$chain;
      (_this$callbacks$chain = this.callbacks.chainChanged) == null || _this$callbacks$chain.forEach((cb2) => cb2(chainIdHex, origin));
    });
    this.defaultChainId.onDefaultChainIdChanged((chainId) => {
      var _this$callbacks$chain2;
      const chainIdHex = toQuantity(chainId);
      (_this$callbacks$chain2 = this.callbacks.chainChanged) == null || _this$callbacks$chain2.forEach((cb2) => cb2(chainIdHex));
    });
    if (options != null && options.projectAccessKey) {
      this.projectAccessKey = options.projectAccessKey;
    }
    if (this.projectAccessKey && options != null && options.analytics) {
      this.analytics = setupAnalytics(this.projectAccessKey);
    }
    if ((_this$session$getSess = this.session.getSession()) != null && _this$session$getSess.accountAddress) {
      var _this$analytics, _this$session$getSess2;
      (_this$analytics = this.analytics) == null || _this$analytics.identify((_this$session$getSess2 = this.session.getSession()) == null || (_this$session$getSess2 = _this$session$getSess2.accountAddress) == null ? void 0 : _this$session$getSess2.toLowerCase());
    }
  }
  // Callbacks
  registerCallback(eventName, callback) {
    if (!this.callbacks[eventName]) {
      this.callbacks[eventName] = [];
    }
    this.callbacks[eventName].push(callback);
    return () => {
      this.callbacks[eventName] = this.callbacks[eventName].filter((c2) => c2 !== callback);
    };
  }
  // Individual callbacks lead to more idiomatic code
  onOpen(callback) {
    return this.registerCallback("open", callback);
  }
  onClose(callback) {
    return this.registerCallback("close", callback);
  }
  onConnect(callback) {
    return this.registerCallback("connect", callback);
  }
  onDisconnect(callback) {
    return this.registerCallback("disconnect", callback);
  }
  onNetworks(callback) {
    return this.registerCallback("networks", callback);
  }
  onAccountsChanged(callback) {
    return this.registerCallback("accountsChanged", callback);
  }
  // @deprecated
  onWalletContext(callback) {
    return this.registerCallback("walletContext", callback);
  }
  onChainChanged(callback) {
    return this.registerCallback("chainChanged", callback);
  }
  onDefaultChainIdChanged(callback) {
    return this.registerCallback("chainChanged", callback);
  }
  getChainId() {
    return this.defaultChainId.getDefaultChainId();
  }
  setDefaultChainId(chainId) {
    return this.defaultChainId.setDefaultChainId(chainId);
  }
  // Proxy transport methods
  async openWallet(path, intent) {
    this.transport.openWallet(path, intent, this.getChainId());
    await this.transport.waitUntilOpened();
    return this.isOpened();
  }
  closeWallet() {
    return this.transport.closeWallet();
  }
  isOpened() {
    return this.transport.isOpened();
  }
  isConnected() {
    return this.session.hasSession();
  }
  getSession() {
    return this.session.getSession();
  }
  // Basic API
  getAddress() {
    const session = this.session.connectedSession();
    return session.accountAddress;
  }
  async connect(options) {
    if ((options == null ? void 0 : options.authorizeVersion) === void 0) {
      options.authorizeVersion = 2;
    }
    if ((options == null ? void 0 : options.refresh) === true) {
      this.disconnect();
    }
    options.projectAccessKey = this.projectAccessKey;
    if (options) {
      if (options.authorize) {
        if (!options.app) {
          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);
        }
        if (options.authorizeVersion === void 0) {
          options.authorizeVersion = 2;
        }
      }
    }
    await this.openWallet(void 0, {
      type: "connect",
      options: _extends$4({}, options, {
        networkId: this.getChainId(),
        clientVersion: VERSION$1
      })
    });
    const connectDetails = await this.transport.waitUntilConnected().catch((error) => {
      if (error instanceof Error) {
        return {
          connected: false,
          error: error.message
        };
      } else {
        return {
          connected: false,
          error: JSON.stringify(error)
        };
      }
    });
    if (connectDetails.chainId) {
      connectDetails.chainId = BigInt(connectDetails.chainId).toString();
    }
    if (connectDetails.connected) {
      var _connectDetails$sessi;
      if (!connectDetails.session) {
        throw new Error("impossible state, connect response is missing session");
      }
      this.session.setSession(connectDetails.session);
      if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
        var _this$analytics2;
        (_this$analytics2 = this.analytics) == null || _this$analytics2.identify(connectDetails.session.accountAddress.toLowerCase());
      }
    }
    return connectDetails;
  }
  disconnect() {
    var _this$analytics3;
    if (this.isOpened()) {
      this.closeWallet();
    }
    (_this$analytics3 = this.analytics) == null || _this$analytics3.reset();
    return this.session.clearSession();
  }
  // Higher level API
  async request(request) {
    request.method = this.mapSignMethod(request.method);
    const result = await this.transport.request(request);
    return unwrapJsonRpcResponse(result);
  }
  async getNetworks(pull) {
    const connectedSession = this.session.connectedSession();
    if (pull) {
      connectedSession.networks = await this.request({
        method: "sequence_getNetworks"
      });
      this.session.setSession(connectedSession);
    }
    return connectedSession.networks;
  }
  // NOTICE: `legacy_sign` will get overriden by `send`
  // it is done this way to ensure that:
  //  - `send` handles `personal_sign` as a request for the default sign method
  //  - explicit `personal_sign` is not replaced by `sequence_sign` (if default is EI6492)
  signMethod(options) {
    if ((options == null ? void 0 : options.eip6492) === void 0) {
      return "personal_sign";
    }
    return options.eip6492 ? "sequence_sign" : "legacy_sign";
  }
  signTypedDataMethod(options) {
    if ((options == null ? void 0 : options.eip6492) === void 0) {
      return "eth_signTypedData_v4";
    }
    return options.eip6492 ? "sequence_signTypedData_v4" : "legacy_signTypedData_v4";
  }
  mapSignMethod(method) {
    if (method === "personal_sign") {
      if (this.defaultEIP6492) {
        return "sequence_sign";
      } else {
        return "personal_sign";
      }
    }
    if (method === "eth_signTypedData_v4") {
      if (this.defaultEIP6492) {
        return "sequence_signTypedData_v4";
      } else {
        return "eth_signTypedData_v4";
      }
    }
    if (method === "legacy_sign") {
      return "personal_sign";
    }
    if (method === "legacy_signTypedData_v4") {
      return "eth_signTypedData_v4";
    }
    return method;
  }
  async signMessage(message, options) {
    var _this$analytics4;
    const method = this.signMethod(options);
    (_this$analytics4 = this.analytics) == null || _this$analytics4.track({
      event: "SIGN_MESSAGE_REQUEST",
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    message = hexlify(messageToBytes(message));
    return this.request({
      method,
      params: [message, this.getAddress()],
      chainId: options == null ? void 0 : options.chainId
    });
  }
  async signTypedData(typedData, options) {
    var _this$analytics5;
    const method = this.signTypedDataMethod(options);
    const encoded = TypedDataEncoder.getPayload(typedData.domain, typedData.types, typedData.message);
    (_this$analytics5 = this.analytics) == null || _this$analytics5.track({
      event: "SIGN_TYPED_DATA_REQUEST",
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    return this.request({
      method,
      params: [this.getAddress(), encoded],
      chainId: (options == null ? void 0 : options.chainId) || typedData.domain.chainId && Number(typedData.domain.chainId) || this.getChainId()
    });
  }
  async sendTransaction(tx, options) {
    var _this$analytics6;
    const sequenceTxs = Array.isArray(tx) ? tx : [tx];
    const extendedTxs = toExtended(sequenceTxs);
    (_this$analytics6 = this.analytics) == null || _this$analytics6.track({
      event: "SEND_TRANSACTION_REQUEST",
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    return this.request({
      method: "eth_sendTransaction",
      params: [extendedTxs],
      chainId: options == null ? void 0 : options.chainId
    });
  }
  async getWalletContext() {
    return this.request({
      method: "sequence_getWalletContext"
    });
  }
  async getOnchainWalletConfig(options) {
    const res = await this.request({
      method: "sequence_getWalletConfig",
      params: [(options == null ? void 0 : options.chainId) || this.getChainId()],
      chainId: options == null ? void 0 : options.chainId
    });
    return Array.isArray(res) ? res[0] : res;
  }
  // NOTICE: We are leaving out all the "regular" methods os a tipical
  // JSON RPC Provider (eth_getBlockByNumber, eth_call, etc)
  // wallet-webapp does implement them, but this client is meant to be
  // exclusively used for Sequence specific methods
}
const unwrapJsonRpcResponse = (response) => {
  if (response && typeof response === "object" && "jsonrpc" in response && "result" in response) {
    return response.result;
  }
  return response;
};
const DefaultProviderConfig = {
  transports: {
    walletAppURL: "https://sequence.app",
    windowTransport: {
      enabled: true
    },
    proxyTransport: {
      enabled: false
    }
  },
  defaultNetwork: 1,
  analytics: true
};
let sequenceWalletProvider;
const initWallet = (projectAccessKey2, partialConfig) => {
  var _config$networks$filt, _config$networks, _findNetworkConfig;
  if (!projectAccessKey2 || typeof projectAccessKey2 !== "string") {
    throw new Error("Please pass a projectAccessKey in initWallet.");
  }
  if (sequenceWalletProvider) {
    return sequenceWalletProvider;
  }
  const config2 = _extends$4({}, DefaultProviderConfig, partialConfig, {
    transports: _extends$4({}, DefaultProviderConfig.transports, partialConfig == null ? void 0 : partialConfig.transports)
  });
  const rpcProviders = {};
  const newNetworks = (_config$networks$filt = (_config$networks = config2.networks) == null ? void 0 : _config$networks.filter((n2) => {
    n2.rpcUrl !== void 0 && n2.chainId !== void 0 && !allNetworks$1.find((an) => an.chainId === n2.chainId);
  })) != null ? _config$networks$filt : [];
  const combinedNetworks = allNetworks$1.map((n2) => {
    var _config$networks2;
    const network2 = (_config$networks2 = config2.networks) == null ? void 0 : _config$networks2.find((cn) => cn.chainId === n2.chainId);
    return network2 ? _extends$4({}, n2, network2) : n2;
  }).concat(newNetworks).map((network2) => {
    if (network2.rpcUrl.includes(projectAccessKey2)) {
      return network2;
    }
    network2.rpcUrl = network2.rpcUrl + `/${projectAccessKey2}`;
    return network2;
  });
  const providerForChainId = (chainId) => {
    if (!rpcProviders[chainId]) {
      var _combinedNetworks$fin;
      const rpcUrl = (_combinedNetworks$fin = combinedNetworks.find((n2) => n2.chainId === chainId)) == null ? void 0 : _combinedNetworks$fin.rpcUrl;
      if (!rpcUrl) {
        throw new Error(`no rpcUrl found for chainId: ${chainId}`);
      }
      rpcProviders[chainId] = new JsonRpcProvider(rpcUrl, {
        middlewares: [loggingProviderMiddleware, exceptionProviderMiddleware, new CachedProvider()]
      }, {
        cacheTimeout: -1
      });
    }
    return rpcProviders[chainId];
  };
  const defaultNetwork = config2.defaultNetwork ? (_findNetworkConfig = findNetworkConfig(combinedNetworks, config2.defaultNetwork)) == null ? void 0 : _findNetworkConfig.chainId : void 0;
  if (!defaultNetwork && config2.defaultNetwork) {
    throw new Error(`defaultNetwork not found for chainId: ${config2.defaultNetwork}`);
  }
  const itemStore = config2.localStorage || useBestStore();
  const client2 = new SequenceClient(config2.transports, itemStore, {
    defaultChainId: defaultNetwork,
    defaultEIP6492: config2.defaultEIP6492,
    projectAccessKey: projectAccessKey2,
    analytics: config2.analytics
  });
  sequenceWalletProvider = new SequenceProvider(client2, providerForChainId);
  return sequenceWalletProvider;
};
const unregisterWallet = () => {
  if (!sequenceWalletProvider) return;
  sequenceWalletProvider.client.closeWallet();
  sequenceWalletProvider.client.transport.unregister();
  sequenceWalletProvider = void 0;
};
const getWallet = () => {
  if (!sequenceWalletProvider) {
    throw new Error("Wallet has not been initialized, call sequence.initWallet(config) first.");
  }
  return sequenceWalletProvider;
};
const provider$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseInjectedTransport,
  BaseProviderTransport,
  BaseWalletTransport,
  CHANNEL_ID,
  DefaultChainIdTracker,
  DefaultProviderConfig,
  ErrSignedInRequired,
  EventType,
  ExtensionMessageHandler,
  ExtensionMessageProvider,
  InitState,
  LocalStorage,
  MemoryItemStore,
  MuxMessageProvider,
  OpenState,
  PROVIDER_OPEN_TIMEOUT,
  ProviderError,
  ProxyMessageChannel,
  ProxyMessageChannelPort,
  ProxyMessageHandler,
  ProxyMessageProvider,
  SequenceClient,
  SequenceClientSession,
  SequenceProvider,
  SequenceSigner,
  SingleNetworkSequenceProvider,
  SingleNetworkSequenceSigner,
  UnrealMessageHandler,
  UnrealMessageProvider,
  WalletRequestHandler,
  WindowMessageHandler,
  WindowMessageProvider,
  WindowSessionParams,
  getWallet,
  initWallet,
  isBrowserExtension,
  isMuxTransportTemplate,
  isProviderTransport,
  isUnityPlugin,
  isValidMessageSignature,
  isValidSignature,
  isValidTypedDataSignature,
  isWalletUpToDate,
  messageToBytes,
  nextMessageIdx,
  prefixEIP191Message,
  resolveArrayProperties,
  trimEIP191Prefix,
  unregisterWallet,
  useBestStore,
  validateTransactionRequest
}, Symbol.toStringTag, { value: "Module" }));
function _mergeNamespaces$1(n2, m2) {
  m2.forEach(function(e2) {
    e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e2[k2];
          }
        });
      }
    });
  });
  return Object.freeze(n2);
}
var abi$1 = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [abi$1$2]);
var api = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [api$1]);
var auth = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [auth$1]);
var guard = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [guard$1]);
var indexer = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [indexer$1]);
var metadata = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [metadata$1]);
var network = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [network$1]);
var provider = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [provider$1]);
var relayer = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [relayer$1]);
const transactions = index$1$1.transaction;
var transactions$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  transactions
});
var utils = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null,
  isValidSignature,
  isValidMessageSignature,
  isValidTypedDataSignature,
  isWalletUpToDate
}, [utils$1]);
var core = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [core$1]);
var signhub = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [signhub$1]);
var sessions = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [sessions$1]);
var migration = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [migration$1]);
var account = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [account$1]);
var sequence$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$1,
  api,
  auth,
  guard,
  indexer,
  metadata,
  network,
  provider,
  relayer,
  transactions: transactions$1,
  utils,
  core,
  signhub,
  sessions,
  migration,
  account,
  initWallet,
  getWallet,
  unregisterWallet,
  SequenceProvider,
  SequenceClient,
  SequenceSigner
});
function useLoadGsiScript(options = {}) {
  const { nonce, onScriptLoadSuccess, onScriptLoadError } = options;
  const [scriptLoadedSuccessfully, setScriptLoadedSuccessfully] = reactExports.useState(false);
  const onScriptLoadSuccessRef = reactExports.useRef(onScriptLoadSuccess);
  onScriptLoadSuccessRef.current = onScriptLoadSuccess;
  const onScriptLoadErrorRef = reactExports.useRef(onScriptLoadError);
  onScriptLoadErrorRef.current = onScriptLoadError;
  reactExports.useEffect(() => {
    const scriptTag = document.createElement("script");
    scriptTag.src = "https://accounts.google.com/gsi/client";
    scriptTag.async = true;
    scriptTag.defer = true;
    scriptTag.nonce = nonce;
    scriptTag.onload = () => {
      var _a2;
      setScriptLoadedSuccessfully(true);
      (_a2 = onScriptLoadSuccessRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onScriptLoadSuccessRef);
    };
    scriptTag.onerror = () => {
      var _a2;
      setScriptLoadedSuccessfully(false);
      (_a2 = onScriptLoadErrorRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onScriptLoadErrorRef);
    };
    document.body.appendChild(scriptTag);
    return () => {
      document.body.removeChild(scriptTag);
    };
  }, [nonce]);
  return scriptLoadedSuccessfully;
}
const GoogleOAuthContext = reactExports.createContext(null);
function GoogleOAuthProvider({ clientId, nonce, onScriptLoadSuccess, onScriptLoadError, children }) {
  const scriptLoadedSuccessfully = useLoadGsiScript({
    nonce,
    onScriptLoadSuccess,
    onScriptLoadError
  });
  const contextValue = reactExports.useMemo(() => ({
    clientId,
    scriptLoadedSuccessfully
  }), [clientId, scriptLoadedSuccessfully]);
  return React.createElement(GoogleOAuthContext.Provider, { value: contextValue }, children);
}
function useGoogleOAuth() {
  const context2 = reactExports.useContext(GoogleOAuthContext);
  if (!context2) {
    throw new Error("Google OAuth components must be used within GoogleOAuthProvider");
  }
  return context2;
}
function extractClientId(credentialResponse) {
  var _a2;
  const clientId = (_a2 = credentialResponse === null || credentialResponse === void 0 ? void 0 : credentialResponse.clientId) !== null && _a2 !== void 0 ? _a2 : credentialResponse === null || credentialResponse === void 0 ? void 0 : credentialResponse.client_id;
  return clientId;
}
const containerHeightMap = { large: 40, medium: 32, small: 20 };
function GoogleLogin({ onSuccess, onError, useOneTap, promptMomentNotification, type = "standard", theme = "outline", size: size2 = "large", text: text2, shape, logo_alignment, width, locale, click_listener, containerProps, ...props }) {
  const btnContainerRef = reactExports.useRef(null);
  const { clientId, scriptLoadedSuccessfully } = useGoogleOAuth();
  const onSuccessRef = reactExports.useRef(onSuccess);
  onSuccessRef.current = onSuccess;
  const onErrorRef = reactExports.useRef(onError);
  onErrorRef.current = onError;
  const promptMomentNotificationRef = reactExports.useRef(promptMomentNotification);
  promptMomentNotificationRef.current = promptMomentNotification;
  reactExports.useEffect(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2;
    if (!scriptLoadedSuccessfully)
      return;
    (_c2 = (_b2 = (_a2 = window === null || window === void 0 ? void 0 : window.google) === null || _a2 === void 0 ? void 0 : _a2.accounts) === null || _b2 === void 0 ? void 0 : _b2.id) === null || _c2 === void 0 ? void 0 : _c2.initialize({
      client_id: clientId,
      callback: (credentialResponse) => {
        var _a3;
        if (!(credentialResponse === null || credentialResponse === void 0 ? void 0 : credentialResponse.credential)) {
          return (_a3 = onErrorRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onErrorRef);
        }
        const { credential, select_by } = credentialResponse;
        onSuccessRef.current({
          credential,
          clientId: extractClientId(credentialResponse),
          select_by
        });
      },
      ...props
    });
    (_f2 = (_e2 = (_d2 = window === null || window === void 0 ? void 0 : window.google) === null || _d2 === void 0 ? void 0 : _d2.accounts) === null || _e2 === void 0 ? void 0 : _e2.id) === null || _f2 === void 0 ? void 0 : _f2.renderButton(btnContainerRef.current, {
      type,
      theme,
      size: size2,
      text: text2,
      shape,
      logo_alignment,
      width,
      locale,
      click_listener
    });
    if (useOneTap)
      (_j2 = (_h2 = (_g2 = window === null || window === void 0 ? void 0 : window.google) === null || _g2 === void 0 ? void 0 : _g2.accounts) === null || _h2 === void 0 ? void 0 : _h2.id) === null || _j2 === void 0 ? void 0 : _j2.prompt(promptMomentNotificationRef.current);
    return () => {
      var _a3, _b3, _c3;
      if (useOneTap)
        (_c3 = (_b3 = (_a3 = window === null || window === void 0 ? void 0 : window.google) === null || _a3 === void 0 ? void 0 : _a3.accounts) === null || _b3 === void 0 ? void 0 : _b3.id) === null || _c3 === void 0 ? void 0 : _c3.cancel();
    };
  }, [
    clientId,
    scriptLoadedSuccessfully,
    useOneTap,
    type,
    theme,
    size2,
    text2,
    shape,
    logo_alignment,
    width,
    locale
  ]);
  return React.createElement("div", { ...containerProps, ref: btnContainerRef, style: { height: containerHeightMap[size2], ...containerProps === null || containerProps === void 0 ? void 0 : containerProps.style } });
}
var LocalStorageKey;
(function(LocalStorageKey2) {
  LocalStorageKey2["Settings"] = "@kit.settings";
  LocalStorageKey2["Theme"] = "@kit.theme";
  LocalStorageKey2["EthAuthProof"] = "@kit.ethAuthProof";
  LocalStorageKey2["EthAuthSettings"] = "@kit.ethAuthSettings";
  LocalStorageKey2["WaasGoogleClientID"] = "@kit.waasGoogleClientId";
  LocalStorageKey2["WaasGoogleIdToken"] = "@kit.waasGoogleIdToken";
  LocalStorageKey2["WaasAppleClientID"] = "@kit.waasAppleClientId";
  LocalStorageKey2["WaasAppleRedirectURI"] = "@kit.waasAppleRedirectURI";
  LocalStorageKey2["WaasAppleIdToken"] = "@kit.waasAppleIdToken";
  LocalStorageKey2["WaasActiveLoginType"] = "@kit.waasActiveLoginType";
  LocalStorageKey2["WaasEmailIdToken"] = "@kit.waasEmailIdToken";
  LocalStorageKey2["WaasSignInEmail"] = "@kit.waasSignInEmail";
  LocalStorageKey2["SignInEmail"] = "@kit.signInEmail";
})(LocalStorageKey || (LocalStorageKey = {}));
const DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7;
const TRANSACTION_CONFIRMATIONS_DEFAULT = 4;
const NATIVE_TOKEN_ADDRESS_0X = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
const createGenericContext$2 = () => {
  const genericContext = reactExports.createContext(void 0);
  const useGenericContext = () => {
    const contextIsDefined = reactExports.useContext(genericContext);
    if (!contextIsDefined) {
      throw new Error("useGenericContext must be used within a Provider");
    }
    return contextIsDefined;
  };
  return [useGenericContext, genericContext.Provider];
};
const [useAnalyticsContext, AnalyticsContextProvider] = createGenericContext$2();
const [useConnectModalContext, ConnectModalContextProvider] = createGenericContext$2();
const [useKitConfig, KitConfigContextProvider] = createGenericContext$2();
const [useThemeContext, ThemeContextProvider] = createGenericContext$2();
const [useWalletConfigContext, WalletConfigContextProvider] = createGenericContext$2();
const useStorage = () => {
  const config2 = useConfig();
  if (!config2.storage) {
    return null;
  }
  return config2.storage;
};
const useStorageItem = (key) => {
  const storage = useStorage();
  return useQuery$1({
    queryKey: ["storage", key],
    queryFn: async () => {
      return storage == null ? void 0 : storage.getItem(key);
    },
    retry: true,
    enabled: !!storage
  });
};
class Deferred {
  constructor() {
    __publicField(this, "_resolve", () => {
    });
    __publicField(this, "_reject", () => {
    });
    __publicField(this, "_promise", new Promise((resolve, reject) => {
      this._reject = reject;
      this._resolve = resolve;
    }));
  }
  get promise() {
    return this._promise;
  }
  resolve(value) {
    this._resolve(value);
  }
  reject(value) {
    this._reject(value);
  }
}
let _pendingConfirmation;
function useWaasConfirmationHandler(waasConnector) {
  const [pendingRequestConfirmation, setPendingRequestConfirmation] = reactExports.useState();
  function confirmPendingRequest(id2) {
    _pendingConfirmation == null ? void 0 : _pendingConfirmation.resolve({ id: id2, confirmed: true });
    setPendingRequestConfirmation(void 0);
    _pendingConfirmation = void 0;
  }
  function rejectPendingRequest(id2) {
    _pendingConfirmation == null ? void 0 : _pendingConfirmation.resolve({ id: id2, confirmed: false });
    setPendingRequestConfirmation(void 0);
    _pendingConfirmation = void 0;
  }
  reactExports.useEffect(() => {
    async function setup() {
      if (!waasConnector) {
        return;
      }
      const waasProvider = waasConnector.sequenceWaasProvider;
      if (!waasProvider) {
        return;
      }
      waasProvider.requestConfirmationHandler = {
        confirmSignTransactionRequest(id2, txs, chainId) {
          const pending = new Deferred();
          setPendingRequestConfirmation({ id: id2, type: "signTransaction", txs: Array.isArray(txs) ? txs : [txs], chainId });
          _pendingConfirmation = pending;
          return pending.promise;
        },
        confirmSignMessageRequest(id2, message, chainId) {
          const pending = new Deferred();
          setPendingRequestConfirmation({ id: id2, type: "signMessage", message, chainId });
          _pendingConfirmation = pending;
          return pending.promise;
        }
      };
    }
    setup();
  });
  return [pendingRequestConfirmation, confirmPendingRequest, rejectPendingRequest];
}
function canonicalize(obj) {
  var buffer2 = "";
  serialize2(obj);
  return buffer2;
  function serialize2(object2) {
    if (object2 === null || typeof object2 !== "object" || object2.toJSON != null) {
      buffer2 += JSON.stringify(object2);
    } else if (Array.isArray(object2)) {
      buffer2 += "[";
      var next_1 = false;
      object2.forEach(function(element) {
        if (next_1) {
          buffer2 += ",";
        }
        next_1 = true;
        if (element === void 0) {
          element = null;
        }
        serialize2(element);
      });
      buffer2 += "]";
    } else {
      buffer2 += "{";
      var vKeys = Object.keys(object2).filter(function(k2) {
        return object2[k2] !== void 0;
      }).sort();
      vKeys.forEach(function(property, index2) {
        return addProp(object2, property, index2);
      });
      buffer2 += "}";
    }
  }
  function addProp(object2, property, index2) {
    if (index2 > 0) {
      buffer2 += ",";
    }
    buffer2 += JSON.stringify(property);
    buffer2 += ":";
    serialize2(object2[property]);
  }
}
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
  let httpHandler = runtimeConfig.httpHandler;
  return {
    setHttpHandler(handler) {
      httpHandler = handler;
    },
    httpHandler() {
      return httpHandler;
    },
    updateHttpClientConfig(key, value) {
      httpHandler.updateHttpClientConfig(key, value);
    },
    httpHandlerConfigs() {
      return httpHandler.httpHandlerConfigs();
    }
  };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
  return {
    httpHandler: httpHandlerExtensionConfiguration.httpHandler()
  };
};
var HttpAuthLocation;
(function(HttpAuthLocation2) {
  HttpAuthLocation2["HEADER"] = "header";
  HttpAuthLocation2["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));
var HttpApiKeyAuthLocation;
(function(HttpApiKeyAuthLocation2) {
  HttpApiKeyAuthLocation2["HEADER"] = "header";
  HttpApiKeyAuthLocation2["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
var EndpointURLScheme;
(function(EndpointURLScheme2) {
  EndpointURLScheme2["HTTP"] = "http";
  EndpointURLScheme2["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));
var AlgorithmId;
(function(AlgorithmId2) {
  AlgorithmId2["MD5"] = "md5";
  AlgorithmId2["CRC32"] = "crc32";
  AlgorithmId2["CRC32C"] = "crc32c";
  AlgorithmId2["SHA1"] = "sha1";
  AlgorithmId2["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
var FieldPosition;
(function(FieldPosition2) {
  FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
  FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));
const SMITHY_CONTEXT_KEY = "__smithy_context";
var IniSectionType;
(function(IniSectionType2) {
  IniSectionType2["PROFILE"] = "profile";
  IniSectionType2["SSO_SESSION"] = "sso-session";
  IniSectionType2["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));
var RequestHandlerProtocol;
(function(RequestHandlerProtocol2) {
  RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
class HttpRequest {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static clone(request) {
    const cloned = new HttpRequest({
      ...request,
      headers: { ...request.headers }
    });
    if (cloned.query) {
      cloned.query = cloneQuery(cloned.query);
    }
    return cloned;
  }
  static isInstance(request) {
    if (!request) {
      return false;
    }
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    return HttpRequest.clone(this);
  }
}
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}
class HttpResponse {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
}
function resolveHostHeaderConfig(input2) {
  return input2;
}
const hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
    delete request.headers["host"];
    request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
  } else if (!request.headers["host"]) {
    let host = request.hostname;
    if (request.port != null)
      host += `:${request.port}`;
    request.headers["host"] = host;
  }
  return next(args);
};
const hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
const getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});
const loggerMiddleware = () => (next, context2) => async (args) => {
  var _a2, _b2;
  try {
    const response = await next(args);
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context2;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context2.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context2.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    (_a2 = logger2 == null ? void 0 : logger2.info) == null ? void 0 : _a2.call(logger2, {
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context2;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context2.inputFilterSensitiveLog;
    (_b2 = logger2 == null ? void 0 : logger2.error) == null ? void 0 : _b2.call(logger2, {
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
};
const loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
const getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});
var define_process_env_default = {};
const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = define_process_env_default[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = define_process_env_default[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request
  });
};
const addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
const getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});
function resolveUserAgentConfig(input2) {
  return {
    ...input2,
    customUserAgent: typeof input2.customUserAgent === "string" ? [[input2.customUserAgent]] : input2.customUserAgent
  };
}
class EndpointCache {
  constructor({ size: size2, params }) {
    this.data = /* @__PURE__ */ new Map();
    this.parameters = [];
    this.capacity = size2 ?? 50;
    if (params) {
      this.parameters = params;
    }
  }
  get(endpointParams, resolver) {
    const key = this.hash(endpointParams);
    if (key === false) {
      return resolver();
    }
    if (!this.data.has(key)) {
      if (this.data.size > this.capacity + 10) {
        const keys = this.data.keys();
        let i = 0;
        while (true) {
          const { value, done } = keys.next();
          this.data.delete(value);
          if (done || ++i > 10) {
            break;
          }
        }
      }
      this.data.set(key, resolver());
    }
    return this.data.get(key);
  }
  size() {
    return this.data.size;
  }
  hash(endpointParams) {
    let buffer2 = "";
    const { parameters } = this;
    if (parameters.length === 0) {
      return false;
    }
    for (const param of parameters) {
      const val = String(endpointParams[param] ?? "");
      if (val.includes("|;")) {
        return false;
      }
      buffer2 += val + "|;";
    }
    return buffer2;
  }
}
const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};
const customEndpointFunctions = {};
const debugId = "endpoints";
function toDebugString(input2) {
  if (typeof input2 !== "object" || input2 == null) {
    return input2;
  }
  if ("ref" in input2) {
    return `$${toDebugString(input2.ref)}`;
  }
  if ("fn" in input2) {
    return `${input2.fn}(${(input2.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input2, null, 2);
}
class EndpointError extends Error {
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
}
const booleanEquals = (value1, value2) => value1 === value2;
const getAttrPathList = (path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};
const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index2) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index2}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index2)];
  }
  return acc[index2];
}, value);
const isSet = (value) => value != null;
const not = (value) => !value;
const DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
};
const parseURL = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url.search = Object.entries(query).map(([k2, v3]) => `${k2}=${v3}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search: search2 } = whatwgURL;
  if (search2) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};
const stringEquals = (value1, value2) => value1 === value2;
const substring = (input2, start, stop, reverse) => {
  if (start >= stop || input2.length < stop) {
    return null;
  }
  if (!reverse) {
    return input2.substring(start, stop);
  }
  return input2.substring(input2.length - stop, input2.length - start);
};
const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`);
const endpointFunctions = {
  booleanEquals,
  getAttr,
  isSet,
  isValidHostLabel,
  not,
  parseURL,
  stringEquals,
  substring,
  uriEncode
};
const evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};
const getReferenceValue = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};
const evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
const callFunction = ({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  const fnSegments = fn.split(".");
  if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
    return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
  }
  return endpointFunctions[fn](...evaluatedArgs);
};
const evaluateCondition = ({ assign, ...fnArgs }, options) => {
  var _a2, _b2;
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};
const evaluateConditions = (conditions = [], options) => {
  var _a2, _b2;
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};
const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});
const getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
};
const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});
const getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};
const evaluateEndpointRule = (endpointRule, options) => {
  var _a2, _b2;
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};
const evaluateErrorRule = (errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};
const evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};
const evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
};
const resolveEndpoint = (ruleSetObject, options) => {
  var _a2, _b2, _c2, _d2;
  const { endpointParams, logger: logger2 } = options;
  const { parameters, rules } = ruleSetObject;
  (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v3]) => v3.default != null).map(([k2, v3]) => [k2, v3.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v3]) => v3.required).map(([k2]) => k2);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
  (_d2 = (_c2 = options.logger) == null ? void 0 : _c2.debug) == null ? void 0 : _d2.call(_c2, `${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
  return endpoint;
};
const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value)) {
    return false;
  }
  return true;
};
const ARN_DELIMITER = ":";
const RESOURCE_DELIMITER = "/";
const parseArn = (value) => {
  const segments = value.split(ARN_DELIMITER);
  if (segments.length < 6)
    return null;
  const [arn, partition2, service, region, accountId, ...resourcePath] = segments;
  if (arn !== "arn" || partition2 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
    return null;
  const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
  return {
    partition: partition2,
    service,
    region,
    accountId,
    resourceId
  };
};
const partitions = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "ap-southeast-5": {
        description: "Asia Pacific (Malaysia)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {
      "eu-isoe-west-1": {
        description: "EU ISOE West"
      }
    }
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
];
const version$1 = "1.1";
const partitionsInfo = {
  partitions,
  version: version$1
};
let selectedPartitionsInfo = partitionsInfo;
const partition = (value) => {
  const { partitions: partitions2 } = selectedPartitionsInfo;
  for (const partition2 of partitions2) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions2) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions2.find((partition2) => partition2.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
};
const awsEndpointFunctions = {
  isVirtualHostableS3Bucket,
  parseArn,
  partition
};
customEndpointFunctions.aws = awsEndpointFunctions;
const USER_AGENT = "user-agent";
const X_AMZ_USER_AGENT = "x-amz-user-agent";
const SPACE$1 = " ";
const UA_NAME_SEPARATOR = "/";
const UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
const UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
const UA_ESCAPE_CHAR = "-";
const userAgentMiddleware = (options) => (next, context2) => async (args) => {
  var _a2, _b2;
  const { request } = args;
  if (!HttpRequest.isInstance(request))
    return next(args);
  const { headers } = request;
  const userAgent = ((_a2 = context2 == null ? void 0 : context2.userAgent) == null ? void 0 : _a2.map(escapeUserAgent)) || [];
  const defaultUserAgent2 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  const customUserAgent = ((_b2 = options == null ? void 0 : options.customUserAgent) == null ? void 0 : _b2.map(escapeUserAgent)) || [];
  const sdkUserAgentValue = [].concat([...defaultUserAgent2, ...userAgent, ...customUserAgent]).join(SPACE$1);
  const normalUAValue = [
    ...defaultUserAgent2.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE$1);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request
  });
};
const escapeUserAgent = (userAgentPair) => {
  var _a2;
  const name2 = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version2 = (_a2 = userAgentPair[1]) == null ? void 0 : _a2.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name2.indexOf(UA_NAME_SEPARATOR);
  const prefix = name2.substring(0, prefixSeparatorIndex);
  let uaName = name2.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version2].filter((item2) => item2 && item2.length > 0).reduce((acc, item2, index2) => {
    switch (index2) {
      case 0:
        return item2;
      case 1:
        return `${acc}/${item2}`;
      default:
        return `${acc}#${item2}`;
    }
  }, "");
};
const getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
const getUserAgentPlugin = (config2) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config2), getUserAgentMiddlewareOptions);
  }
});
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));
const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
const DEFAULT_USE_FIPS_ENDPOINT = false;
const getSmithyContext = (context2) => context2[SMITHY_CONTEXT_KEY] || (context2[SMITHY_CONTEXT_KEY] = {});
const normalizeProvider$1 = (input2) => {
  if (typeof input2 === "function")
    return input2;
  const promisified = Promise.resolve(input2);
  return () => promisified;
};
const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
const getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
const resolveRegionConfig = (input2) => {
  const { region, useFipsEndpoint } = input2;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input2,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};
function convertHttpAuthSchemesToMap(httpAuthSchemes) {
  const map = /* @__PURE__ */ new Map();
  for (const scheme of httpAuthSchemes) {
    map.set(scheme.schemeId, scheme);
  }
  return map;
}
const httpAuthSchemeMiddleware = (config2, mwOptions) => (next, context2) => async (args) => {
  var _a2;
  const options = config2.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config2, context2, args.input));
  const authSchemes = convertHttpAuthSchemesToMap(config2.httpAuthSchemes);
  const smithyContext = getSmithyContext(context2);
  const failureReasons = [];
  for (const option of options) {
    const scheme = authSchemes.get(option.schemeId);
    if (!scheme) {
      failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
      continue;
    }
    const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config2));
    if (!identityProvider) {
      failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
      continue;
    }
    const { identityProperties = {}, signingProperties = {} } = ((_a2 = option.propertiesExtractor) == null ? void 0 : _a2.call(option, config2, context2)) || {};
    option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
    option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
    smithyContext.selectedHttpAuthScheme = {
      httpAuthOption: option,
      identity: await identityProvider(option.identityProperties),
      signer: scheme.signer
    };
    break;
  }
  if (!smithyContext.selectedHttpAuthScheme) {
    throw new Error(failureReasons.join("\n"));
  }
  return next(args);
};
const resolveParamsForS3 = async (endpointParams) => {
  const bucket = (endpointParams == null ? void 0 : endpointParams.Bucket) || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
  const [arn, partition2, service, , , bucket] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = Boolean(isArn && partition2 && service && bucket);
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return isValidArn;
};
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config2) => {
  const configProvider = async () => {
    const configValue = config2[configKey] ?? config2[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
    return async () => {
      const credentials = typeof config2.credentials === "function" ? await config2.credentials() : config2.credentials;
      const configValue = (credentials == null ? void 0 : credentials.credentialScope) ?? (credentials == null ? void 0 : credentials.CredentialScope);
      return configValue;
    };
  }
  if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
    return async () => {
      const credentials = typeof config2.credentials === "function" ? await config2.credentials() : config2.credentials;
      const configValue = (credentials == null ? void 0 : credentials.accountId) ?? (credentials == null ? void 0 : credentials.AccountId);
      return configValue;
    };
  }
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};
const getEndpointFromConfig = async (serviceId) => void 0;
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}
const parseUrl = (url) => {
  if (typeof url === "string") {
    return parseUrl(new URL(url));
  }
  const { hostname, pathname, port, protocol, search: search2 } = url;
  let query;
  if (search2) {
    query = parseQueryString(search2);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};
const toEndpointV1 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};
const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context2) => {
  if (!clientConfig.endpoint) {
    let endpointFromConfig;
    if (clientConfig.serviceConfiguredEndpoint) {
      endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
    } else {
      endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId);
    }
    if (endpointFromConfig) {
      clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
    }
  }
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context2);
  return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  var _a2;
  const endpointParams = {};
  const instructions = ((_a2 = instructionsSupplier == null ? void 0 : instructionsSupplier.getEndpointParameterInstructions) == null ? void 0 : _a2.call(instructionsSupplier)) || {};
  for (const [name2, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name2] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name2] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name2] = await createConfigValueProvider(instruction.name, name2, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};
const endpointMiddleware = ({ config: config2, instructions }) => {
  return (next, context2) => async (args) => {
    var _a2, _b2, _c2;
    const endpoint = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config2 }, context2);
    context2.endpointV2 = endpoint;
    context2.authSchemes = (_a2 = endpoint.properties) == null ? void 0 : _a2.authSchemes;
    const authScheme = (_b2 = context2.authSchemes) == null ? void 0 : _b2[0];
    if (authScheme) {
      context2["signing_region"] = authScheme.signingRegion;
      context2["signing_service"] = authScheme.signingName;
      const smithyContext = getSmithyContext(context2);
      const httpAuthOption = (_c2 = smithyContext == null ? void 0 : smithyContext.selectedHttpAuthScheme) == null ? void 0 : _c2.httpAuthOption;
      if (httpAuthOption) {
        httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
          signing_region: authScheme.signingRegion,
          signingRegion: authScheme.signingRegion,
          signing_service: authScheme.signingName,
          signingName: authScheme.signingName,
          signingRegionSet: authScheme.signingRegionSet
        }, authScheme.properties);
      }
    }
    return next({
      ...args
    });
  };
};
const deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    if (!("$metadata" in error)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error.message += "\n  " + hint;
      if (typeof error.$responseBodyText !== "undefined") {
        if (error.$response) {
          error.$response.body = error.$responseBodyText;
        }
      }
    }
    throw error;
  }
};
const serializerMiddleware = (options, serializer) => (next, context2) => async (args) => {
  var _a2;
  const endpoint = ((_a2 = context2.endpointV2) == null ? void 0 : _a2.url) && options.urlParser ? async () => options.urlParser(context2.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request = await serializer(args.input, { ...options, endpoint });
  return next({
    ...args,
    request
  });
};
const deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
const serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config2, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config2, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config2, serializer), serializerMiddlewareOption);
    }
  };
}
const endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
const getEndpointPlugin = (config2, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config: config2,
      instructions
    }), endpointMiddlewareOptions);
  }
});
const resolveEndpointConfig = (input2) => {
  const tls = input2.tls ?? true;
  const { endpoint } = input2;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider$1(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  const resolvedConfig = {
    ...input2,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider$1(input2.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider$1(input2.useFipsEndpoint ?? false)
  };
  let configuredEndpointPromise = void 0;
  resolvedConfig.serviceConfiguredEndpoint = async () => {
    if (input2.serviceId && !configuredEndpointPromise) {
      configuredEndpointPromise = getEndpointFromConfig(input2.serviceId);
    }
    return configuredEndpointPromise;
  };
  return resolvedConfig;
};
const httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: endpointMiddlewareOptions.name
};
const getHttpAuthSchemeEndpointRuleSetPlugin = (config2, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(httpAuthSchemeMiddleware(config2, {
      httpAuthSchemeParametersProvider,
      identityProviderConfigProvider
    }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
  }
});
({
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
});
const defaultErrorHandler = (signingProperties) => (error) => {
  throw error;
};
const defaultSuccessHandler = (httpResponse, signingProperties) => {
};
const httpSigningMiddleware = (config2) => (next, context2) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const smithyContext = getSmithyContext(context2);
  const scheme = smithyContext.selectedHttpAuthScheme;
  if (!scheme) {
    throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
  }
  const { httpAuthOption: { signingProperties = {} }, identity, signer: signer2 } = scheme;
  const output2 = await next({
    ...args,
    request: await signer2.sign(args.request, identity, signingProperties)
  }).catch((signer2.errorHandler || defaultErrorHandler)(signingProperties));
  (signer2.successHandler || defaultSuccessHandler)(output2.response, signingProperties);
  return output2;
};
var RETRY_MODES;
(function(RETRY_MODES2) {
  RETRY_MODES2["STANDARD"] = "standard";
  RETRY_MODES2["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
const DEFAULT_MAX_ATTEMPTS = 3;
const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;
const THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
const TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
const isClockSkewCorrectedError = (error) => {
  var _a2;
  return (_a2 = error.$metadata) == null ? void 0 : _a2.clockSkewCorrected;
};
const isThrottlingError = (error) => {
  var _a2, _b2;
  return ((_a2 = error.$metadata) == null ? void 0 : _a2.httpStatusCode) === 429 || THROTTLING_ERROR_CODES.includes(error.name) || ((_b2 = error.$retryable) == null ? void 0 : _b2.throttling) == true;
};
const isTransientError = (error) => {
  var _a2;
  return isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes((error == null ? void 0 : error.code) || "") || TRANSIENT_ERROR_STATUS_CODES.includes(((_a2 = error.$metadata) == null ? void 0 : _a2.httpStatusCode) || 0);
};
const isServerError = (error) => {
  var _a2;
  if (((_a2 = error.$metadata) == null ? void 0 : _a2.httpStatusCode) !== void 0) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
      return true;
    }
    return false;
  }
  return false;
};
class DefaultRateLimiter {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = (options == null ? void 0 : options.beta) ?? 0.7;
    this.minCapacity = (options == null ? void 0 : options.minCapacity) ?? 1;
    this.minFillRate = (options == null ? void 0 : options.minFillRate) ?? 0.5;
    this.scaleConstant = (options == null ? void 0 : options.scaleConstant) ?? 0.4;
    this.smooth = (options == null ? void 0 : options.smooth) ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay2 = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve) => setTimeout(resolve, delay2));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t2 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t2 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
}
const DEFAULT_RETRY_DELAY_BASE = 100;
const MAXIMUM_RETRY_DELAY = 20 * 1e3;
const THROTTLING_RETRY_DELAY_BASE = 500;
const INITIAL_RETRY_TOKENS = 500;
const RETRY_COST = 5;
const TIMEOUT_RETRY_COST = 10;
const NO_RETRY_INCREMENT = 1;
const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
const REQUEST_HEADER = "amz-sdk-request";
const getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay2) => {
    delayBase = delay2;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};
const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
  const getRetryCost = () => retryCost;
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
};
class StandardRetryStrategy {
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
}
class AdaptiveRetryStrategy {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
}
let getRandomValues$2;
const rnds8$1 = new Uint8Array(16);
function rng$1() {
  if (!getRandomValues$2) {
    getRandomValues$2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues$2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues$2(rnds8$1);
}
const byteToHex$1 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex$1.push((i + 256).toString(16).slice(1));
}
function unsafeStringify$1(arr, offset2 = 0) {
  return byteToHex$1[arr[offset2 + 0]] + byteToHex$1[arr[offset2 + 1]] + byteToHex$1[arr[offset2 + 2]] + byteToHex$1[arr[offset2 + 3]] + "-" + byteToHex$1[arr[offset2 + 4]] + byteToHex$1[arr[offset2 + 5]] + "-" + byteToHex$1[arr[offset2 + 6]] + byteToHex$1[arr[offset2 + 7]] + "-" + byteToHex$1[arr[offset2 + 8]] + byteToHex$1[arr[offset2 + 9]] + "-" + byteToHex$1[arr[offset2 + 10]] + byteToHex$1[arr[offset2 + 11]] + byteToHex$1[arr[offset2 + 12]] + byteToHex$1[arr[offset2 + 13]] + byteToHex$1[arr[offset2 + 14]] + byteToHex$1[arr[offset2 + 15]];
}
const randomUUID$1 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native$1 = {
  randomUUID: randomUUID$1
};
function v4$1(options, buf, offset2) {
  if (native$1.randomUUID && !buf && !options) {
    return native$1.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng$1)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify$1(rnds);
}
const asSdkError = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};
const resolveRetryConfig = (input2) => {
  const { retryStrategy } = input2;
  const maxAttempts = normalizeProvider$1(input2.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input2,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider$1(input2.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
};
class NoOpLogger {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
const getAllAliases = (name2, aliases) => {
  const _aliases = [];
  if (name2) {
    _aliases.push(name2);
  }
  if (aliases) {
    for (const alias of aliases) {
      _aliases.push(alias);
    }
  }
  return _aliases;
};
const getMiddlewareNameWithAliases = (name2, aliases) => {
  return `${name2 || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  let identifyOnResolve = false;
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = (entries) => entries.sort((a2, b2) => stepWeights[b2.step] - stepWeights[a2.step] || priorityWeights[b2.priority || "normal"] - priorityWeights[a2.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      const aliases = getAllAliases(entry.name, entry.aliases);
      if (aliases.includes(toRemove)) {
        isRemoved = true;
        for (const alias of aliases) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        for (const alias of getAllAliases(entry.name, entry.aliases)) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    var _a2;
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    (_a2 = toStack.identifyOnResolve) == null ? void 0 : _a2.call(toStack, stack.identifyOnResolve());
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug2 = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug2) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware, options = {}) => {
      const { name: name2, override, aliases: _aliases } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      const aliases = getAllAliases(name2, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name2, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = absoluteEntries.findIndex((entry2) => {
              var _a2;
              return entry2.name === alias || ((_a2 = entry2.aliases) == null ? void 0 : _a2.some((a2) => a2 === alias));
            });
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = absoluteEntries[toOverrideIndex];
            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name2, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
            }
            absoluteEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name: name2, override, aliases: _aliases } = options;
      const entry = {
        middleware,
        ...options
      };
      const aliases = getAllAliases(name2, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name2, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = relativeEntries.findIndex((entry2) => {
              var _a2;
              return entry2.name === alias || ((_a2 = entry2.aliases) == null ? void 0 : _a2.some((a2) => a2 === alias));
            });
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = relativeEntries[toOverrideIndex];
            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name2, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
            }
            relativeEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name: name2, aliases: _aliases } = entry;
        if (tags && tags.includes(toRemove)) {
          const aliases = getAllAliases(name2, _aliases);
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      var _a2;
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (((_a2 = from.identifyOnResolve) == null ? void 0 : _a2.call(from)) ?? false));
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
        return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
      });
    },
    identifyOnResolve(toggle) {
      if (typeof toggle === "boolean")
        identifyOnResolve = toggle;
      return identifyOnResolve;
    },
    resolve: (handler, context2) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware(handler, context2);
      }
      if (identifyOnResolve) {
        console.log(stack.identify());
      }
      return handler;
    }
  };
  return stack;
};
const stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
const priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};
class Client {
  constructor(config2) {
    this.config = config2;
    this.middlewareStack = constructStack();
  }
  send(command, optionsOrCb, cb2) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
    const useHandlerCache = options === void 0 && this.config.cacheMiddleware === true;
    let handler;
    if (useHandlerCache) {
      if (!this.handlers) {
        this.handlers = /* @__PURE__ */ new WeakMap();
      }
      const handlers = this.handlers;
      if (handlers.has(command.constructor)) {
        handler = handlers.get(command.constructor);
      } else {
        handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        handlers.set(command.constructor, handler);
      }
    } else {
      delete this.handlers;
      handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    }
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    var _a2, _b2, _c2;
    (_c2 = (_b2 = (_a2 = this.config) == null ? void 0 : _a2.requestHandler) == null ? void 0 : _b2.destroy) == null ? void 0 : _c2.call(_b2);
    delete this.handlers;
  }
}
const alphabetByEncoding = {};
const alphabetByValue = new Array(64);
for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
  const char = String.fromCharCode(i + start);
  alphabetByEncoding[char] = i;
  alphabetByValue[i] = char;
}
for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
  const char = String.fromCharCode(i + start);
  const index2 = i + 26;
  alphabetByEncoding[char] = index2;
  alphabetByValue[index2] = char;
}
for (let i = 0; i < 10; i++) {
  alphabetByEncoding[i.toString(10)] = i + 52;
  const char = i.toString(10);
  const index2 = i + 52;
  alphabetByEncoding[char] = index2;
  alphabetByValue[index2] = char;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
const bitsPerLetter = 6;
const bitsPerByte = 8;
const maxLetterValue = 63;
const fromBase64 = (input2) => {
  let totalByteLength = input2.length / 4 * 3;
  if (input2.slice(-2) === "==") {
    totalByteLength -= 2;
  } else if (input2.slice(-1) === "=") {
    totalByteLength--;
  }
  const out = new ArrayBuffer(totalByteLength);
  const dataView = new DataView(out);
  for (let i = 0; i < input2.length; i += 4) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i, limit = i + 3; j2 <= limit; j2++) {
      if (input2[j2] !== "=") {
        if (!(input2[j2] in alphabetByEncoding)) {
          throw new TypeError(`Invalid character ${input2[j2]} in base64 string.`);
        }
        bits |= alphabetByEncoding[input2[j2]] << (limit - j2) * bitsPerLetter;
        bitLength += bitsPerLetter;
      } else {
        bits >>= bitsPerLetter;
      }
    }
    const chunkOffset = i / 4 * 3;
    bits >>= bitLength % bitsPerByte;
    const byteLength2 = Math.floor(bitLength / bitsPerByte);
    for (let k2 = 0; k2 < byteLength2; k2++) {
      const offset2 = (byteLength2 - k2 - 1) * bitsPerByte;
      dataView.setUint8(chunkOffset + k2, (bits & 255 << offset2) >> offset2);
    }
  }
  return new Uint8Array(out);
};
const fromUtf8$2 = (input2) => new TextEncoder().encode(input2);
const toUint8Array = (data) => {
  if (typeof data === "string") {
    return fromUtf8$2(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};
const toUtf8 = (input2) => {
  if (typeof input2 === "string") {
    return input2;
  }
  if (typeof input2 !== "object" || typeof input2.byteOffset !== "number" || typeof input2.byteLength !== "number") {
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  }
  return new TextDecoder("utf-8").decode(input2);
};
function toBase64(_input) {
  let input2;
  if (typeof _input === "string") {
    input2 = fromUtf8$2(_input);
  } else {
    input2 = _input;
  }
  const isArrayLike = typeof input2 === "object" && typeof input2.length === "number";
  const isUint8Array = typeof input2 === "object" && typeof input2.byteOffset === "number" && typeof input2.byteLength === "number";
  if (!isArrayLike && !isUint8Array) {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  let str = "";
  for (let i = 0; i < input2.length; i += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i, limit = Math.min(i + 3, input2.length); j2 < limit; j2++) {
      bits |= input2[j2] << (limit - j2 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k2 = 1; k2 <= bitClusterCount; k2++) {
      const offset2 = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset2) >> offset2];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}
function transformToString(payload, encoding = "utf-8") {
  if (encoding === "base64") {
    return toBase64(payload);
  }
  return toUtf8(payload);
}
function transformFromString(str, encoding) {
  if (encoding === "base64") {
    return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
  }
  return Uint8ArrayBlobAdapter.mutate(fromUtf8$2(str));
}
class Uint8ArrayBlobAdapter extends Uint8Array {
  static fromString(source, encoding = "utf-8") {
    switch (typeof source) {
      case "string":
        return transformFromString(source, encoding);
      default:
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(source) {
    Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
    return source;
  }
  transformToString(encoding = "utf-8") {
    return transformToString(this, encoding);
  }
}
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`;
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i = 0, iLen = value.length; i < iLen; i++) {
        parts.push(`${key}=${escapeUri(value[i])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
function requestTimeout(timeoutInMs = 0) {
  return new Promise((resolve, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}
const keepAliveSupport = {
  supported: void 0
};
class FetchHttpHandler {
  static create(instanceOrOptions) {
    if (typeof (instanceOrOptions == null ? void 0 : instanceOrOptions.handle) === "function") {
      return instanceOrOptions;
    }
    return new FetchHttpHandler(instanceOrOptions);
  }
  constructor(options) {
    if (typeof options === "function") {
      this.configProvider = options().then((opts) => opts || {});
    } else {
      this.config = options ?? {};
      this.configProvider = Promise.resolve(this.config);
    }
    if (keepAliveSupport.supported === void 0) {
      keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"));
    }
  }
  destroy() {
  }
  async handle(request, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    const requestTimeoutInMs = this.config.requestTimeout;
    const keepAlive = this.config.keepAlive === true;
    const credentials = this.config.credentials;
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      const abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    let path = request.path;
    const queryString = buildQueryString(request.query || {});
    if (queryString) {
      path += `?${queryString}`;
    }
    if (request.fragment) {
      path += `#${request.fragment}`;
    }
    let auth2 = "";
    if (request.username != null || request.password != null) {
      const username = request.username ?? "";
      const password = request.password ?? "";
      auth2 = `${username}:${password}@`;
    }
    const { port, method } = request;
    const url = `${request.protocol}//${auth2}${request.hostname}${port ? `:${port}` : ""}${path}`;
    const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
    const requestOptions = {
      body,
      headers: new Headers(request.headers),
      method,
      credentials,
      cache: this.config.cache ?? "default"
    };
    if (body) {
      requestOptions.duplex = "half";
    }
    if (typeof AbortController !== "undefined") {
      requestOptions.signal = abortSignal;
    }
    if (keepAliveSupport.supported) {
      requestOptions.keepalive = keepAlive;
    }
    if (typeof this.config.requestInit === "function") {
      Object.assign(requestOptions, this.config.requestInit(request));
    }
    let removeSignalEventListener = () => {
    };
    const fetchRequest = new Request(url, requestOptions);
    const raceOfPromises = [
      fetch(fetchRequest).then((response) => {
        const fetchHeaders = response.headers;
        const transformedHeaders = {};
        for (const pair of fetchHeaders.entries()) {
          transformedHeaders[pair[0]] = pair[1];
        }
        const hasReadableStream = response.body != void 0;
        if (!hasReadableStream) {
          return response.blob().then((body2) => ({
            response: new HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: body2
            })
          }));
        }
        return {
          response: new HttpResponse({
            headers: transformedHeaders,
            reason: response.statusText,
            statusCode: response.status,
            body: response.body
          })
        };
      }),
      requestTimeout(requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise((resolve, reject) => {
        const onAbort = () => {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
        if (typeof abortSignal.addEventListener === "function") {
          const signal = abortSignal;
          signal.addEventListener("abort", onAbort, { once: true });
          removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
        } else {
          abortSignal.onabort = onAbort;
        }
      }));
    }
    return Promise.race(raceOfPromises).finally(removeSignalEventListener);
  }
  updateHttpClientConfig(key, value) {
    this.config = void 0;
    this.configProvider = this.configProvider.then((config2) => {
      config2[key] = value;
      return config2;
    });
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
const streamCollector = (stream) => {
  if (typeof Blob === "function" && stream instanceof Blob) {
    return collectBlob(stream);
  }
  return collectStream(stream);
};
async function collectBlob(blob) {
  const base64 = await readToBase64(blob);
  const arrayBuffer = fromBase64(base64);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  const chunks = [];
  const reader2 = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value } = await reader2.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset2 = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset2);
    offset2 += chunk.length;
  }
  return collected;
}
function readToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader2 = new FileReader();
    reader2.onloadend = () => {
      if (reader2.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = reader2.result ?? "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve(result.substring(dataOffset));
    };
    reader2.onabort = () => reject(new Error("Read aborted"));
    reader2.onerror = () => reject(reader2.error);
    reader2.readAsDataURL(blob);
  });
}
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
  let encodedByte = i.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = `0${encodedByte}`;
  }
  SHORT_TO_HEX[i] = encodedByte;
  HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i = 0; i < encoded.length; i += 2) {
    const encodedByte = encoded.slice(i, i + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes2) {
  let out = "";
  for (let i = 0; i < bytes2.byteLength; i++) {
    out += SHORT_TO_HEX[bytes2[i]];
  }
  return out;
}
const collectBody = async (streamBody = new Uint8Array(), context2) => {
  if (streamBody instanceof Uint8Array) {
    return Uint8ArrayBlobAdapter.mutate(streamBody);
  }
  if (!streamBody) {
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  }
  const fromContext = context2.streamCollector(streamBody);
  return Uint8ArrayBlobAdapter.mutate(await fromContext);
};
class Command {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder();
  }
  resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
    for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
      this.middlewareStack.use(mw);
    }
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      [SMITHY_CONTEXT_KEY]: {
        commandInstance: this,
        ...smithyContext
      },
      ...additionalContext
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
}
class ClassBuilder {
  constructor() {
    this._init = () => {
    };
    this._ep = {};
    this._middlewareFn = () => [];
    this._commandName = "";
    this._clientName = "";
    this._additionalContext = {};
    this._smithyContext = {};
    this._inputFilterSensitiveLog = (_) => _;
    this._outputFilterSensitiveLog = (_) => _;
    this._serializer = null;
    this._deserializer = null;
  }
  init(cb2) {
    this._init = cb2;
  }
  ep(endpointParameterInstructions) {
    this._ep = endpointParameterInstructions;
    return this;
  }
  m(middlewareSupplier) {
    this._middlewareFn = middlewareSupplier;
    return this;
  }
  s(service, operation, smithyContext = {}) {
    this._smithyContext = {
      service,
      operation,
      ...smithyContext
    };
    return this;
  }
  c(additionalContext = {}) {
    this._additionalContext = additionalContext;
    return this;
  }
  n(clientName, commandName) {
    this._clientName = clientName;
    this._commandName = commandName;
    return this;
  }
  f(inputFilter = (_) => _, outputFilter = (_) => _) {
    this._inputFilterSensitiveLog = inputFilter;
    this._outputFilterSensitiveLog = outputFilter;
    return this;
  }
  ser(serializer) {
    this._serializer = serializer;
    return this;
  }
  de(deserializer) {
    this._deserializer = deserializer;
    return this;
  }
  build() {
    const closure = this;
    let CommandRef;
    return CommandRef = class extends Command {
      static getEndpointParameterInstructions() {
        return closure._ep;
      }
      constructor(...[input2]) {
        super();
        this.serialize = closure._serializer;
        this.deserialize = closure._deserializer;
        this.input = input2 ?? {};
        closure._init(this);
      }
      resolveMiddleware(stack, configuration, options) {
        return this.resolveMiddlewareWithContext(stack, configuration, options, {
          CommandCtor: CommandRef,
          middlewareFn: closure._middlewareFn,
          clientName: closure._clientName,
          commandName: closure._commandName,
          inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
          outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
          smithyContext: closure._smithyContext,
          additionalContext: closure._additionalContext
        });
      }
    };
  }
}
const SENSITIVE_STRING = "***SensitiveInformation***";
class ServiceException extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
}
const decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v3]) => v3 !== void 0).forEach(([k2, v3]) => {
    if (exception[k2] == void 0 || exception[k2] === "") {
      exception[k2] = v3;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};
const throwDefaultError$1 = ({ output: output2, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata$1(output2);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: (parsedBody == null ? void 0 : parsedBody.code) || (parsedBody == null ? void 0 : parsedBody.Code) || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
  return ({ output: output2, parsedBody, errorCode }) => {
    throwDefaultError$1({ output: output2, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
};
const deserializeMetadata$1 = (output2) => ({
  httpStatusCode: output2.statusCode,
  requestId: output2.headers["x-amzn-requestid"] ?? output2.headers["x-amzn-request-id"] ?? output2.headers["x-amz-request-id"],
  extendedRequestId: output2.headers["x-amz-id-2"],
  cfId: output2.headers["x-amz-cf-id"]
});
const loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};
const getChecksumConfiguration = (runtimeConfig) => {
  const checksumAlgorithms = [];
  for (const id2 in AlgorithmId) {
    const algorithmId = AlgorithmId[id2];
    if (runtimeConfig[algorithmId] === void 0) {
      continue;
    }
    checksumAlgorithms.push({
      algorithmId: () => algorithmId,
      checksumConstructor: () => runtimeConfig[algorithmId]
    });
  }
  return {
    _checksumAlgorithms: checksumAlgorithms,
    addChecksumAlgorithm(algo) {
      this._checksumAlgorithms.push(algo);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
};
const resolveChecksumRuntimeConfig = (clientConfig) => {
  const runtimeConfig = {};
  clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
    runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
  });
  return runtimeConfig;
};
const getRetryConfiguration = (runtimeConfig) => {
  let _retryStrategy = runtimeConfig.retryStrategy;
  return {
    setRetryStrategy(retryStrategy) {
      _retryStrategy = retryStrategy;
    },
    retryStrategy() {
      return _retryStrategy;
    }
  };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
  const runtimeConfig = {};
  runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
  return runtimeConfig;
};
const getDefaultExtensionConfiguration = (runtimeConfig) => {
  return {
    ...getChecksumConfiguration(runtimeConfig),
    ...getRetryConfiguration(runtimeConfig)
  };
};
const resolveDefaultRuntimeConfig = (config2) => {
  return {
    ...resolveChecksumRuntimeConfig(config2),
    ...resolveRetryRuntimeConfig(config2)
  };
};
const StringWrapper = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);
const _json = (obj) => {
  if (obj == null) {
    return {};
  }
  if (Array.isArray(obj)) {
    return obj.filter((_) => _ != null).map(_json);
  }
  if (typeof obj === "object") {
    const target = {};
    for (const key of Object.keys(obj)) {
      if (obj[key] == null) {
        continue;
      }
      target[key] = _json(obj[key]);
    }
    return target;
  }
  return obj;
};
const isStreamingPayload = (request) => (request == null ? void 0 : request.body) instanceof ReadableStream;
const retryMiddleware = (options) => (next, context2) => async (args) => {
  var _a2;
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context2["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request } = args;
    const isRequest = HttpRequest.isInstance(request);
    if (isRequest) {
      request.headers[INVOCATION_ID_HEADER] = v4$1();
    }
    while (true) {
      try {
        if (isRequest) {
          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output: output2 } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output2.$metadata.attempts = attempts + 1;
        output2.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output: output2 };
      } catch (e2) {
        const retryErrorInfo = getRetryErrorInfo(e2);
        lastError = asSdkError(e2);
        if (isRequest && isStreamingPayload(request)) {
          (_a2 = context2.logger instanceof NoOpLogger ? console : context2.logger) == null ? void 0 : _a2.warn("An error was encountered in a non-retryable streaming request.");
          throw lastError;
        }
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay2 = retryToken.getRetryDelay();
        totalRetryDelay += delay2;
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy == null ? void 0 : retryStrategy.mode)
      context2.userAgent = [...context2.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error) => {
  const errorInfo = {
    error,
    errorType: getRetryErrorType(error)
  };
  const retryAfterHint = getRetryAfterHint(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
const getRetryErrorType = (error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
const retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
const getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
});
const getRetryAfterHint = (response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};
const httpSigningMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["HTTP_SIGNING"],
  name: "httpSigningMiddleware",
  aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
  override: true,
  relation: "after",
  toMiddleware: retryMiddlewareOptions.name
};
const getHttpSigningPlugin = (config2) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
  }
});
class DefaultIdentityProviderConfig {
  constructor(config2) {
    this.authSchemes = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(config2)) {
      if (value !== void 0) {
        this.authSchemes.set(key, value);
      }
    }
  }
  getIdentityProvider(schemeId) {
    return this.authSchemes.get(schemeId);
  }
}
class NoAuthSigner {
  async sign(httpRequest, identity, signingProperties) {
    return httpRequest;
  }
}
const createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
const EXPIRATION_MS = 3e5;
const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
const doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;
const memoizeIdentityProvider = (provider2, isExpired, requiresRefresh) => {
  if (provider2 === void 0) {
    return void 0;
  }
  const normalizedProvider = typeof provider2 !== "function" ? async () => Promise.resolve(provider2) : provider2;
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async (options) => {
    if (!pending) {
      pending = normalizedProvider(options);
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
        resolved = await coalesceProvider(options);
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
      resolved = await coalesceProvider(options);
    }
    if (isConstant) {
      return resolved;
    }
    if (!requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider(options);
      return resolved;
    }
    return resolved;
  };
};
const normalizeProvider = (input2) => {
  if (typeof input2 === "function")
    return input2;
  const promisified = Promise.resolve(input2);
  return () => promisified;
};
const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
const contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
const getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});
const getDateHeader = (response) => {
  var _a2, _b2;
  return HttpResponse.isInstance(response) ? ((_a2 = response.headers) == null ? void 0 : _a2.date) ?? ((_b2 = response.headers) == null ? void 0 : _b2.Date) : void 0;
};
const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
const isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};
const throwSigningPropertyError = (name2, property) => {
  if (!property) {
    throw new Error(`Property \`${name2}\` is not resolved for AWS SDK SigV4Auth`);
  }
  return property;
};
const validateSigningProperties = async (signingProperties) => {
  var _a2, _b2, _c2;
  const context2 = throwSigningPropertyError("context", signingProperties.context);
  const config2 = throwSigningPropertyError("config", signingProperties.config);
  const authScheme = (_c2 = (_b2 = (_a2 = context2.endpointV2) == null ? void 0 : _a2.properties) == null ? void 0 : _b2.authSchemes) == null ? void 0 : _c2[0];
  const signerFunction = throwSigningPropertyError("signer", config2.signer);
  const signer2 = await signerFunction(authScheme);
  const signingRegion = signingProperties == null ? void 0 : signingProperties.signingRegion;
  const signingRegionSet = signingProperties == null ? void 0 : signingProperties.signingRegionSet;
  const signingName = signingProperties == null ? void 0 : signingProperties.signingName;
  return {
    config: config2,
    signer: signer2,
    signingRegion,
    signingRegionSet,
    signingName
  };
};
class AwsSdkSigV4Signer {
  async sign(httpRequest, identity, signingProperties) {
    var _a2;
    if (!HttpRequest.isInstance(httpRequest)) {
      throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
    }
    const validatedProps = await validateSigningProperties(signingProperties);
    const { config: config2, signer: signer2 } = validatedProps;
    let { signingRegion, signingName } = validatedProps;
    const handlerExecutionContext = signingProperties.context;
    if (((_a2 = handlerExecutionContext == null ? void 0 : handlerExecutionContext.authSchemes) == null ? void 0 : _a2.length) ?? 0 > 1) {
      const [first, second] = handlerExecutionContext.authSchemes;
      if ((first == null ? void 0 : first.name) === "sigv4a" && (second == null ? void 0 : second.name) === "sigv4") {
        signingRegion = (second == null ? void 0 : second.signingRegion) ?? signingRegion;
        signingName = (second == null ? void 0 : second.signingName) ?? signingName;
      }
    }
    const signedRequest = await signer2.sign(httpRequest, {
      signingDate: getSkewCorrectedDate(config2.systemClockOffset),
      signingRegion,
      signingService: signingName
    });
    return signedRequest;
  }
  errorHandler(signingProperties) {
    return (error) => {
      const serverTime = error.ServerTime ?? getDateHeader(error.$response);
      if (serverTime) {
        const config2 = throwSigningPropertyError("config", signingProperties.config);
        const initialSystemClockOffset = config2.systemClockOffset;
        config2.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config2.systemClockOffset);
        const clockSkewCorrected = config2.systemClockOffset !== initialSystemClockOffset;
        if (clockSkewCorrected && error.$metadata) {
          error.$metadata.clockSkewCorrected = true;
        }
      }
      throw error;
    };
  }
  successHandler(httpResponse, signingProperties) {
    const dateHeader = getDateHeader(httpResponse);
    if (dateHeader) {
      const config2 = throwSigningPropertyError("config", signingProperties.config);
      config2.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config2.systemClockOffset);
    }
  }
}
const memoize = (provider2, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider2();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  {
    return async (options) => {
      if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
};
const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
const AUTH_HEADER = "authorization";
const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
const DATE_HEADER = "date";
const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
const SHA256_HEADER = "x-amz-content-sha256";
const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
const ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
const PROXY_HEADER_PATTERN = /^proxy-/;
const SEC_HEADER_PATTERN = /^sec-/;
const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
const MAX_CACHE_SIZE = 50;
const KEY_TYPE_IDENTIFIER = "aws4_request";
const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
  const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
  const cacheKey2 = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
  if (cacheKey2 in signingKeyCache) {
    return signingKeyCache[cacheKey2];
  }
  cacheQueue.push(cacheKey2);
  while (cacheQueue.length > MAX_CACHE_SIZE) {
    delete signingKeyCache[cacheQueue.shift()];
  }
  let key = `AWS4${credentials.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
    key = await hmac(sha256Constructor, key, signable);
  }
  return signingKeyCache[cacheKey2] = key;
};
const hmac = (ctor, secret, data) => {
  const hash2 = new ctor(secret);
  hash2.update(toUint8Array(data));
  return hash2.digest();
};
const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders == null ? void 0 : unsignableHeaders.has(canonicalHeaderName)) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};
const getCanonicalQuery = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key of Object.keys(query).sort()) {
    if (key.toLowerCase() === SIGNATURE_HEADER) {
      continue;
    }
    keys.push(key);
    const value = query[key];
    if (typeof value === "string") {
      serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).sort().join("&");
    }
  }
  return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
};
const isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
const getPayloadHash = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER) {
      return headers[headerName];
    }
  }
  if (body == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array(body));
    return toHex(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD;
};
class HeaderFormatter {
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes2 = fromUtf8$2(headerName);
      chunks.push(Uint8Array.from([bytes2.byteLength]), bytes2, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes2) => carry + bytes2.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = fromUtf8$2(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
}
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE2) {
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
class Int64 {
  constructor(bytes2) {
    this.bytes = bytes2;
    if (bytes2.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number2) {
    if (number2 > 9223372036854776e3 || number2 < -9223372036854776e3) {
      throw new Error(`${number2} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes2 = new Uint8Array(8);
    for (let i = 7, remaining = Math.abs(Math.round(number2)); i > -1 && remaining > 0; i--, remaining /= 256) {
      bytes2[i] = remaining;
    }
    if (number2 < 0) {
      negate(bytes2);
    }
    return new Int64(bytes2);
  }
  valueOf() {
    const bytes2 = this.bytes.slice(0);
    const negative = bytes2[0] & 128;
    if (negative) {
      negate(bytes2);
    }
    return parseInt(toHex(bytes2), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function negate(bytes2) {
  for (let i = 0; i < 8; i++) {
    bytes2[i] ^= 255;
  }
  for (let i = 7; i > -1; i--) {
    bytes2[i]++;
    if (bytes2[i] !== 0)
      break;
  }
}
const hasHeader = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};
const moveHeadersToQuery = (request, options = {}) => {
  var _a2;
  const { headers, query = {} } = HttpRequest.clone(request);
  for (const name2 of Object.keys(headers)) {
    const lname = name2.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !((_a2 = options.unhoistableHeaders) == null ? void 0 : _a2.has(lname))) {
      query[name2] = headers[name2];
      delete headers[name2];
    }
  }
  return {
    ...request,
    headers,
    query
  };
};
const prepareRequest = (request) => {
  request = HttpRequest.clone(request);
  for (const headerName of Object.keys(request.headers)) {
    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
      delete request.headers[headerName];
    }
  }
  return request;
};
const iso8601 = (time2) => toDate(time2).toISOString().replace(/\.\d{3}Z$/, "Z");
const toDate = (time2) => {
  if (typeof time2 === "number") {
    return new Date(time2 * 1e3);
  }
  if (typeof time2 === "string") {
    if (Number(time2)) {
      return new Date(Number(time2) * 1e3);
    }
    return new Date(time2);
  }
  return time2;
};
class SignatureV4 {
  constructor({ applyChecksum, credentials, region, service, sha256: sha2562, uriEscapePath = true }) {
    this.headerFormatter = new HeaderFormatter();
    this.service = service;
    this.sha256 = sha2562;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider$1(region);
    this.credentialProvider = normalizeProvider$1(credentials);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
    if (credentials.sessionToken) {
      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
    }
    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
    request.query[AMZ_DATE_QUERY_PARAM] = longDate;
    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
    return request;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else if (toSign.message) {
      return this.signMessage(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
    const hash2 = new this.sha256();
    hash2.update(headers);
    const hashedHeaders = toHex(await hash2.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
    const promise = this.signEvent({
      headers: this.headerFormatter.format(signableMessage.message.headers),
      payload: signableMessage.message.body
    }, {
      signingDate,
      signingRegion,
      signingService,
      priorSignature: signableMessage.priorSignature
    });
    return promise.then((signature2) => {
      return { message: signableMessage.message, signature: signature2 };
    });
  }
  async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate(signingDate);
    const hash2 = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const request = prepareRequest(requestToSign);
    const { longDate, shortDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    request.headers[AMZ_DATE_HEADER] = longDate;
    if (credentials.sessionToken) {
      request.headers[TOKEN_HEADER] = credentials.sessionToken;
    }
    const payloadHash = await getPayloadHash(request, this.sha256);
    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
      request.headers[SHA256_HEADER] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    const signature2 = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature2}`;
    return request;
  }
  createCanonicalRequest(request, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name2) => `${name2}:${canonicalHeaders[name2]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash2 = new this.sha256();
    hash2.update(toUint8Array(canonicalRequest));
    const hashedRequest = await hash2.digest();
    return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
  }
  getCanonicalPath({ path }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path.split("/")) {
        if ((pathSegment == null ? void 0 : pathSegment.length) === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${(path == null ? void 0 : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path == null ? void 0 : path.endsWith("/")) ? "/" : ""}`;
      const doubleEncoded = escapeUri(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash2 = new this.sha256(await keyPromise);
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  getSigningKey(credentials, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials) {
    if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
}
const formatDate = (now) => {
  const longDate = iso8601(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");
const resolveAwsSdkSigV4Config = (config2) => {
  let normalizedCreds;
  if (config2.credentials) {
    normalizedCreds = memoizeIdentityProvider(config2.credentials, isIdentityExpired, doesIdentityRequireRefresh);
  }
  if (!normalizedCreds) {
    if (config2.credentialDefaultProvider) {
      normalizedCreds = normalizeProvider(config2.credentialDefaultProvider(Object.assign({}, config2, {
        parentClientConfig: config2
      })));
    } else {
      normalizedCreds = async () => {
        throw new Error("`credentials` is missing");
      };
    }
  }
  const { signingEscapePath = true, systemClockOffset = config2.systemClockOffset || 0, sha256: sha2562 } = config2;
  let signer2;
  if (config2.signer) {
    signer2 = normalizeProvider(config2.signer);
  } else if (config2.regionInfoProvider) {
    signer2 = () => normalizeProvider(config2.region)().then(async (region) => [
      await config2.regionInfoProvider(region, {
        useFipsEndpoint: await config2.useFipsEndpoint(),
        useDualstackEndpoint: await config2.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      config2.signingRegion = config2.signingRegion || signingRegion || region;
      config2.signingName = config2.signingName || signingService || config2.serviceId;
      const params = {
        ...config2,
        credentials: normalizedCreds,
        region: config2.signingRegion,
        service: config2.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config2.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    });
  } else {
    signer2 = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: config2.signingName || config2.defaultSigningName,
        signingRegion: await normalizeProvider(config2.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      config2.signingRegion = config2.signingRegion || signingRegion;
      config2.signingName = config2.signingName || signingService || config2.serviceId;
      const params = {
        ...config2,
        credentials: normalizedCreds,
        region: config2.signingRegion,
        service: config2.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config2.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    };
  }
  return {
    ...config2,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer: signer2
  };
};
const collectBodyString = (streamBody, context2) => collectBody(streamBody, context2).then((body) => context2.utf8Encoder(body));
const parseJsonBody = (streamBody, context2) => collectBodyString(streamBody, context2).then((encoded) => {
  if (encoded.length) {
    try {
      return JSON.parse(encoded);
    } catch (e2) {
      if ((e2 == null ? void 0 : e2.name) === "SyntaxError") {
        Object.defineProperty(e2, "$responseBodyText", {
          value: encoded
        });
      }
      throw e2;
    }
  }
  return {};
});
const parseJsonErrorBody = async (errorBody, context2) => {
  const value = await parseJsonBody(errorBody, context2);
  value.message = value.message ?? value.Message;
  return value;
};
const loadRestJsonErrorCode = (output2, data) => {
  const findKey = (object2, key) => Object.keys(object2).find((k2) => k2.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output2.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output2.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};
const defaultCognitoIdentityProviderHttpAuthSchemeParametersProvider = async (config2, context2, input2) => {
  return {
    operation: getSmithyContext(context2).operation,
    region: await normalizeProvider$1(config2.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "cognito-idp",
      region: authParameters.region
    },
    propertiesExtractor: (config2, context2) => ({
      signingProperties: {
        config: config2,
        context: context2
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
const defaultCognitoIdentityProviderHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "AssociateSoftwareToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ChangePassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ConfirmDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ConfirmForgotPassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ConfirmSignUp": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "DeleteUser": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "DeleteUserAttributes": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ForgetDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ForgotPassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GetDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GetUser": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GetUserAttributeVerificationCode": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GlobalSignOut": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "InitiateAuth": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ListDevices": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ResendConfirmationCode": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "RespondToAuthChallenge": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "RevokeToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "SetUserMFAPreference": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "SetUserSettings": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "SignUp": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "UpdateAuthEventFeedback": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "UpdateDeviceStatus": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "UpdateUserAttributes": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "VerifySoftwareToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "VerifyUserAttribute": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
    }
  }
  return options;
};
const resolveHttpAuthSchemeConfig = (config2) => {
  const config_0 = resolveAwsSdkSigV4Config(config2);
  return {
    ...config_0
  };
};
const resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "cognito-idp"
  };
};
const commonParams = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
const name = "@aws-sdk/client-cognito-identity-provider";
const description = "AWS SDK for JavaScript Cognito Identity Provider Client for Node.js, Browser and React Native";
const version = "3.654.0";
const scripts = {
  build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
  "build:cjs": "node ../../scripts/compilation/inline client-cognito-identity-provider",
  "build:es": "tsc -p tsconfig.es.json",
  "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
  "build:types": "tsc -p tsconfig.types.json",
  "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
  clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
  "extract:docs": "api-extractor run --local",
  "generate:client": "node ../../scripts/generate-clients/single-service --solo cognito-identity-provider"
};
const main = "./dist-cjs/index.js";
const types = "./dist-types/index.d.ts";
const module = "./dist-es/index.js";
const sideEffects = false;
const dependencies = {
  "@aws-crypto/sha256-browser": "5.2.0",
  "@aws-crypto/sha256-js": "5.2.0",
  "@aws-sdk/client-sso-oidc": "3.654.0",
  "@aws-sdk/client-sts": "3.654.0",
  "@aws-sdk/core": "3.654.0",
  "@aws-sdk/credential-provider-node": "3.654.0",
  "@aws-sdk/middleware-host-header": "3.654.0",
  "@aws-sdk/middleware-logger": "3.654.0",
  "@aws-sdk/middleware-recursion-detection": "3.654.0",
  "@aws-sdk/middleware-user-agent": "3.654.0",
  "@aws-sdk/region-config-resolver": "3.654.0",
  "@aws-sdk/types": "3.654.0",
  "@aws-sdk/util-endpoints": "3.654.0",
  "@aws-sdk/util-user-agent-browser": "3.654.0",
  "@aws-sdk/util-user-agent-node": "3.654.0",
  "@smithy/config-resolver": "^3.0.8",
  "@smithy/core": "^2.4.3",
  "@smithy/fetch-http-handler": "^3.2.7",
  "@smithy/hash-node": "^3.0.6",
  "@smithy/invalid-dependency": "^3.0.6",
  "@smithy/middleware-content-length": "^3.0.8",
  "@smithy/middleware-endpoint": "^3.1.3",
  "@smithy/middleware-retry": "^3.0.18",
  "@smithy/middleware-serde": "^3.0.6",
  "@smithy/middleware-stack": "^3.0.6",
  "@smithy/node-config-provider": "^3.1.7",
  "@smithy/node-http-handler": "^3.2.2",
  "@smithy/protocol-http": "^4.1.3",
  "@smithy/smithy-client": "^3.3.2",
  "@smithy/types": "^3.4.2",
  "@smithy/url-parser": "^3.0.6",
  "@smithy/util-base64": "^3.0.0",
  "@smithy/util-body-length-browser": "^3.0.0",
  "@smithy/util-body-length-node": "^3.0.0",
  "@smithy/util-defaults-mode-browser": "^3.0.18",
  "@smithy/util-defaults-mode-node": "^3.0.18",
  "@smithy/util-endpoints": "^2.1.2",
  "@smithy/util-middleware": "^3.0.6",
  "@smithy/util-retry": "^3.0.6",
  "@smithy/util-utf8": "^3.0.0",
  tslib: "^2.6.2"
};
const devDependencies = {
  "@tsconfig/node16": "16.1.3",
  "@types/node": "^16.18.96",
  concurrently: "7.0.0",
  "downlevel-dts": "0.10.1",
  rimraf: "3.0.2",
  typescript: "~4.9.5"
};
const engines = {
  node: ">=16.0.0"
};
const typesVersions = {
  "<4.0": {
    "dist-types/*": [
      "dist-types/ts3.4/*"
    ]
  }
};
const files = [
  "dist-*/**"
];
const author = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
};
const license = "Apache-2.0";
const browser = {
  "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
const homepage = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity-provider";
const repository = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-cognito-identity-provider"
};
const packageInfo = {
  name,
  description,
  version,
  scripts,
  main,
  types,
  module,
  sideEffects,
  dependencies,
  devDependencies,
  engines,
  typesVersions,
  files,
  author,
  license,
  browser,
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage,
  repository
};
const fromUtf8$1 = (input2) => new TextEncoder().encode(input2);
var fromUtf8 = typeof Buffer2 !== "undefined" && Buffer2.from ? function(input2) {
  return Buffer2.from(input2, "utf8");
} : fromUtf8$1;
function convertToBuffer(data) {
  if (data instanceof Uint8Array)
    return data;
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
var SHA_256_HASH = { name: "SHA-256" };
var SHA_256_HMAC_ALGO = {
  name: "HMAC",
  hash: SHA_256_HASH
};
var EMPTY_DATA_SHA_256 = new Uint8Array([
  227,
  176,
  196,
  66,
  152,
  252,
  28,
  20,
  154,
  251,
  244,
  200,
  153,
  111,
  185,
  36,
  39,
  174,
  65,
  228,
  100,
  155,
  147,
  76,
  164,
  149,
  153,
  27,
  120,
  82,
  184,
  85
]);
const fallbackWindow = {};
function locateWindow() {
  if (typeof window !== "undefined") {
    return window;
  } else if (typeof self !== "undefined") {
    return self;
  }
  return fallbackWindow;
}
var Sha256$2 = (
  /** @class */
  function() {
    function Sha2562(secret) {
      this.toHash = new Uint8Array(0);
      this.secret = secret;
      this.reset();
    }
    Sha2562.prototype.update = function(data) {
      if (isEmptyData(data)) {
        return;
      }
      var update = convertToBuffer(data);
      var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
      typedArray.set(this.toHash, 0);
      typedArray.set(update, this.toHash.byteLength);
      this.toHash = typedArray;
    };
    Sha2562.prototype.digest = function() {
      var _this = this;
      if (this.key) {
        return this.key.then(function(key) {
          return locateWindow().crypto.subtle.sign(SHA_256_HMAC_ALGO, key, _this.toHash).then(function(data) {
            return new Uint8Array(data);
          });
        });
      }
      if (isEmptyData(this.toHash)) {
        return Promise.resolve(EMPTY_DATA_SHA_256);
      }
      return Promise.resolve().then(function() {
        return locateWindow().crypto.subtle.digest(SHA_256_HASH, _this.toHash);
      }).then(function(data) {
        return Promise.resolve(new Uint8Array(data));
      });
    };
    Sha2562.prototype.reset = function() {
      var _this = this;
      this.toHash = new Uint8Array(0);
      if (this.secret && this.secret !== void 0) {
        this.key = new Promise(function(resolve, reject) {
          locateWindow().crypto.subtle.importKey("raw", convertToBuffer(_this.secret), SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
        });
        this.key.catch(function() {
        });
      }
    };
    return Sha2562;
  }()
);
var BLOCK_SIZE = 64;
var DIGEST_LENGTH = 32;
var KEY = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var INIT = [
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
];
var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
var RawSha256 = (
  /** @class */
  function() {
    function RawSha2562() {
      this.state = Int32Array.from(INIT);
      this.temp = new Int32Array(64);
      this.buffer = new Uint8Array(64);
      this.bufferLength = 0;
      this.bytesHashed = 0;
      this.finished = false;
    }
    RawSha2562.prototype.update = function(data) {
      if (this.finished) {
        throw new Error("Attempted to update an already finished hash.");
      }
      var position = 0;
      var byteLength2 = data.byteLength;
      this.bytesHashed += byteLength2;
      if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
        throw new Error("Cannot hash more than 2^53 - 1 bits");
      }
      while (byteLength2 > 0) {
        this.buffer[this.bufferLength++] = data[position++];
        byteLength2--;
        if (this.bufferLength === BLOCK_SIZE) {
          this.hashBuffer();
          this.bufferLength = 0;
        }
      }
    };
    RawSha2562.prototype.digest = function() {
      if (!this.finished) {
        var bitsHashed = this.bytesHashed * 8;
        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        var undecoratedLength = this.bufferLength;
        bufferView.setUint8(this.bufferLength++, 128);
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
          for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
            bufferView.setUint8(i, 0);
          }
          this.hashBuffer();
          this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
          bufferView.setUint8(i, 0);
        }
        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
        this.hashBuffer();
        this.finished = true;
      }
      var out = new Uint8Array(DIGEST_LENGTH);
      for (var i = 0; i < 8; i++) {
        out[i * 4] = this.state[i] >>> 24 & 255;
        out[i * 4 + 1] = this.state[i] >>> 16 & 255;
        out[i * 4 + 2] = this.state[i] >>> 8 & 255;
        out[i * 4 + 3] = this.state[i] >>> 0 & 255;
      }
      return out;
    };
    RawSha2562.prototype.hashBuffer = function() {
      var _a2 = this, buffer2 = _a2.buffer, state = _a2.state;
      var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
      for (var i = 0; i < BLOCK_SIZE; i++) {
        if (i < 16) {
          this.temp[i] = (buffer2[i * 4] & 255) << 24 | (buffer2[i * 4 + 1] & 255) << 16 | (buffer2[i * 4 + 2] & 255) << 8 | buffer2[i * 4 + 3] & 255;
        } else {
          var u2 = this.temp[i - 2];
          var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
          u2 = this.temp[i - 15];
          var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
          this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
        }
        var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i] + this.temp[i] | 0) | 0) | 0;
        var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
        state7 = state6;
        state6 = state5;
        state5 = state4;
        state4 = state3 + t1 | 0;
        state3 = state2;
        state2 = state1;
        state1 = state0;
        state0 = t1 + t2 | 0;
      }
      state[0] += state0;
      state[1] += state1;
      state[2] += state2;
      state[3] += state3;
      state[4] += state4;
      state[5] += state5;
      state[6] += state6;
      state[7] += state7;
    };
    return RawSha2562;
  }()
);
var Sha256$1 = (
  /** @class */
  function() {
    function Sha2562(secret) {
      this.secret = secret;
      this.hash = new RawSha256();
      this.reset();
    }
    Sha2562.prototype.update = function(toHash) {
      if (isEmptyData(toHash) || this.error) {
        return;
      }
      try {
        this.hash.update(convertToBuffer(toHash));
      } catch (e2) {
        this.error = e2;
      }
    };
    Sha2562.prototype.digestSync = function() {
      if (this.error) {
        throw this.error;
      }
      if (this.outer) {
        if (!this.outer.finished) {
          this.outer.update(this.hash.digest());
        }
        return this.outer.digest();
      }
      return this.hash.digest();
    };
    Sha2562.prototype.digest = function() {
      return __awaiter$1(this, void 0, void 0, function() {
        return __generator$1(this, function(_a2) {
          return [2, this.digestSync()];
        });
      });
    };
    Sha2562.prototype.reset = function() {
      this.hash = new RawSha256();
      if (this.secret) {
        this.outer = new RawSha256();
        var inner = bufferFromSecret(this.secret);
        var outer = new Uint8Array(BLOCK_SIZE);
        outer.set(inner);
        for (var i = 0; i < BLOCK_SIZE; i++) {
          inner[i] ^= 54;
          outer[i] ^= 92;
        }
        this.hash.update(inner);
        this.outer.update(outer);
        for (var i = 0; i < inner.byteLength; i++) {
          inner[i] = 0;
        }
      }
    };
    return Sha2562;
  }()
);
function bufferFromSecret(secret) {
  var input2 = convertToBuffer(secret);
  if (input2.byteLength > BLOCK_SIZE) {
    var bufferHash = new RawSha256();
    bufferHash.update(input2);
    input2 = bufferHash.digest();
  }
  var buffer2 = new Uint8Array(BLOCK_SIZE);
  buffer2.set(input2);
  return buffer2;
}
var subtleCryptoMethods = [
  "decrypt",
  "digest",
  "encrypt",
  "exportKey",
  "generateKey",
  "importKey",
  "sign",
  "verify"
];
function supportsWebCrypto(window2) {
  if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
    var subtle = window2.crypto.subtle;
    return supportsSubtleCrypto(subtle);
  }
  return false;
}
function supportsSecureRandom(window2) {
  if (typeof window2 === "object" && typeof window2.crypto === "object") {
    var getRandomValues2 = window2.crypto.getRandomValues;
    return typeof getRandomValues2 === "function";
  }
  return false;
}
function supportsSubtleCrypto(subtle) {
  return subtle && subtleCryptoMethods.every(function(methodName) {
    return typeof subtle[methodName] === "function";
  });
}
var Sha256 = (
  /** @class */
  function() {
    function Sha2562(secret) {
      if (supportsWebCrypto(locateWindow())) {
        this.hash = new Sha256$2(secret);
      } else {
        this.hash = new Sha256$1(secret);
      }
    }
    Sha2562.prototype.update = function(data, encoding) {
      this.hash.update(convertToBuffer(data));
    };
    Sha2562.prototype.digest = function() {
      return this.hash.digest();
    };
    Sha2562.prototype.reset = function() {
      this.hash.reset();
    };
    return Sha2562;
  }()
);
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
const BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
const PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
const OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
const ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua2) {
    const match = ua2.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua2) {
    const match = ua2.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua2, _const) {
    if (regexp.test(ua2)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version2) {
    switch (version2) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version2) {
    const v3 = version2.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v3.push(0);
    if (v3[0] !== 10) return void 0;
    switch (v3[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version2) {
    const v3 = version2.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v3.push(0);
    if (v3[0] === 1 && v3[1] < 5) return void 0;
    if (v3[0] === 1 && v3[1] < 6) return "Cupcake";
    if (v3[0] === 1 && v3[1] >= 6) return "Donut";
    if (v3[0] === 2 && v3[1] < 2) return "Eclair";
    if (v3[0] === 2 && v3[1] === 2) return "Froyo";
    if (v3[0] === 2 && v3[1] > 2) return "Gingerbread";
    if (v3[0] === 3) return "Honeycomb";
    if (v3[0] === 4 && v3[1] < 1) return "Ice Cream Sandwich";
    if (v3[0] === 4 && v3[1] < 4) return "Jelly Bean";
    if (v3[0] === 4 && v3[1] >= 4) return "KitKat";
    if (v3[0] === 5) return "Lollipop";
    if (v3[0] === 6) return "Marshmallow";
    if (v3[0] === 7) return "Nougat";
    if (v3[0] === 8) return "Oreo";
    if (v3[0] === 9) return "Pie";
    return void 0;
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version2) {
    return version2.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = Utils.getVersionPrecision(versionA);
    const versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version2) => {
      const delta = precision - Utils.getVersionPrecision(version2);
      const _version = version2 + new Array(delta + 1).join(".0");
      return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i += 1) {
      result.push(iterator(arr[i]));
    }
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i = 0, l2 = arr.length; i < l2; i += 1) {
      const value = arr[i];
      if (predicate(value, i)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i;
    let l2;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i = 0, l2 = assigners.length; i < l2; i += 1) {
      const assigner = assigners[i];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
const browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua2) {
      const browser2 = {
        name: "Googlebot"
      };
      const version2 = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Samsung Internet for Android"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Whale/i],
    describe(ua2) {
      const browser2 = {
        name: "NAVER Whale Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "MZ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/focus/i],
    describe(ua2) {
      const browser2 = {
        name: "Focus"
      };
      const version2 = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/swing/i],
    describe(ua2) {
      const browser2 = {
        name: "Swing"
      };
      const version2 = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/coast/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera Coast"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera Touch"
      };
      const version2 = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Yandex Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "UC Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua2) {
      const browser2 = {
        name: "Maxthon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua2) {
      const browser2 = {
        name: "Epiphany"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/puffin/i],
    describe(ua2) {
      const browser2 = {
        name: "Puffin"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua2) {
      const browser2 = {
        name: "Sleipnir"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua2) {
      const browser2 = {
        name: "K-Meleon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua2) {
      const browser2 = {
        name: "WeChat"
      };
      const version2 = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua2) {
      const browser2 = {
        name: /qqbrowserlite/i.test(ua2) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua2) {
      const browser2 = {
        name: "Internet Explorer"
      };
      const version2 = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua2) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua2) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua2) {
      const browser2 = {
        name: "Vivaldi"
      };
      const version2 = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua2) {
      const browser2 = {
        name: "SeaMonkey"
      };
      const version2 = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua2) {
      const browser2 = {
        name: "Sailfish"
      };
      const version2 = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/silk/i],
    describe(ua2) {
      const browser2 = {
        name: "Amazon Silk"
      };
      const version2 = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/phantom/i],
    describe(ua2) {
      const browser2 = {
        name: "PhantomJS"
      };
      const version2 = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua2) {
      const browser2 = {
        name: "SlimerJS"
      };
      const version2 = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua2) {
      const browser2 = {
        name: "BlackBerry"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua2) {
      const browser2 = {
        name: "WebOS Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/bada/i],
    describe(ua2) {
      const browser2 = {
        name: "Bada"
      };
      const version2 = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/tizen/i],
    describe(ua2) {
      const browser2 = {
        name: "Tizen"
      };
      const version2 = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua2) {
      const browser2 = {
        name: "QupZilla"
      };
      const version2 = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua2) {
      const browser2 = {
        name: "Firefox"
      };
      const version2 = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/electron/i],
    describe(ua2) {
      const browser2 = {
        name: "Electron"
      };
      const version2 = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Miui"
      };
      const version2 = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chromium/i],
    describe(ua2) {
      const browser2 = {
        name: "Chromium"
      };
      const version2 = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua2) {
      const browser2 = {
        name: "Chrome"
      };
      const version2 = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/GSA/i],
    describe(ua2) {
      const browser2 = {
        name: "Google Search"
      };
      const version2 = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua2) {
      const browser2 = {
        name: "Android Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua2) {
      const browser2 = {
        name: "PlayStation 4"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua2) {
      const browser2 = {
        name: "Safari"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua2) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua2.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua2),
        version: Utils.getSecondMatch(regexp, ua2)
      };
    }
  }
];
const osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua2);
      return {
        name: OS_MAP.Roku,
        version: version2
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.WindowsPhone,
        version: version2
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua2);
      const versionName = Utils.getWindowsVersionName(version2);
      return {
        name: OS_MAP.Windows,
        version: version2,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua2) {
      const result = {
        name: OS_MAP.iOS
      };
      const version2 = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua2);
      if (version2) {
        result.version = version2;
      }
      return result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua2).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version2);
      const os = {
        name: OS_MAP.MacOS,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua2).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: version2
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua2);
      const versionName = Utils.getAndroidVersionName(version2);
      const os = {
        name: OS_MAP.Android,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua2);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version2 && version2.length) {
        os.version = version2;
      }
      return os;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua2) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua2) || Utils.getFirstMatch(/\bbb(\d+)/i, ua2);
      return {
        name: OS_MAP.BlackBerry,
        version: version2
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.Bada,
        version: version2
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.Tizen,
        version: version2
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.PlayStation4,
        version: version2
      };
    }
  }
];
const platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua2) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua2) && "Nova";
      const platform2 = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform2.model = model;
      }
      return platform2;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua2) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua2);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];
const enginesParsersList = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua2) {
      const isBlinkBased = /\sedg\//i.test(ua2);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version2 = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua2);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: version2
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version2 = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version2 = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version2 = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version2 = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(browsersList, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(osParsersList, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name: name2 } = this.getOS();
    if (toLowerCase) {
      return String(name2).toLowerCase() || "";
    }
    return name2 || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform2 = Utils.find(platformParsersList, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform2) {
      this.parsedResult.platform = platform2.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isOS(name2));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name2) => this.isPlatform(name2)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name2) => this.isBrowser(name2, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version2) {
    let expectedResults = [0];
    let comparableVersion = version2;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version2[0] === ">" || version2[0] === "<") {
      comparableVersion = version2.substr(1);
      if (version2[1] === "=") {
        isLoose = true;
        comparableVersion = version2.substr(2);
      } else {
        expectedResults = [];
      }
      if (version2[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version2[0] === "=") {
      comparableVersion = version2.substr(1);
    } else if (version2[0] === "~") {
      isLoose = true;
      comparableVersion = version2.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new Parser(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new Parser(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
const defaultUserAgent = ({ serviceId, clientVersion }) => async () => {
  var _a2, _b2, _c2, _d2, _e2;
  const parsedUA = typeof window !== "undefined" && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0;
  const sections = [
    ["aws-sdk-js", clientVersion],
    ["ua", "2.0"],
    [`os/${((_b2 = parsedUA == null ? void 0 : parsedUA.os) == null ? void 0 : _b2.name) || "other"}`, (_c2 = parsedUA == null ? void 0 : parsedUA.os) == null ? void 0 : _c2.version],
    ["lang/js"],
    ["md/browser", `${((_d2 = parsedUA == null ? void 0 : parsedUA.browser) == null ? void 0 : _d2.name) ?? "unknown"}_${((_e2 = parsedUA == null ? void 0 : parsedUA.browser) == null ? void 0 : _e2.version) ?? "unknown"}`]
  ];
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  return sections;
};
const invalidProvider = (message) => () => Promise.reject(message);
const TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
const calculateBodyLength = (body) => {
  if (typeof body === "string") {
    if (TEXT_ENCODER) {
      return TEXT_ENCODER.encode(body).byteLength;
    }
    let len = body.length;
    for (let i = len - 1; i >= 0; i--) {
      const code2 = body.charCodeAt(i);
      if (code2 > 127 && code2 <= 2047)
        len++;
      else if (code2 > 2047 && code2 <= 65535)
        len += 2;
      if (code2 >= 56320 && code2 <= 57343)
        i--;
    }
    return len;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};
const s = "required", t = "fn", u = "argv", v = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = { [s]: false, "type": "String" }, i$1 = { [s]: true, "default": false, "type": "Boolean" }, j = { [v]: "Endpoint" }, k = { [t]: c, [u]: [{ [v]: "UseFIPS" }, true] }, l = { [t]: c, [u]: [{ [v]: "UseDualStack" }, true] }, m = {}, n = { [t]: "getAttr", [u]: [{ [v]: g }, "supportsFIPS"] }, o = { [t]: c, [u]: [true, { [t]: "getAttr", [u]: [{ [v]: g }, "supportsDualStack"] }] }, p = [k], q = [l], r = [{ [v]: "Region" }];
const _data = { version: "1.0", parameters: { Region: h, UseDualStack: i$1, UseFIPS: i$1, Endpoint: h }, rules: [{ conditions: [{ [t]: b, [u]: [j] }], rules: [{ conditions: p, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: q, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: j, properties: m, headers: m }, type: e }], type: f }, { conditions: [{ [t]: b, [u]: r }], rules: [{ conditions: [{ [t]: "aws.partition", [u]: r, assign: g }], rules: [{ conditions: [k, l], rules: [{ conditions: [{ [t]: c, [u]: [a, n] }, o], rules: [{ endpoint: { url: "https://cognito-idp-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: p, rules: [{ conditions: [{ [t]: c, [u]: [n, a] }], rules: [{ endpoint: { url: "https://cognito-idp-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: q, rules: [{ conditions: [o], rules: [{ endpoint: { url: "https://cognito-idp.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://cognito-idp.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;
const cache = new EndpointCache({
  size: 50,
  params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
});
const defaultEndpointResolver = (endpointParams, context2 = {}) => {
  return cache.get(endpointParams, () => resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context2.logger
  }));
};
customEndpointFunctions.aws = awsEndpointFunctions;
const getRuntimeConfig$1 = (config2) => {
  return {
    apiVersion: "2016-04-18",
    base64Decoder: (config2 == null ? void 0 : config2.base64Decoder) ?? fromBase64,
    base64Encoder: (config2 == null ? void 0 : config2.base64Encoder) ?? toBase64,
    disableHostPrefix: (config2 == null ? void 0 : config2.disableHostPrefix) ?? false,
    endpointProvider: (config2 == null ? void 0 : config2.endpointProvider) ?? defaultEndpointResolver,
    extensions: (config2 == null ? void 0 : config2.extensions) ?? [],
    httpAuthSchemeProvider: (config2 == null ? void 0 : config2.httpAuthSchemeProvider) ?? defaultCognitoIdentityProviderHttpAuthSchemeProvider,
    httpAuthSchemes: (config2 == null ? void 0 : config2.httpAuthSchemes) ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new AwsSdkSigV4Signer()
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new NoAuthSigner()
      }
    ],
    logger: (config2 == null ? void 0 : config2.logger) ?? new NoOpLogger(),
    serviceId: (config2 == null ? void 0 : config2.serviceId) ?? "Cognito Identity Provider",
    urlParser: (config2 == null ? void 0 : config2.urlParser) ?? parseUrl,
    utf8Decoder: (config2 == null ? void 0 : config2.utf8Decoder) ?? fromUtf8$2,
    utf8Encoder: (config2 == null ? void 0 : config2.utf8Encoder) ?? toUtf8
  };
};
const DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
const resolveDefaultsModeConfig = ({ defaultsMode } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode == null ? void 0 : mode.toLowerCase()) {
    case "auto":
      return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(mode == null ? void 0 : mode.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
});
const isMobileBrowser = () => {
  var _a2, _b2;
  const parsedUA = typeof window !== "undefined" && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0;
  const platform2 = (_b2 = parsedUA == null ? void 0 : parsedUA.platform) == null ? void 0 : _b2.type;
  return platform2 === "tablet" || platform2 === "mobile";
};
const getRuntimeConfig = (config2) => {
  const defaultsMode = resolveDefaultsModeConfig(config2);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig$1(config2);
  return {
    ...clientSharedValues,
    ...config2,
    runtime: "browser",
    defaultsMode,
    bodyLengthChecker: (config2 == null ? void 0 : config2.bodyLengthChecker) ?? calculateBodyLength,
    credentialDefaultProvider: (config2 == null ? void 0 : config2.credentialDefaultProvider) ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: (config2 == null ? void 0 : config2.defaultUserAgentProvider) ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo.version }),
    maxAttempts: (config2 == null ? void 0 : config2.maxAttempts) ?? DEFAULT_MAX_ATTEMPTS,
    region: (config2 == null ? void 0 : config2.region) ?? invalidProvider("Region is missing"),
    requestHandler: FetchHttpHandler.create((config2 == null ? void 0 : config2.requestHandler) ?? defaultConfigProvider),
    retryMode: (config2 == null ? void 0 : config2.retryMode) ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
    sha256: (config2 == null ? void 0 : config2.sha256) ?? Sha256,
    streamCollector: (config2 == null ? void 0 : config2.streamCollector) ?? streamCollector,
    useDualstackEndpoint: (config2 == null ? void 0 : config2.useDualstackEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
    useFipsEndpoint: (config2 == null ? void 0 : config2.useFipsEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
  };
};
const getAwsRegionExtensionConfiguration = (runtimeConfig) => {
  let runtimeConfigRegion = async () => {
    if (runtimeConfig.region === void 0) {
      throw new Error("Region is missing from runtimeConfig");
    }
    const region = runtimeConfig.region;
    if (typeof region === "string") {
      return region;
    }
    return region();
  };
  return {
    setRegion(region) {
      runtimeConfigRegion = region;
    },
    region() {
      return runtimeConfigRegion;
    }
  };
};
const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
  return {
    region: awsRegionExtensionConfiguration.region()
  };
};
const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index2 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index2 === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index2, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
const resolveHttpAuthRuntimeConfig = (config2) => {
  return {
    httpAuthSchemes: config2.httpAuthSchemes(),
    httpAuthSchemeProvider: config2.httpAuthSchemeProvider(),
    credentials: config2.credentials()
  };
};
const asPartial = (t2) => t2;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
  };
};
class CognitoIdentityProviderClient extends Client {
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveUserAgentConfig(_config_1);
    const _config_3 = resolveRetryConfig(_config_2);
    const _config_4 = resolveRegionConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveEndpointConfig(_config_5);
    const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
    const _config_8 = resolveRuntimeExtensions(_config_7, (configuration == null ? void 0 : configuration.extensions) || []);
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getUserAgentPlugin(this.config));
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultCognitoIdentityProviderHttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config2) => new DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config2.credentials
      })
    }));
    this.middlewareStack.use(getHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}
class CognitoIdentityProviderServiceException extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, CognitoIdentityProviderServiceException.prototype);
  }
}
class InternalErrorException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InternalErrorException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalErrorException";
    this.$fault = "server";
    Object.setPrototypeOf(this, InternalErrorException.prototype);
  }
}
class InvalidParameterException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidParameterException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidParameterException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidParameterException.prototype);
  }
}
class NotAuthorizedException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "NotAuthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "NotAuthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, NotAuthorizedException.prototype);
  }
}
class ResourceNotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
  }
}
class TooManyRequestsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TooManyRequestsException.prototype);
  }
}
class UserImportInProgressException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserImportInProgressException",
      $fault: "client",
      ...opts
    });
    this.name = "UserImportInProgressException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserImportInProgressException.prototype);
  }
}
class UserNotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "UserNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserNotFoundException.prototype);
  }
}
class InvalidLambdaResponseException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidLambdaResponseException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidLambdaResponseException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidLambdaResponseException.prototype);
  }
}
class LimitExceededException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "LimitExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, LimitExceededException.prototype);
  }
}
class TooManyFailedAttemptsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "TooManyFailedAttemptsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyFailedAttemptsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TooManyFailedAttemptsException.prototype);
  }
}
class UnexpectedLambdaException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnexpectedLambdaException",
      $fault: "client",
      ...opts
    });
    this.name = "UnexpectedLambdaException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnexpectedLambdaException.prototype);
  }
}
class UserLambdaValidationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserLambdaValidationException",
      $fault: "client",
      ...opts
    });
    this.name = "UserLambdaValidationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserLambdaValidationException.prototype);
  }
}
class CodeDeliveryFailureException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "CodeDeliveryFailureException",
      $fault: "client",
      ...opts
    });
    this.name = "CodeDeliveryFailureException";
    this.$fault = "client";
    Object.setPrototypeOf(this, CodeDeliveryFailureException.prototype);
  }
}
class InvalidPasswordException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidPasswordException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidPasswordException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidPasswordException.prototype);
  }
}
class InvalidSmsRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidSmsRoleAccessPolicyException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidSmsRoleAccessPolicyException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidSmsRoleAccessPolicyException.prototype);
  }
}
class InvalidSmsRoleTrustRelationshipException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidSmsRoleTrustRelationshipException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidSmsRoleTrustRelationshipException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidSmsRoleTrustRelationshipException.prototype);
  }
}
class PreconditionNotMetException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "PreconditionNotMetException",
      $fault: "client",
      ...opts
    });
    this.name = "PreconditionNotMetException";
    this.$fault = "client";
    Object.setPrototypeOf(this, PreconditionNotMetException.prototype);
  }
}
class UnsupportedUserStateException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedUserStateException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedUserStateException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedUserStateException.prototype);
  }
}
class UsernameExistsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UsernameExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "UsernameExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UsernameExistsException.prototype);
  }
}
class AliasExistsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "AliasExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "AliasExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AliasExistsException.prototype);
  }
}
class InvalidUserPoolConfigurationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidUserPoolConfigurationException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidUserPoolConfigurationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidUserPoolConfigurationException.prototype);
  }
}
class InvalidEmailRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidEmailRoleAccessPolicyException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidEmailRoleAccessPolicyException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidEmailRoleAccessPolicyException.prototype);
  }
}
class MFAMethodNotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "MFAMethodNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "MFAMethodNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, MFAMethodNotFoundException.prototype);
  }
}
class PasswordResetRequiredException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "PasswordResetRequiredException",
      $fault: "client",
      ...opts
    });
    this.name = "PasswordResetRequiredException";
    this.$fault = "client";
    Object.setPrototypeOf(this, PasswordResetRequiredException.prototype);
  }
}
class UserNotConfirmedException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserNotConfirmedException",
      $fault: "client",
      ...opts
    });
    this.name = "UserNotConfirmedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserNotConfirmedException.prototype);
  }
}
class UserPoolAddOnNotEnabledException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserPoolAddOnNotEnabledException",
      $fault: "client",
      ...opts
    });
    this.name = "UserPoolAddOnNotEnabledException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserPoolAddOnNotEnabledException.prototype);
  }
}
class CodeMismatchException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "CodeMismatchException",
      $fault: "client",
      ...opts
    });
    this.name = "CodeMismatchException";
    this.$fault = "client";
    Object.setPrototypeOf(this, CodeMismatchException.prototype);
  }
}
class ExpiredCodeException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ExpiredCodeException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredCodeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ExpiredCodeException.prototype);
  }
}
class PasswordHistoryPolicyViolationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "PasswordHistoryPolicyViolationException",
      $fault: "client",
      ...opts
    });
    this.name = "PasswordHistoryPolicyViolationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, PasswordHistoryPolicyViolationException.prototype);
  }
}
class SoftwareTokenMFANotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "SoftwareTokenMFANotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "SoftwareTokenMFANotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, SoftwareTokenMFANotFoundException.prototype);
  }
}
class ConcurrentModificationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ConcurrentModificationException",
      $fault: "client",
      ...opts
    });
    this.name = "ConcurrentModificationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
  }
}
class ForbiddenException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ForbiddenException",
      $fault: "client",
      ...opts
    });
    this.name = "ForbiddenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ForbiddenException.prototype);
  }
}
class GroupExistsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "GroupExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "GroupExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, GroupExistsException.prototype);
  }
}
class DuplicateProviderException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "DuplicateProviderException",
      $fault: "client",
      ...opts
    });
    this.name = "DuplicateProviderException";
    this.$fault = "client";
    Object.setPrototypeOf(this, DuplicateProviderException.prototype);
  }
}
class UserPoolTaggingException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserPoolTaggingException",
      $fault: "client",
      ...opts
    });
    this.name = "UserPoolTaggingException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserPoolTaggingException.prototype);
  }
}
class InvalidOAuthFlowException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidOAuthFlowException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidOAuthFlowException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidOAuthFlowException.prototype);
  }
}
class ScopeDoesNotExistException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ScopeDoesNotExistException",
      $fault: "client",
      ...opts
    });
    this.name = "ScopeDoesNotExistException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ScopeDoesNotExistException.prototype);
  }
}
class UnsupportedIdentityProviderException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedIdentityProviderException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedIdentityProviderException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedIdentityProviderException.prototype);
  }
}
const AttributeTypeFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Value && { Value: SENSITIVE_STRING }
});
const AuthenticationResultTypeFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.AccessToken && { AccessToken: SENSITIVE_STRING },
  ...obj.RefreshToken && { RefreshToken: SENSITIVE_STRING },
  ...obj.IdToken && { IdToken: SENSITIVE_STRING }
});
const InitiateAuthRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.AuthParameters && { AuthParameters: SENSITIVE_STRING },
  ...obj.ClientId && { ClientId: SENSITIVE_STRING },
  ...obj.UserContextData && { UserContextData: SENSITIVE_STRING }
});
const InitiateAuthResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Session && { Session: SENSITIVE_STRING },
  ...obj.AuthenticationResult && {
    AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
  }
});
const RespondToAuthChallengeRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.ClientId && { ClientId: SENSITIVE_STRING },
  ...obj.Session && { Session: SENSITIVE_STRING },
  ...obj.ChallengeResponses && { ChallengeResponses: SENSITIVE_STRING },
  ...obj.UserContextData && { UserContextData: SENSITIVE_STRING }
});
class UnauthorizedException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnauthorizedException.prototype);
  }
}
class UnsupportedOperationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedOperationException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedOperationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
  }
}
class UnsupportedTokenTypeException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedTokenTypeException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedTokenTypeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedTokenTypeException.prototype);
  }
}
class EnableSoftwareTokenMFAException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "EnableSoftwareTokenMFAException",
      $fault: "client",
      ...opts
    });
    this.name = "EnableSoftwareTokenMFAException";
    this.$fault = "client";
    Object.setPrototypeOf(this, EnableSoftwareTokenMFAException.prototype);
  }
}
const RespondToAuthChallengeResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Session && { Session: SENSITIVE_STRING },
  ...obj.AuthenticationResult && {
    AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
  }
});
const SignUpRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.ClientId && { ClientId: SENSITIVE_STRING },
  ...obj.SecretHash && { SecretHash: SENSITIVE_STRING },
  ...obj.Username && { Username: SENSITIVE_STRING },
  ...obj.Password && { Password: SENSITIVE_STRING },
  ...obj.UserAttributes && {
    UserAttributes: obj.UserAttributes.map((item2) => AttributeTypeFilterSensitiveLog(item2))
  },
  ...obj.ValidationData && {
    ValidationData: obj.ValidationData.map((item2) => AttributeTypeFilterSensitiveLog(item2))
  },
  ...obj.UserContextData && { UserContextData: SENSITIVE_STRING }
});
const se_InitiateAuthCommand = async (input2, context2) => {
  const headers = sharedHeaders("InitiateAuth");
  let body;
  body = JSON.stringify(_json(input2));
  return buildHttpRpcRequest(context2, headers, "/", void 0, body);
};
const se_RespondToAuthChallengeCommand = async (input2, context2) => {
  const headers = sharedHeaders("RespondToAuthChallenge");
  let body;
  body = JSON.stringify(_json(input2));
  return buildHttpRpcRequest(context2, headers, "/", void 0, body);
};
const se_SignUpCommand = async (input2, context2) => {
  const headers = sharedHeaders("SignUp");
  let body;
  body = JSON.stringify(_json(input2));
  return buildHttpRpcRequest(context2, headers, "/", void 0, body);
};
const de_InitiateAuthCommand = async (output2, context2) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context2);
  }
  const data = await parseJsonBody(output2.body, context2);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
const de_RespondToAuthChallengeCommand = async (output2, context2) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context2);
  }
  const data = await parseJsonBody(output2.body, context2);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
const de_SignUpCommand = async (output2, context2) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context2);
  }
  const data = await parseJsonBody(output2.body, context2);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
const de_CommandError = async (output2, context2) => {
  const parsedOutput = {
    ...output2,
    body: await parseJsonErrorBody(output2.body, context2)
  };
  const errorCode = loadRestJsonErrorCode(output2, parsedOutput.body);
  switch (errorCode) {
    case "InternalErrorException":
    case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
      throw await de_InternalErrorExceptionRes(parsedOutput);
    case "InvalidParameterException":
    case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput);
    case "NotAuthorizedException":
    case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
      throw await de_NotAuthorizedExceptionRes(parsedOutput);
    case "ResourceNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput);
    case "TooManyRequestsException":
    case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput);
    case "UserImportInProgressException":
    case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
      throw await de_UserImportInProgressExceptionRes(parsedOutput);
    case "UserNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
      throw await de_UserNotFoundExceptionRes(parsedOutput);
    case "InvalidLambdaResponseException":
    case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
      throw await de_InvalidLambdaResponseExceptionRes(parsedOutput);
    case "LimitExceededException":
    case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput);
    case "TooManyFailedAttemptsException":
    case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
      throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput);
    case "UnexpectedLambdaException":
    case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
      throw await de_UnexpectedLambdaExceptionRes(parsedOutput);
    case "UserLambdaValidationException":
    case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
      throw await de_UserLambdaValidationExceptionRes(parsedOutput);
    case "CodeDeliveryFailureException":
    case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
      throw await de_CodeDeliveryFailureExceptionRes(parsedOutput);
    case "InvalidPasswordException":
    case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
      throw await de_InvalidPasswordExceptionRes(parsedOutput);
    case "InvalidSmsRoleAccessPolicyException":
    case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
      throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput);
    case "InvalidSmsRoleTrustRelationshipException":
    case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
      throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput);
    case "PreconditionNotMetException":
    case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
      throw await de_PreconditionNotMetExceptionRes(parsedOutput);
    case "UnsupportedUserStateException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedUserStateException":
      throw await de_UnsupportedUserStateExceptionRes(parsedOutput);
    case "UsernameExistsException":
    case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
      throw await de_UsernameExistsExceptionRes(parsedOutput);
    case "AliasExistsException":
    case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
      throw await de_AliasExistsExceptionRes(parsedOutput);
    case "InvalidUserPoolConfigurationException":
    case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
      throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput);
    case "InvalidEmailRoleAccessPolicyException":
    case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
      throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput);
    case "MFAMethodNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
      throw await de_MFAMethodNotFoundExceptionRes(parsedOutput);
    case "PasswordResetRequiredException":
    case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
      throw await de_PasswordResetRequiredExceptionRes(parsedOutput);
    case "UserNotConfirmedException":
    case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
      throw await de_UserNotConfirmedExceptionRes(parsedOutput);
    case "UserPoolAddOnNotEnabledException":
    case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
      throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput);
    case "CodeMismatchException":
    case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
      throw await de_CodeMismatchExceptionRes(parsedOutput);
    case "ExpiredCodeException":
    case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
      throw await de_ExpiredCodeExceptionRes(parsedOutput);
    case "PasswordHistoryPolicyViolationException":
    case "com.amazonaws.cognitoidentityprovider#PasswordHistoryPolicyViolationException":
      throw await de_PasswordHistoryPolicyViolationExceptionRes(parsedOutput);
    case "SoftwareTokenMFANotFoundException":
    case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
      throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput);
    case "ConcurrentModificationException":
    case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput);
    case "ForbiddenException":
    case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
      throw await de_ForbiddenExceptionRes(parsedOutput);
    case "GroupExistsException":
    case "com.amazonaws.cognitoidentityprovider#GroupExistsException":
      throw await de_GroupExistsExceptionRes(parsedOutput);
    case "DuplicateProviderException":
    case "com.amazonaws.cognitoidentityprovider#DuplicateProviderException":
      throw await de_DuplicateProviderExceptionRes(parsedOutput);
    case "UserPoolTaggingException":
    case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
      throw await de_UserPoolTaggingExceptionRes(parsedOutput);
    case "InvalidOAuthFlowException":
    case "com.amazonaws.cognitoidentityprovider#InvalidOAuthFlowException":
      throw await de_InvalidOAuthFlowExceptionRes(parsedOutput);
    case "ScopeDoesNotExistException":
    case "com.amazonaws.cognitoidentityprovider#ScopeDoesNotExistException":
      throw await de_ScopeDoesNotExistExceptionRes(parsedOutput);
    case "UnsupportedIdentityProviderException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedIdentityProviderException":
      throw await de_UnsupportedIdentityProviderExceptionRes(parsedOutput);
    case "UnauthorizedException":
    case "com.amazonaws.cognitoidentityprovider#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput);
    case "UnsupportedOperationException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedOperationException":
      throw await de_UnsupportedOperationExceptionRes(parsedOutput);
    case "UnsupportedTokenTypeException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedTokenTypeException":
      throw await de_UnsupportedTokenTypeExceptionRes(parsedOutput);
    case "EnableSoftwareTokenMFAException":
    case "com.amazonaws.cognitoidentityprovider#EnableSoftwareTokenMFAException":
      throw await de_EnableSoftwareTokenMFAExceptionRes(parsedOutput);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output: output2,
        parsedBody,
        errorCode
      });
  }
};
const de_AliasExistsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new AliasExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_CodeDeliveryFailureExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new CodeDeliveryFailureException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_CodeMismatchExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new CodeMismatchException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ConcurrentModificationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_DuplicateProviderExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new DuplicateProviderException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_EnableSoftwareTokenMFAExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new EnableSoftwareTokenMFAException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ExpiredCodeExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ExpiredCodeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ForbiddenExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ForbiddenException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_GroupExistsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new GroupExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InternalErrorExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InternalErrorException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidEmailRoleAccessPolicyExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidEmailRoleAccessPolicyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidLambdaResponseExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidLambdaResponseException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidOAuthFlowExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidOAuthFlowException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidParameterExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidParameterException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidPasswordExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidPasswordException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidSmsRoleAccessPolicyExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidSmsRoleAccessPolicyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidSmsRoleTrustRelationshipExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidSmsRoleTrustRelationshipException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidUserPoolConfigurationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidUserPoolConfigurationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_MFAMethodNotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new MFAMethodNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_NotAuthorizedExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new NotAuthorizedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_PasswordHistoryPolicyViolationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new PasswordHistoryPolicyViolationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_PasswordResetRequiredExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new PasswordResetRequiredException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_PreconditionNotMetExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new PreconditionNotMetException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ScopeDoesNotExistExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ScopeDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_SoftwareTokenMFANotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new SoftwareTokenMFANotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_TooManyFailedAttemptsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new TooManyFailedAttemptsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnauthorizedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnexpectedLambdaExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnexpectedLambdaException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedIdentityProviderExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedIdentityProviderException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedOperationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedOperationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedTokenTypeExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedTokenTypeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedUserStateExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedUserStateException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserImportInProgressExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserImportInProgressException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserLambdaValidationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserLambdaValidationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UsernameExistsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UsernameExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserNotConfirmedExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserNotConfirmedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserNotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserPoolAddOnNotEnabledExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserPoolAddOnNotEnabledException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserPoolTaggingExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserPoolTaggingException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const deserializeMetadata = (output2) => ({
  httpStatusCode: output2.statusCode,
  requestId: output2.headers["x-amzn-requestid"] ?? output2.headers["x-amzn-request-id"] ?? output2.headers["x-amz-request-id"],
  extendedRequestId: output2.headers["x-amz-id-2"],
  cfId: output2.headers["x-amz-cf-id"]
});
const throwDefaultError = withBaseException(CognitoIdentityProviderServiceException);
const buildHttpRpcRequest = async (context2, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context2.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
function sharedHeaders(operation) {
  return {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AWSCognitoIdentityProviderService.${operation}`
  };
}
class InitiateAuthCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config2, o2) {
  return [
    getSerdePlugin(config2, this.serialize, this.deserialize),
    getEndpointPlugin(config2, Command2.getEndpointParameterInstructions())
  ];
}).s("AWSCognitoIdentityProviderService", "InitiateAuth", {}).n("CognitoIdentityProviderClient", "InitiateAuthCommand").f(InitiateAuthRequestFilterSensitiveLog, InitiateAuthResponseFilterSensitiveLog).ser(se_InitiateAuthCommand).de(de_InitiateAuthCommand).build() {
}
class RespondToAuthChallengeCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config2, o2) {
  return [
    getSerdePlugin(config2, this.serialize, this.deserialize),
    getEndpointPlugin(config2, Command2.getEndpointParameterInstructions())
  ];
}).s("AWSCognitoIdentityProviderService", "RespondToAuthChallenge", {}).n("CognitoIdentityProviderClient", "RespondToAuthChallengeCommand").f(RespondToAuthChallengeRequestFilterSensitiveLog, RespondToAuthChallengeResponseFilterSensitiveLog).ser(se_RespondToAuthChallengeCommand).de(de_RespondToAuthChallengeCommand).build() {
}
class SignUpCommand extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config2, o2) {
  return [
    getSerdePlugin(config2, this.serialize, this.deserialize),
    getEndpointPlugin(config2, Command2.getEndpointParameterInstructions())
  ];
}).s("AWSCognitoIdentityProviderService", "SignUp", {}).n("CognitoIdentityProviderClient", "SignUpCommand").f(SignUpRequestFilterSensitiveLog, void 0).ser(se_SignUpCommand).de(de_SignUpCommand).build() {
}
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m2, p2) => {
    let code2 = p2.charCodeAt(0).toString(16).toUpperCase();
    if (code2.length < 2) {
      code2 = "0" + code2;
    }
    return "%" + code2;
  }));
}
function base64UrlDecode(str) {
  let output2 = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output2.length % 4) {
    case 0:
      break;
    case 2:
      output2 += "==";
      break;
    case 3:
      output2 += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output2);
  } catch (err) {
    return atob(output2);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e2.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e2.message})`);
  }
}
function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$3.apply(null, arguments);
}
function _objectWithoutPropertiesLoose$2(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (e2.includes(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
const _excluded$3 = ["signatures"];
const INTENTS_VERSION = 1;
const VERSION = `${INTENTS_VERSION} (Web ${VERSION$1})`;
function makeIntent(name2, lifespan, data) {
  const issuedAt = Math.floor(Date.now() / 1e3);
  const expiresAt = issuedAt + lifespan;
  return {
    version: VERSION,
    issuedAt,
    expiresAt,
    name: name2,
    data
  };
}
async function signIntent(session, intent) {
  const hash2 = hashIntent(intent);
  const signature2 = await session.sign(new Uint8Array(hash2));
  return _extends$3({}, intent, {
    signatures: [{
      sessionId: await session.sessionId(),
      signature: signature2
    }]
  });
}
function hashIntent(intent) {
  const {
    version: version2,
    issuedAt,
    expiresAt,
    name: name2,
    data
  } = intent;
  const hashableIntent = {
    version: version2,
    issuedAt,
    expiresAt,
    name: name2,
    data
  };
  const encoded = toUtf8Bytes(canonicalize(hashableIntent));
  return getBytes(keccak256(encoded));
}
function changeIntentTime(intent, now) {
  const unsignedIntent = _objectWithoutPropertiesLoose$2(intent, _excluded$3);
  const lifespan = intent.expiresAt - intent.issuedAt;
  unsignedIntent.issuedAt = Math.floor(now.getTime() / 1e3);
  unsignedIntent.expiresAt = unsignedIntent.issuedAt + lifespan;
  return unsignedIntent;
}
let IntentName = /* @__PURE__ */ function(IntentName2) {
  IntentName2["initiateAuth"] = "initiateAuth";
  IntentName2["openSession"] = "openSession";
  IntentName2["closeSession"] = "closeSession";
  IntentName2["validateSession"] = "validateSession";
  IntentName2["finishValidateSession"] = "finishValidateSession";
  IntentName2["listSessions"] = "listSessions";
  IntentName2["getSession"] = "getSession";
  IntentName2["sessionAuthProof"] = "sessionAuthProof";
  IntentName2["feeOptions"] = "feeOptions";
  IntentName2["signMessage"] = "signMessage";
  IntentName2["sendTransaction"] = "sendTransaction";
  IntentName2["getTransactionReceipt"] = "getTransactionReceipt";
  IntentName2["federateAccount"] = "federateAccount";
  IntentName2["removeAccount"] = "removeAccount";
  IntentName2["listAccounts"] = "listAccounts";
  IntentName2["getIdToken"] = "getIdToken";
  return IntentName2;
}({});
let IntentResponseCode = /* @__PURE__ */ function(IntentResponseCode2) {
  IntentResponseCode2["authInitiated"] = "authInitiated";
  IntentResponseCode2["sessionOpened"] = "sessionOpened";
  IntentResponseCode2["sessionClosed"] = "sessionClosed";
  IntentResponseCode2["sessionList"] = "sessionList";
  IntentResponseCode2["validationRequired"] = "validationRequired";
  IntentResponseCode2["validationStarted"] = "validationStarted";
  IntentResponseCode2["validationFinished"] = "validationFinished";
  IntentResponseCode2["sessionAuthProof"] = "sessionAuthProof";
  IntentResponseCode2["signedMessage"] = "signedMessage";
  IntentResponseCode2["feeOptions"] = "feeOptions";
  IntentResponseCode2["transactionReceipt"] = "transactionReceipt";
  IntentResponseCode2["transactionFailed"] = "transactionFailed";
  IntentResponseCode2["getSessionResponse"] = "getSessionResponse";
  IntentResponseCode2["accountList"] = "accountList";
  IntentResponseCode2["accountFederated"] = "accountFederated";
  IntentResponseCode2["accountRemoved"] = "accountRemoved";
  IntentResponseCode2["idToken"] = "idToken";
  return IntentResponseCode2;
}({});
let FeeTokenType = /* @__PURE__ */ function(FeeTokenType2) {
  FeeTokenType2["unknown"] = "unknown";
  FeeTokenType2["erc20Token"] = "erc20Token";
  FeeTokenType2["erc1155Token"] = "erc1155Token";
  return FeeTokenType2;
}({});
let IdentityType = /* @__PURE__ */ function(IdentityType2) {
  IdentityType2["None"] = "None";
  IdentityType2["Guest"] = "Guest";
  IdentityType2["OIDC"] = "OIDC";
  IdentityType2["Email"] = "Email";
  IdentityType2["PlayFab"] = "PlayFab";
  IdentityType2["Stytch"] = "Stytch";
  return IdentityType2;
}({});
function signMessage({
  wallet,
  chainId,
  message,
  lifespan
}) {
  return makeIntent(IntentName.signMessage, lifespan, {
    wallet,
    network: chainId.toString(),
    message: message.startsWith("0x") ? message : hexlify(toUtf8Bytes(message))
  });
}
const _excluded$2 = ["lifespan"], _excluded2$2 = ["lifespan"], _excluded3$2 = ["lifespan"], _excluded4$1 = ["lifespan"], _excluded5 = ["lifespan"], _excluded6 = ["lifespan"], _excluded7 = ["lifespan"], _excluded8 = ["lifespan"], _excluded9 = ["lifespan"];
async function initiateAuth(_ref) {
  let {
    lifespan
  } = _ref, data = _objectWithoutPropertiesLoose$2(_ref, _excluded$2);
  return makeIntent(IntentName.initiateAuth, lifespan, data);
}
async function openSession(_ref2) {
  let {
    lifespan
  } = _ref2, data = _objectWithoutPropertiesLoose$2(_ref2, _excluded2$2);
  return makeIntent(IntentName.openSession, lifespan, data);
}
async function validateSession(_ref3) {
  let {
    lifespan
  } = _ref3, data = _objectWithoutPropertiesLoose$2(_ref3, _excluded3$2);
  return makeIntent(IntentName.validateSession, lifespan, data);
}
function finishValidateSession(_ref4) {
  let {
    lifespan
  } = _ref4, data = _objectWithoutPropertiesLoose$2(_ref4, _excluded4$1);
  return makeIntent(IntentName.finishValidateSession, lifespan, data);
}
function closeSession(_ref5) {
  let {
    lifespan
  } = _ref5, data = _objectWithoutPropertiesLoose$2(_ref5, _excluded5);
  return makeIntent(IntentName.closeSession, lifespan, data);
}
function listSessions(_ref6) {
  let {
    lifespan
  } = _ref6, data = _objectWithoutPropertiesLoose$2(_ref6, _excluded6);
  return makeIntent(IntentName.listSessions, lifespan, data);
}
function getSession(_ref7) {
  let {
    lifespan
  } = _ref7, data = _objectWithoutPropertiesLoose$2(_ref7, _excluded7);
  return makeIntent(IntentName.getSession, lifespan, data);
}
function sessionAuthProof(_ref8) {
  let {
    lifespan
  } = _ref8, data = _objectWithoutPropertiesLoose$2(_ref8, _excluded8);
  return makeIntent(IntentName.sessionAuthProof, lifespan, data);
}
function getIdToken(_ref9) {
  let {
    lifespan
  } = _ref9, data = _objectWithoutPropertiesLoose$2(_ref9, _excluded9);
  return makeIntent(IntentName.getIdToken, lifespan, data);
}
const _excluded$1$1 = ["token", "to", "value"], _excluded2$1 = ["token", "to", "id", "safe", "data"], _excluded3$1 = ["token", "to", "values", "data"], _excluded4 = ["to", "value", "abi", "func", "args"];
function feeOptions({
  lifespan,
  wallet,
  identifier,
  chainId,
  transactions: transactions2
}) {
  return makeIntent(IntentName.feeOptions, lifespan, {
    identifier,
    wallet,
    network: chainId.toString(),
    transactions: transactions2.map((tx) => {
      if (!tx.to || tx.to === ZeroAddress) {
        throw new Error("Contract creation not supported");
      }
      if (!isEthersTx(tx)) {
        return tx;
      }
      return {
        type: "transaction",
        to: tx.to,
        value: toHexString(BigInt(tx.value || 0)),
        data: hexlify(tx.data || "0x")
      };
    })
  });
}
function sendTransactions$1({
  lifespan,
  wallet,
  identifier,
  chainId,
  transactions: transactions2,
  transactionsFeeQuote,
  transactionsFeeOption
}) {
  return makeIntent(IntentName.sendTransaction, lifespan, {
    identifier,
    wallet,
    network: chainId.toString(),
    transactions: withTransactionFee(transactions2, transactionsFeeOption).map((tx) => {
      if (!tx.to || tx.to === ZeroAddress) {
        throw new Error("Contract creation not supported");
      }
      if (!isEthersTx(tx)) {
        return tx;
      }
      return {
        type: "transaction",
        to: tx.to,
        value: toHexString(BigInt(tx.value || 0)),
        data: hexlify(tx.data || "0x")
      };
    }),
    transactionsFeeQuote
  });
}
function withTransactionFee(transactions2, feeOption) {
  const extendedTransactions = [...transactions2];
  if (feeOption) {
    switch (feeOption.token.type) {
      case FeeTokenType.unknown:
        extendedTransactions.push({
          to: feeOption.to,
          value: feeOption.value
        });
        break;
      case FeeTokenType.erc20Token:
        if (!feeOption.token.contractAddress) {
          throw new Error("contract address is required");
        }
        extendedTransactions.push(erc20({
          tokenAddress: feeOption.token.contractAddress,
          to: feeOption.to,
          value: feeOption.value
        }));
        break;
      case FeeTokenType.erc1155Token:
        if (!feeOption.token.contractAddress) {
          throw new Error("contract address is required");
        }
        if (!feeOption.token.tokenID) {
          throw new Error("token ID is required");
        }
        extendedTransactions.push(erc1155({
          tokenAddress: feeOption.token.contractAddress,
          to: feeOption.to,
          vals: [{
            id: feeOption.token.tokenID,
            amount: feeOption.value
          }]
        }));
        break;
    }
  }
  return extendedTransactions;
}
function getTransactionReceipt({
  lifespan,
  chainId,
  wallet,
  metaTxHash
}) {
  return makeIntent(IntentName.getTransactionReceipt, lifespan, {
    wallet,
    network: chainId.toString(),
    metaTxHash
  });
}
function sendERC20(_ref) {
  let {
    token,
    to,
    value
  } = _ref, args = _objectWithoutPropertiesLoose$2(_ref, _excluded$1$1);
  return sendTransactions$1(_extends$3({
    transactions: [erc20({
      tokenAddress: token,
      to,
      value: value.toString()
    })]
  }, args));
}
function sendERC721(_ref2) {
  let {
    token,
    to,
    id: id2,
    safe,
    data
  } = _ref2, args = _objectWithoutPropertiesLoose$2(_ref2, _excluded2$1);
  return sendTransactions$1(_extends$3({
    transactions: [erc721({
      tokenAddress: token,
      to,
      id: id2,
      data,
      safe
    })]
  }, args));
}
function sendERC1155(_ref3) {
  let {
    token,
    to,
    values,
    data
  } = _ref3, args = _objectWithoutPropertiesLoose$2(_ref3, _excluded3$1);
  const vals = values.map((v3) => ({
    id: v3.id,
    amount: BigInt(v3.amount).toString()
  }));
  return sendTransactions$1(_extends$3({
    transactions: [erc1155({
      tokenAddress: token,
      to,
      vals,
      data
    })]
  }, args));
}
function sendContractCall(_ref4) {
  let {
    to,
    value,
    abi: abi2,
    func,
    args
  } = _ref4, otherArgs = _objectWithoutPropertiesLoose$2(_ref4, _excluded4);
  return sendTransactions$1(_extends$3({
    transactions: [contractCall({
      to,
      value: BigInt(value || 0).toString(),
      data: {
        abi: abi2,
        func,
        args
      }
    })]
  }, otherArgs));
}
function erc20(data) {
  const sendERC20Args = data;
  const transactionERC20 = data;
  if (sendERC20Args.token !== void 0) {
    return {
      type: "erc20send",
      tokenAddress: sendERC20Args.token,
      to: sendERC20Args.to,
      value: sendERC20Args.value.toString()
    };
  } else if (transactionERC20.tokenAddress !== void 0) {
    return _extends$3({
      type: "erc20send"
    }, transactionERC20);
  } else {
    throw new Error("Invalid ERC20 transaction");
  }
}
function erc721(data) {
  const sendERC721Args = data;
  const transactionERC721 = data;
  if (sendERC721Args.token !== void 0) {
    return {
      type: "erc721send",
      tokenAddress: sendERC721Args.token,
      to: sendERC721Args.to,
      id: sendERC721Args.id,
      data: sendERC721Args.data,
      safe: sendERC721Args.safe
    };
  } else if (transactionERC721.tokenAddress !== void 0) {
    return _extends$3({
      type: "erc721send"
    }, transactionERC721);
  } else {
    throw new Error("Invalid ERC721 transaction");
  }
}
function erc1155(data) {
  const sendERC1155Args = data;
  const transactionERC1155 = data;
  if (sendERC1155Args.values !== void 0) {
    return {
      type: "erc1155send",
      vals: sendERC1155Args.values.map((v3) => ({
        id: v3.id,
        amount: v3.amount.toString()
      })),
      tokenAddress: sendERC1155Args.token,
      to: sendERC1155Args.to,
      data: sendERC1155Args.data
    };
  } else if (transactionERC1155.vals !== void 0) {
    return {
      type: "erc1155send",
      vals: transactionERC1155.vals.map((v3) => ({
        id: v3.id,
        amount: v3.amount
      })),
      tokenAddress: transactionERC1155.tokenAddress,
      to: transactionERC1155.to,
      data: transactionERC1155.data
    };
  } else {
    throw new Error("Invalid ERC1155 transaction");
  }
}
function contractCall(data) {
  const sendContractCallArgs = data;
  const transactionContractCall = data;
  if (sendContractCallArgs.abi !== void 0) {
    return {
      type: "contractCall",
      to: sendContractCallArgs.to,
      value: toHexString(BigInt(sendContractCallArgs.value || 0)),
      data: {
        abi: sendContractCallArgs.abi,
        func: sendContractCallArgs.func,
        args: sendContractCallArgs.args
      }
    };
  } else if (transactionContractCall.data !== void 0) {
    return {
      type: "contractCall",
      to: transactionContractCall.to,
      value: transactionContractCall.value,
      data: transactionContractCall.data
    };
  } else {
    throw new Error("Invalid contract transaction");
  }
}
function combineTransactionIntents(intents) {
  if (intents.length === 0) {
    throw new Error("No packets provided");
  }
  const network2 = intents[0].data.network;
  const wallet = intents[0].data.wallet;
  const lifespan = intents[0].expiresAt - intents[0].issuedAt;
  const identifier = intents[0].data.identifier;
  const transactionsFeeQuote = intents[0].data.transactionsFeeQuote;
  if (!intents.every((intent) => intent.data.network === network2)) {
    throw new Error("All packets must have the same chainId");
  }
  if (!intents.every((intent) => intent.data.wallet === wallet)) {
    throw new Error("All packets must have the same wallet");
  }
  return makeIntent(IntentName.sendTransaction, lifespan, {
    network: network2,
    wallet,
    identifier,
    transactions: intents.flatMap((intent) => intent.data.transactions),
    transactionsFeeQuote
  });
}
function isEthersTx(tx) {
  return !["transaction", "erc20send", "erc721send", "erc1155send", "delayedEncode", "contractCall"].includes(tx.type);
}
class StoreObj {
  constructor(store, key, defaultValue) {
    this.store = store;
    this.key = key;
    this.defaultValue = defaultValue;
  }
  async get() {
    const value = await this.store.get(this.key);
    return value ? value : this.defaultValue;
  }
  async set(value) {
    if (value) {
      await this.store.set(this.key, value);
    } else {
      await this.store.set(this.key, null);
    }
  }
}
class LocalStore {
  constructor() {
    this.store = void 0;
    if (WindowLocalStorage.isAvailable()) {
      this.store = new WindowLocalStorage();
    } else {
      this.store = new MemoryStore();
    }
  }
  async get(key) {
    return this.store.get(key);
  }
  async set(key, value) {
    return this.store.set(key, value);
  }
}
class WindowLocalStorage {
  static isAvailable() {
    return typeof window === "object" && typeof window.localStorage === "object";
  }
  constructor() {
    if (!WindowLocalStorage.isAvailable()) {
      throw new Error("No localStorage");
    }
  }
  async get(key) {
    return window.localStorage.getItem(key);
  }
  async set(key, value) {
    if (!value) {
      window.localStorage.removeItem(key);
    } else {
      window.localStorage.setItem(key, value);
    }
  }
}
class MemoryStore {
  constructor() {
    this.store = {};
    this.store = {};
  }
  async get(key) {
    return this.store[key] || null;
  }
  async set(key, value) {
    if (value) {
      this.store[key] = value;
    } else {
      delete this.store[key];
    }
  }
}
const idbName$1 = "seq-waas-session-p256k1";
const idbStoreName$1 = "seq-waas-session";
async function newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend) {
  const privateKey = await secureStoreBackend.get(idbName$1, idbStoreName$1, sessionId);
  if (!privateKey) {
    throw new Error("No private key found");
  }
  const wallet = new Wallet$1(privateKey);
  return {
    sessionId() {
      return wallet.getAddress();
    },
    sign(message) {
      return wallet.signMessage(message);
    },
    clear: async () => {
      await secureStoreBackend.delete(idbName$1, idbStoreName$1, sessionId);
    }
  };
}
async function newSECP256K1SessionFromPrivateKey(privateKey, secureStoreBackend) {
  const wallet = new Wallet$1(privateKey);
  const sessionId = await wallet.getAddress();
  await secureStoreBackend.set(idbName$1, idbStoreName$1, sessionId, privateKey);
  return newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend);
}
async function newSECP256K1Session(secureStoreBackend) {
  const wallet = Wallet$1.createRandom();
  return newSECP256K1SessionFromPrivateKey(wallet.privateKey, secureStoreBackend);
}
let KeyTypes = /* @__PURE__ */ function(KeyTypes2) {
  KeyTypes2[KeyTypes2["ECDSAP256K1"] = 0] = "ECDSAP256K1";
  KeyTypes2[KeyTypes2["ECDSAP256R1"] = 1] = "ECDSAP256R1";
  return KeyTypes2;
}({});
const idbName = "seq-waas-session-p256r1";
const idbStoreName = "seq-waas-session";
async function newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend) {
  const keys = await secureStoreBackend.get(idbName, idbStoreName, sessionId);
  if (!keys || !keys.privateKey) {
    throw new Error("No private key found");
  }
  const encoder2 = new TextEncoder();
  return {
    sessionId: async () => {
      const pubKeyRaw = await cryptoBackend.exportKey("raw", keys.publicKey);
      const pubKeyTypedRaw = new Uint8Array(pubKeyRaw.byteLength + 1);
      pubKeyTypedRaw[0] = KeyTypes.ECDSAP256R1;
      pubKeyTypedRaw.set(new Uint8Array(pubKeyRaw), 1);
      return hexlify(pubKeyTypedRaw);
    },
    sign: async (message) => {
      if (typeof message === "string") {
        if (message.startsWith("0x")) {
          message = message.slice(2);
          message = getBytes(message);
        } else {
          message = encoder2.encode(message);
        }
      }
      const signatureBuff = await cryptoBackend.sign({
        name: "ECDSA",
        hash: {
          name: "SHA-256"
        }
      }, keys.privateKey, message);
      return hexlify(new Uint8Array(signatureBuff));
    },
    clear: async () => {
      await secureStoreBackend.delete(idbName, idbStoreName, sessionId);
    }
  };
}
async function newSECP256R1SessionFromKeyPair(keyPair, cryptoBackend, secureStoreBackend) {
  const sessionId = await pubKeyToSessionId(cryptoBackend, keyPair.publicKey);
  await secureStoreBackend.set(idbName, idbStoreName, sessionId, keyPair);
  return newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend);
}
async function newSECP256R1Session(cryptoBackend, secureStoreBackend) {
  const generatedKeys = await cryptoBackend.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, false, ["sign", "verify"]);
  return newSECP256R1SessionFromKeyPair(generatedKeys, cryptoBackend, secureStoreBackend);
}
async function pubKeyToSessionId(cryptoBackend, pubKey) {
  const pubKeyRaw = await cryptoBackend.exportKey("raw", pubKey);
  const pubKeyTypedRaw = new Uint8Array(pubKeyRaw.byteLength + 1);
  pubKeyTypedRaw[0] = KeyTypes.ECDSAP256R1;
  pubKeyTypedRaw.set(new Uint8Array(pubKeyRaw), 1);
  return hexlify(pubKeyTypedRaw);
}
async function newSessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend) {
  if (!secureStoreBackend) {
    throw new Error("No secure store available");
  }
  if (cryptoBackend) {
    return newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend);
  } else {
    return newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend);
  }
}
async function newSession(cryptoBackend, secureStoreBackend) {
  if (!secureStoreBackend) {
    throw new Error("No secure store available");
  }
  if (cryptoBackend) {
    return newSECP256R1Session(cryptoBackend, secureStoreBackend);
  } else {
    return newSECP256K1Session(secureStoreBackend);
  }
}
const _excluded$4 = ["lifespan"], _excluded2 = ["lifespan"], _excluded3 = ["lifespan"];
function listAccounts(_ref) {
  let {
    lifespan
  } = _ref, data = _objectWithoutPropertiesLoose$2(_ref, _excluded$4);
  return makeIntent(IntentName.listAccounts, lifespan, data);
}
function federateAccount(_ref2) {
  let {
    lifespan
  } = _ref2, data = _objectWithoutPropertiesLoose$2(_ref2, _excluded2);
  return makeIntent(IntentName.federateAccount, lifespan, data);
}
function removeAccount(_ref3) {
  let {
    lifespan
  } = _ref3, data = _objectWithoutPropertiesLoose$2(_ref3, _excluded3);
  return makeIntent(IntentName.removeAccount, lifespan, data);
}
const nameToId = Object.entries(networks$1).reduce((acc, [key, value]) => {
  acc[value.name] = value.chainId;
  return acc;
}, {});
const idToName = Object.entries(nameToId).reduce((acc, [key, value]) => {
  acc[value] = key;
  return acc;
}, {});
function toNetworkID(network2) {
  const networkNumber = typeof network2 === "number" ? network2 : parseInt(network2);
  if (networkNumber in idToName) {
    return networkNumber;
  }
  const networkLower = network2.toString().toLowerCase();
  if (networkLower in nameToId) {
    return nameToId[networkLower];
  }
  throw new Error(`Unknown network: ${network2}`);
}
const getDefaultSubtleCryptoBackend = () => {
  if (isWindowSubtleCryptoAvailable()) {
    return new WindowSubtleCryptoBackend();
  } else {
    return null;
  }
};
function isWindowSubtleCryptoAvailable() {
  return typeof window === "object" && typeof window.crypto === "object" && typeof window.crypto.subtle === "object";
}
class WindowSubtleCryptoBackend {
  constructor() {
    if (!isWindowSubtleCryptoAvailable()) {
      throw new Error("window.crypto.subtle is not available");
    }
  }
  generateKey(algorithm, extractable, keyUsages) {
    return window.crypto.subtle.generateKey(algorithm, extractable, keyUsages);
  }
  importKey(format2, keyData, algorithm, extractable, keyUsages) {
    return window.crypto.subtle.importKey(format2, keyData, algorithm, extractable, keyUsages);
  }
  async exportKey(format2, key) {
    const keyData = await window.crypto.subtle.exportKey(format2, key);
    return new Uint8Array(keyData);
  }
  async digest(algorithm, data) {
    const digest = await window.crypto.subtle.digest(algorithm, data);
    return new Uint8Array(digest);
  }
  async sign(algorithm, key, data) {
    const signature2 = await window.crypto.subtle.sign(algorithm, key, data);
    return new Uint8Array(signature2);
  }
  verify(algorithm, key, signature2, data) {
    return window.crypto.subtle.verify(algorithm, key, signature2, data);
  }
  getRandomValues(len) {
    const randomValues = new Uint8Array(len);
    return window.crypto.getRandomValues(randomValues);
  }
}
const getDefaultSecureStoreBackend = () => {
  if (isIndexedDbAvailable()) {
    return new IndexedDbSecureStoreBackend();
  } else {
    return null;
  }
};
function isIndexedDbAvailable() {
  return typeof indexedDB === "object";
}
class IndexedDbSecureStoreBackend {
  constructor() {
    this.db = void 0;
    if (!isIndexedDbAvailable()) {
      throw new Error("IndexedDB is not available");
    }
    this.db = null;
  }
  async openDB(dbName, dbStoreName, version2) {
    if (this.db) {
      return this.db;
    }
    this.db = await openDB(dbName, 1, {
      upgrade(db2) {
        db2.createObjectStore(dbStoreName);
      }
    });
    return this.db;
  }
  async get(dbName, dbStoreName, key) {
    const db2 = await this.openDB(dbName, dbStoreName, 1);
    const tx = db2.transaction(dbStoreName, "readonly");
    const value = await db2.get(dbStoreName, key);
    await tx.done;
    return value;
  }
  async set(dbName, dbStoreName, key, value) {
    const db2 = await this.openDB(dbName, dbStoreName, 1);
    const tx = db2.transaction(dbStoreName, "readwrite");
    await db2.put(dbStoreName, value, key);
    await tx.done;
    return true;
  }
  async delete(dbName, dbStoreName, key) {
    const db2 = await this.openDB(dbName, dbStoreName, 1);
    const tx = db2.transaction(dbStoreName, "readwrite");
    await db2.delete(dbStoreName, key);
    await tx.done;
    return true;
  }
}
const SEQUENCE_WAAS_WALLET_KEY = "@0xsequence.waas.wallet";
const SEQUENCE_WAAS_SESSION_ID_KEY = "@0xsequence.waas.session_id";
const SEQUENCE_WAAS_STATUS_KEY = "@0xsequence.waas.status";
const DEFAULT_LIFESPAN = 5 * 60;
class SequenceWaaSBase {
  constructor(config2 = {
    network: 1
  }, store = new LocalStore(), cryptoBackend = getDefaultSubtleCryptoBackend(), secureStoreBackend = getDefaultSecureStoreBackend()) {
    this.config = config2;
    this.store = store;
    this.cryptoBackend = cryptoBackend;
    this.secureStoreBackend = secureStoreBackend;
    this.status = void 0;
    this.sessionId = void 0;
    this.wallet = void 0;
    this.sessionObservers = [];
    this.gettingSessionIdPromise = void 0;
    this.status = new StoreObj(this.store, SEQUENCE_WAAS_STATUS_KEY, "signed-out");
    this.sessionId = new StoreObj(this.store, SEQUENCE_WAAS_SESSION_ID_KEY, void 0);
    this.wallet = new StoreObj(this.store, SEQUENCE_WAAS_WALLET_KEY, void 0);
  }
  async getAddress() {
    return this.getWalletAddress();
  }
  async getWalletAddress() {
    if (!await this.isSignedIn()) {
      throw new Error("Not signed in");
    }
    const wallet = await this.wallet.get();
    if (!wallet) {
      throw new Error("No wallet");
    }
    return wallet;
  }
  async commonArgs(args) {
    var _args$lifespan;
    return _extends$3({}, args, {
      identifier: args == null ? void 0 : args.identifier,
      wallet: await this.getWalletAddress(),
      lifespan: (_args$lifespan = args == null ? void 0 : args.lifespan) != null ? _args$lifespan : DEFAULT_LIFESPAN,
      chainId: toNetworkID(args.network || this.config.network)
    });
  }
  /**
   * Builds a payload that can be sent to the WaaS API to sign a transaction.
   * It automatically signs the payload, and attaches the current wallet address.
   *
   * @param packet The action already packed into a packet
   * @returns A payload that can be sent to the WaaS API
   */
  async signIntent(intent) {
    const sessionId = await this.getSessionId();
    if (sessionId === void 0) {
      throw new Error("session not open");
    }
    const session = await newSessionFromSessionId(sessionId, this.cryptoBackend, this.secureStoreBackend);
    return signIntent(session, intent);
  }
  async signUsingSessionKey(message) {
    const sessionId = await this.getSessionId();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const signer2 = await newSessionFromSessionId(sessionId, this.cryptoBackend, this.secureStoreBackend);
    return signer2.sign(message);
  }
  /**
   * This method will return session id.
   *
   * @returns an id of the session
   */
  async getSessionId() {
    var _this = this;
    if (this.gettingSessionIdPromise) {
      return this.gettingSessionIdPromise;
    }
    const promiseGenerator = async function promiseGenerator2() {
      let sessionId = await _this.sessionId.get();
      if (!sessionId) {
        const session = await newSession(_this.cryptoBackend, _this.secureStoreBackend);
        sessionId = await session.sessionId();
        await _this.sessionId.set(sessionId);
        _this.signalObservers(_this.sessionObservers, sessionId);
      }
      _this.gettingSessionIdPromise = void 0;
      return sessionId;
    };
    this.gettingSessionIdPromise = promiseGenerator();
    return this.gettingSessionIdPromise;
  }
  /**
   * This method will initiate a sign-in process with the waas API. It must be performed
   * when the user wants to sign in to the app, in parallel with the authentication of the
   * application's own authentication system.
   *
   * This method begins the sign-in process, but does not complete it. The returned payload
   * must be sent to the waas API to complete the sign-in. The waas API will return a receipt
   * that must be sent to the `completeSignIn` method to complete the sign-in.
   *
   * @param idToken Information about the user that can be used to prove their identity
   * @returns a session payload that **must** be sent to the waas API to complete the sign-in
   * @throws {Error} If the session is already signed in or there is a pending sign-in
   */
  async signInWithIdToken(idToken) {
    const status = await this.status.get();
    if (status !== "signed-out") {
      await this.completeSignOut();
      throw new Error("you are already signed in");
    }
    const sessionId = await this.getSessionId();
    const intent = await openSession({
      sessionId,
      identityType: IdentityType.None,
      idToken,
      lifespan: DEFAULT_LIFESPAN
    });
    await this.status.set("pending");
    return this.signIntent(intent);
  }
  async initiateGuestAuth() {
    const sessionId = await this.getSessionId();
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Guest,
      verifier: sessionId,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateEmailAuth(email2) {
    const sessionId = await this.getSessionId();
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Email,
      verifier: `${email2};${sessionId}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateIdTokenAuth(idToken, exp) {
    const sessionId = await this.getSessionId();
    const idTokenHash = id$1(idToken);
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.OIDC,
      verifier: `${idTokenHash};${exp}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateStytchAuth(idToken, exp) {
    const sessionId = await this.getSessionId();
    const idTokenHash = id$1(idToken);
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Stytch,
      verifier: `${idTokenHash};${exp}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiatePlayFabAuth(titleId, sessionTicket) {
    const sessionId = await this.getSessionId();
    const ticketHash = id$1(sessionTicket);
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.PlayFab,
      verifier: `${titleId}|${ticketHash}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async completeAuth(params, optParams) {
    const sessionId = await this.getSessionId();
    const intent = await openSession(_extends$3({}, optParams, {
      sessionId,
      lifespan: DEFAULT_LIFESPAN
    }, params));
    await this.status.set("pending");
    return this.signIntent(intent);
  }
  onSessionStateChanged(callback) {
    this.sessionObservers.push(callback);
    return () => {
      this.sessionObservers = this.sessionObservers.filter((o2) => o2 != callback);
    };
  }
  async signOut({
    lifespan,
    sessionId
  } = {}) {
    sessionId = sessionId || await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = closeSession({
      lifespan: lifespan || DEFAULT_LIFESPAN,
      sessionId
    });
    return this.signIntent(intent);
  }
  async signOutSession(sessionId) {
    const intent = closeSession({
      lifespan: DEFAULT_LIFESPAN,
      sessionId
    });
    return this.signIntent(intent);
  }
  async listSessions() {
    const intent = listSessions({
      lifespan: DEFAULT_LIFESPAN,
      wallet: await this.getWalletAddress()
    });
    return this.signIntent(intent);
  }
  async completeSignOut() {
    await Promise.all([this.status.set("signed-out"), this.wallet.set(void 0), this.sessionId.set(void 0)]);
    this.signalObservers(this.sessionObservers, null);
  }
  /**
   * This method will complete a sign-in process with the waas API. It must be performed
   * after the `signIn` method, when the waas API has returned a receipt.
   *
   * This method completes the sign-in process by validating the receipt's proof.
   * If the proof is invalid or there is no pending sign-in, it will throw an error.
   *
   * After this method is called, the wallet is ready to be used to sign transactions.
   *
   * @param receipt The receipt returned by the waas API after the `signIn` method
   * @returns The wallet address of the user that signed in
   * @throws {Error} If there is no pending sign-in or the receipt is invalid
   */
  async completeSignIn(receipt) {
    if (receipt.result) {
      return this.completeSignIn(receipt.result);
    }
    const status = await this.status.get();
    if (receipt.code !== "sessionOpened") {
      throw new Error("Invalid receipt");
    }
    if (status !== "pending") {
      throw new Error("No pending sign in");
    }
    await Promise.all([this.status.set("signed-in"), this.wallet.set(receipt.data.wallet)]);
    return receipt.data.wallet;
  }
  async isSignedIn() {
    const status = await this.status.get();
    return status === "signed-in";
  }
  async sessionAuthProof(args) {
    var _args$lifespan2;
    const packet = sessionAuthProof({
      lifespan: (_args$lifespan2 = args.lifespan) != null ? _args$lifespan2 : DEFAULT_LIFESPAN,
      network: toNetworkID(args.network || this.config.network).toString(),
      wallet: await this.getWalletAddress(),
      nonce: args.nonce
    });
    return this.signIntent(packet);
  }
  //
  // Signer methods
  //
  /**
   * This method can be used to sign message using waas API. It can only be used
   * after successfully signing in with the `signIn` and `completeSignIn` methods.
   *
   * The method does not sign the message. It only returns a payload
   * that must be sent to the waas API to complete the sign process.
   *
   * @param chainId The network on which the message will be signed
   * @param message  The message that will be signed
   * @return a payload that must be sent to the waas API to complete sign process
   */
  async signMessage(args) {
    var _args$lifespan3;
    const packet = signMessage(_extends$3({
      chainId: toNetworkID(args.network || this.config.network)
    }, args, {
      lifespan: (_args$lifespan3 = args.lifespan) != null ? _args$lifespan3 : DEFAULT_LIFESPAN,
      wallet: await this.getWalletAddress()
    }));
    return this.signIntent(packet);
  }
  /**
   * This method can be used to send transactions to the waas API. It can only be used
   * after successfully signing in with the `signIn` and `completeSignIn` methods.
   *
   * The method does not send the transactions to the network. It only returns a payload
   * that must be sent to the waas API to complete the transaction.
   *
   * @param transactions The transactions to be sent
   * @param chainId The network on which the transactions will be sent
   * @returns a payload that must be sent to the waas API to complete the transaction
   */
  async sendTransaction(args) {
    const intent = sendTransactions$1(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async getTransactionReceipt(args) {
    const intent = getTransactionReceipt(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC20(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error("Cannot burn tokens using sendERC20");
    }
    const intent = sendERC20(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC721(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error("Cannot burn tokens using sendERC721");
    }
    const intent = sendERC721(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC1155(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error("Cannot burn tokens using sendERC1155");
    }
    const intent = sendERC1155(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async callContract(args) {
    const intent = sendContractCall(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async feeOptions(args) {
    const intent = feeOptions(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async validateSession({
    deviceMetadata
  }) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = await validateSession({
      lifespan: DEFAULT_LIFESPAN,
      sessionId,
      deviceMetadata,
      wallet: await this.getWalletAddress()
    });
    return this.signIntent(intent);
  }
  async getSession() {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = getSession({
      sessionId,
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async finishValidateSession(salt, challenge) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const wallet = await this.getWalletAddress();
    const intent = finishValidateSession({
      sessionId,
      wallet,
      lifespan: DEFAULT_LIFESPAN,
      salt,
      challenge
    });
    return this.signIntent(intent);
  }
  async listAccounts() {
    const intent = listAccounts({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async linkAccount(params) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = federateAccount(_extends$3({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      sessionId
    }, params));
    return this.signIntent(intent);
  }
  async removeAccount({
    accountId
  }) {
    const intent = removeAccount({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      accountId
    });
    return this.signIntent(intent);
  }
  async getIdToken({
    nonce
  }) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = getIdToken({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      sessionId,
      nonce
    });
    return this.signIntent(intent);
  }
  async batch(intents) {
    const combined = combineTransactionIntents(intents);
    return this.signIntent(combined);
  }
  signalObservers(observers2, value) {
    observers2.forEach((observer) => observer(value));
  }
  async updateIntentTime(intent, time2) {
    const newIntent = changeIntentTime(intent, time2);
    return this.signIntent(newIntent);
  }
}
class WaasAuthenticator {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/WaasAuthenticator/";
    this.registerSession = (args, headers, signal) => {
      return this.fetch(this.url("RegisterSession"), createHTTPRequest(args, headers, signal)).then((res) => {
        return buildResponse(res).then((_data6) => {
          return {
            session: _data6.session,
            response: _data6.response
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sendIntent = (args, headers, signal) => {
      return this.fetch(this.url("SendIntent"), createHTTPRequest(args, headers, signal)).then((res) => {
        return buildResponse(res).then((_data6) => {
          return {
            response: _data6.response
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.chainList = (headers, signal) => {
      return this.fetch(this.url("ChainList"), createHTTPRequest({}, headers, signal)).then((res) => {
        return buildResponse(res).then((_data6) => {
          return {
            chains: _data6.chains
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init2) => fetch2(input2, init2);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$3({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError7.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode[code2] || WebrpcError7).new(data);
    }
    return data;
  });
};
class WebrpcError7 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError7.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
}
class WebrpcEndpointError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError7.prototype);
  }
}
class WebrpcRequestFailedError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError7.prototype);
  }
}
class WebrpcBadRouteError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError7.prototype);
  }
}
class WebrpcBadMethodError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError7.prototype);
  }
}
class WebrpcBadRequestError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError7.prototype);
  }
}
class WebrpcBadResponseError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError7.prototype);
  }
}
class WebrpcServerPanicError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError7.prototype);
  }
}
class WebrpcInternalErrorError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError7.prototype);
  }
}
class WebrpcClientDisconnectedError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError7.prototype);
  }
}
class WebrpcStreamLostError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError7.prototype);
  }
}
class WebrpcStreamFinishedError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError7.prototype);
  }
}
class UnauthorizedError6 extends WebrpcError7 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError6.prototype);
  }
}
class TenantNotFoundError extends WebrpcError7 {
  constructor(name2 = "TenantNotFound", code2 = 1001, message = "Tenant not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TenantNotFoundError.prototype);
  }
}
class EmailAlreadyInUseError extends WebrpcError7 {
  constructor(name2 = "EmailAlreadyInUse", code2 = 7e3, message = "Could not create account as the email is already in use", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, EmailAlreadyInUseError.prototype);
  }
}
class AccountAlreadyLinkedError extends WebrpcError7 {
  constructor(name2 = "AccountAlreadyLinked", code2 = 7001, message = "Could not link account as it is linked to another wallet", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AccountAlreadyLinkedError.prototype);
  }
}
class ProofVerificationFailedError extends WebrpcError7 {
  constructor(name2 = "ProofVerificationFailed", code2 = 7002, message = "The authentication proof could not be verified", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ProofVerificationFailedError.prototype);
  }
}
class AnswerIncorrectError extends WebrpcError7 {
  constructor(name2 = "AnswerIncorrect", code2 = 7003, message = "The provided answer is incorrect", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AnswerIncorrectError.prototype);
  }
}
class ChallengeExpiredError extends WebrpcError7 {
  constructor(name2 = "ChallengeExpired", code2 = 7004, message = "The challenge has expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ChallengeExpiredError.prototype);
  }
}
class TooManyAttemptsError extends WebrpcError7 {
  constructor(name2 = "TooManyAttempts", code2 = 7005, message = "Too many attempts", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TooManyAttemptsError.prototype);
  }
}
const webrpcErrorByCode = {
  [0]: WebrpcEndpointError7,
  [-1]: WebrpcRequestFailedError7,
  [-2]: WebrpcBadRouteError7,
  [-3]: WebrpcBadMethodError7,
  [-4]: WebrpcBadRequestError7,
  [-5]: WebrpcBadResponseError7,
  [-6]: WebrpcServerPanicError7,
  [-7]: WebrpcInternalErrorError7,
  [-8]: WebrpcClientDisconnectedError7,
  [-9]: WebrpcStreamLostError7,
  [-10]: WebrpcStreamFinishedError7,
  [1e3]: UnauthorizedError6,
  [1001]: TenantNotFoundError,
  [7e3]: EmailAlreadyInUseError,
  [7001]: AccountAlreadyLinkedError,
  [7002]: ProofVerificationFailedError,
  [7003]: AnswerIncorrectError,
  [7004]: ChallengeExpiredError,
  [7005]: TooManyAttemptsError
};
function isInitiateAuthResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.authInitiated && typeof receipt.data === "object" && typeof receipt.data.sessionId === "string" && typeof receipt.data.identityType === "string" && typeof receipt.data.expiresIn === "number";
}
function isSentTransactionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "transactionReceipt" && typeof receipt.data === "object" && typeof receipt.data.txHash === "string" && typeof receipt.data.receipt === "object" && typeof receipt.data.request === "object";
}
function isTimedOutTransactionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "transactionReceipt" && typeof receipt.data === "object" && typeof receipt.data.metaTxHash === "string" && !receipt.data.txHash && typeof receipt.data.request === "object";
}
function isFailedTransactionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "transactionFailed" && typeof receipt.data === "object" && typeof receipt.data.request === "object" && Array.isArray(receipt.data.simulations) && typeof receipt.data.error === "string";
}
function isMaySentTransactionResponse(receipt) {
  return isSentTransactionResponse(receipt) || isFailedTransactionResponse(receipt) || isTimedOutTransactionResponse(receipt);
}
function isSignedMessageResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "signedMessage" && typeof receipt.data === "object" && typeof receipt.data.message === "string" && typeof receipt.data.signature === "string";
}
function isSessionAuthProofResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "sessionAuthProof" && typeof receipt.data === "object" && typeof receipt.data.sessionId === "string" && typeof receipt.data.network === "string" && typeof receipt.data.wallet === "string" && typeof receipt.data.message === "string" && typeof receipt.data.signature === "string";
}
function isFeeOptionsResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "feeOptions" && typeof receipt.data === "object" && Array.isArray(receipt.data.feeOptions);
}
function isValidationRequiredResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.validationRequired && typeof receipt.data === "object" && typeof receipt.data.sessionId === "string";
}
function isFinishValidateSessionResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.validationFinished && typeof receipt.data === "object";
}
function isCloseSessionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "sessionClosed";
}
function isGetSessionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "getSessionResponse" && typeof receipt.data === "object" && typeof receipt.data.session === "string" && typeof receipt.data.wallet === "string";
}
function isLinkAccountResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.accountFederated && typeof receipt.data === "object" && typeof receipt.data.account === "object";
}
function isListAccountsResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.accountList && typeof receipt.data === "object";
}
function isIntentTimeError(error) {
  var _error$cause, _error$cause2;
  return !!(error instanceof WebrpcError7 && ((_error$cause = error.cause) != null && _error$cause.endsWith("intent is invalid: intent expired") || (_error$cause2 = error.cause) != null && _error$cause2.endsWith("intent is invalid: intent issued in the future")));
}
function isGetIdTokenResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.idToken && typeof receipt.data === "object" && typeof receipt.data.idToken === "string";
}
class EmailAuth {
  constructor(region, clientId) {
    this.region = region;
    this.clientId = clientId;
    this.cognitoMemo = void 0;
  }
  cognito() {
    if (!this.cognitoMemo) {
      this.cognitoMemo = new CognitoIdentityProviderClient({
        region: this.region
      });
    }
    return this.cognitoMemo;
  }
  signUp(email2) {
    email2 = email2.toLowerCase().trim();
    return this.cognito().send(new SignUpCommand({
      ClientId: this.clientId,
      Username: email2,
      Password: "aB1%" + getRandomString(14),
      UserAttributes: [{
        Name: "email",
        Value: email2
      }]
    }));
  }
  signIn(email2) {
    email2 = email2.toLowerCase().trim();
    return this.cognito().send(new InitiateAuthCommand({
      AuthFlow: "CUSTOM_AUTH",
      ClientId: this.clientId,
      AuthParameters: {
        USERNAME: email2
      }
    }));
  }
  async initiateAuth({
    email: email2
  }) {
    let res;
    email2 = email2.toLowerCase().trim();
    try {
      res = await this.signIn(email2);
    } catch (e2) {
      if (e2 instanceof UserLambdaValidationException && e2.message.includes("user not found")) {
        await this.signUp(email2);
        res = await this.signIn(email2);
      } else {
        throw e2;
      }
    }
    if (!res.Session) {
      throw new Error("response session is empty");
    }
    return {
      // Notice: rename session to instance to avoid
      // confusion with the native waas session
      instance: res.Session,
      email: email2
    };
  }
  async finalizeAuth({
    instance,
    email: email2,
    answer,
    sessionHash
  }) {
    email2 = email2.toLowerCase().trim();
    const res = await this.cognito().send(new RespondToAuthChallengeCommand({
      ClientId: this.clientId,
      Session: instance,
      ChallengeName: "CUSTOM_CHALLENGE",
      ChallengeResponses: {
        USERNAME: email2,
        ANSWER: answer
      },
      ClientMetadata: {
        SESSION_HASH: sessionHash
      }
    }));
    if (!res.AuthenticationResult || !res.AuthenticationResult.IdToken) {
      throw new Error("AuthenticationResult.IdToken is empty");
    }
    return {
      idToken: res.AuthenticationResult.IdToken
    };
  }
}
function getRandomString(len) {
  return Array.from(getRandomValues$1(len)).map((nr) => nr.toString(16).padStart(2, "0")).join("");
}
function getRandomValues$1(len) {
  const randomValues = new Uint8Array(len);
  if (typeof window === "object" && typeof window.crypto === "object") {
    return window.crypto.getRandomValues(randomValues);
  } else {
    console.warn("window.crypto.getRandomValues is not available. Falling back to less secure Math.random().");
    const _randomValues = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      const randomInteger = Math.floor(Math.random() * 256);
      _randomValues[i] = randomInteger;
    }
    return _randomValues;
  }
}
class Challenge {
}
class GuestChallenge extends Challenge {
  constructor(sessionId, challenge) {
    super();
    this.sessionId = sessionId;
    this.challenge = challenge;
  }
  getIntentParams() {
    const answer = id$1(this.challenge + this.sessionId);
    return {
      identityType: IdentityType.Guest,
      verifier: this.sessionId,
      answer
    };
  }
  withAnswer(answer) {
    return this;
  }
}
class EmailChallenge extends Challenge {
  constructor(email2, sessionId, challenge) {
    super();
    this.email = email2;
    this.sessionId = sessionId;
    this.challenge = challenge;
    this.hashedAnswer = void 0;
  }
  getIntentParams() {
    return {
      identityType: IdentityType.Email,
      verifier: `${this.email};${this.sessionId}`,
      answer: this.hashedAnswer
    };
  }
  setAnswer(answer) {
    this.hashedAnswer = id$1(this.challenge + answer);
  }
  withAnswer(answer) {
    const challenge = new EmailChallenge(this.email, this.sessionId, this.challenge);
    challenge.setAnswer(answer);
    return challenge;
  }
}
class IdTokenChallenge extends Challenge {
  constructor(idToken) {
    super();
    this.idToken = idToken;
  }
  getIntentParams() {
    const decoded = jwtDecode(this.idToken);
    const idTokenHash = id$1(this.idToken);
    return {
      identityType: IdentityType.OIDC,
      verifier: `${idTokenHash};${decoded.exp}`,
      answer: this.idToken
    };
  }
  withAnswer() {
    return this;
  }
}
class StytchChallenge extends IdTokenChallenge {
  constructor(idToken) {
    super(idToken);
    this.idToken = idToken;
  }
  getIntentParams() {
    return _extends$3({}, super.getIntentParams(), {
      identityType: IdentityType.Stytch
    });
  }
}
class PlayFabChallenge extends Challenge {
  constructor(titleId, sessionTicket) {
    super();
    this.titleId = titleId;
    this.sessionTicket = sessionTicket;
  }
  getIntentParams() {
    const ticketHash = id$1(this.sessionTicket);
    return {
      identityType: IdentityType.PlayFab,
      verifier: `${this.titleId}|${ticketHash}`,
      answer: this.sessionTicket
    };
  }
  withAnswer() {
    return this;
  }
}
function parseSequenceWaaSConfigKey(key) {
  return JSON.parse(atob(key));
}
function defaultArgsOrFail(config2) {
  const key = config2.waasConfigKey;
  const keyOverrides = key ? parseSequenceWaaSConfigKey(key) : {};
  const preconfig = _extends$3({}, config2, keyOverrides);
  if (preconfig.network === void 0) {
    preconfig.network = 1;
  }
  if (preconfig.projectId === void 0) {
    throw new Error("Missing project id");
  }
  if (preconfig.projectAccessKey === void 0) {
    throw new Error("Missing access key");
  }
  return preconfig;
}
const fetch$1 = globalThis.fetch;
const jwksDev = {
  keys: [{
    alg: "RS256",
    e: "AQAB",
    kid: "9LkLZyHdNq1N2aeHMlC5jw",
    kty: "RSA",
    n: "qllUB_ERsOjbKx4SirGow4XDov05lQyhiF7Duo4sPkH9CwMN11OqhLuIqeIXPq0rPNIXGP99A7riXTcpRNk-5ZNL29zs-Xjj3idp7nZQZLIU1CBQErTcbxbwUYp8Q46k7lJXVlMmwoLQvQAgH8BZLuSe-Xk1tye0mDC-bHvmrMfqm2zmuWeDnZercU3Jg2iYwyPrjKWx7YSBSMTXTKPGndws4m3s3XIEpI2alLcLLWsPQk2UjIlux6I7vLwvjM_BgjFhYHqgg1tgZUPn_Xxt4wvhobF8UIacRVmGcuyYBnhRxKnBQhEClGSBVtnFYYBSvRjTgliOwf3DhFoXdnmyPQ",
    use: "sig"
  }]
};
const jwksProd = {
  keys: [{
    alg: "RS256",
    e: "AQAB",
    kid: "nWh-_3nQ1lnhhI1ZSQTQmw",
    kty: "RSA",
    n: "pECaEq2k0k22J9e7hFLAFmKbzPLlWToUJJmFeWAdEiU4zpW17EUEOyfjRzjgBewc7KFJQEblC3eTD7Vc5bh9-rafPEj8LaKyZzzS5Y9ZATXhlMo5Pnlar3BrTm48XcnT6HnLsvDeJHUVbrYd1JyE1kqeTjUKWvgKX4mgIJiuYhpdzbOC22cPaWb1dYCVhArDVAPHGqaEwRjX7JneETdY5hLJ6JhsAws706W7fwfNKddPQo2mY95S9q8HFxMr5EaXEMmhwxk8nT5k-Ouar2dobMXRMmQiEZSt9fJaGKlK7KWJSnbPOVa2cZud1evs1Rz2SdCSA2bhuZ6NnZCxkqnagw",
    use: "sig"
  }]
};
class SequenceWaaS {
  constructor(config2, store = new LocalStore(), cryptoBackend = getDefaultSubtleCryptoBackend(), secureStoreBackend = getDefaultSecureStoreBackend()) {
    var _this = this;
    this.store = store;
    this.cryptoBackend = cryptoBackend;
    this.secureStoreBackend = secureStoreBackend;
    this.waas = void 0;
    this.client = void 0;
    this.validationRequiredCallback = [];
    this.emailConflictCallback = [];
    this.emailAuthCodeRequiredCallback = [];
    this.validationRequiredSalt = void 0;
    this.config = void 0;
    this.deviceName = void 0;
    this.emailClient = void 0;
    this.lastDate = void 0;
    this.signatureVerificationFailed = false;
    this._fetch = (input2, init2) => {
      if (this.signatureVerificationFailed) {
        throw new Error("Signature verification failed");
      }
      if (this.cryptoBackend && this.config.disableHttpSignatureCheck !== true && init2 != null && init2.headers) {
        const headers = {};
        headers["Accept-Signature"] = 'sig=();alg="rsa-v1_5-sha256"';
        init2.headers = _extends$3({}, init2.headers, headers);
      }
      const response = fetch$1(input2, init2);
      if (this.cryptoBackend && this.config.disableHttpSignatureCheck !== true) {
        response.then(async function(r2) {
          try {
            var _contentDigest$match, _signature$match;
            const clone = r2.clone();
            const responseBodyText = await clone.text();
            const contentDigest = r2.headers.get("Content-Digest");
            const signatureInput = r2.headers.get("Signature-Input");
            const signature2 = r2.headers.get("Signature");
            if (!contentDigest) {
              throw new Error("Content-Digest header not set");
            }
            if (!signatureInput) {
              throw new Error("Signature-Input header not set");
            }
            if (!signature2) {
              throw new Error("Signature header not set");
            }
            const contentDigestSha = (_contentDigest$match = contentDigest.match(":(.*):")) == null ? void 0 : _contentDigest$match[1];
            if (!contentDigestSha) {
              throw new Error("Content digest not found");
            }
            const responseBodyTextUint8Array = new TextEncoder().encode(responseBodyText);
            const responseBodyTextDigest = await _this.cryptoBackend.digest("SHA-256", responseBodyTextUint8Array);
            const base64EncodedDigest = btoa(String.fromCharCode(...responseBodyTextDigest));
            if (contentDigestSha !== base64EncodedDigest) {
              throw new Error("Digest mismatch");
            }
            const message = `"content-digest": ${contentDigest}
"@signature-params": ${signatureInput.substring(4)}`;
            const algo = {
              name: "RSASSA-PKCS1-v1_5",
              hash: "SHA-256"
            };
            const jwks = r2.url.includes("dev-waas") ? jwksDev : jwksProd;
            const key = await _this.cryptoBackend.importKey("jwk", jwks.keys[0], algo, false, ["verify"]);
            const sig = (_signature$match = signature2.match(":(.*):")) == null ? void 0 : _signature$match[1];
            if (!sig) {
              throw new Error("Signature not found");
            }
            const signatureBuffer = Uint8Array.from(atob(sig), (c2) => c2.charCodeAt(0));
            const verifyResult = await _this.cryptoBackend.verify(algo, key, signatureBuffer, new TextEncoder().encode(message));
            if (!verifyResult) {
              throw new Error("Signature verification failed, consequent requests will fail");
            }
          } catch (e2) {
            _this.signatureVerificationFailed = true;
            throw e2;
          }
        });
      }
      return response;
    };
    this.config = defaultArgsOrFail(config2);
    this.waas = new SequenceWaaSBase(_extends$3({
      network: 1
    }, config2), this.store, this.cryptoBackend, this.secureStoreBackend);
    this.client = new WaasAuthenticator(this.config.rpcServer, this._fetch);
    this.deviceName = new StoreObj(this.store, "@0xsequence.waas.auth.deviceName", void 0);
  }
  get email() {
    if (this.emailClient) {
      return this.emailClient;
    }
    if (!this.config.emailRegion) {
      throw new Error("Missing emailRegion");
    }
    if (!this.config.emailClientId) {
      throw new Error("Missing emailClientId");
    }
    this.emailClient = new EmailAuth(this.config.emailRegion, this.config.emailClientId);
    return this.emailClient;
  }
  async onValidationRequired(callback) {
    this.validationRequiredCallback.push(callback);
    return () => {
      this.validationRequiredCallback = this.validationRequiredCallback.filter((c2) => c2 !== callback);
    };
  }
  onEmailConflict(callback) {
    this.emailConflictCallback.push(callback);
    return () => {
      this.emailConflictCallback = this.emailConflictCallback.filter((c2) => c2 !== callback);
    };
  }
  onEmailAuthCodeRequired(callback) {
    this.emailAuthCodeRequiredCallback.push(callback);
    return () => {
      this.emailAuthCodeRequiredCallback = this.emailAuthCodeRequiredCallback.filter((c2) => c2 !== callback);
    };
  }
  async handleValidationRequired({
    onValidationRequired
  } = {}) {
    var _await$this$deviceNam;
    const proceed = onValidationRequired ? onValidationRequired() : true;
    if (!proceed) {
      return false;
    }
    const intent = await this.waas.validateSession({
      deviceMetadata: (_await$this$deviceNam = await this.deviceName.get()) != null ? _await$this$deviceNam : "Unknown device"
    });
    const sendIntent = await this.sendIntent(intent);
    this.validationRequiredSalt = sendIntent.data.salt;
    for (const callback of this.validationRequiredCallback) {
      callback();
    }
    return this.waitForSessionValid();
  }
  headers() {
    return {
      "X-Access-Key": this.config.projectAccessKey
    };
  }
  async sendIntent(intent) {
    const sessionId = await this.waas.getSessionId();
    if (!sessionId) {
      throw new Error("session not open");
    }
    try {
      const res = await this.client.sendIntent({
        intent
      }, this.headers());
      return res.response;
    } catch (e2) {
      if (isIntentTimeError(e2) && this.lastDate) {
        const newIntent = await this.waas.updateIntentTime(intent, this.lastDate);
        const res = await this.client.sendIntent({
          intent: newIntent
        }, this.headers());
        return res.response;
      }
      throw e2;
    }
  }
  async isSignedIn() {
    return this.waas.isSignedIn();
  }
  async signIn(creds, sessionName) {
    var _this2 = this;
    const currentSessionId = await this.waas.getSessionId();
    if (currentSessionId) {
      await this.dropSession({
        sessionId: currentSessionId,
        strict: false
      });
    }
    const isEmailAuth = "email" in creds;
    if (isEmailAuth && this.emailAuthCodeRequiredCallback.length == 0) {
      return Promise.reject("Missing emailAuthCodeRequired callback");
    }
    return new Promise(async function(resolve, reject) {
      let challenge;
      try {
        challenge = await _this2.initAuth(creds);
      } catch (e2) {
        return reject(e2);
      }
      const respondToChallenge = async function respondToChallenge2(answer) {
        try {
          const res = await _this2.completeAuth(challenge.withAnswer(answer), {
            sessionName
          });
          resolve(res);
        } catch (e2) {
          if (e2 instanceof AnswerIncorrectError) {
            throw e2;
          } else if (e2 instanceof EmailAlreadyInUseError) {
            const forceCreate = async function forceCreate2() {
              try {
                const res = await _this2.completeAuth(challenge.withAnswer(answer), {
                  sessionName,
                  forceCreateAccount: true
                });
                resolve(res);
              } catch (e3) {
                reject(e3);
              }
            };
            const info = {
              type: IdentityType.None,
              email: "",
              issuer: ""
            };
            if (e2.cause) {
              const parts = e2.cause.split("|");
              if (parts.length >= 2) {
                info.type = parts[0];
                info.email = parts[1];
              }
              if (parts.length >= 3) {
                info.issuer = parts[2];
              }
            }
            for (const callback of _this2.emailConflictCallback) {
              callback(info, forceCreate);
            }
          } else {
            reject(e2);
          }
        }
      };
      if (isEmailAuth) {
        for (const callback of _this2.emailAuthCodeRequiredCallback) {
          callback(respondToChallenge);
        }
      } else {
        respondToChallenge("");
      }
    });
  }
  async initAuth(identity) {
    if ("guest" in identity && identity.guest) {
      return this.initGuestAuth();
    } else if ("idToken" in identity) {
      return this.initIdTokenAuth(identity.idToken);
    } else if ("email" in identity) {
      return this.initEmailAuth(identity.email);
    } else if ("playFabTitleId" in identity) {
      return this.initPlayFabAuth(identity.playFabTitleId, identity.playFabSessionTicket);
    }
    throw new Error("invalid identity");
  }
  async initGuestAuth() {
    const sessionId = await this.waas.getSessionId();
    const intent = await this.waas.initiateGuestAuth();
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new GuestChallenge(sessionId, res.data.challenge);
  }
  async initIdTokenAuth(idToken) {
    var _decoded$iss;
    const decoded = jwtDecode(idToken);
    const isStytch = ((_decoded$iss = decoded.iss) == null ? void 0 : _decoded$iss.startsWith("stytch.com/")) || false;
    const intent = isStytch ? await this.waas.initiateStytchAuth(idToken, decoded.exp) : await this.waas.initiateIdTokenAuth(idToken, decoded.exp);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return isStytch ? new StytchChallenge(idToken) : new IdTokenChallenge(idToken);
  }
  async initEmailAuth(email2) {
    const sessionId = await this.waas.getSessionId();
    const intent = await this.waas.initiateEmailAuth(email2);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new EmailChallenge(email2, sessionId, res.data.challenge);
  }
  async initPlayFabAuth(titleId, sessionTicket) {
    const intent = await this.waas.initiatePlayFabAuth(titleId, sessionTicket);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new PlayFabChallenge(titleId, sessionTicket);
  }
  async completeAuth(challenge, opts) {
    const isSignedIn = await this.isSignedIn();
    if (isSignedIn) {
      throw new Error("You are already signed in. Use dropSession to sign out from current session first.");
    }
    if (!opts) {
      opts = {};
    }
    if (!opts.sessionName) {
      opts.sessionName = "session name";
    }
    const intent = await this.waas.completeAuth(challenge.getIntentParams(), {
      forceCreateAccount: opts.forceCreateAccount
    });
    try {
      const res = await this.registerSession(intent, opts.sessionName);
      await this.waas.completeSignIn({
        code: "sessionOpened",
        data: {
          sessionId: res.session.id,
          wallet: res.response.data.wallet
        }
      });
      return {
        sessionId: res.session.id,
        wallet: res.response.data.wallet,
        email: res.session.identity.email
      };
    } catch (e2) {
      if (!(e2 instanceof EmailAlreadyInUseError) && !(e2 instanceof AnswerIncorrectError)) {
        await this.waas.completeSignOut();
      }
      throw e2;
    }
  }
  async registerSession(intent, name2) {
    try {
      const res = await this.client.registerSession({
        intent,
        friendlyName: name2
      }, this.headers());
      return res;
    } catch (e2) {
      if (isIntentTimeError(e2) && this.lastDate) {
        const newIntent = await this.waas.updateIntentTime(intent, this.lastDate);
        return await this.client.registerSession({
          intent: newIntent,
          friendlyName: name2
        }, this.headers());
      }
      throw e2;
    }
  }
  async refreshSession() {
    throw new Error("Not implemented");
  }
  async getSessionId() {
    return this.waas.getSessionId();
  }
  async getSessionHash() {
    const sessionId = (await this.waas.getSessionId()).toLowerCase();
    return id$1(sessionId);
  }
  async dropSession({
    sessionId,
    strict
  } = {}) {
    const thisSessionId = await this.waas.getSessionId();
    if (!thisSessionId) {
      throw new Error("session not open");
    }
    const closeSessionId = sessionId || thisSessionId;
    try {
      const intent = await this.waas.signOutSession(closeSessionId);
      const result = await this.sendIntent(intent);
      if (!isCloseSessionResponse(result)) {
        throw new Error(`Invalid response: ${JSON.stringify(result)}`);
      }
    } catch (e2) {
      if (strict) {
        throw e2;
      }
      console.error(e2);
    }
    if (closeSessionId === thisSessionId) {
      if (!this.secureStoreBackend) {
        throw new Error("No secure store available");
      }
      const session = await newSessionFromSessionId(thisSessionId, this.cryptoBackend, this.secureStoreBackend);
      session.clear();
      await this.waas.completeSignOut();
      await this.deviceName.set(void 0);
    }
  }
  async listSessions() {
    const sessionId = await this.waas.getSessionId();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = await this.waas.listSessions();
    const res = await this.sendIntent(intent);
    return res.data.map((session) => _extends$3({}, session, {
      isThis: session.id === sessionId
    }));
  }
  // WaaS specific methods
  async getAddress() {
    return this.waas.getAddress();
  }
  async validateSession(args) {
    if (await this.isSessionValid()) {
      return true;
    }
    return this.handleValidationRequired(args);
  }
  async finishValidateSession(challenge) {
    const intent = await this.waas.finishValidateSession(this.validationRequiredSalt, challenge);
    const result = await this.sendIntent(intent);
    if (!isFinishValidateSessionResponse(result)) {
      throw new Error(`Invalid response: ${JSON.stringify(result)}`);
    }
    this.validationRequiredSalt = "";
    return result.data.isValid;
  }
  async isSessionValid() {
    const intent = await this.waas.getSession();
    const result = await this.sendIntent(intent);
    if (!isGetSessionResponse(result)) {
      throw new Error(`Invalid response: ${JSON.stringify(result)}`);
    }
    return result.data.validated;
  }
  async waitForSessionValid(timeout = 6e5, pollRate = 2e3) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (await this.isSessionValid()) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, pollRate));
    }
    return false;
  }
  async sessionAuthProof({
    nonce,
    network: network2,
    validation
  }) {
    const intent = await this.waas.sessionAuthProof({
      nonce,
      network: network2
    });
    return await this.trySendIntent({
      validation
    }, intent, isSessionAuthProofResponse);
  }
  async listAccounts() {
    const intent = await this.waas.listAccounts();
    const res = await this.sendIntent(intent);
    if (!isListAccountsResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async linkAccount(challenge) {
    const intent = await this.waas.linkAccount(challenge.getIntentParams());
    const res = await this.sendIntent(intent);
    if (!isLinkAccountResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async removeAccount(accountId) {
    const intent = await this.waas.removeAccount({
      accountId
    });
    await this.sendIntent(intent);
  }
  async getIdToken(args) {
    const intent = await this.waas.getIdToken({
      nonce: args == null ? void 0 : args.nonce
    });
    const res = await this.sendIntent(intent);
    if (!isGetIdTokenResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async useIdentifier(args) {
    if (args.identifier) {
      return args;
    }
    const identifier = `ts-sdk-${Date.now()}-${await this.waas.getSessionId()}`;
    return _extends$3({}, args, {
      identifier
    });
  }
  async trySendIntent(args, intent, isExpectedResponse) {
    const response = await this.sendIntent(intent);
    if (isExpectedResponse(response)) {
      return response;
    }
    if (isValidationRequiredResponse(response)) {
      const proceed = await this.handleValidationRequired(args.validation);
      if (proceed) {
        const response2 = await this.sendIntent(intent);
        if (isExpectedResponse(response2)) {
          return response2;
        }
      }
    }
    throw new Error(JSON.stringify(response));
  }
  async signMessage(args) {
    const intent = await this.waas.signMessage(await this.useIdentifier(args));
    return this.trySendIntent(args, intent, isSignedMessageResponse);
  }
  async trySendTransactionIntent(intent, args) {
    let result = await this.trySendIntent(args, intent, isMaySentTransactionResponse);
    while (isTimedOutTransactionResponse(result)) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      const receiptArgs = {
        metaTxHash: result.data.metaTxHash,
        network: intent.data.network,
        identifier: intent.data.identifier,
        validation: args.validation
      };
      const receiptIntent = await this.waas.getTransactionReceipt(await this.useIdentifier(receiptArgs));
      result = await this.trySendIntent(receiptArgs, receiptIntent, isMaySentTransactionResponse);
    }
    return result;
  }
  async sendTransaction(args) {
    const intent = await this.waas.sendTransaction(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC20(args) {
    const intent = await this.waas.sendERC20(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC721(args) {
    const intent = await this.waas.sendERC721(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC1155(args) {
    const intent = await this.waas.sendERC1155(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async callContract(args) {
    const intent = await this.waas.callContract(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async feeOptions(args) {
    const intent = await this.waas.feeOptions(await this.useIdentifier(args));
    return this.trySendIntent(args, intent, isFeeOptionsResponse);
  }
  async networkList() {
    const networks2 = [];
    const chainList = await this.client.chainList({
      "X-Access-Key": this.config.projectAccessKey
    });
    for (const chain of chainList.chains) {
      networks2.push({
        id: chain.id,
        name: chain.name,
        isEnabled: chain.isEnabled
      });
    }
    return networks2;
  }
  onSessionStateChanged(callback) {
    return this.waas.onSessionStateChanged(callback);
  }
  // Special version of fetch that keeps track of the last seen Date header
  async fetch(input2, init2) {
    const res = await globalThis.fetch(input2, init2);
    const headerValue = res.headers.get("date");
    if (headerValue) {
      this.lastDate = new Date(headerValue);
    }
    return res;
  }
}
const accountTypeText = (info) => {
  if (!info) {
    return "Unknown account type";
  }
  if (info.type === IdentityType.PlayFab) {
    return "PlayFab login";
  }
  if (info.type === IdentityType.Email) {
    return "Email login";
  }
  if (info.type === IdentityType.OIDC) {
    if (info.issuer.includes("cognito-idp")) {
      return "Legacy Email login";
    }
    switch (info.issuer) {
      case "https://accounts.google.com":
        return "Google login";
      case "https://appleid.apple.com":
        return "Apple login";
      default:
        return "Unknown account type";
    }
  }
  return info.type;
};
const useEmailConflict = () => {
  const { connectors } = useConnect();
  const forceCreateFuncRef = reactExports.useRef(null);
  const [isOpen, toggleModal] = reactExports.useState(false);
  const [emailConflictInfo, setEmailConflictInfo] = reactExports.useState(null);
  const waasConnector = connectors.find((connector) => !!connector.sequenceWaas);
  const waas = waasConnector == null ? void 0 : waasConnector.sequenceWaas;
  reactExports.useEffect(() => {
    if (waas) {
      const disposer = waas.onEmailConflict(async (info, forceCreate) => {
        forceCreateFuncRef.current = forceCreate;
        setEmailConflictInfo(info);
        toggleModal(true);
      });
      return disposer;
    }
  }, []);
  return {
    toggleEmailConflictModal: toggleModal,
    isEmailConflictOpen: isOpen,
    emailConflictInfo: {
      email: (emailConflictInfo == null ? void 0 : emailConflictInfo.email) ?? "Unknown",
      type: accountTypeText(emailConflictInfo)
    },
    forceCreate: async () => {
      var _a2;
      return (_a2 = forceCreateFuncRef.current) == null ? void 0 : _a2.call(forceCreateFuncRef, true);
    }
  };
};
const getModalPositionCss = (position) => {
  switch (position) {
    case "top-right":
      return {
        top: "0px",
        right: "0px"
      };
    case "top-left":
      return {
        top: "0px",
        left: "0px"
      };
    case "top-center":
      return {
        top: "0px"
      };
    case "bottom-right":
      return {
        bottom: "0px",
        right: "0px"
      };
    case "bottom-left":
      return {
        bottom: "0px",
        left: "0px"
      };
    case "bottom-center":
      return {
        bottom: "0px"
      };
    case "middle-right":
      return {
        right: "0px"
      };
    case "middle-left":
      return {
        left: "0px"
      };
    case "center":
    default:
      return {};
  }
};
var dist = {};
var AppleSigninButton$1 = {};
var useScript$1 = {};
Object.defineProperty(useScript$1, "__esModule", {
  value: true
});
useScript$1.default = void 0;
var _react$2 = reactExports;
function useScript(src) {
  (0, _react$2.useEffect)(
    function() {
      if (!src) {
        return;
      }
      var script = document.querySelectorAll('script[src="'.concat(src, '"]'))[0];
      if (!script) {
        script = document.createElement("script");
        script.src = src;
        script.async = true;
        document.body.appendChild(script);
      }
    },
    [src]
    // Only re-run effect if script src changes
  );
}
var _default$3 = useScript;
useScript$1.default = _default$3;
var appleAuthHelpers = {};
var waitForVar$1 = {};
Object.defineProperty(waitForVar$1, "__esModule", {
  value: true
});
waitForVar$1.default = void 0;
var waitForVar = function waitForVar2(name2) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    pollFrequency: 1e3,
    retries: 100,
    parent: window
  }, _ref$pollFrequency = _ref.pollFrequency, pollFrequency = _ref$pollFrequency === void 0 ? 1e3 : _ref$pollFrequency, _ref$retries = _ref.retries, inRetries = _ref$retries === void 0 ? 100 : _ref$retries, _ref$parent = _ref.parent, parent2 = _ref$parent === void 0 ? window : _ref$parent;
  if (parent2 && parent2.hasOwnProperty(name2)) {
    return Promise.resolve(parent2[name2]);
  }
  if (!inRetries) {
    return Promise.resolve(void 0);
  }
  var retries = inRetries - 1;
  return new Promise(function(resolve) {
    return setTimeout(resolve, typeof pollFrequency === "function" ? pollFrequency({
      retries
    }) : pollFrequency);
  }).then(function() {
    return waitForVar2(name2, {
      pollFrequency,
      parent: parent2,
      retries
    });
  });
};
var _default$2 = waitForVar;
waitForVar$1.default = _default$2;
Object.defineProperty(appleAuthHelpers, "__esModule", {
  value: true
});
appleAuthHelpers.default = void 0;
var _waitForVar = _interopRequireDefault$2(waitForVar$1);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var APPLE_SCRIPT_SRC = "https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js";
var signIn = function signIn2(_ref) {
  var authOptions = _ref.authOptions, onSuccess = _ref.onSuccess, onError = _ref.onError;
  return (
    /** wait for apple sript to load */
    (0, _waitForVar.default)("AppleID").then(function() {
      if (!window.AppleID) {
        console.error(new Error("Error loading apple script"));
      }
      window.AppleID.auth.init(authOptions);
      return window.AppleID.auth.signIn().then(function(response) {
        if (onSuccess) {
          onSuccess(response);
        }
        return response;
      }).catch(function(err) {
        if (onError) {
          onError(err);
        } else {
          console.error(err);
        }
        return null;
      });
    }).catch(function(err) {
      if (onError) {
        onError(err);
      } else {
        console.error(err);
      }
      return null;
    })
  );
};
var _default$1 = {
  APPLE_SCRIPT_SRC,
  signIn
};
appleAuthHelpers.default = _default$1;
Object.defineProperty(AppleSigninButton$1, "__esModule", {
  value: true
});
AppleSigninButton$1.default = void 0;
var _react$1 = _interopRequireDefault$1(reactExports);
var _useScript = _interopRequireDefault$1(useScript$1);
var _appleAuthHelpers = _interopRequireDefault$1(appleAuthHelpers);
var _excluded$1 = ["onSuccess", "onError", "skipScript", "authOptions", "iconProps", "render", "uiType", "className", "noDefaultStyle", "buttonExtraChildren"];
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function ownKeys$1(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var _style = "\n.react-apple-signin-auth-btn {\n  background-color: transparent;\n  border: none;\n  padding: 0;\n  cursor: pointer;\n  border-radius: 4px;\n  padding: 0 8px 0 2px;\n  font-size: 14px;\n  font-size: 1em;\n  line-height: 1;\n  border: 1px solid #000;\n  overflow: hidden;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n}\n.react-apple-signin-auth-btn-light {\n  background-color: #FFF;\n  color: #000;\n  border-color: #000;\n}\n.react-apple-signin-auth-btn-dark {\n  background-color: #000;\n  color: #FFF;\n  border-color: #FFF;\n}".replace(/ {2}|\n/g, "");
var AppleSigninButton = function AppleSigninButton2(_ref) {
  var onSuccess = _ref.onSuccess, onError = _ref.onError, _ref$skipScript = _ref.skipScript, skipScript = _ref$skipScript === void 0 ? false : _ref$skipScript, authOptions = _ref.authOptions, iconProps = _ref.iconProps, render = _ref.render, _ref$uiType = _ref.uiType, uiType = _ref$uiType === void 0 ? "dark" : _ref$uiType, className = _ref.className, _ref$noDefaultStyle = _ref.noDefaultStyle, noDefaultStyle = _ref$noDefaultStyle === void 0 ? false : _ref$noDefaultStyle, _ref$buttonExtraChild = _ref.buttonExtraChildren, buttonExtraChildren = _ref$buttonExtraChild === void 0 ? "Continue with Apple" : _ref$buttonExtraChild, rest = _objectWithoutProperties$1(_ref, _excluded$1);
  (0, _useScript.default)(skipScript ? null : _appleAuthHelpers.default.APPLE_SCRIPT_SRC);
  var handleClick = function handleClick2(e2) {
    if (e2) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    _appleAuthHelpers.default.signIn({
      authOptions,
      onSuccess,
      onError
    });
  };
  var props = _objectSpread$1({
    children: /* @__PURE__ */ _react$1.default.createElement(_react$1.default.Fragment, null, /* @__PURE__ */ _react$1.default.createElement("svg", _extends$2({
      width: "24px",
      height: "44px",
      viewBox: "0 0 24 44"
    }, iconProps), /* @__PURE__ */ _react$1.default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ _react$1.default.createElement("rect", {
      fill: uiType === "light" ? "#FFF" : "#000",
      x: "0",
      y: "0",
      width: "24",
      height: "44"
    }), /* @__PURE__ */ _react$1.default.createElement("path", {
      d: "M12.2337427,16.9879688 C12.8896607,16.9879688 13.7118677,16.5445313 14.2014966,15.9532812 C14.6449341,15.4174609 14.968274,14.6691602 14.968274,13.9208594 C14.968274,13.8192383 14.9590357,13.7176172 14.9405591,13.6344727 C14.2107349,13.6621875 13.3330982,14.1241016 12.8065162,14.7430664 C12.3907935,15.2142188 12.012024,15.9532812 12.012024,16.7108203 C12.012024,16.8216797 12.0305005,16.9325391 12.0397388,16.9694922 C12.0859302,16.9787305 12.1598365,16.9879688 12.2337427,16.9879688 Z M9.92417241,28.1662891 C10.8202857,28.1662891 11.2175318,27.5658008 12.3353638,27.5658008 C13.4716724,27.5658008 13.721106,28.1478125 14.7188404,28.1478125 C15.6980982,28.1478125 16.3540162,27.2424609 16.972981,26.3555859 C17.6658521,25.339375 17.9522388,24.3416406 17.9707154,24.2954492 C17.9060474,24.2769727 16.0306763,23.5101953 16.0306763,21.3576758 C16.0306763,19.491543 17.5088013,18.6508594 17.5919459,18.5861914 C16.612688,17.1819727 15.1253248,17.1450195 14.7188404,17.1450195 C13.6194849,17.1450195 12.7233716,17.8101758 12.1598365,17.8101758 C11.5501099,17.8101758 10.7463794,17.1819727 9.79483648,17.1819727 C7.98413335,17.1819727 6.14571538,18.6785742 6.14571538,21.5054883 C6.14571538,23.2607617 6.8293482,25.1176563 7.67003179,26.3186328 C8.39061773,27.3348438 9.01882085,28.1662891 9.92417241,28.1662891 Z",
      fill: uiType === "light" ? "#000" : "#FFF",
      fillRule: "nonzero"
    }))), buttonExtraChildren),
    onClick: handleClick
  }, rest);
  if (render) {
    return render(props);
  }
  return /* @__PURE__ */ _react$1.default.createElement(_react$1.default.Fragment, null, /* @__PURE__ */ _react$1.default.createElement("button", _extends$2({
    className: "".concat(noDefaultStyle ? "" : "react-apple-signin-auth-btn react-apple-signin-auth-btn-".concat(uiType)).concat(className ? " ".concat(className) : ""),
    type: "button",
    "aria-label": "Signin with apple ID"
  }, props)), noDefaultStyle ? null : /* @__PURE__ */ _react$1.default.createElement("style", null, _style));
};
var _default = AppleSigninButton;
AppleSigninButton$1.default = _default;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "appleAuthHelpers", {
    enumerable: true,
    get: function get2() {
      return _appleAuthHelpers2.default;
    }
  });
  Object.defineProperty(exports, "useScript", {
    enumerable: true,
    get: function get2() {
      return _useScript2.default;
    }
  });
  exports.default = void 0;
  var _AppleSigninButton = _interopRequireDefault2(AppleSigninButton$1);
  var _appleAuthHelpers2 = _interopRequireDefault2(appleAuthHelpers);
  var _useScript2 = _interopRequireDefault2(useScript$1);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default2 = _AppleSigninButton.default;
  exports.default = _default2;
})(dist);
sequenceWallet.type = "sequence";
function sequenceWallet(params) {
  const { defaultNetwork, connect: connect2, walletAppURL } = params;
  const { projectAccessKey: projectAccessKey2 } = connect2;
  return createConnector((config2) => ({
    id: "sequence",
    name: "Sequence",
    type: sequenceWallet.type,
    params,
    setEmail(email2) {
      if (params.connect.settings) {
        params.connect.settings.signInWithEmail = email2;
      }
    },
    async setup() {
      const provider2 = await this.getProvider();
      provider2.on("chainChanged", (chainIdHex) => {
        config2.emitter.emit("change", { chainId: normalizeChainId$1(chainIdHex) });
      });
      provider2.on("disconnect", () => {
        this.onDisconnect();
      });
    },
    async connect() {
      var _a2, _b2, _c2, _d2, _e2, _f2;
      const provider2 = await this.getProvider();
      if (!provider2.isConnected()) {
        const localStorageTheme = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(LocalStorageKey.Theme));
        const ethAuthSettings = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem(LocalStorageKey.EthAuthSettings)) ?? {};
        const connectOptionsWithTheme = {
          authorize: true,
          askForEmail: true,
          ...ethAuthSettings,
          ...connect2,
          settings: {
            theme: localStorageTheme || "dark",
            ...connect2 == null ? void 0 : connect2.settings
          }
        };
        const e2 = await provider2.connect(connectOptionsWithTheme);
        if (e2.error) {
          throw new UserRejectedRequestError(new Error(e2.error));
        }
        if (!e2.connected) {
          throw new UserRejectedRequestError(new Error("Wallet connection rejected"));
        }
        const proofString = (_c2 = e2.proof) == null ? void 0 : _c2.proofString;
        const proofTypedData = (_d2 = e2.proof) == null ? void 0 : _d2.typedData;
        if (proofString && proofTypedData) {
          const jsonEthAuthProof = {
            proofString,
            typedData: proofTypedData
          };
          await ((_e2 = config2.storage) == null ? void 0 : _e2.setItem(LocalStorageKey.EthAuthProof, jsonEthAuthProof));
        }
        await ((_f2 = config2.storage) == null ? void 0 : _f2.setItem(LocalStorageKey.WaasSignInEmail, e2.email || null));
      }
      const accounts = await this.getAccounts();
      return {
        accounts: [...accounts],
        chainId: provider2.getChainId()
      };
    },
    async disconnect() {
      var _a2;
      const provider2 = await this.getProvider();
      provider2.disconnect();
      await ((_a2 = config2.storage) == null ? void 0 : _a2.removeItem(LocalStorageKey.WaasSignInEmail));
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      const signer2 = provider2.getSigner();
      const account2 = getAddress$1(await signer2.getAddress());
      return [account2];
    },
    async getProvider() {
      try {
        const provider2 = sequence$1.getWallet();
        return provider2;
      } catch (err) {
        if (!projectAccessKey2) {
          throw "projectAccessKey not found";
        }
        const provider2 = sequence$1.initWallet(projectAccessKey2, {
          defaultNetwork,
          transports: {
            walletAppURL: walletAppURL || "https://sequence.app"
          },
          defaultEIP6492: true,
          analytics: false
        });
        const chainId = provider2.getChainId();
        config2.emitter.emit("change", { chainId: normalizeChainId$1(chainId) });
        return provider2;
      }
    },
    async isAuthorized() {
      try {
        const account2 = await this.getAccounts();
        return !!account2;
      } catch (e2) {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const provider2 = await this.getProvider();
      const chain = config2.chains.find((c2) => c2.id === chainId) || config2.chains[0];
      provider2.setDefaultChainId(normalizeChainId$1(chainId));
      config2.emitter.emit("change", { chainId });
      return chain;
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = provider2.getChainId();
      return chainId;
    },
    async onAccountsChanged(accounts) {
      return { account: accounts[0] };
    },
    async onChainChanged(chain) {
      const provider2 = await this.getProvider();
      config2.emitter.emit("change", { chainId: normalizeChainId$1(chain) });
      provider2.setDefaultChainId(normalizeChainId$1(chain));
    },
    async onConnect(_connectinfo) {
    },
    async onDisconnect() {
      var _a2;
      await ((_a2 = config2.storage) == null ? void 0 : _a2.removeItem(LocalStorageKey.EthAuthProof));
      config2.emitter.emit("disconnect");
    }
  }));
}
function normalizeChainId$1(chainId) {
  if (typeof chainId === "object")
    return normalizeChainId$1(chainId.chainId);
  if (typeof chainId === "string")
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset2) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
sequenceWaasWallet.type = "sequence-waas";
function sequenceWaasWallet(params) {
  const isDev = !!(params == null ? void 0 : params.isDev);
  const nodesUrl = isDev ? "https://dev-nodes.sequence.app" : "https://nodes.sequence.app";
  const showConfirmationModal = params.enableConfirmationModal ?? false;
  const sequenceWaas = new SequenceWaaS({
    waasConfigKey: params.waasConfigKey,
    projectAccessKey: params.projectAccessKey,
    network: params.network ?? 137
  });
  const sequenceWaasProvider = new SequenceWaasProvider(sequenceWaas, showConfirmationModal, nodesUrl);
  return createConnector((config2) => ({
    id: `sequence-waas`,
    name: "Sequence WaaS",
    type: sequenceWaasWallet.type,
    sequenceWaas,
    sequenceWaasProvider,
    params,
    async setup() {
      var _a2, _b2, _c2;
      if (typeof window !== "object") {
        return;
      }
      if (params.googleClientId) {
        await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem(LocalStorageKey.WaasGoogleClientID, params.googleClientId));
      }
      if (params.appleClientId) {
        await ((_b2 = config2.storage) == null ? void 0 : _b2.setItem(LocalStorageKey.WaasAppleClientID, params.appleClientId));
      }
      if (params.appleRedirectURI) {
        await ((_c2 = config2.storage) == null ? void 0 : _c2.setItem(LocalStorageKey.WaasAppleRedirectURI, params.appleRedirectURI));
      }
      sequenceWaasProvider.on("error", (error) => {
        if (isSessionInvalidOrNotFoundError(error)) {
          this.disconnect();
        }
      });
    },
    async connect(_connectInfo) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
      const provider2 = await this.getProvider();
      const isSignedIn = await provider2.sequenceWaas.isSignedIn();
      if (!isSignedIn) {
        const googleIdToken = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(LocalStorageKey.WaasGoogleIdToken));
        const emailIdToken = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem(LocalStorageKey.WaasEmailIdToken));
        const appleIdToken = await ((_c2 = config2.storage) == null ? void 0 : _c2.getItem(LocalStorageKey.WaasAppleIdToken));
        let idToken;
        if (params.loginType === "google" && googleIdToken) {
          idToken = googleIdToken;
        } else if (params.loginType === "email" && emailIdToken) {
          idToken = emailIdToken;
        } else if (params.loginType === "apple" && appleIdToken) {
          idToken = appleIdToken;
        }
        await ((_d2 = config2.storage) == null ? void 0 : _d2.removeItem(LocalStorageKey.WaasGoogleIdToken));
        await ((_e2 = config2.storage) == null ? void 0 : _e2.removeItem(LocalStorageKey.WaasEmailIdToken));
        await ((_f2 = config2.storage) == null ? void 0 : _f2.removeItem(LocalStorageKey.WaasAppleIdToken));
        if (idToken) {
          try {
            const signInResponse = await provider2.sequenceWaas.signIn({ idToken }, randomName());
            if (signInResponse == null ? void 0 : signInResponse.email) {
              await ((_g2 = config2.storage) == null ? void 0 : _g2.setItem(LocalStorageKey.WaasSignInEmail, signInResponse.email));
            }
          } catch (e2) {
            console.log(e2);
            await this.disconnect();
            throw e2;
          }
        }
      }
      const accounts = await this.getAccounts();
      if (accounts.length) {
        await ((_h2 = config2.storage) == null ? void 0 : _h2.setItem(LocalStorageKey.WaasActiveLoginType, params.loginType));
      } else {
        throw new Error("No accounts found");
      }
      return {
        accounts,
        chainId: await this.getChainId()
      };
    },
    async disconnect() {
      var _a2, _b2;
      const provider2 = await this.getProvider();
      try {
        await provider2.sequenceWaas.dropSession({ sessionId: await provider2.sequenceWaas.getSessionId(), strict: false });
      } catch (e2) {
        console.log(e2);
      }
      await ((_a2 = config2.storage) == null ? void 0 : _a2.removeItem(LocalStorageKey.WaasActiveLoginType));
      await ((_b2 = config2.storage) == null ? void 0 : _b2.removeItem(LocalStorageKey.WaasSignInEmail));
      config2.emitter.emit("disconnect");
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      try {
        const isSignedIn = await provider2.sequenceWaas.isSignedIn();
        if (isSignedIn) {
          const address = await provider2.sequenceWaas.getAddress();
          return [getAddress$1(address)];
        }
      } catch (err) {
        return [];
      }
      return [];
    },
    async getProvider() {
      return sequenceWaasProvider;
    },
    async isAuthorized() {
      var _a2;
      const provider2 = await this.getProvider();
      const activeWaasOption = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(LocalStorageKey.WaasActiveLoginType));
      if (params.loginType !== activeWaasOption) {
        return false;
      }
      try {
        return await provider2.sequenceWaas.isSignedIn();
      } catch (e2) {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const provider2 = await this.getProvider();
      const chain = config2.chains.find((c2) => c2.id === chainId) || config2.chains[0];
      await provider2.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: toQuantity(chainId) }]
      });
      config2.emitter.emit("change", { chainId });
      return chain;
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      return Number(provider2.getChainId());
    },
    async onAccountsChanged(accounts) {
      return { account: accounts[0] };
    },
    async onChainChanged(chain) {
      config2.emitter.emit("change", { chainId: normalizeChainId(chain) });
    },
    async onConnect(_connectInfo) {
    },
    async onDisconnect() {
      await this.disconnect();
    }
  }));
}
class SequenceWaasProvider extends AbstractProvider {
  constructor(sequenceWaas, showConfirmation, nodesUrl) {
    var _a2;
    super(sequenceWaas.config.network);
    __publicField(this, "sequenceWaas");
    __publicField(this, "showConfirmation");
    __publicField(this, "nodesUrl");
    __publicField(this, "jsonRpcProvider");
    __publicField(this, "requestConfirmationHandler");
    __publicField(this, "feeConfirmationHandler");
    __publicField(this, "currentNetwork");
    this.sequenceWaas = sequenceWaas;
    this.showConfirmation = showConfirmation;
    this.nodesUrl = nodesUrl;
    const initialChain = sequenceWaas.config.network;
    const initialChainName = (_a2 = allNetworks$1.find((n2) => n2.chainId === initialChain || n2.name === initialChain)) == null ? void 0 : _a2.name;
    const initialJsonRpcProvider = new JsonRpcProvider$1(`${nodesUrl}/${initialChainName}/${sequenceWaas.config.projectAccessKey}`);
    this.jsonRpcProvider = initialJsonRpcProvider;
    this.currentNetwork = Network.from(sequenceWaas.config.network);
  }
  async request({ method, params }) {
    var _a2;
    if (method === "wallet_switchEthereumChain") {
      const chainId = normalizeChainId(params == null ? void 0 : params[0].chainId);
      const networkName = (_a2 = allNetworks$1.find((n2) => n2.chainId === chainId)) == null ? void 0 : _a2.name;
      const jsonRpcProvider = new JsonRpcProvider$1(`${this.nodesUrl}/${networkName}/${this.sequenceWaas.config.projectAccessKey}`);
      this.jsonRpcProvider = jsonRpcProvider;
      this.currentNetwork = Network.from(chainId);
      return null;
    }
    if (method === "eth_chainId") {
      return toQuantity(this.currentNetwork.chainId);
    }
    if (method === "eth_accounts") {
      const address = await this.sequenceWaas.getAddress();
      const account2 = getAddress$1(address);
      return [account2];
    }
    if (method === "eth_sendTransaction") {
      const txns = await resolveProperties$1(params == null ? void 0 : params[0]);
      const chainId = this.getChainId();
      let feeOptionsResponse;
      try {
        feeOptionsResponse = await this.checkTransactionFeeOptions({ transactions: [txns], chainId });
      } catch (error) {
        if (isSessionInvalidOrNotFoundError(error)) {
          await this.emit("error", error);
          throw new ProviderDisconnectedError(new Error("Provider is not connected"));
        } else {
          const message = typeof error === "object" && error !== null && "cause" in error ? String(error.cause) ?? "Failed to check transaction fee options" : "Failed to check transaction fee options";
          throw new InternalRpcError(new Error(message));
        }
      }
      const feeOptions2 = feeOptionsResponse == null ? void 0 : feeOptionsResponse.feeOptions;
      let selectedFeeOption;
      if (!(feeOptionsResponse == null ? void 0 : feeOptionsResponse.isSponsored) && feeOptions2 && feeOptions2.length > 0) {
        if (!this.feeConfirmationHandler) {
          throw new TransactionRejectedRpcError(new Error("Unable to send transaction: please use useWaasFeeOptions hook and pick a fee option"));
        }
        const id2 = v4();
        const confirmation = await this.feeConfirmationHandler.confirmFeeOption(id2, feeOptions2, txns, chainId);
        if (!confirmation.confirmed) {
          throw new UserRejectedRequestError(new Error("User rejected send transaction request"));
        }
        if (id2 !== confirmation.id) {
          throw new UserRejectedRequestError(new Error("User confirmation ids do not match"));
        }
        selectedFeeOption = feeOptions2.find((feeOption) => feeOption.token.contractAddress === confirmation.feeTokenAddress);
      }
      if (this.requestConfirmationHandler && this.showConfirmation) {
        const id2 = v4();
        const confirmation = await this.requestConfirmationHandler.confirmSignTransactionRequest(id2, txns, chainId);
        if (!confirmation.confirmed) {
          throw new UserRejectedRequestError(new Error("User rejected send transaction request"));
        }
        if (id2 !== confirmation.id) {
          throw new UserRejectedRequestError(new Error("User confirmation ids do not match"));
        }
      }
      let response;
      try {
        response = await this.sequenceWaas.sendTransaction({
          transactions: [await resolveProperties$1(params == null ? void 0 : params[0])],
          network: chainId,
          transactionsFeeOption: selectedFeeOption,
          transactionsFeeQuote: feeOptionsResponse == null ? void 0 : feeOptionsResponse.feeQuote
        });
      } catch (error) {
        if (isSessionInvalidOrNotFoundError(error)) {
          await this.emit("error", error);
          throw new ProviderDisconnectedError(new Error("Provider is not connected"));
        } else {
          const message = typeof error === "object" && error !== null && "cause" in error ? String(error.cause) ?? "Failed to send transaction" : "Failed to send transaction";
          throw new InternalRpcError(new Error(message));
        }
      }
      if (response.code === "transactionFailed") {
        throw new TransactionRejectedRpcError(new Error(`Unable to send transaction: ${response.data.error}`));
      }
      if (response.code === "transactionReceipt") {
        const { txHash } = response.data;
        return txHash;
      }
    }
    if (method === "eth_sign" || method === "eth_signTypedData" || method === "eth_signTypedData_v4" || method === "personal_sign") {
      if (this.requestConfirmationHandler && this.showConfirmation) {
        const id2 = v4();
        const confirmation = await this.requestConfirmationHandler.confirmSignMessageRequest(id2, params == null ? void 0 : params[0], Number(this.currentNetwork.chainId));
        if (!confirmation.confirmed) {
          throw new UserRejectedRequestError(new Error("User rejected sign message request"));
        }
        if (id2 !== confirmation.id) {
          throw new UserRejectedRequestError(new Error("User confirmation ids do not match"));
        }
      }
      let sig;
      try {
        sig = await this.sequenceWaas.signMessage({ message: params == null ? void 0 : params[0], network: Number(this.currentNetwork.chainId) });
      } catch (error) {
        if (isSessionInvalidOrNotFoundError(error)) {
          await this.emit("error", error);
          throw new ProviderDisconnectedError(new Error("Provider is not connected"));
        } else {
          const message = typeof error === "object" && error !== null && "cause" in error ? String(error.cause) ?? "Failed to sign message" : "Failed to sign message";
          throw new InternalRpcError(new Error(message));
        }
      }
      return sig.data.signature;
    }
    return await this.jsonRpcProvider.send(method, params ?? []);
  }
  async getTransaction(txHash) {
    return await this.jsonRpcProvider.getTransaction(txHash);
  }
  detectNetwork() {
    return Promise.resolve(this.currentNetwork);
  }
  getChainId() {
    return Number(this.currentNetwork.chainId);
  }
  async checkTransactionFeeOptions({ transactions: transactions2, chainId }) {
    const resp = await this.sequenceWaas.feeOptions({
      transactions: transactions2,
      network: chainId
    });
    if (resp.data.feeQuote && resp.data.feeOptions) {
      return { feeQuote: resp.data.feeQuote, feeOptions: resp.data.feeOptions, isSponsored: false };
    }
    return { feeQuote: resp.data.feeQuote, feeOptions: resp.data.feeOptions, isSponsored: true };
  }
}
const DEVICE_EMOJIS = [
  // 256 emojis for unsigned byte range 0 - 255
  ...""
];
function randomName() {
  const wordlistSize = 2048;
  const words2 = wordlists.en;
  const randomEmoji = DEVICE_EMOJIS[Math.floor(Math.random() * DEVICE_EMOJIS.length)];
  const randomWord1 = words2.getWord(Math.floor(Math.random() * wordlistSize));
  const randomWord2 = words2.getWord(Math.floor(Math.random() * wordlistSize));
  return `${randomEmoji} ${randomWord1} ${randomWord2}`;
}
function normalizeChainId(chainId) {
  if (typeof chainId === "object")
    return normalizeChainId(chainId.chainId);
  if (typeof chainId === "string")
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
function isSessionInvalidOrNotFoundError(error) {
  return error instanceof WebrpcEndpointError7 && error.cause === "session invalid or not found";
}
function useEmailAuth({ connector, onSuccess }) {
  if (!connector) {
    return {
      inProgress: false,
      loading: false,
      error: void 0,
      initiateAuth: async (_email) => {
      },
      sendChallengeAnswer: async (_answer) => {
      }
    };
  }
  const [email2, setEmail] = reactExports.useState("");
  const [error, setError] = reactExports.useState();
  const [loading, setLoading] = reactExports.useState(false);
  const [instance, setInstance] = reactExports.useState("");
  const [respondWithCode, setRespondWithCode] = reactExports.useState();
  const getSequenceWaas = () => {
    if (!connector) {
      throw new Error("Connector is not defined");
    }
    const sequenceWaas = connector.sequenceWaas;
    if (!sequenceWaas) {
      throw new Error("Connector does not support SequenceWaaS");
    }
    return sequenceWaas;
  };
  const initiateAuth2 = async (email3) => {
    const params = connector.params;
    const waas = getSequenceWaas();
    setLoading(true);
    setError(void 0);
    if (params.legacyEmailAuth) {
      try {
        const { instance: instance2 } = await waas.email.initiateAuth({ email: email3 });
        setInstance(instance2);
        setEmail(email3);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    } else {
      waas.onEmailAuthCodeRequired(async (respondWithCode2) => {
        setRespondWithCode(() => respondWithCode2);
      });
      waas.signIn({ email: email3 }, randomName()).then((signInResponse) => {
        onSuccess({ version: 2, signInResponse });
        if (signInResponse.email) {
          setEmail(signInResponse.email);
        }
      }).catch((err) => {
        setError(err);
      });
      setLoading(false);
    }
  };
  const sendChallengeAnswer = async (answer) => {
    const params = connector.params;
    const waas = getSequenceWaas();
    setLoading(true);
    setError(void 0);
    if (params.legacyEmailAuth) {
      try {
        const sessionHash = await waas.getSessionHash();
        const { idToken } = await waas.email.finalizeAuth({ instance, answer, email: email2, sessionHash });
        onSuccess({ version: 1, idToken });
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    } else {
      if (!respondWithCode) {
        throw new Error("Email v2 auth, respondWithCode is not defined");
      }
      try {
        await respondWithCode(answer);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }
  };
  const cancel = () => {
    setLoading(false);
    setRespondWithCode(null);
    setError(void 0);
  };
  return {
    inProgress: loading || !!instance,
    loading,
    error,
    initiateAuth: initiateAuth2,
    sendChallengeAnswer,
    cancel
  };
}
const isEmailValid = (email2) => {
  return /^\S+@\S+\.\S{2,}$/.test(email2);
};
const compareAddress$2 = (a2, b2) => {
  return a2.toLowerCase() === b2.toLowerCase();
};
var ValueType$2;
(function(ValueType2) {
  ValueType2[ValueType2["VERY_LARGE"] = 0] = "VERY_LARGE";
  ValueType2[ValueType2["FRACTION"] = 1] = "FRACTION";
  ValueType2[ValueType2["VERY_TINY"] = 2] = "VERY_TINY";
  ValueType2[ValueType2["MIXED"] = 3] = "MIXED";
})(ValueType$2 || (ValueType$2 = {}));
const capitalize = (word) => {
  return word.charAt(0).toUpperCase() + word.slice(1);
};
const BUTTON_SIZE = "14";
const ICON_SIZE = "10";
const getLogo = (theme, walletProps) => theme === "dark" ? walletProps.logoDark || walletProps.monochromeLogoDark : walletProps.logoLight || walletProps.monochromeLogoLight;
const ConnectButton = (props) => {
  const { connector, label, onConnect } = props;
  const { theme } = useTheme$1();
  const walletProps = connector._wallet;
  const Logo = getLogo(theme, walletProps);
  return jsxRuntimeExports$1.jsx(Tooltip, { message: label || walletProps.name, children: jsxRuntimeExports$1.jsx(Card, { clickable: true, width: BUTTON_SIZE, height: BUTTON_SIZE, padding: "2", borderRadius: "xs", justifyContent: "center", alignItems: "center", onClick: () => onConnect(connector), children: jsxRuntimeExports$1.jsx(Box, { as: Logo, width: ICON_SIZE, height: ICON_SIZE }) }) });
};
const GoogleWaasConnectButton = (props) => {
  const { connector, onConnect } = props;
  const storage = useStorage();
  const [enableGoogleTooltip, setEnableGoogleTooltip] = reactExports.useState(false);
  const { theme } = useTheme$1();
  const walletProps = connector._wallet;
  const Logo = getLogo(theme, walletProps);
  reactExports.useEffect(() => {
    setTimeout(() => {
      setEnableGoogleTooltip(true);
    }, 300);
  });
  return jsxRuntimeExports$1.jsx(Tooltip, { message: "Google", disabled: !enableGoogleTooltip, children: jsxRuntimeExports$1.jsxs(Card, { clickable: true, background: "transparent", borderRadius: "xs", padding: "0", width: BUTTON_SIZE, height: BUTTON_SIZE, position: "relative", children: [jsxRuntimeExports$1.jsx(Box, { width: "full", height: "full", overflow: "hidden", borderRadius: "sm", alignItems: "center", justifyContent: "center", style: { opacity: 1e-7, transform: "scale(1.4)" }, children: jsxRuntimeExports$1.jsx(GoogleLogin, { type: "icon", size: "large", width: "56", onSuccess: (credentialResponse) => {
    if (credentialResponse.credential) {
      storage == null ? void 0 : storage.setItem(LocalStorageKey.WaasGoogleIdToken, credentialResponse.credential);
      onConnect(connector);
    }
  }, onError: () => {
    console.log("Login Failed");
  } }) }), jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", borderRadius: "xs", display: "flex", justifyContent: "center", alignItems: "center", position: "absolute", pointerEvents: "none", width: "full", height: "full", top: "0", right: "0", children: jsxRuntimeExports$1.jsx(Box, { as: Logo, width: ICON_SIZE, height: ICON_SIZE }) })] }) });
};
const AppleWaasConnectButton = (props) => {
  const { connector, onConnect } = props;
  const storage = useStorage();
  const { data: appleClientId } = useStorageItem(LocalStorageKey.WaasAppleClientID);
  const { data: appleRedirectUri } = useStorageItem(LocalStorageKey.WaasAppleRedirectURI);
  return appleClientId && appleRedirectUri ? jsxRuntimeExports$1.jsx(ConnectButton, { connector, onConnect: () => {
    dist.appleAuthHelpers.signIn({
      authOptions: {
        clientId: appleClientId,
        redirectURI: appleRedirectUri,
        scope: "openid email",
        usePopup: true
      },
      onSuccess: (response) => {
        var _a2;
        if ((_a2 = response.authorization) == null ? void 0 : _a2.id_token) {
          storage == null ? void 0 : storage.setItem(LocalStorageKey.WaasAppleIdToken, response.authorization.id_token);
          onConnect(connector);
        } else {
          console.log("Apple login error: No id_token found");
        }
      },
      onError: (error) => console.error(error)
    });
  } }) : null;
};
const EmailConnectButton = (props) => {
  const { onClick } = props;
  return jsxRuntimeExports$1.jsx(Tooltip, { message: "Email", children: jsxRuntimeExports$1.jsx(Card, { clickable: true, width: BUTTON_SIZE, height: BUTTON_SIZE, padding: "2", borderRadius: "xs", justifyContent: "center", alignItems: "center", onClick, children: jsxRuntimeExports$1.jsx(SvgEmailIcon, { size: "xl", color: "text100" }) }) });
};
const SequenceLogo$1 = ({ ...props }) => {
  return jsxRuntimeExports$1.jsx(React.Fragment, { children: jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", style: { fill: "none" }, id: "svg1316", version: "1.1", viewBox: "0 0 396 396", ...props, children: [jsxRuntimeExports$1.jsx("g", { transform: "translate(0,38)", id: "g1256", clipPath: "url(#clip0_5_131)", children: jsxRuntimeExports$1.jsxs("g", { id: "g1254", clipPath: "url(#clip1_5_131)", children: [jsxRuntimeExports$1.jsx("path", { style: { fill: "#111111" }, id: "path1232", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint0_linear_5_13" }, id: "path1234", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint1_linear_5_131" }, id: "path1236", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint2_linear_5_131)" }, id: "path1238", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint3_linear_5_131)" }, id: "path1240", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint4_linear_5_131)" }, id: "path1242", d: "m 98.9999,238.126 c 0,-10.965 -8.8648,-19.854 -19.8,-19.854 -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.966 8.8648,19.855 19.8,19.855 10.9352,0 19.8,-8.889 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint5_linear_5_131)" }, id: "path1244", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint6_linear_5_131)" }, id: "path1246", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint7_linear_5_131)" }, id: "path1248", d: "M 316.8,59.5632 H 158.4 c -10.935,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.865,19.8544 19.8,19.8544 h 158.4 c 10.935,0 19.8,-8.8892 19.8,-19.8544 0,-10.9653 -8.865,-19.8544 -19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint8_linear_5_131)" }, id: "path1250", d: "M 316.8,218.272 H 158.4 c -10.935,0 -19.8,8.889 -19.8,19.854 0,10.966 8.865,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.889 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint9_linear_5_131)" }, id: "path1252", d: "M 237.6,138.981 H 79.2 c -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.965 8.8648,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.89 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" })] }) }), jsxRuntimeExports$1.jsxs("defs", { id: "defs1314", children: [jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "318", x2: "198", y1: "4.0585401e-05", x1: "198", id: "paint0_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1258", stopColor: "#1D273D" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1260", stopColor: "#0D0F13", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "63", x2: "92.5", y1: "99", x1: "65.5", id: "paint1_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1263", stopColor: "#4462FE" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1265", stopColor: "#7D69FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint2_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1268", stopColor: "#3757FD" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1270", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint3_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1273", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1275", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "223.5", x2: "91.5", y1: "251.5", x1: "65", id: "paint4_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1278", stopColor: "#BC3EE6" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1280", stopColor: "#D972F1", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "146", x2: "329.5", y1: "172", x1: "305", id: "paint5_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1283", stopColor: "#29BDFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1285", stopColor: "#96E7FB", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "176.772", x2: "334.56699", y1: "178.418", x1: "300.17999", id: "paint6_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1288", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1290", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "60", x2: "317.5", y1: "99", x1: "154.5", id: "paint7_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1293", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1295", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "218", x2: "312.5", y1: "258", x1: "156", id: "paint8_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1298", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1300", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "139", x2: "235.5", y1: "179", x1: "86.000099", id: "paint9_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1303", stopColor: "#6634FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1305", stopColor: "#9C6DFF", offset: "1" })] }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip0_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1308", height: "317.67001", width: "396" }) }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip1_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1311", height: "317.67001", width: "396" }) })] })] }) });
};
const PoweredBySequence = () => {
  return jsxRuntimeExports$1.jsxs(Box, { onClick: () => {
    if (typeof window !== "undefined") {
      window.open("https://sequence.xyz");
    }
  }, gap: "1", marginTop: "4", flexDirection: "row", alignItems: "center", justifyContent: "center", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text100", children: "Powered by Sequence" }), jsxRuntimeExports$1.jsx(Box, { height: "5", width: "5", children: jsxRuntimeExports$1.jsx(SequenceLogo$1, {}) })] });
};
const Banner = ({ config: config2 = {} }) => {
  const { signIn: signIn3 = {} } = config2;
  const { logoUrl } = signIn3;
  return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: logoUrl && jsxRuntimeExports$1.jsx(Box, { marginTop: "5", justifyContent: "center", alignItems: "center", children: jsxRuntimeExports$1.jsx(Image$1, { src: logoUrl, style: { height: "110px" } }) }) });
};
const EmailWaasVerify = (props) => {
  const { isLoading, error, onConfirm } = props;
  const [waasEmailPinCode, setWaasEmailPinCode] = reactExports.useState([]);
  return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: jsxRuntimeExports$1.jsxs(Box, { paddingY: "6", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Text, { marginTop: "5", marginBottom: "4", variant: "normal", color: "text80", children: "Enter code received in email." }), jsxRuntimeExports$1.jsx(PINCodeInput, { value: waasEmailPinCode, digits: 6, group: 3, onChange: setWaasEmailPinCode, disabled: isLoading }), jsxRuntimeExports$1.jsxs(Box, { gap: "4", marginTop: "4", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Button, { variant: "primary", disabled: waasEmailPinCode.includes("") || isLoading, label: "Confirm", onClick: () => onConfirm(waasEmailPinCode.join("")), "data-id": "verifyButton" }), isLoading && jsxRuntimeExports$1.jsx(Spinner, {}), error && jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "negative", textAlign: "center", children: error.message })] })] }) });
};
const ExtendedWalletList = ({ onConnect, connectors }) => {
  const { theme } = useTheme$1();
  const { isPending } = useConnect();
  return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", marginTop: "5", children: connectors.map((connector) => {
    const Logo = theme === "dark" ? connector._wallet.logoDark : connector._wallet.logoLight;
    const walletName = connector._wallet.name;
    const connectorId = connector._wallet.id;
    return jsxRuntimeExports$1.jsx(Button, { width: "full", shape: "square", leftIcon: () => jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", alignItems: "center", style: { backgroundColor: connector._wallet.iconBackground }, width: "8", height: "8", overflow: "hidden", children: jsxRuntimeExports$1.jsx(Logo, { style: { width: 30 } }) }), onClick: () => onConnect(connector), label: jsxRuntimeExports$1.jsxs(Text, { children: [walletName, isPending] }) }, connectorId);
  }) });
};
const Connect = (props) => {
  dist.useScript(dist.appleAuthHelpers.APPLE_SCRIPT_SRC);
  const { onClose, emailConflictInfo, config: config2 = {} } = props;
  const { signIn: signIn3 = {} } = config2;
  const { isConnected } = useAccount();
  const storage = useStorage();
  const [email2, setEmail] = reactExports.useState("");
  const [showEmailInput, setShowEmailInput] = reactExports.useState(false);
  const [showEmailWaasPinInput, setShowEmailWaasPinInput] = reactExports.useState(false);
  const [showExtendedList, setShowExtendedList] = reactExports.useState(false);
  const { connectors, connect: connect2 } = useConnect();
  const hasInjectedSequenceConnector = connectors.some((c2) => c2.id === "app.sequence");
  const baseWalletConnectors = connectors.filter((c2) => {
    return c2._wallet && (c2._wallet.type === "wallet" || c2._wallet.type === void 0);
  }).filter((c2) => {
    var _a2;
    if (((_a2 = c2._wallet) == null ? void 0 : _a2.id) === "sequence" && hasInjectedSequenceConnector) {
      return false;
    }
    return true;
  });
  const mockConnector = baseWalletConnectors.find((connector) => {
    return connector._wallet.id === "mock";
  });
  const injectedConnectors = connectors.filter((c2) => c2.type === "injected").filter((connector) => {
    if (connector.id === "com.coinbase.wallet") {
      return !connectors.find((connector2) => {
        var _a2;
        return ((_a2 = connector2 == null ? void 0 : connector2._wallet) == null ? void 0 : _a2.id) === "coinbase-wallet";
      });
    }
    return true;
  }).map((connector) => {
    const Logo = (props2) => {
      return jsxRuntimeExports$1.jsx(Image$1, { src: connector.icon, alt: connector.name, disableAnimation: true, ...props2 });
    };
    return {
      ...connector,
      _wallet: {
        id: connector.id,
        name: connector.name,
        logoLight: Logo,
        logoDark: Logo,
        type: "wallet"
      }
    };
  });
  const socialAuthConnectors = connectors.filter((c2) => {
    var _a2;
    return ((_a2 = c2._wallet) == null ? void 0 : _a2.type) === "social";
  });
  const walletConnectors = [...baseWalletConnectors, ...injectedConnectors];
  const emailConnector = socialAuthConnectors.find((c2) => c2._wallet.id.includes("email"));
  const isEmailOnly = emailConnector && socialAuthConnectors.length === 1;
  const displayExtendedListButton = walletConnectors.length > 7;
  const onChangeEmail = (ev) => {
    setEmail(ev.target.value);
  };
  reactExports.useEffect(() => {
    if (isConnected) {
      onClose();
    }
  }, [isConnected]);
  const onConnect = (connector) => {
    if (signIn3.useMock && mockConnector) {
      connect2({ connector: mockConnector });
      return;
    }
    if (connector._wallet.id === "email") {
      const email3 = prompt("Auto-email login, please specify the email address:");
      if ("setEmail" in connector) {
        connector.setEmail(email3);
      }
    }
    connect2({ connector });
  };
  const onConnectInlineEmail = async (e2) => {
    e2.preventDefault();
    if (signIn3.useMock && mockConnector) {
      connect2({ connector: mockConnector });
      return;
    }
    if (emailConnector) {
      if ("setEmail" in emailConnector) {
        emailConnector.setEmail(email2);
      }
      if (emailConnector._wallet.id === "email-waas") {
        try {
          await initiateEmailAuth(email2);
          setShowEmailWaasPinInput(true);
        } catch (e3) {
          console.log(e3);
        }
      } else {
        connect2({ connector: emailConnector });
      }
    }
  };
  const { inProgress: emailAuthInProgress, loading: emailAuthLoading, error: emailAuthError, initiateAuth: initiateEmailAuth, sendChallengeAnswer } = useEmailAuth({
    connector: emailConnector,
    onSuccess: async (result) => {
      var _a2;
      if ("signInResponse" in result && ((_a2 = result.signInResponse) == null ? void 0 : _a2.email)) {
        storage == null ? void 0 : storage.setItem(LocalStorageKey.WaasSignInEmail, result.signInResponse.email);
      }
      if (emailConnector) {
        if (result.version === 1) {
          storage == null ? void 0 : storage.setItem(LocalStorageKey.WaasEmailIdToken, result.idToken);
        }
        connect2({ connector: emailConnector });
      }
    }
  });
  reactExports.useEffect(() => {
    if (emailConflictInfo) {
      setShowEmailWaasPinInput(false);
    }
  }, [emailConflictInfo]);
  if (showEmailWaasPinInput) {
    return jsxRuntimeExports$1.jsx(EmailWaasVerify, { error: emailAuthError, isLoading: emailAuthLoading, onConfirm: sendChallengeAnswer });
  }
  if (showExtendedList) {
    return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Box, { position: "absolute", top: "4", children: jsxRuntimeExports$1.jsx(IconButton, { icon: SvgChevronLeftIcon, onClick: () => setShowExtendedList(false), size: "xs" }) }), jsxRuntimeExports$1.jsx(ExtendedWalletList, { connectors: walletConnectors, onConnect })] });
  }
  return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Banner, { config: config2 }), jsxRuntimeExports$1.jsxs(Box, { marginTop: "6", children: [emailConnector && (showEmailInput || isEmailOnly) ? jsxRuntimeExports$1.jsxs("form", { onSubmit: onConnectInlineEmail, children: [jsxRuntimeExports$1.jsx(TextInput, { onChange: onChangeEmail, value: email2, name: "email", placeholder: "Enter email", "data-1p-ignore": true }), jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", justifyContent: "center", marginTop: "4", children: [!emailAuthInProgress && jsxRuntimeExports$1.jsxs(Box, { gap: "2", width: "full", children: [!isEmailOnly && jsxRuntimeExports$1.jsx(Button, { label: "Back", width: "full", onClick: () => setShowEmailInput(false) }), jsxRuntimeExports$1.jsx(Button, { type: "submit", variant: "primary", disabled: !isEmailValid(email2), width: "full", label: "Continue", rightIcon: SvgChevronRightIcon })] }), emailAuthInProgress && jsxRuntimeExports$1.jsx(Spinner, {})] })] }) : jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: socialAuthConnectors.length > 0 && jsxRuntimeExports$1.jsx(Box, { marginTop: "2", gap: "2", flexDirection: "row", justifyContent: "center", alignItems: "center", flexWrap: "wrap", children: socialAuthConnectors.map((connector) => {
    return jsxRuntimeExports$1.jsx(Box, { aspectRatio: "1/1", alignItems: "center", justifyContent: "center", children: connector._wallet.id === "google-waas" ? jsxRuntimeExports$1.jsx(GoogleWaasConnectButton, { connector, onConnect }) : connector._wallet.id === "apple-waas" ? jsxRuntimeExports$1.jsx(AppleWaasConnectButton, { connector, onConnect }) : connector._wallet.id.includes("email") ? jsxRuntimeExports$1.jsx(EmailConnectButton, { onClick: () => setShowEmailInput(true) }) : jsxRuntimeExports$1.jsx(ConnectButton, { connector, onConnect }) }, connector.uid);
  }) }) }), walletConnectors.length > 0 && !showEmailInput && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [socialAuthConnectors.length > 0 && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Divider, { color: "backgroundSecondary" }), jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", alignItems: "center", children: jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: "or select a wallet" }) })] }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", gap: "2", flexDirection: "row", justifyContent: "center", alignItems: "center", children: walletConnectors.slice(0, 7).map((connector) => {
    return jsxRuntimeExports$1.jsx(ConnectButton, { connector, onConnect }, connector.uid);
  }) }), displayExtendedListButton && jsxRuntimeExports$1.jsx(Box, { marginTop: "4", justifyContent: "center", children: jsxRuntimeExports$1.jsx(Button, { shape: "square", size: "xs", onClick: () => setShowExtendedList(true), label: "More options", rightIcon: SvgChevronRightIcon }) })] })] }), jsxRuntimeExports$1.jsx(PoweredBySequence, {})] });
};
const ConnectWalletContent = (props) => {
  var _a2;
  const { emailConflictInfo, config: config2, isPreview = false } = props;
  const projectName = (_a2 = config2 == null ? void 0 : config2.signIn) == null ? void 0 : _a2.projectName;
  return jsxRuntimeExports$1.jsxs(Box, { padding: "4", children: [jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", color: "text100", alignItems: "center", fontWeight: "medium", style: {
    marginTop: "4px"
  }, children: jsxRuntimeExports$1.jsx(TitleWrapper, { isPreview, children: jsxRuntimeExports$1.jsxs(Text, { children: ["Sign in ", projectName ? `to ${projectName}` : ""] }) }) }), jsxRuntimeExports$1.jsx(Connect, { emailConflictInfo, ...props })] });
};
const TitleWrapper = ({ children, isPreview }) => {
  if (isPreview) {
    return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children });
  }
  return jsxRuntimeExports$1.jsx(index$2$1.Title, { asChild: true, children });
};
const getNetworkColor = (chainId, mode = "light") => {
  switch (chainId) {
    case ChainId$1.MAINNET:
      return mode === "light" ? "#abf" : "#abf";
    case ChainId$1.POLYGON:
      return mode === "light" ? "#c7a6ff" : "#c7a6ff";
    case ChainId$1.ARBITRUM:
      return mode === "light" ? "#52A7E6" : "#52A7E6";
    case ChainId$1.OPTIMISM:
      return mode === "light" ? "#DB3132" : "#DB3132";
    case ChainId$1.BSC:
      return mode === "light" ? "#CB9C1D" : "#EEB445";
    case ChainId$1.AVALANCHE:
      return mode === "light" ? "#E84142" : "#E84142";
    case ChainId$1.GNOSIS:
      return mode === "light" ? "#00193C" : "#D8E8FF";
    case ChainId$1.GOERLI:
      return mode === "light" ? "#A77A00" : "#FFA700";
    case ChainId$1.POLYGON_MUMBAI:
    case ChainId$1.POLYGON_AMOY:
      return mode === "light" ? "#D68828" : "#FFA700";
    default:
      return mode === "light" ? "#abf" : "#abf";
  }
};
const getNetworkBackgroundColor = (chainId, mode = "light") => {
  switch (chainId) {
    case ChainId$1.MAINNET:
      return mode === "light" ? "#132362" : "#132362";
    case ChainId$1.POLYGON:
      return mode === "light" ? "#350881" : "#350881";
    case ChainId$1.ARBITRUM:
      return mode === "light" ? "#EDF7FF" : "#0C3754";
    case ChainId$1.OPTIMISM:
      return mode === "light" ? "#FFEAE9" : "#390B0C";
    case ChainId$1.BSC:
      return mode === "light" ? "#FFE8AB" : "#554018";
    case ChainId$1.AVALANCHE:
      return mode === "light" ? "#FBDFDF" : "#390B0C";
    case ChainId$1.GNOSIS:
      return mode === "light" ? "#D8E8FF" : "#00193C";
    case ChainId$1.GOERLI:
      return mode === "light" ? "#FFD871" : "#554018";
    case ChainId$1.POLYGON_MUMBAI:
    case ChainId$1.POLYGON_AMOY:
      return mode === "light" ? "#FFE8CD" : "#554018";
    default:
      return mode === "light" ? "#132362" : "#132362";
  }
};
const getNetwork = (chainId) => {
  const network2 = networks$1[chainId];
  if (!network2) {
    throw new Error(`Unknown network chainId: ${chainId}`);
  }
  return network2;
};
const NetworkBadge$1 = ({ chainId }) => {
  const network2 = getNetwork(chainId);
  const chainColor = getNetworkColor(chainId);
  const chainBGColor = getNetworkBackgroundColor(chainId);
  return jsxRuntimeExports$1.jsxs(Box, { height: "6", paddingX: "2", gap: "1", borderRadius: "xs", flexDirection: "row", justifyContent: "center", alignItems: "center", width: "fit", style: {
    background: chainBGColor
  }, children: [jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { variant: "xsmall", fontWeight: "bold", style: {
    color: chainColor
  }, capitalize: true, ellipsis: true, children: network2.title ?? network2.name })] });
};
const PageHeading = (props) => {
  const { children, ...rest } = props;
  return jsxRuntimeExports$1.jsx(Text, { as: "h1", variant: "normal", fontWeight: "bold", color: "text100", textAlign: "center", marginTop: "10", marginBottom: "6", ...rest, children });
};
const useProjectAccessKey = () => {
  const { projectAccessKey: projectAccessKey2 } = useKitConfig();
  return projectAccessKey2;
};
const useAPIClient = () => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const clientUrl = isDev ? "https://dev-api.sequence.app" : "https://api.sequence.app";
  const apiClient = reactExports.useMemo(() => {
    return new SequenceAPIClient(clientUrl, projectAccessKey2);
  }, [projectAccessKey2]);
  return apiClient;
};
const useIndexerClient = (chainId) => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const indexerClients = reactExports.useMemo(() => {
    return /* @__PURE__ */ new Map();
  }, [projectAccessKey2, isDev]);
  const network2 = networks$1[chainId];
  const clientUrl = isDev ? `https://dev-${network2.name}-indexer.sequence.app` : `https://${network2.name}-indexer.sequence.app`;
  if (!indexerClients.has(chainId)) {
    indexerClients.set(chainId, new SequenceIndexer(clientUrl, projectAccessKey2));
  }
  const indexerClient = indexerClients.get(chainId);
  if (!indexerClient) {
    throw new Error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
  }
  return indexerClient;
};
const useIndexerClients = (chainIds) => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const indexerClients = reactExports.useMemo(() => {
    return /* @__PURE__ */ new Map();
  }, [projectAccessKey2, isDev]);
  const result = /* @__PURE__ */ new Map();
  for (const chainId of chainIds) {
    const network2 = networks$1[chainId];
    const clientUrl = isDev ? `https://dev-${network2.name}-indexer.sequence.app` : `https://${network2.name}-indexer.sequence.app`;
    if (!indexerClients.has(chainId)) {
      indexerClients.set(chainId, new SequenceIndexer(clientUrl, projectAccessKey2));
    }
    const indexerClient = indexerClients.get(chainId);
    if (!indexerClient) {
      throw new Error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
    }
    result.set(chainId, indexerClient);
  }
  return result;
};
const useMetadataClient = () => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const metadataClient = reactExports.useMemo(() => {
    const clientUrl = isDev ? "https://dev-metadata.sequence.app" : "https://metadata.sequence.app";
    return new SequenceMetadata(clientUrl, projectAccessKey2);
  }, [projectAccessKey2]);
  return metadataClient;
};
const time$1 = {
  oneSecond: 1 * 1e3,
  oneMinute: 60 * 1e3,
  oneHour: 60 * 60 * 1e3
};
const getNativeTokenBalance = async (indexerClient, chainId, accountAddress) => {
  const res = await indexerClient.getEtherBalance({ accountAddress });
  const tokenBalance = {
    chainId,
    contractAddress: zeroAddress,
    accountAddress,
    balance: (res == null ? void 0 : res.balance.balanceWei) || "0",
    contractType: ContractType$1.UNKNOWN,
    blockHash: "",
    blockNumber: 0,
    tokenID: "",
    uniqueCollectibles: "",
    isSummary: false
  };
  return tokenBalance;
};
const getTokenBalances = async (indexerClient, args) => {
  const res = await indexerClient.getTokenBalances({
    accountAddress: args.accountAddress,
    includeMetadata: args.includeMetadata ?? true,
    metadataOptions: {
      verifiedOnly: args.verifiedOnly ?? true
    },
    ...args.contractAddress && { contractAddress: args.contractAddress }
  });
  return (res == null ? void 0 : res.balances) || [];
};
const getBalances = async (indexerClient, chainId, args) => {
  if (!args.accountAddress) {
    return [];
  }
  const balances = (await Promise.allSettled([
    getNativeTokenBalance(indexerClient, chainId, args.accountAddress),
    getTokenBalances(indexerClient, args)
  ])).map((res) => res.status === "fulfilled" ? res.value : []).flat();
  return balances;
};
const useBalances = ({ chainIds, ...args }) => {
  const indexerClients = useIndexerClients(chainIds);
  return useQuery$1({
    queryKey: ["balances", chainIds, args],
    queryFn: async () => {
      const res = (await Promise.all(Array.from(indexerClients.entries()).map(([chainId, indexerClient]) => getBalances(indexerClient, chainId, args)))).flat();
      return res;
    },
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: chainIds.length > 0 && !!args.accountAddress
  });
};
const useCoinBalance = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useQuery$1({
    queryKey: ["coinBalance", args],
    queryFn: async () => {
      if (compareAddress$2((args == null ? void 0 : args.contractAddress) || "", zeroAddress)) {
        const res = await getNativeTokenBalance(indexerClient, args.chainId, args.accountAddress);
        return res;
      } else {
        const res = await getTokenBalances(indexerClient, args);
        return res[0];
      }
    },
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress
  });
};
const useCollectibleBalance = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useQuery$1({
    queryKey: ["collectibleBalance", args],
    queryFn: async () => {
      const res = await indexerClient.getTokenBalances({
        accountAddress: args.accountAddress,
        contractAddress: args.contractAddress,
        tokenID: args.tokenId,
        includeMetadata: true,
        metadataOptions: {
          verifiedOnly: args.verifiedOnly ?? true
        }
      });
      return res.balances[0];
    },
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress && !!args.contractAddress && !!args.tokenId
  });
};
const getCollectionBalance = async (indexerClient, args) => {
  const res = await indexerClient.getTokenBalances({
    accountAddress: args.accountAddress,
    contractAddress: args.contractAddress,
    includeMetadata: args.includeMetadata ?? true,
    metadataOptions: {
      verifiedOnly: args.verifiedOnly ?? true
    }
  });
  return (res == null ? void 0 : res.balances) || [];
};
const useCollectionBalance = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useQuery$1({
    queryKey: ["collectionBalance", args],
    queryFn: () => getCollectionBalance(indexerClient, args),
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress && !!args.contractAddress
  });
};
const useExchangeRate = (toCurrency) => {
  const apiClient = useAPIClient();
  return useQuery$1({
    queryKey: ["exchangeRate", toCurrency],
    queryFn: async () => {
      if (toCurrency === "USD") {
        return 1;
      }
      const res = await apiClient.getExchangeRate({ toCurrency });
      return res.exchangeRate.value;
    },
    retry: true,
    staleTime: time$1.oneMinute * 10
  });
};
const getCoinPrices = async (apiClient, tokens) => {
  if (tokens.length === 0) {
    return [];
  }
  const res = await apiClient.getCoinPrices({ tokens });
  return (res == null ? void 0 : res.tokenPrices) || [];
};
const useCoinPrices = (tokens, disabled) => {
  const apiClient = useAPIClient();
  return useQuery$1({
    queryKey: ["coinPrices", tokens],
    queryFn: () => getCoinPrices(apiClient, tokens),
    retry: true,
    staleTime: time$1.oneMinute,
    enabled: tokens.length > 0 && !disabled
  });
};
const getCollectiblePrices = async (apiClient, tokens) => {
  if (tokens.length === 0) {
    return [];
  }
  const res = await apiClient.getCollectiblePrices({ tokens });
  return (res == null ? void 0 : res.tokenPrices) || [];
};
const useCollectiblePrices = (tokens) => {
  const apiClient = useAPIClient();
  return useQuery$1({
    queryKey: ["useCollectiblePrices", tokens],
    queryFn: () => getCollectiblePrices(apiClient, tokens),
    retry: true,
    staleTime: time$1.oneMinute,
    enabled: tokens.length > 0
  });
};
const useTokenMetadata = (chainId, contractAddress, tokenIds) => {
  const metadataClient = useMetadataClient();
  return useQuery$1({
    queryKey: ["tokenMetadata", chainId, contractAddress, tokenIds],
    queryFn: async () => {
      const res = await metadataClient.getTokenMetadata({
        chainID: String(chainId),
        contractAddress,
        tokenIDs: tokenIds
      });
      return res.tokenMetadata;
    },
    retry: true,
    staleTime: time$1.oneMinute * 10,
    enabled: !!chainId && !!contractAddress
  });
};
const useContractInfo = (chainId, contractAddress) => {
  const metadataClient = useMetadataClient();
  return useQuery$1({
    queryKey: ["contractInfo", chainId, contractAddress],
    queryFn: async () => {
      const isNativeToken = compareAddress$2(zeroAddress, contractAddress);
      const res = await metadataClient.getContractInfo({
        chainID: String(chainId),
        contractAddress
      });
      const network2 = findSupportedNetwork(chainId);
      return {
        ...res.contractInfo,
        ...isNativeToken && network2 ? {
          ...network2.nativeToken,
          logoURI: network2.logoURI
        } : {}
      };
    },
    retry: true,
    staleTime: time$1.oneMinute * 10,
    enabled: !!chainId && !!contractAddress
  });
};
const getTransactionHistory = async (indexerClient, { contractAddress, accountAddress, tokenId, page }) => {
  const res = indexerClient.getTransactionHistory({
    includeMetadata: true,
    page,
    filter: {
      accountAddress,
      contractAddress,
      tokenID: tokenId
    }
  });
  return res;
};
const useTransactionHistory = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useInfiniteQuery({
    queryKey: ["transactionHistory", args],
    queryFn: ({ pageParam }) => {
      return getTransactionHistory(indexerClient, {
        ...args,
        page: { page: pageParam }
      });
    },
    getNextPageParam: ({ page }) => {
      if (!page.more) {
        return void 0;
      }
      return (page == null ? void 0 : page.page) || 1;
    },
    initialPageParam: 1,
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress
  });
};
const getSwapPrices = async (apiClient, metadataClient, indexerClient, args) => {
  if (!args.chainId || !args.userAddress || !args.buyCurrencyAddress || !args.buyAmount || args.buyAmount === "0") {
    return [];
  }
  try {
    const network2 = findSupportedNetwork(args.chainId);
    const { withContractInfo, ...swapPricesArgs } = args;
    const res = await apiClient.getSwapPrices({
      ...swapPricesArgs
    });
    if (res.swapPrices === null) {
      return [];
    }
    const currencyInfoMap = /* @__PURE__ */ new Map();
    if (withContractInfo) {
      res == null ? void 0 : res.swapPrices.forEach((price) => {
        const { currencyAddress } = price;
        const isNativeToken = compareAddress$2(currencyAddress, NATIVE_TOKEN_ADDRESS_0X);
        if (currencyAddress && !currencyInfoMap.has(currencyAddress)) {
          currencyInfoMap.set(currencyAddress, metadataClient.getContractInfo({
            chainID: String(args.chainId),
            contractAddress: currencyAddress
          }).then((data) => {
            return {
              ...data.contractInfo,
              ...isNativeToken ? {
                ...network2 == null ? void 0 : network2.nativeToken,
                logoURI: (network2 == null ? void 0 : network2.logoURI) || ""
              } : {}
            };
          }));
        }
      });
    }
    const currencyBalanceInfoMap = /* @__PURE__ */ new Map();
    res == null ? void 0 : res.swapPrices.forEach((price) => {
      const { currencyAddress } = price;
      const isNativeToken = compareAddress$2(currencyAddress, NATIVE_TOKEN_ADDRESS_0X);
      if (currencyAddress && !currencyBalanceInfoMap.has(currencyAddress)) {
        currencyBalanceInfoMap.set(currencyAddress, isNativeToken ? indexerClient.getEtherBalance({
          accountAddress: args.userAddress
        }).then((res2) => ({
          balance: res2.balance.balanceWei
        })) : indexerClient.getTokenBalances({
          accountAddress: args.userAddress,
          contractAddress: currencyAddress,
          includeMetadata: false,
          metadataOptions: {
            verifiedOnly: true
          }
        }).then((balances) => {
          var _a2;
          return {
            balance: ((_a2 = balances.balances) == null ? void 0 : _a2[0].balance) || "0"
          };
        }));
      }
    });
    return Promise.all((res == null ? void 0 : res.swapPrices.map(async (price) => ({
      price,
      info: await currencyInfoMap.get(price.currencyAddress) || void 0,
      balance: await currencyBalanceInfoMap.get(price.currencyAddress) || { balance: "0" }
    }))) || []);
  } catch (e2) {
    console.error(e2);
    return [];
  }
};
const useSwapPrices = (args, options) => {
  const apiClient = useAPIClient();
  const metadataClient = useMetadataClient();
  const indexerClient = useIndexerClient(args.chainId);
  const enabled = !!args.chainId && !!args.userAddress && !!args.buyCurrencyAddress && !!args.buyAmount && args.buyAmount !== "0" && !options.disabled;
  return useQuery$1({
    queryKey: ["swapPrices", args],
    queryFn: () => getSwapPrices(apiClient, metadataClient, indexerClient, args),
    retry: true,
    // We must keep a long staletime to avoid the list of quotes being refreshed while the user is doing the transactions
    // Instead, we will invalidate the query manually
    staleTime: time$1.oneHour,
    enabled
  });
};
const useSwapQuote = (args, options) => {
  const apiClient = useAPIClient();
  const { disabled = false } = options;
  return useQuery$1({
    queryKey: ["useSwapQuote", args],
    queryFn: async () => {
      const res = await apiClient.getSwapQuote(args);
      return res.swapQuote;
    },
    retry: true,
    staleTime: time$1.oneMinute * 1,
    enabled: !disabled || !args.userAddress || !args.chainId || !args.buyCurrencyAddress
  });
};
const chains = allNetworks$1.reduce((acc, network2) => {
  if (network2.deprecated) {
    return acc;
  }
  if (network2.name.startsWith("hardhat")) {
    return acc;
  }
  acc[network2.chainId] = defineChain({
    id: network2.chainId,
    name: network2.title,
    shortName: network2.name,
    nativeCurrency: {
      name: network2.nativeToken.name,
      symbol: network2.nativeToken.symbol,
      decimals: network2.nativeToken.decimals
    },
    rpcUrls: {
      default: {
        http: [network2.rpcUrl]
      }
    },
    ...network2.blockExplorer ? {
      blockExplorers: {
        default: {
          name: network2.blockExplorer.name,
          url: network2.blockExplorer.rootUrl
        }
      }
    } : void 0
  });
  return acc;
}, {});
const getNativeTokenInfoByChainId = (chainId, wagmiChains) => {
  var _a2, _b2;
  const chain = wagmiChains.find((chain2) => chain2.id === chainId) || chains[chainId];
  if (chain) {
    return {
      chainId: chain.id,
      name: chain.nativeCurrency.name,
      symbol: chain.nativeCurrency.symbol,
      decimals: chain.nativeCurrency.decimals,
      logoURI: nativeTokenImageUrl(chain.id),
      blockExplorerName: (_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.name,
      blockExplorerUrl: (_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url
    };
  }
  return {
    chainId,
    name: "Unknown",
    symbol: "???",
    decimals: 18,
    logoURI: ""
  };
};
var DecodingType;
(function(DecodingType2) {
  DecodingType2["APPROVE"] = "approve";
  DecodingType2["TRANSFER"] = "transfer";
  DecodingType2["SWAP"] = "swap";
  DecodingType2["AWARD_ITEM"] = "awardItem";
  DecodingType2["UNIMPLEMENTED"] = "unimplemented";
  DecodingType2["UNKNOWN"] = "unknown";
})(DecodingType || (DecodingType = {}));
const transformArgs = (args) => {
  return Object.fromEntries(args.map((arg, i) => [
    arg.name && !arg.name.startsWith("unnamed") ? arg.name : `_${i}`,
    Array.isArray(arg.value) ? arg.type.startsWith("(") && (arg.type.endsWith(")") || arg.type.endsWith(")[]")) ? transformArgs(arg.value) : arg.value : arg.value
  ]));
};
const createTxnData = (to, call2, value, data) => {
  const args = transformArgs(call2.args);
  const byteSignature = dataSlice(data, 0, 4);
  let objs = [];
  switch (call2.signature) {
    case "execute((bool,bool,uint256,address,uint256,bytes)[],uint256,bytes)":
    case "selfExecute((bool,bool,uint256,address,uint256,bytes)[])": {
      const txns = call2.args[0].value;
      objs = txns.map((txn) => txn.call ? createTxnData(txn.target, txn.call, txn.value, txn.data) : {
        to: txn.target,
        signature: "",
        byteSignature: dataSlice(txn.data, 0, 4),
        methodName: "",
        args: {},
        objs: [],
        value: BigInt(txn.value).toString(),
        data: hexlify(txn.data)
      });
    }
  }
  return {
    to,
    signature: call2.signature,
    byteSignature,
    methodName: call2.function,
    args,
    objs,
    value: BigInt(value).toString(),
    data: hexlify(data)
  };
};
const encodeTransactions = (transactions2) => {
  return transactions2.map((transaction2) => {
    if ("target" in transaction2) {
      return transaction2;
    } else {
      return { ...transaction2, target: transaction2.to };
    }
  }).map((transaction2) => ({
    delegateCall: transaction2.delegateCall ?? false,
    revertOnError: transaction2.revertOnError ?? false,
    gasLimit: transaction2.gasLimit ?? 0,
    target: transaction2.target ?? "0x0000000000000000000000000000000000000000",
    value: transaction2.value ?? 0,
    data: transaction2.data ?? "0x"
  }));
};
var ByteSignature;
(function(ByteSignature2) {
  ByteSignature2["SEQUENCE_DEPLOY"] = "0x32c02a14";
  ByteSignature2["SEQUENCE_PUBLISH_CONFIG"] = "0x44d466c2";
  ByteSignature2["SEQUENCE_UPDATE_IMAGE_HASH"] = "0x29561426";
  ByteSignature2["SEQUENCE_UPDATE_IMPLEMENTATION"] = "0x025b22bc";
  ByteSignature2["SEQUENCE_REQUIRE_SESSION_NONCE"] = "0x8853baa0";
  ByteSignature2["EXECUTE"] = "0x7a9a1628";
  ByteSignature2["SELF_EXECUTE"] = "0x61c2926c";
  ByteSignature2["APPROVE"] = "0x095ea7b3";
  ByteSignature2["TRANSFER"] = "0xa9059cbb";
  ByteSignature2["DEPOSIT"] = "0xd0e30db0";
  ByteSignature2["WITHDRAW"] = "0x2e1a7d4d";
  ByteSignature2["ERC721_SAFE_TRANSFER_FROM"] = "0x42842e0e";
  ByteSignature2["ERC721_SAFE_TRANSFER_FROM_WITH_DATA"] = "0xb88d4fde";
  ByteSignature2["ERC1155_SAFE_TRANSFER_FROM"] = "0xf242432a";
  ByteSignature2["ERC1155_SAFE_BATCH_TRANSFER_FROM"] = "0x2eb2c2d6";
  ByteSignature2["NIFTYSWAP_BUY_TOKENS"] = "0xd93e8aaa";
  ByteSignature2["TRANSFORM_ERC20"] = "0x415565b0";
  ByteSignature2["OUTBOUND_TRANSFER_TO"] = "0xa44bbb15";
  ByteSignature2["CELER_SEND"] = "0xa5977fbb";
  ByteSignature2["UNISWAPV3_MULTICALL"] = "0x5ae401dc";
  ByteSignature2["UNISWAPV2_SWAP_EXACT_TOKENS_FOR_TOKENS"] = "0x38ed1739";
  ByteSignature2["UNISWAPV2_SWAP_TOKENS_FOR_EXACT_TOKENS"] = "0x8803dbee";
  ByteSignature2["UNISWAPV2_SWAP_EXACT_ETH_FOR_TOKENS"] = "0x7ff36ab5";
  ByteSignature2["UNISWAPV2_SWAP_ETH_FOR_EXACT_TOKENS"] = "0xfb3bdb41";
  ByteSignature2["UNISWAPV2_SWAP_TOKENS_FOR_EXACT_ETH"] = "0x4a25d94a";
  ByteSignature2["UNISWAPV2_SWAP_EXACT_TOKENS_FOR_ETH"] = "0x18cbafe5";
  ByteSignature2["AWARD_ITEM"] = "0xcf378343";
})(ByteSignature || (ByteSignature = {}));
const decodeTxnData = async (apiClient, txns) => {
  const mainModule2 = new Interface(mainModuleAbi);
  const callData = mainModule2.encodeFunctionData("selfExecute", [txns]);
  try {
    const { call: call2 } = await apiClient.decodeContractCall({ callData });
    return createTxnData("", call2, 0, callData);
  } catch (err) {
    throw err;
  }
};
const decodeTransactions = async (apiClient, accountAddress, txns) => {
  const encodedTxns = encodeTransactions(txns);
  const decodedTxnDatas = (await decodeTxnData(apiClient, encodedTxns)).objs;
  const from = getAddress(accountAddress);
  const txnProps = encodedTxns.map((txn, i) => {
    const decodedTxnData = decodedTxnDatas[i];
    const data = txn.data.toString();
    const value = BigInt(txn.value).toString();
    const target = txn.target;
    if (data === "0x" || !data) {
      return {
        signature: "",
        byteSignature: "",
        type: DecodingType.TRANSFER,
        methodName: "nativeTokenTransfer",
        transferType: TxnTransferType.SEND,
        contractAddress: ZeroAddress,
        contractType: ContractType$1.UNKNOWN,
        from,
        to: getAddress(txn.target),
        tokenIds: ["0"],
        amounts: [value],
        target,
        value
      };
    }
    if (!decodedTxnData) {
      return void 0;
    }
    const contractAddress = getAddress(txn.target);
    const baseDecoding = {
      type: DecodingType.UNIMPLEMENTED,
      signature: decodedTxnData.signature,
      byteSignature: decodedTxnData.byteSignature,
      methodName: decodedTxnData.methodName,
      target,
      value
    };
    switch (decodedTxnData.byteSignature) {
      case ByteSignature.TRANSFER: {
        const { args } = decodedTxnData;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC20,
          from,
          to: getAddress(args.recipient),
          tokenIds: ["0"],
          amounts: [String(args.amount)]
        };
      }
      case ByteSignature.ERC721_SAFE_TRANSFER_FROM:
      case ByteSignature.ERC721_SAFE_TRANSFER_FROM_WITH_DATA: {
        const args = decodedTxnData.args;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC721,
          from,
          to: getAddress(args.to),
          tokenIds: [args.tokenId],
          amounts: ["1"]
        };
      }
      case ByteSignature.ERC1155_SAFE_TRANSFER_FROM: {
        const args = decodedTxnData.args;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC1155,
          from,
          to: getAddress(args._to),
          tokenIds: [args._id],
          amounts: [args._amount]
        };
      }
      case ByteSignature.ERC1155_SAFE_BATCH_TRANSFER_FROM: {
        const { args } = decodedTxnData;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC1155,
          from,
          to: getAddress(args._to),
          tokenIds: args._ids,
          amounts: args._amounts
        };
      }
      case ByteSignature.AWARD_ITEM: {
        const { args } = decodedTxnData;
        return {
          ...baseDecoding,
          type: DecodingType.AWARD_ITEM,
          contractAddress,
          to: getAddress(args._0),
          amount: "1"
        };
      }
    }
    return void 0;
  });
  return txnProps.flatMap((txn) => {
    if (txn) {
      return [txn];
    }
    return [];
  });
};
const mainModuleAbi = [
  {
    type: "function",
    name: "nonce",
    constant: true,
    inputs: [],
    outputs: [
      {
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view"
  },
  {
    type: "function",
    name: "readNonce",
    constant: true,
    inputs: [
      {
        type: "uint256"
      }
    ],
    outputs: [
      {
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view"
  },
  {
    type: "function",
    name: "updateImplementation",
    constant: false,
    inputs: [
      {
        type: "address"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "selfExecute",
    constant: false,
    inputs: [
      {
        components: [
          {
            type: "bool",
            name: "delegateCall"
          },
          {
            type: "bool",
            name: "revertOnError"
          },
          {
            type: "uint256",
            name: "gasLimit"
          },
          {
            type: "address",
            name: "target"
          },
          {
            type: "uint256",
            name: "value"
          },
          {
            type: "bytes",
            name: "data"
          }
        ],
        type: "tuple[]"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "execute",
    constant: false,
    inputs: [
      {
        components: [
          {
            type: "bool",
            name: "delegateCall"
          },
          {
            type: "bool",
            name: "revertOnError"
          },
          {
            type: "uint256",
            name: "gasLimit"
          },
          {
            type: "address",
            name: "target"
          },
          {
            type: "uint256",
            name: "value"
          },
          {
            type: "bytes",
            name: "data"
          }
        ],
        type: "tuple[]"
      },
      {
        type: "uint256"
      },
      {
        type: "bytes"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "createContract",
    inputs: [
      {
        type: "bytes"
      }
    ],
    payable: true,
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "setExtraImageHash",
    constant: false,
    inputs: [
      {
        type: "bytes32",
        name: "imageHash"
      },
      {
        type: "uint256",
        name: "expiration"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  }
];
const CollectibleTileImage$1 = ({ imageUrl }) => {
  return jsxRuntimeExports$1.jsx(Card, { padding: "0", aspectRatio: "1/1", justifyContent: "center", alignItems: "center", overflow: "hidden", borderRadius: "sm", background: "backgroundSecondary", children: jsxRuntimeExports$1.jsx(Image$1, { style: { height: "100%" }, src: imageUrl }) });
};
const TxnDetailsSkeleton = () => {
  return jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 30, height: 30 }, borderRadius: "circle" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 100, height: 14 } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 75, height: 14 } })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", alignItems: "flex-end", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 100, height: 14 } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 50, height: 12 } })] })] });
};
const TxnDetails = ({ address, txs, chainId }) => {
  const apiClient = useAPIClient();
  const [decodingType, setDecodingType] = reactExports.useState(void 0);
  const [transferProps, setTransferProps] = reactExports.useState([]);
  const [awardItemProps, setAwardItemProps] = reactExports.useState([]);
  const getTxnProps = async () => {
    var _a2;
    const decodedTxnDatas = await decodeTransactions(apiClient, address, txs);
    const type = (_a2 = decodedTxnDatas[0]) == null ? void 0 : _a2.type;
    setDecodingType(type);
    if (type === DecodingType.TRANSFER) {
      setTransferProps(decodedTxnDatas);
    }
    if (type === DecodingType.AWARD_ITEM) {
      setAwardItemProps(decodedTxnDatas);
    }
  };
  reactExports.useEffect(() => {
    getTxnProps();
  }, []);
  if (!decodingType) {
    return jsxRuntimeExports$1.jsx(TxnDetailsSkeleton, {});
  }
  if (decodingType === DecodingType.UNKNOWN) {
    return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {});
  }
  if (transferProps[0]) {
    return jsxRuntimeExports$1.jsx(TransferItemInfo, { address, transferProps: transferProps[0], chainId });
  }
  if (awardItemProps[0]) {
    return jsxRuntimeExports$1.jsx(AwardItemInfo, { awardItemProps: awardItemProps[0] });
  }
};
const TransferItemInfo = ({ address, transferProps, chainId }) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
  const { chains: chains2 } = useConfig();
  const contractAddress = transferProps.contractAddress;
  const toAddress = transferProps.to;
  const isNativeCoin = contractAddress ? compareAddress$2(contractAddress, ZeroAddress) : true;
  const is1155 = transferProps.contractType === ContractType$1.ERC1155;
  const isNFT = transferProps.contractType === ContractType$1.ERC1155 || transferProps.contractType === ContractType$1.ERC721;
  const nativeTokenInfo = getNativeTokenInfoByChainId(chainId, chains2);
  const { data: balances = [] } = useBalances({
    chainIds: [chainId],
    accountAddress: address,
    contractAddress
  });
  const { data: tokenMetadata } = useTokenMetadata(chainId, contractAddress, transferProps.tokenIds ?? []);
  const tokenBalance = contractAddress ? balances.find((b2) => compareAddress$2(b2.contractAddress, contractAddress)) : void 0;
  const decimals = isNativeCoin ? nativeTokenInfo.decimals : ((_a2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _a2.decimals) || 18;
  const imageUrl = isNativeCoin ? nativeTokenInfo.logoURI : isNFT ? (_b2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _b2.image : (_c2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _c2.logoURI;
  const name2 = isNativeCoin ? nativeTokenInfo.name : isNFT ? (_d2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _d2.name : ((_e2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _e2.name) || "";
  const symbol = isNativeCoin ? nativeTokenInfo.symbol : isNFT ? "" : ((_f2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _f2.symbol) || "";
  const amountSending = transferProps.amounts[0] ?? transferProps.value;
  const showSquareImage = isNFT;
  return jsxRuntimeExports$1.jsxs(Card, { children: [jsxRuntimeExports$1.jsx(Box, { marginBottom: "2", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: capitalize(transferProps.type ?? "") }) }), jsxRuntimeExports$1.jsx(Box, { alignItems: "flex-end", justifyContent: "space-between", marginBottom: "2", children: jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", gap: "2", children: [showSquareImage ? jsxRuntimeExports$1.jsx(Box, { style: { width: "40px" }, children: jsxRuntimeExports$1.jsx(CollectibleTileImage$1, { imageUrl }) }) : jsxRuntimeExports$1.jsx(TokenImage, { src: imageUrl, symbol, size: "md" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Box, { flexDirection: "row", alignItems: "center", gap: "1", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: name2 }) }), jsxRuntimeExports$1.jsxs(Text, { color: "text50", variant: "normal", children: [" ", `${formatUnits$1(amountSending, is1155 ? (_g2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _g2.decimals : isNFT ? 0 : decimals)} ${symbol} `] })] })] }) }), toAddress !== void 0 && jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", children: "To" }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", borderRadius: "md", background: "backgroundSecondary", width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", padding: "4", style: { height: "52px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: toAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle$1(toAddress.substring(2), 12)}` })] }) })] })] });
};
const AwardItemInfo = ({ awardItemProps }) => {
  return jsxRuntimeExports$1.jsxs(Card, { children: [jsxRuntimeExports$1.jsx(Box, { marginBottom: "2", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: "Mint" }) }), jsxRuntimeExports$1.jsx(Box, { alignItems: "flex-end", justifyContent: "space-between", marginBottom: "2", children: jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Box, { style: { width: "40px" }, children: jsxRuntimeExports$1.jsx(CollectibleTileImage$1, { imageUrl: "https://dev-metadata.sequence.app/projects/277/collections/62/tokens/0/image.jpeg" }) }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Box, { flexDirection: "row", alignItems: "center", gap: "1", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: "Waas Demo NFT" }) }), jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", children: awardItemProps.amount })] })] }) }), awardItemProps.to !== void 0 && jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", children: "To" }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", borderRadius: "md", background: "backgroundSecondary", width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", padding: "4", style: { height: "52px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: awardItemProps.to, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle$1(awardItemProps.to.substring(2), 12)}` })] }) })] })] });
};
const truncateAtMiddle$1 = (text2, truncateAt) => {
  let finalText = text2;
  if (text2.length >= truncateAt) {
    finalText = text2.slice(0, truncateAt / 2) + "..." + text2.slice(text2.length - truncateAt / 2, text2.length);
  }
  return finalText;
};
const KitProvider = (props) => {
  var _a2, _b2;
  const { config: config2, children } = props;
  const { defaultTheme = "dark", signIn: signIn3 = {}, position = "center", displayedAssets: displayedAssetsSetting = [], ethAuth = {}, disableAnalytics = false } = config2;
  const defaultAppName = signIn3.projectName || "app";
  const { expiry = DEFAULT_SESSION_EXPIRATION, app = defaultAppName, origin, nonce } = ethAuth;
  const [openConnectModal, setOpenConnectModal] = reactExports.useState(false);
  const [theme, setTheme] = reactExports.useState(defaultTheme || "dark");
  const [modalPosition, setModalPosition] = reactExports.useState(position);
  const [displayedAssets, setDisplayedAssets] = reactExports.useState(displayedAssetsSetting);
  const [analytics, setAnalytics] = reactExports.useState();
  const { address, isConnected } = useAccount();
  const wagmiConfig = useConfig();
  const storage = useStorage();
  const connections = useConnections();
  const waasConnector = (_a2 = connections.find((c2) => c2.connector.id.includes("waas"))) == null ? void 0 : _a2.connector;
  const [pendingRequestConfirmation, confirmPendingRequest, rejectPendingRequest] = useWaasConfirmationHandler(waasConnector);
  const googleWaasConnector = wagmiConfig.connectors.find((c2) => c2.id === "sequence-waas" && c2._wallet.id === "google-waas");
  const googleClientId = ((_b2 = googleWaasConnector == null ? void 0 : googleWaasConnector.params) == null ? void 0 : _b2.googleClientId) || "";
  const setupAnalytics2 = (projectAccessKey2) => {
    const s2 = sequence$1.initWallet(projectAccessKey2);
    const sequenceAnalytics = s2.client.analytics;
    setAnalytics(sequenceAnalytics);
  };
  reactExports.useEffect(() => {
    if (!isConnected) {
      analytics == null ? void 0 : analytics.reset();
      return;
    }
    if (address) {
      analytics == null ? void 0 : analytics.identify(address.toLowerCase());
    }
  }, [analytics, address, isConnected]);
  reactExports.useEffect(() => {
    if (!disableAnalytics) {
      setupAnalytics2(config2.projectAccessKey);
    }
  }, []);
  reactExports.useEffect(() => {
    if (theme !== defaultTheme) {
      setTheme(defaultTheme);
    }
  }, [defaultTheme]);
  reactExports.useEffect(() => {
    if (modalPosition !== position) {
      setModalPosition(position);
    }
  }, [position]);
  reactExports.useEffect(() => {
    if (typeof theme === "object") ;
    else {
      localStorage.setItem(LocalStorageKey.Theme, theme);
    }
    storage == null ? void 0 : storage.setItem(LocalStorageKey.EthAuthSettings, {
      expiry,
      app,
      origin: origin || location.origin,
      nonce
    });
  }, [theme, ethAuth]);
  reactExports.useEffect(() => {
    setDisplayedAssets(displayedAssets);
  }, [displayedAssetsSetting]);
  const { isEmailConflictOpen, emailConflictInfo, toggleEmailConflictModal } = useEmailConflict();
  return jsxRuntimeExports$1.jsx(KitConfigContextProvider, { value: config2, children: jsxRuntimeExports$1.jsx(ThemeContextProvider, { value: {
    theme,
    setTheme,
    position: modalPosition,
    setPosition: setModalPosition
  }, children: jsxRuntimeExports$1.jsx(GoogleOAuthProvider, { clientId: googleClientId, children: jsxRuntimeExports$1.jsx(ConnectModalContextProvider, { value: { setOpenConnectModal, openConnectModalState: openConnectModal }, children: jsxRuntimeExports$1.jsx(WalletConfigContextProvider, { value: { setDisplayedAssets, displayedAssets }, children: jsxRuntimeExports$1.jsxs(AnalyticsContextProvider, { value: { setAnalytics, analytics }, children: [jsxRuntimeExports$1.jsx("div", { id: "kit-provider", children: jsxRuntimeExports$1.jsx(ThemeProvider, { root: "#kit-provider", scope: "kit", theme, children: jsxRuntimeExports$1.jsxs(AnimatePresence, { children: [openConnectModal && jsxRuntimeExports$1.jsx(Modal, { scroll: false, backdropColor: "backgroundBackdrop", size: "sm", contentProps: {
    style: {
      maxWidth: "364px",
      overflow: "visible",
      ...getModalPositionCss(position)
    }
  }, onClose: () => setOpenConnectModal(false), children: jsxRuntimeExports$1.jsx(ConnectWalletContent, { onClose: () => setOpenConnectModal(false), emailConflictInfo, ...props }) }), pendingRequestConfirmation && jsxRuntimeExports$1.jsx(Modal, { scroll: false, backdropColor: "backgroundBackdrop", size: "sm", contentProps: {
    style: {
      maxWidth: "364px",
      ...getModalPositionCss(position)
    }
  }, isDismissible: false, onClose: () => {
    rejectPendingRequest("");
  }, children: jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingTop: "4", paddingBottom: "2", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", justifyContent: "center", color: "text100", alignItems: "center", fontWeight: "medium", style: {
    marginTop: "4px"
  }, children: [jsxRuntimeExports$1.jsx(index$2$1.Title, { asChild: true, children: jsxRuntimeExports$1.jsxs(Text, { as: "h1", variant: "large", marginBottom: "5", children: ["Confirm ", pendingRequestConfirmation.type === "signMessage" ? "signing message" : "transaction"] }) }), pendingRequestConfirmation.type === "signMessage" && jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", width: "full", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: "Message" }), jsxRuntimeExports$1.jsx(Card, { marginTop: "2", paddingY: "6", children: jsxRuntimeExports$1.jsx(Text, { variant: "normal", marginBottom: "4", children: toUtf8String(pendingRequestConfirmation.message ?? "") }) })] }), pendingRequestConfirmation.type === "signTransaction" && jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", width: "full", children: [jsxRuntimeExports$1.jsx(TxnDetails, { address: address ?? "", txs: pendingRequestConfirmation.txs ?? [], chainId: pendingRequestConfirmation.chainId ?? ChainId$1.POLYGON }), jsxRuntimeExports$1.jsx(Collapsible, { label: "Transaction data", marginTop: "4", children: jsxRuntimeExports$1.jsx(Card, { overflowX: "scroll", marginY: "3", children: jsxRuntimeExports$1.jsx(Text, { variant: "code", marginBottom: "4", children: JSON.stringify(pendingRequestConfirmation.txs, null, 2) }) }) })] }), pendingRequestConfirmation.chainId && jsxRuntimeExports$1.jsxs(Box, { width: "full", marginTop: "3", justifyContent: "flex-end", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Box, { width: "1/2", justifyContent: "flex-start", children: jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: "Network" }) }), jsxRuntimeExports$1.jsx(Box, { width: "1/2", justifyContent: "flex-end", children: jsxRuntimeExports$1.jsx(NetworkBadge$1, { chainId: pendingRequestConfirmation.chainId }) })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", width: "full", marginTop: "5", children: [jsxRuntimeExports$1.jsx(Button, { width: "full", shape: "square", size: "lg", label: "Reject", onClick: () => {
    rejectPendingRequest(pendingRequestConfirmation == null ? void 0 : pendingRequestConfirmation.id);
  } }), jsxRuntimeExports$1.jsx(Button, { alignItems: "center", textAlign: "center", width: "full", shape: "square", size: "lg", label: "Confirm", variant: "primary", onClick: () => {
    confirmPendingRequest(pendingRequestConfirmation == null ? void 0 : pendingRequestConfirmation.id);
  } })] })] }), jsxRuntimeExports$1.jsx(PoweredBySequence, {})] }) }), isEmailConflictOpen && emailConflictInfo && jsxRuntimeExports$1.jsx(Modal, { size: "sm", scroll: false, onClose: () => toggleEmailConflictModal(false), children: jsxRuntimeExports$1.jsxs(Box, { padding: "4", children: [jsxRuntimeExports$1.jsx(index$2$1.Title, { asChild: true, children: jsxRuntimeExports$1.jsx(PageHeading, { children: "Email already in use" }) }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Text, { variant: "normal", color: "text80", textAlign: "center", children: ["Another account with this email address ", jsxRuntimeExports$1.jsxs(Text, { color: "text100", children: ["(", emailConflictInfo.email, ")"] }), " ", "already exists with account type ", jsxRuntimeExports$1.jsxs(Text, { color: "text100", children: ["(", emailConflictInfo.type, ")"] }), ". Please sign in again with the correct account."] }), jsxRuntimeExports$1.jsx(Box, { marginTop: "4", gap: "2", alignItems: "center", justifyContent: "center", children: jsxRuntimeExports$1.jsx(Button, { label: "OK", onClick: () => toggleEmailConflictModal(false) }) })] })] }) })] }) }) }), children] }) }) }) }) }) });
};
const defaultQueryClient = new QueryClient();
const SequenceKit = (props) => {
  const { config: config2, queryClient, children } = props;
  const { kitConfig: kitConfig2, wagmiConfig } = config2;
  return jsxRuntimeExports$1.jsx(WagmiProvider, { config: wagmiConfig, children: jsxRuntimeExports$1.jsx(QueryClientProvider, { client: queryClient || defaultQueryClient, children: jsxRuntimeExports$1.jsx(KitProvider, { config: kitConfig2, children }) }) });
};
const getDefaultChains = (chainIdsFilter) => {
  if (chainIdsFilter) {
    return chainIdsFilter.map((chainId) => {
      const chain = chains[chainId];
      if (!chain) {
        throw new Error(`Chain with id ${chainId} not supported by Sequence`);
      }
      return chain;
    });
  }
  return Object.values(chains);
};
const getAppleLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "white" : "black";
  const AppleLogo = (props) => {
    return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M27.166 20.8774C27.1338 17.335 30.0617 15.633 30.1936 15.5493C28.5463 13.1395 25.9852 12.8113 25.0714 12.7727C22.8932 12.5507 20.8179 14.0565 19.7111 14.0565C18.6043 14.0565 16.8991 12.8049 15.0909 12.8403C12.7131 12.8757 10.5221 14.2205 9.2962 16.3505C6.8284 20.6297 8.66557 26.9777 11.0722 30.4557C12.2498 32.1545 13.6494 34.0689 15.493 33.9981C17.2691 33.9273 17.9383 32.8495 20.0811 32.8495C22.224 32.8495 22.8289 33.9981 24.7014 33.9627C26.6094 33.9241 27.8191 32.2253 28.9871 30.5201C30.3352 28.5478 30.8918 26.6366 30.924 26.5369C30.8822 26.5208 27.2046 25.1116 27.166 20.8774Z", fill: fillColor }), jsxRuntimeExports$1.jsx("path", { d: "M23.6429 10.4722C24.621 9.28822 25.2806 7.64089 25.1004 6C23.6911 6.05791 21.9859 6.93949 20.9756 8.12351C20.0715 9.16917 19.2768 10.8455 19.4923 12.4542C21.0592 12.5764 22.6648 11.653 23.6429 10.4722Z", fill: fillColor })] });
  };
  return AppleLogo;
};
const getAppleMonochromeLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "#FFFFFF" : "#000000";
  const AppleOtcLogo = (props) => {
    return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M27.166 20.8774C27.1338 17.335 30.0617 15.633 30.1936 15.5493C28.5463 13.1395 25.9852 12.8113 25.0714 12.7727C22.8932 12.5507 20.8179 14.0565 19.7111 14.0565C18.6043 14.0565 16.8991 12.8049 15.0909 12.8403C12.7131 12.8757 10.5221 14.2205 9.2962 16.3505C6.8284 20.6297 8.66557 26.9777 11.0722 30.4557C12.2498 32.1545 13.6494 34.0689 15.493 33.9981C17.2691 33.9273 17.9383 32.8495 20.0811 32.8495C22.224 32.8495 22.8289 33.9981 24.7014 33.9627C26.6094 33.9241 27.8191 32.2253 28.9871 30.5201C30.3352 28.5478 30.8918 26.6366 30.924 26.5369C30.8822 26.5208 27.2046 25.1116 27.166 20.8774Z", fill: fillColor }), jsxRuntimeExports$1.jsx("path", { d: "M23.6429 10.4722C24.621 9.28822 25.2806 7.64089 25.1004 6C23.6911 6.05791 21.9859 6.93949 20.9756 8.12351C20.0715 9.16917 19.2768 10.8455 19.4923 12.4542C21.0592 12.5764 22.6648 11.653 23.6429 10.4722Z", fill: fillColor })] });
  };
  return AppleOtcLogo;
};
const apple = (options) => ({
  id: "apple",
  isSequenceBased: true,
  logoDark: getAppleLogo({ isDarkMode: true }),
  logoLight: getAppleLogo({ isDarkMode: false }),
  monochromeLogoDark: getAppleMonochromeLogo({ isDarkMode: true }),
  monochromeLogoLight: getAppleMonochromeLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Apple",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "apple"
        }
      }
    });
    return connector;
  }
});
const appleWaas = (options) => ({
  id: "apple-waas",
  logoDark: getAppleLogo({ isDarkMode: true }),
  logoLight: getAppleLogo({ isDarkMode: false }),
  monochromeLogoDark: getAppleMonochromeLogo({ isDarkMode: true }),
  monochromeLogoLight: getAppleMonochromeLogo({ isDarkMode: false }),
  name: "Apple",
  type: "social",
  createConnector: () => {
    const connector = sequenceWaasWallet({
      ...options,
      loginType: "apple"
    });
    return connector;
  }
});
coinbaseWallet$1.type = "coinbaseWallet";
function coinbaseWallet$1(parameters = {}) {
  if (parameters.version === "3" || parameters.headlessMode)
    return version3(parameters);
  return version4(parameters);
}
function version4(parameters) {
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    supportsSimulation: true,
    type: coinbaseWallet$1.type,
    async connect({ chainId } = {}) {
      try {
        const provider2 = await this.getProvider();
        const accounts = (await provider2.request({
          method: "eth_requestAccounts"
        })).map((x2) => getAddress$1(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a2;
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider2.disconnect();
      (_a2 = provider2.close) == null ? void 0 : _a2.call(provider2);
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      return (await provider2.request({
        method: "eth_accounts"
      })).map((x2) => getAddress$1(x2));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = await provider2.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const CoinbaseWalletSDK = await (async () => {
          const { default: SDK } = await __vitePreload(async () => {
            const { default: SDK2 } = await import("./index-CT7htynR.js").then((n2) => n2.i);
            return { default: SDK2 };
          }, true ? __vite__mapDeps([0,1,2]) : void 0, import.meta.url);
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        sdk = new CoinbaseWalletSDK({
          ...parameters,
          appChainIds: config2.chains.map((x2) => x2.id)
        });
        walletProvider = sdk.makeWeb3Provider({
          ...parameters,
          options: parameters.preference ?? "all"
        });
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2, _d2;
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider2 = await this.getProvider();
      try {
        await provider2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress$1(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error2) {
      config2.emitter.emit("disconnect");
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
function version3(parameters) {
  const reloadOnDisconnect = false;
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    supportsSimulation: true,
    type: coinbaseWallet$1.type,
    async connect({ chainId } = {}) {
      try {
        const provider2 = await this.getProvider();
        const accounts = (await provider2.request({
          method: "eth_requestAccounts"
        })).map((x2) => getAddress$1(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider2.disconnect();
      provider2.close();
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      return (await provider2.request({
        method: "eth_accounts"
      })).map((x2) => getAddress$1(x2));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = await provider2.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      var _a2;
      if (!walletProvider) {
        const CoinbaseWalletSDK = await (async () => {
          const { default: SDK } = await __vitePreload(async () => {
            const { default: SDK2 } = await import("./index-BE7fuU30.js").then((n2) => n2.i);
            return { default: SDK2 };
          }, true ? __vite__mapDeps([3,2,1]) : void 0, import.meta.url);
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect });
        const walletExtensionChainId = (_a2 = sdk.walletExtension) == null ? void 0 : _a2.getChainId();
        const chain = config2.chains.find((chain2) => parameters.chainId ? chain2.id === parameters.chainId : chain2.id === walletExtensionChainId) || config2.chains[0];
        const chainId = parameters.chainId || (chain == null ? void 0 : chain.id);
        const jsonRpcUrl = parameters.jsonRpcUrl || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2, _d2;
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider2 = await this.getProvider();
      try {
        await provider2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress$1(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error2) {
      config2.emitter.emit("disconnect");
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
walletConnect$1.type = "walletConnect";
function walletConnect$1(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  const NAMESPACE = "eip155";
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config2) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect$1.type,
    async setup() {
      const provider2 = await this.getProvider().catch(() => null);
      if (!provider2)
        return;
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider2.on("session_delete", sessionDelete);
      }
    },
    async connect({ chainId, ...rest } = {}) {
      var _a2, _b2;
      try {
        const provider2 = await this.getProvider();
        if (!provider2)
          throw new ProviderNotFoundError();
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider2.on("display_uri", displayUri);
        }
        let targetChainId = chainId;
        if (!targetChainId) {
          const state = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem("state")) ?? {};
          const isChainSupported = config2.chains.some((x2) => x2.id === state.chainId);
          if (isChainSupported)
            targetChainId = state.chainId;
          else
            targetChainId = (_b2 = config2.chains[0]) == null ? void 0 : _b2.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const isChainsStale = await this.isChainsStale();
        if (provider2.session && isChainsStale)
          await provider2.disconnect();
        if (!provider2.session || isChainsStale) {
          const optionalChains = config2.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
          await provider2.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(config2.chains.map((x2) => x2.id));
        }
        const accounts = (await provider2.enable()).map((x2) => getAddress$1(x2));
        const currentChainId = await this.getChainId();
        if (displayUri) {
          provider2.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider2.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider2.on("session_delete", sessionDelete);
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      try {
        await (provider2 == null ? void 0 : provider2.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        if (chainChanged) {
          provider2 == null ? void 0 : provider2.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider2 == null ? void 0 : provider2.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider2 == null ? void 0 : provider2.on("connect", connect2);
        }
        if (accountsChanged) {
          provider2 == null ? void 0 : provider2.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider2 == null ? void 0 : provider2.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      return provider2.accounts.map((x2) => getAddress$1(x2));
    },
    async getProvider({ chainId } = {}) {
      var _a2;
      async function initProvider() {
        const optionalChains = config2.chains.map((x2) => x2.id);
        if (!optionalChains.length)
          return;
        const { EthereumProvider } = await __vitePreload(async () => {
          const { EthereumProvider: EthereumProvider2 } = await import("./index.es-Mgm5-TKN.js");
          return { EthereumProvider: EthereumProvider2 };
        }, true ? __vite__mapDeps([4,2]) : void 0, import.meta.url);
        return await EthereumProvider.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: parameters.projectId,
          rpcMap: Object.fromEntries(config2.chains.map((chain) => {
            const [url] = extractRpcUrls({
              chain,
              transports: config2.transports
            });
            return [chain.id, url];
          })),
          showQrModal: parameters.showQrModal ?? true
        });
      }
      if (!provider_) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider_ = await providerPromise;
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      if (chainId)
        await ((_a2 = this.switchChain) == null ? void 0 : _a2.call(this, { chainId }));
      return provider_;
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      return provider2.chainId;
    },
    async isAuthorized() {
      try {
        const [accounts, provider2] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        if (!accounts.length)
          return false;
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider2.session) {
          await provider2.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          new Promise((resolve) => {
            const listener = ({ chainId: currentChainId }) => {
              if (currentChainId === chainId) {
                config2.emitter.off("change", listener);
                resolve();
              }
            };
            config2.emitter.on("change", listener);
          }),
          provider2.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          })
        ]);
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return chain;
      } catch (err) {
        const error = err;
        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          else
            blockExplorerUrls = ((_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
          let rpcUrls;
          if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
            rpcUrls = addEthereumChainParameter.rpcUrls;
          else
            rpcUrls = [...chain.rpcUrls.default.http];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
            rpcUrls
          };
          await provider2.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress$1(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config2.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error2) {
      this.setRequestedChainsIds([]);
      config2.emitter.emit("disconnect");
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider2.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config2.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a2, _b2, _c2;
      if (!provider_)
        return [];
      const chainIds = (_c2 = (_b2 = (_a2 = provider_.session) == null ? void 0 : _a2.namespaces[NAMESPACE]) == null ? void 0 : _b2.accounts) == null ? void 0 : _c2.map((account2) => Number.parseInt(account2.split(":")[1] || ""));
      return chainIds ?? [];
    },
    async getRequestedChainsIds() {
      var _a2;
      return await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!isNewChainsStale)
        return false;
      const connectorChains = config2.chains.map((x2) => x2.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id2) => connectorChains.includes(id2)))
        return false;
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id2) => requestedChains.includes(id2));
    },
    async setRequestedChainsIds(chains2) {
      var _a2;
      await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem(this.requestedChainsStorageKey, chains2));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}
const CoinbaseWalletLogo = (props) => {
  return jsxRuntimeExports$1.jsxs("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsxRuntimeExports$1.jsx("rect", { width: "28", height: "28", fill: "#2C5FF6" }), jsxRuntimeExports$1.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 23.8C19.4124 23.8 23.8 19.4124 23.8 14C23.8 8.58761 19.4124 4.2 14 4.2C8.58761 4.2 4.2 8.58761 4.2 14C4.2 19.4124 8.58761 23.8 14 23.8ZM11.55 10.8C11.1358 10.8 10.8 11.1358 10.8 11.55V16.45C10.8 16.8642 11.1358 17.2 11.55 17.2H16.45C16.8642 17.2 17.2 16.8642 17.2 16.45V11.55C17.2 11.1358 16.8642 10.8 16.45 10.8H11.55Z", fill: "white" })] });
};
const coinbaseWallet = (params) => ({
  id: "coinbase-wallet",
  logoDark: CoinbaseWalletLogo,
  logoLight: CoinbaseWalletLogo,
  name: "Coinbase Wallet",
  type: "wallet",
  createConnector: () => {
    const connector = coinbaseWallet$1({ ...params });
    return connector;
  }
});
const getEmailLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "white" : "black";
  const EmailLogo = (props) => {
    return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 35 34", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M17.0826 16.3805C17.1802 16.4598 17.32 16.4598 17.4176 16.3805L30.1401 6.04341C30.5283 5.72801 30.3053 5.09985 29.8051 5.09985H4.69499C4.19482 5.09985 3.9718 5.72801 4.35998 6.04341L17.0826 16.3805Z", fill: fillColor }), jsxRuntimeExports$1.jsx("path", { d: "M19.7626 19.2667L33.3838 8.19943C33.731 7.91735 34.2501 8.16441 34.2501 8.61174V24.2249C34.2501 26.5721 32.3473 28.4749 30.0001 28.4749H4.50006C2.15285 28.4749 0.250061 26.5721 0.250061 24.2249V8.61174C0.250061 8.16441 0.769134 7.91735 1.11631 8.19943L14.7375 19.2667C16.2014 20.4561 18.2987 20.4561 19.7626 19.2667Z", fill: fillColor })] });
  };
  return EmailLogo;
};
const email = (options) => ({
  id: "email",
  isSequenceBased: true,
  logoDark: getEmailLogo({ isDarkMode: true }),
  logoLight: getEmailLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Email",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInOptions: ["email"]
        }
      }
    });
    return connector;
  }
});
const emailWaas = ({ legacyEmailAuth = false, ...rest }) => ({
  id: "email-waas",
  logoDark: getEmailLogo({ isDarkMode: true }),
  logoLight: getEmailLogo({ isDarkMode: false }),
  name: "Email",
  type: "social",
  createConnector: () => {
    const options = { legacyEmailAuth, ...rest };
    const connector = sequenceWaasWallet({
      ...options,
      loginType: "email"
    });
    return connector;
  }
});
const FacebookLogo = (props) => {
  return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M17.4214 36.9716C9.27855 35.5145 3.10712 28.4859 3.10712 20.0001C3.10712 10.5715 10.8214 2.85718 20.25 2.85718C29.6785 2.85718 37.3928 10.5715 37.3928 20.0001C37.3928 28.4859 31.2214 35.5145 23.0785 36.9716L22.1357 36.2002H18.3643L17.4214 36.9716Z", fill: "url(#paint0_linear_193_14528)" }), jsxRuntimeExports$1.jsx("path", { d: "M26.9357 24.7999L27.7072 19.9999H23.1643V16.657C23.1643 15.2856 23.6786 14.257 25.7357 14.257H27.9643V9.88558C26.7643 9.71415 25.3929 9.54272 24.1929 9.54272C20.25 9.54272 17.5071 11.9427 17.5071 16.2285V19.9999H13.2214V24.7999H17.5071V36.8857C18.45 37.0571 19.3929 37.1429 20.3357 37.1429C21.2786 37.1429 22.2214 37.0571 23.1643 36.8857V24.7999H26.9357Z", fill: "white" }), jsxRuntimeExports$1.jsx("defs", { children: jsxRuntimeExports$1.jsxs("linearGradient", { id: "paint0_linear_193_14528", x1: "20.2508", y1: "35.9507", x2: "20.2508", y2: "2.85086", gradientUnits: "userSpaceOnUse", children: [jsxRuntimeExports$1.jsx("stop", { stopColor: "#0062E0" }), jsxRuntimeExports$1.jsx("stop", { offset: "1", stopColor: "#19AFFF" })] }) })] });
};
const getFacebookMonochromeLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "#FFFFFF" : "#000000";
  const FacebookMonochromeLogo = (props) => {
    return jsxRuntimeExports$1.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: jsxRuntimeExports$1.jsx("path", { d: "M25.8582 10.4398C24.1222 10.4398 23.6288 11.2098 23.6288 12.9073V15.709H28.246L27.791 20.2476H23.6279V34H18.1024V20.2468H14.375V15.7081H18.1042V12.9851C18.1042 8.40625 19.9399 6 25.0891 6C26.1942 6 27.5163 6.0875 28.3055 6.19775V10.459", fill: fillColor }) });
  };
  return FacebookMonochromeLogo;
};
const facebook = (options) => ({
  id: "facebook",
  isSequenceBased: true,
  logoDark: FacebookLogo,
  logoLight: FacebookLogo,
  monochromeLogoDark: getFacebookMonochromeLogo({ isDarkMode: true }),
  monochromeLogoLight: getFacebookMonochromeLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Facebook",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "facebook"
        }
      }
    });
    return connector;
  }
});
const GoogleLogo = (props) => {
  return jsxRuntimeExports$1.jsx("svg", { viewBox: "0 0 41 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsxRuntimeExports$1.jsx("g", { id: "Frame 2114", children: jsxRuntimeExports$1.jsxs("g", { id: "Group", children: [jsxRuntimeExports$1.jsx("path", { id: "Vector", d: "M20.7497 16.8828V23.5218H29.9756C29.5705 25.6568 28.3548 27.4647 26.5314 28.6803L32.095 32.9972C35.3366 30.0051 37.2068 25.6102 37.2068 20.3895C37.2068 19.1739 37.0977 18.005 36.895 16.883L20.7497 16.8828Z", fill: "#4285F4" }), jsxRuntimeExports$1.jsx("path", { id: "Vector_2", d: "M11.1424 23.2627L9.88756 24.2232L5.44592 27.6829C8.2667 33.2777 14.0481 37.1427 20.7493 37.1427C25.3778 37.1427 29.2583 35.6154 32.0947 32.9973L26.5311 28.6803C25.0038 29.7089 23.0557 30.3324 20.7493 30.3324C16.2922 30.3324 12.5053 27.3246 11.1494 23.2726L11.1424 23.2627Z", fill: "#34A853" }), jsxRuntimeExports$1.jsx("path", { id: "Vector_3", d: "M5.44594 12.3169C4.27718 14.6233 3.60712 17.2259 3.60712 19.9999C3.60712 22.7739 4.27718 25.3765 5.44594 27.6829C5.44594 27.6984 11.1499 23.2569 11.1499 23.2569C10.8071 22.2284 10.6044 21.1375 10.6044 19.9997C10.6044 18.8619 10.8071 17.7711 11.1499 16.7425L5.44594 12.3169Z", fill: "#FBBC05" }), jsxRuntimeExports$1.jsx("path", { id: "Vector_4", d: "M20.7497 9.6829C23.2744 9.6829 25.5185 10.5556 27.3107 12.2387L32.2198 7.32972C29.2431 4.55574 25.3783 2.85693 20.7497 2.85693C14.0484 2.85693 8.2667 6.70628 5.44592 12.3167L11.1497 16.7427C12.5055 12.6907 16.2926 9.6829 20.7497 9.6829Z", fill: "#EA4335" })] }) }) });
};
const getMonochromeGoogleLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "white" : "black";
  const GoogleMonochromeLogo = (props) => {
    return jsxRuntimeExports$1.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: jsxRuntimeExports$1.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M25.8355 14.7613C24.5584 13.5329 22.9441 12.9032 21.1356 12.9032C17.9377 12.9032 15.2302 15.0813 14.2595 18.0232L14.2593 18.023C14.0142 18.7662 13.8712 19.5609 13.8712 20.3866C13.8712 21.2124 14.004 22.0072 14.2594 22.7504L14.2587 22.751H14.2595C15.2302 25.6929 17.9377 27.871 21.1356 27.871C22.7907 27.871 24.1904 27.4168 25.2939 26.6736V26.6732C26.5812 25.7958 27.4497 24.5055 27.746 22.9777H21.1355V18.3223H32.6808C32.8034 19.0758 32.875 19.85 32.875 20.6655C32.875 24.4332 31.5467 27.6126 29.2377 29.77L29.2378 29.7703C27.2148 31.6594 24.446 32.7742 21.1356 32.7742C16.3438 32.7742 12.2059 29.9871 10.1931 25.9407V25.94L10.193 25.9401C9.35521 24.2678 8.875 22.3891 8.875 20.3866C8.875 18.384 9.35521 16.5053 10.193 14.833H10.1934C12.2063 10.7869 16.344 8 21.1356 8C24.446 8 27.2148 9.22839 29.3298 11.231L25.8355 14.7613Z", fill: fillColor }) });
  };
  return GoogleMonochromeLogo;
};
const google = (options) => ({
  id: "google",
  isSequenceBased: true,
  logoDark: GoogleLogo,
  logoLight: GoogleLogo,
  monochromeLogoDark: getMonochromeGoogleLogo({ isDarkMode: true }),
  monochromeLogoLight: getMonochromeGoogleLogo({ isDarkMode: false }),
  name: "Google",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "google"
        }
      }
    });
    return connector;
  }
});
const googleWaas = (options) => ({
  id: "google-waas",
  logoDark: GoogleLogo,
  logoLight: GoogleLogo,
  monochromeLogoDark: getMonochromeGoogleLogo({ isDarkMode: true }),
  monochromeLogoLight: getMonochromeGoogleLogo({ isDarkMode: false }),
  name: "Google",
  type: "social",
  createConnector: () => {
    const connector = sequenceWaasWallet({
      ...options,
      loginType: "google"
    });
    return connector;
  }
});
const SequenceLogo = (props) => {
  return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", style: { fill: "none" }, id: "svg1316", version: "1.1", viewBox: "0 0 396 396", ...props, children: [jsxRuntimeExports$1.jsx("g", { transform: "translate(0,38)", id: "g1256", clipPath: "url(#clip0_5_131)", children: jsxRuntimeExports$1.jsxs("g", { id: "g1254", clipPath: "url(#clip1_5_131)", children: [jsxRuntimeExports$1.jsx("path", { style: { fill: "#111111" }, id: "path1232", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint0_linear_5_13" }, id: "path1234", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint1_linear_5_131" }, id: "path1236", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint2_linear_5_131)" }, id: "path1238", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint3_linear_5_131)" }, id: "path1240", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint4_linear_5_131)" }, id: "path1242", d: "m 98.9999,238.126 c 0,-10.965 -8.8648,-19.854 -19.8,-19.854 -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.966 8.8648,19.855 19.8,19.855 10.9352,0 19.8,-8.889 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint5_linear_5_131)" }, id: "path1244", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint6_linear_5_131)" }, id: "path1246", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint7_linear_5_131)" }, id: "path1248", d: "M 316.8,59.5632 H 158.4 c -10.935,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.865,19.8544 19.8,19.8544 h 158.4 c 10.935,0 19.8,-8.8892 19.8,-19.8544 0,-10.9653 -8.865,-19.8544 -19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint8_linear_5_131)" }, id: "path1250", d: "M 316.8,218.272 H 158.4 c -10.935,0 -19.8,8.889 -19.8,19.854 0,10.966 8.865,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.889 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint9_linear_5_131)" }, id: "path1252", d: "M 237.6,138.981 H 79.2 c -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.965 8.8648,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.89 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" })] }) }), jsxRuntimeExports$1.jsxs("defs", { id: "defs1314", children: [jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "318", x2: "198", y1: "4.0585401e-05", x1: "198", id: "paint0_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1258", stopColor: "#1D273D" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1260", stopColor: "#0D0F13", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "63", x2: "92.5", y1: "99", x1: "65.5", id: "paint1_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1263", stopColor: "#4462FE" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1265", stopColor: "#7D69FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint2_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1268", stopColor: "#3757FD" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1270", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint3_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1273", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1275", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "223.5", x2: "91.5", y1: "251.5", x1: "65", id: "paint4_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1278", stopColor: "#BC3EE6" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1280", stopColor: "#D972F1", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "146", x2: "329.5", y1: "172", x1: "305", id: "paint5_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1283", stopColor: "#29BDFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1285", stopColor: "#96E7FB", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "176.772", x2: "334.56699", y1: "178.418", x1: "300.17999", id: "paint6_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1288", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1290", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "60", x2: "317.5", y1: "99", x1: "154.5", id: "paint7_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1293", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1295", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "218", x2: "312.5", y1: "258", x1: "156", id: "paint8_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1298", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1300", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "139", x2: "235.5", y1: "179", x1: "86.000099", id: "paint9_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1303", stopColor: "#6634FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1305", stopColor: "#9C6DFF", offset: "1" })] }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip0_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1308", height: "317.67001", width: "396" }) }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip1_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1311", height: "317.67001", width: "396" }) })] })] });
};
const sequence = (options) => ({
  id: "sequence",
  isSequenceBased: true,
  logoDark: SequenceLogo,
  logoLight: SequenceLogo,
  // iconBackground: '#777',
  name: "Sequence",
  type: "wallet",
  createConnector: (projectAccessKey2) => {
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options.connect
      }
    });
    return connector;
  }
});
const getTwitchLogo = ({ isDarkMode }) => {
  let fillColor;
  if (isDarkMode === void 0) {
    fillColor = "#9146FF";
  } else {
    fillColor = isDarkMode ? "white" : "black";
  }
  const TwitchLogo = (props) => {
    return jsxRuntimeExports$1.jsx("svg", { version: "1.1", id: "Layer_1", xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", viewBox: "0 0 2400 2800", transform: "scale(0.80)", ...props, children: jsxRuntimeExports$1.jsx("g", { children: jsxRuntimeExports$1.jsxs("g", { id: "Layer_1-2", children: [jsxRuntimeExports$1.jsx("path", { fill: fillColor, d: "M500,0L0,500v1800h600v500l500-500h400l900-900V0H500z M2200,1300l-400,400h-400l-350,350v-350H600V200h1600\n                  V1300z" }), jsxRuntimeExports$1.jsx("rect", { x: "1700", y: "550", fill: fillColor, width: "200", height: "600" }), jsxRuntimeExports$1.jsx("rect", { x: "1150", y: "550", fill: fillColor, width: "200", height: "600" })] }) }) });
  };
  return TwitchLogo;
};
const twitch = (options) => ({
  id: "twitch",
  isSequenceBased: true,
  logoDark: getTwitchLogo({}),
  logoLight: getTwitchLogo({}),
  monochromeLogoDark: getTwitchLogo({ isDarkMode: true }),
  monochromeLogoLight: getTwitchLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Twitch",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "twitch"
        }
      }
    });
    return connector;
  }
});
const WalletConnectLogo = (props) => {
  return jsxRuntimeExports$1.jsx("svg", { fill: "none", viewBox: "0 0 480 332", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsxRuntimeExports$1.jsx("path", { d: "m126.613 93.9842c62.622-61.3123 164.152-61.3123 226.775 0l7.536 7.3788c3.131 3.066 3.131 8.036 0 11.102l-25.781 25.242c-1.566 1.533-4.104 1.533-5.67 0l-10.371-10.154c-43.687-42.7734-114.517-42.7734-158.204 0l-11.107 10.874c-1.565 1.533-4.103 1.533-5.669 0l-25.781-25.242c-3.132-3.066-3.132-8.036 0-11.102zm280.093 52.2038 22.946 22.465c3.131 3.066 3.131 8.036 0 11.102l-103.463 101.301c-3.131 3.065-8.208 3.065-11.339 0l-73.432-71.896c-.783-.767-2.052-.767-2.835 0l-73.43 71.896c-3.131 3.065-8.208 3.065-11.339 0l-103.4657-101.302c-3.1311-3.066-3.1311-8.036 0-11.102l22.9456-22.466c3.1311-3.065 8.2077-3.065 11.3388 0l73.4333 71.897c.782.767 2.051.767 2.834 0l73.429-71.897c3.131-3.065 8.208-3.065 11.339 0l73.433 71.897c.783.767 2.052.767 2.835 0l73.431-71.895c3.132-3.066 8.208-3.066 11.339 0z", fill: "#3396ff" }) });
};
const walletConnect = (options) => ({
  id: "wallet-connect",
  logoDark: WalletConnectLogo,
  logoLight: WalletConnectLogo,
  // iconBackground: '#fff',
  name: "Walletconnect",
  type: "wallet",
  createConnector: () => {
    const connector = walletConnect$1({
      ...options
    });
    return connector;
  }
});
const getKitConnectWallets = (projectAccessKey2, wallets) => {
  const connectors = [];
  wallets.forEach((wallet) => {
    const { createConnector: createConnector2, ...metaProperties } = wallet;
    const walletProperties = { ...metaProperties };
    const createConnectorOverride = (config2) => {
      const connector = createConnector2(projectAccessKey2);
      const res = connector(config2);
      res._wallet = { ...walletProperties };
      return res;
    };
    connectors.push(createConnectorOverride);
  });
  return connectors;
};
const getDefaultConnectors = (walletType2, options) => {
  if (walletType2 === "waas") {
    return getDefaultWaasConnectors(options);
  } else if (walletType2 === "universal") {
    return getDefaultUniversalConnectors(options);
  }
};
const getDefaultWaasConnectors = (options) => {
  var _a2;
  const { projectAccessKey: projectAccessKey2, waasConfigKey, appName, enableConfirmationModal, defaultChainId, isDev } = options;
  const wallets = [];
  if (options.email !== false) {
    wallets.push(emailWaas({
      projectAccessKey: projectAccessKey2,
      waasConfigKey,
      enableConfirmationModal,
      network: defaultChainId,
      legacyEmailAuth: typeof options.email === "object" && options.email.legacyEmailAuth || options.legacyEmailAuth,
      isDev
    }));
  }
  if (options.google || options.googleClientId) {
    const googleClientId = options.google && options.google.clientId || options.googleClientId;
    wallets.push(googleWaas({
      projectAccessKey: projectAccessKey2,
      waasConfigKey,
      googleClientId,
      enableConfirmationModal,
      network: defaultChainId,
      isDev
    }));
  }
  if (options.apple || options.appleClientId && options.appleRedirectURI) {
    const appleClientId = options.apple && options.apple.clientId || options.appleClientId;
    const appleRedirectURI = options.apple && options.apple.redirectURI || options.appleRedirectURI;
    wallets.push(appleWaas({
      projectAccessKey: projectAccessKey2,
      waasConfigKey,
      appleClientId,
      appleRedirectURI,
      enableConfirmationModal,
      network: defaultChainId,
      isDev
    }));
  }
  if (options.coinbase !== false) {
    wallets.push(coinbaseWallet({
      appName
    }));
  }
  if (options.walletConnect || options.walletConnectProjectId) {
    const projectId = options.walletConnect && ((_a2 = options.walletConnect) == null ? void 0 : _a2.projectId) || options.walletConnectProjectId;
    wallets.push(walletConnect({
      projectId
    }));
  }
  return getKitConnectWallets(projectAccessKey2, wallets);
};
const getDefaultUniversalConnectors = (options) => {
  var _a2;
  const { projectAccessKey: projectAccessKey2, appName, defaultChainId } = options;
  const wallets = [];
  if (options.email !== false) {
    wallets.push(email({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }));
  }
  if (options.google !== false) {
    wallets.push(google({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }));
  }
  if (options.facebook !== false) {
    wallets.push(facebook({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }));
  }
  if (options.twitch !== false) {
    wallets.push(twitch({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }));
  }
  if (options.apple !== false) {
    wallets.push(apple({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }));
  }
  if (options.sequence !== false) {
    wallets.push(sequence({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }));
  }
  if (options.walletConnect || options.walletConnectProjectId) {
    const projectId = options.walletConnect && ((_a2 = options.walletConnect) == null ? void 0 : _a2.projectId) || options.walletConnectProjectId;
    wallets.push(walletConnect({
      projectId
    }));
  }
  return getKitConnectWallets(projectAccessKey2, wallets);
};
const getDefaultTransports = (chains2) => {
  return Object.fromEntries(chains2.map((chain) => [chain.id, http()]));
};
const createConfig = (walletType2, options) => {
  const { projectAccessKey: projectAccessKey2, chainIds, wagmiConfig, ...rest } = options;
  const chains2 = (wagmiConfig == null ? void 0 : wagmiConfig.chains) || getDefaultChains(chainIds);
  const transports = (wagmiConfig == null ? void 0 : wagmiConfig.transports) || getDefaultTransports(chains2);
  const connectors = (wagmiConfig == null ? void 0 : wagmiConfig.connectors) || getDefaultConnectors(walletType2, options);
  return {
    kitConfig: {
      projectAccessKey: projectAccessKey2,
      ...rest
    },
    wagmiConfig: createConfig$1({
      ...wagmiConfig,
      chains: chains2,
      transports,
      connectors
    })
  };
};
const walletClientToSigner = async (walletClient) => {
  var _a2, _b2;
  const { account: account2, chain, transport } = walletClient;
  const network2 = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: (_b2 = (_a2 = chain.contracts) == null ? void 0 : _a2.ensRegistry) == null ? void 0 : _b2.address
  };
  const provider2 = new BrowserProvider(transport, network2);
  const signer2 = await provider2.getSigner(account2.address);
  return signer2;
};
const publicClientToProvider = (publicClient) => {
  var _a2, _b2;
  const { chain, transport } = publicClient;
  const network2 = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: (_b2 = (_a2 = chain.contracts) == null ? void 0 : _a2.ensRegistry) == null ? void 0 : _b2.address
  };
  if (transport.type === "fallback")
    return new FallbackProvider(transport.transports.map(({ value }) => new JsonRpcProvider$1(value == null ? void 0 : value.url, network2)));
  return new JsonRpcProvider$1(transport.url, network2);
};
const signEthAuthProof = async (walletClient, storage) => {
  const proofInformation = await storage.getItem(LocalStorageKey.EthAuthProof);
  if (proofInformation) {
    return proofInformation;
  }
  const proofSettings = await storage.getItem(LocalStorageKey.EthAuthSettings);
  if (!proofSettings) {
    throw new Error("No ETHAuth settings found");
  }
  const walletAddress = walletClient.account.address;
  const proof = new Proof();
  proof.address = walletAddress;
  proof.claims.app = proofSettings.app || "app";
  proof.claims.ogn = proofSettings.origin;
  proof.claims.n = proofSettings.nonce;
  proof.setExpiryIn(proofSettings.expiry ? Math.max(proofSettings.expiry, 200) : DEFAULT_SESSION_EXPIRATION);
  const typedData = proof.messageTypedData();
  typedData.domain.verifyingContract;
  const signer2 = await walletClientToSigner(walletClient);
  const signature2 = await signer2.signTypedData(typedData.domain, typedData.types, typedData.message);
  proof.signature = signature2;
  const ethAuth = new ETHAuth();
  const proofString = await ethAuth.encodeProof(proof, true);
  return {
    typedData,
    proofString
  };
};
const validateEthProof = async (walletClient, publicClient, proof) => {
  const walletAddress = walletClient.account.address;
  const ethAuth = new ETHAuth();
  const decodedProof = await ethAuth.decodeProof(proof.proofString, true);
  const provider2 = publicClientToProvider(publicClient);
  const isValid2 = await isValidTypedDataSignature(walletAddress, proof.typedData, decodedProof.signature, provider2);
  return isValid2;
};
const sendTransactions = async ({ chainId, senderAddress, publicClient, walletClient, connector, transactions: transactions2, transactionConfirmations = TRANSACTION_CONFIRMATIONS_DEFAULT }) => {
  var _a2, _b2;
  const walletClientChainId = await walletClient.getChainId();
  if (walletClientChainId !== chainId) {
    throw new Error("The Wallet Client is using the wrong network");
  }
  if (((_a2 = publicClient.chain) == null ? void 0 : _a2.id) !== chainId) {
    throw new Error("The Public Client is using the wrong network");
  }
  const sequenceWaaS = connector == null ? void 0 : connector["sequenceWaas"];
  const isEmbeddedWallet = !!sequenceWaaS;
  const isSequenceUniversalWallet = !!((_b2 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _b2.isSequenceBased);
  if (isEmbeddedWallet) {
    const resp = await sequenceWaaS.feeOptions({
      transactions: transactions2,
      network: chainId
    });
    const transactionsFeeOption = resp.data.feeOptions[0];
    const transactionsFeeQuote = resp.data.feeQuote;
    const response = await sequenceWaaS.sendTransaction({
      transactions: transactions2,
      transactionsFeeOption,
      transactionsFeeQuote,
      network: chainId
    });
    if (response.code === "transactionFailed") {
      throw new Error(response.data.error);
    }
    const txnHash = response.data.txHash;
    await publicClient.waitForTransactionReceipt({
      hash: txnHash,
      confirmations: transactionConfirmations
    });
    return txnHash;
  } else if (isSequenceUniversalWallet) {
    const wallet = sequence$1.getWallet();
    const signer2 = wallet.getSigner();
    const response = await signer2.sendTransaction(transactions2);
    await publicClient.waitForTransactionReceipt({
      hash: response.hash,
      confirmations: transactionConfirmations
    });
    return response.hash;
  } else {
    let txHash = "";
    for (const transaction2 of transactions2) {
      const txnHash = await walletClient.sendTransaction({
        account: senderAddress,
        to: transaction2.to,
        value: transaction2 == null ? void 0 : transaction2.value,
        data: transaction2 == null ? void 0 : transaction2.data,
        chain: void 0
      });
      await publicClient.waitForTransactionReceipt({
        hash: txnHash,
        confirmations: transactionConfirmations
      });
      txHash = txnHash;
    }
    return txHash;
  }
};
const useOpenConnectModal = () => {
  const { setOpenConnectModal, openConnectModalState } = useConnectModalContext();
  return { setOpenConnectModal, openConnectModalState };
};
const useTheme = () => {
  const { setTheme, theme, position, setPosition } = useThemeContext();
  return {
    setTheme,
    theme,
    position,
    setPosition
  };
};
const useWalletSettings = () => {
  const { setDisplayedAssets, displayedAssets } = useWalletConfigContext();
  return {
    displayedAssets,
    setDisplayedAssets
  };
};
let _pendingFeeConfirmation;
function useWaasFeeOptions() {
  var _a2;
  const connections = useConnections();
  const waasConnector = (_a2 = connections.find((c2) => c2.connector.id.includes("waas"))) == null ? void 0 : _a2.connector;
  const [pendingFeeOptionConfirmation, setPendingFeeOptionConfirmation] = reactExports.useState();
  function confirmPendingFeeOption(id2, feeTokenAddress) {
    _pendingFeeConfirmation == null ? void 0 : _pendingFeeConfirmation.resolve({ id: id2, feeTokenAddress, confirmed: true });
    setPendingFeeOptionConfirmation(void 0);
    _pendingFeeConfirmation = void 0;
  }
  function rejectPendingFeeOption(id2) {
    _pendingFeeConfirmation == null ? void 0 : _pendingFeeConfirmation.resolve({ id: id2, feeTokenAddress: void 0, confirmed: false });
    setPendingFeeOptionConfirmation(void 0);
    _pendingFeeConfirmation = void 0;
  }
  reactExports.useEffect(() => {
    async function setup() {
      if (!waasConnector) {
        return;
      }
      const waasProvider = waasConnector.sequenceWaasProvider;
      if (!waasProvider) {
        return;
      }
      waasProvider.feeConfirmationHandler = {
        confirmFeeOption(id2, options, txs, chainId) {
          const pending = new Deferred();
          setPendingFeeOptionConfirmation({ id: id2, options, chainId });
          _pendingFeeConfirmation = pending;
          return pending.promise;
        }
      };
    }
    setup();
  });
  return [pendingFeeOptionConfirmation, confirmPendingFeeOption, rejectPendingFeeOption];
}
const createGenericContext$1 = () => {
  const genericContext = reactExports.createContext(void 0);
  const useGenericContext = () => {
    const contextIsDefined = reactExports.useContext(genericContext);
    if (!contextIsDefined) {
      throw new Error("useGenericContext must be used within a Provider");
    }
    return contextIsDefined;
  };
  return [useGenericContext, genericContext.Provider];
};
const [useAddFundsModalContext, AddFundsContextProvider] = createGenericContext$1();
const [useCheckoutModalContext, CheckoutModalContextProvider] = createGenericContext$1();
const [useNavigationContext$1, NavigationContextProvider$1] = createGenericContext$1();
const [useSelectPaymentContext, SelectPaymentContextProvider] = createGenericContext$1();
const [useTransferFundsModalContext, TransferFundsContextProvider] = createGenericContext$1();
const HEADER_HEIGHT$1 = "54px";
const useNavigation$1 = () => {
  const { setHistory, history, defaultLocation } = useNavigationContext$1();
  const setNavigation = (navigation2) => {
    const childElement = document.getElementById("sequence-kit-wallet-content");
    const parentElement = childElement == null ? void 0 : childElement.parentElement;
    parentElement == null ? void 0 : parentElement.scrollTo(0, 0);
    const newHistory = [...history, navigation2];
    setHistory(newHistory);
  };
  const goBack = () => {
    const newHistory = [...history];
    newHistory.pop();
    setHistory(newHistory);
  };
  const navigation = history.length > 0 ? history[history.length - 1] : defaultLocation;
  return { setNavigation, history, setHistory, goBack, navigation };
};
const NavigationHeader$1 = ({ secondaryText, primaryText, disableBack = false }) => {
  const { goBack, history } = useNavigation$1();
  const onClickBack = () => {
    goBack();
  };
  return jsxRuntimeExports$1.jsxs(Box, { background: "backgroundPrimary", zIndex: "20", position: "fixed", width: "full", flexDirection: "row", alignItems: "center", justifyContent: "space-between", style: {
    height: HEADER_HEIGHT$1,
    paddingTop: "6px",
    backgroundColor: vars.colors.backgroundPrimary,
    position: "absolute"
  }, children: [history.length > 0 && !disableBack ? jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickBack, icon: SvgChevronLeftIcon, size: "sm", style: {
    background: "rgba(0,0,0,0)",
    width: "44px"
  } }) : jsxRuntimeExports$1.jsx(Box, {}), jsxRuntimeExports$1.jsxs(Box, { width: "full", alignItems: "center", justifyContent: "center", style: { marginLeft: "40px" }, children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text50", children: secondaryText }), jsxRuntimeExports$1.jsx(index$2$1.Title, { asChild: true, children: jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text100", children: primaryText }) })] }), jsxRuntimeExports$1.jsx(Box, { style: {
    width: "44px"
  } })] });
};
const fetchSardineClientToken = async ({ order, isDev, projectAccessKey: projectAccessKey2, tokenMetadata }) => {
  const accessKey = isDev ? "17xhjK4yjRf1fr0am8kgKfICAAAAAAAAA" : projectAccessKey2;
  const url = isDev ? "https://dev-api.sequence.app/rpc/API/GetSardineNFTCheckoutToken" : "https://api.sequence.app/rpc/API/GetSardineNFTCheckoutToken";
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Access-Key": `${accessKey || ""}`
    },
    body: JSON.stringify({
      params: {
        name: (tokenMetadata == null ? void 0 : tokenMetadata.name) || "Unknown",
        imageUrl: (tokenMetadata == null ? void 0 : tokenMetadata.image) || "https://sequence.market/images/placeholder.png",
        network: networks$1[order.chainId].name,
        recipientAddress: order.recipientAddress,
        contractAddress: order.contractAddress,
        platform: "calldata_execution",
        blockchainNftId: order.nftId,
        quantity: Number(order.nftQuantity),
        decimals: Number((order == null ? void 0 : order.nftDecimals) || 0),
        tokenAmount: order.currencyQuantity,
        tokenAddress: order.currencyAddress,
        tokenSymbol: order.currencySymbol,
        tokenDecimals: Number(order.currencyDecimals),
        callData: order.calldata,
        ...(order == null ? void 0 : order.approvedSpenderAddress) ? { approvedSpenderAddress: order.approvedSpenderAddress } : {}
      }
    })
  });
  const { resp: { orderId, token } } = await res.json();
  return {
    token,
    orderId
  };
};
const fetchSardineOrderStatus = async (orderId, isDev, projectAccessKey2) => {
  const accessKey = isDev ? "17xhjK4yjRf1fr0am8kgKfICAAAAAAAAA" : projectAccessKey2;
  const url = isDev ? "https://dev-api.sequence.app/rpc/API/GetSardineNFTCheckoutOrderStatus" : "https://api.sequence.app/rpc/API/GetSardineNFTCheckoutOrderStatus";
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Access-Key": `${accessKey}`
    },
    body: JSON.stringify({
      orderId
    })
  });
  const json = await response.json();
  console.log("json:", json);
  return json;
};
const useAddFundsModal = () => {
  const { triggerAddFunds, closeAddFunds, addFundsSettings } = useAddFundsModalContext();
  return { triggerAddFunds, closeAddFunds, addFundsSettings };
};
const useCheckoutModal = () => {
  const { triggerCheckout, closeCheckout, settings } = useCheckoutModalContext();
  return { triggerCheckout, closeCheckout, settings };
};
const compareAddress$1 = (a2, b2) => {
  return a2.toLowerCase() === b2.toLowerCase();
};
var ValueType$1;
(function(ValueType2) {
  ValueType2[ValueType2["VERY_LARGE"] = 0] = "VERY_LARGE";
  ValueType2[ValueType2["FRACTION"] = 1] = "FRACTION";
  ValueType2[ValueType2["VERY_TINY"] = 2] = "VERY_TINY";
  ValueType2[ValueType2["MIXED"] = 3] = "MIXED";
})(ValueType$1 || (ValueType$1 = {}));
const formatDisplay$1 = (_val2) => {
  if (isNaN(Number(_val2))) {
    console.error(`display format error ${_val2} is not a number`);
    return "NaN";
  }
  const val = Number(_val2);
  if (val === 0) {
    return "0";
  }
  let valMode;
  if (val > 1e8) {
    valMode = ValueType$1.VERY_LARGE;
  } else if (val < 1e-10) {
    valMode = ValueType$1.VERY_TINY;
  } else if (val < 1) {
    valMode = ValueType$1.FRACTION;
  } else {
    valMode = ValueType$1.MIXED;
  }
  let notation = void 0;
  let config2;
  switch (valMode) {
    case ValueType$1.VERY_LARGE:
      notation = "compact";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType$1.VERY_TINY:
      notation = "scientific";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType$1.FRACTION:
      notation = "standard";
      config2 = {
        maximumSignificantDigits: 4
      };
      break;
    default:
      notation = "standard";
      config2 = {
        maximumFractionDigits: 2
      };
  }
  return Intl.NumberFormat("en-US", {
    notation,
    ...config2
  }).format(val);
};
const useSardineClientToken = (args, disabled) => {
  return useQuery$1({
    queryKey: ["useSardineClientToken", args],
    queryFn: async () => {
      const res = await fetchSardineClientToken(args);
      return res;
    },
    retry: false,
    staleTime: 0,
    enabled: !disabled,
    refetchOnWindowFocus: false
  });
};
const useSelectPaymentModal = () => {
  const { openSelectPaymentModal, closeSelectPaymentModal, selectPaymentSettings } = useSelectPaymentContext();
  return { openSelectPaymentModal, closeSelectPaymentModal, selectPaymentSettings };
};
const getERC1155SaleContractConfig = ({ chain, price, currencyAddress = ZeroAddress, recipientAddress, collectibles, collectionAddress, isDev = false, ...restProps }) => {
  const erc1155SalesContractAbi = [
    {
      type: "function",
      name: "mint",
      inputs: [
        { name: "to", type: "address", internalType: "address" },
        { name: "tokenIds", type: "uint256[]", internalType: "uint256[]" },
        { name: "amounts", type: "uint256[]", internalType: "uint256[]" },
        { name: "data", type: "bytes", internalType: "bytes" },
        { name: "expectedPaymentToken", type: "address", internalType: "address" },
        { name: "maxTotal", type: "uint256", internalType: "uint256" },
        { name: "proof", type: "bytes32[]", internalType: "bytes32[]" }
      ],
      outputs: [],
      stateMutability: "payable"
    }
  ];
  const purchaseTransactionData = encodeFunctionData({
    abi: erc1155SalesContractAbi,
    functionName: "mint",
    args: [recipientAddress, collectibles.map((c2) => BigInt(c2.tokenId)), collectibles.map((c2) => BigInt(c2.quantity)), toHex$1(0), currencyAddress, price, [toHex$1(0, { size: 32 })]]
  });
  return {
    chain,
    price,
    currencyAddress,
    recipientAddress,
    collectibles,
    collectionAddress,
    isDev,
    txData: purchaseTransactionData,
    ...restProps
  };
};
const useERC1155SaleContractPaymentModal = () => {
  const { openSelectPaymentModal, closeSelectPaymentModal, selectPaymentSettings } = useSelectPaymentModal();
  const openERC1155SaleContractPaymentModal = (saleContractSettings) => {
    openSelectPaymentModal(getERC1155SaleContractConfig(saleContractSettings));
  };
  return {
    openERC1155SaleContractPaymentModal,
    closeERC1155SaleContractPaymentModal: closeSelectPaymentModal,
    selectPaymentSettings
  };
};
const useClearCachedBalances = () => {
  const queryClient = useQueryClient();
  return {
    clearCachedBalances: () => {
      queryClient.invalidateQueries({
        queryKey: ["balances"]
      });
    }
  };
};
const useTransferFundsModal = () => {
  const { openTransferFundsModal, closeTransferFundsModal, transferFundsSettings } = useTransferFundsModalContext();
  return { openTransferFundsModal, closeTransferFundsModal, transferFundsSettings };
};
const POLLING_TIME = 10 * 1e3;
const PendingTransaction = () => {
  var _a2;
  const nav = useNavigation$1();
  const { settings } = useCheckoutModal();
  const { params: { creditCardCheckout } } = nav.navigation;
  const { setNavigation } = nav;
  const projectAccessKey2 = useProjectAccessKey();
  const { data: tokensMetadata, isLoading: isLoadingTokenMetadata } = useTokenMetadata(creditCardCheckout.chainId, creditCardCheckout.nftAddress, [creditCardCheckout.nftId]);
  const tokenMetadata = tokensMetadata ? tokensMetadata[0] : void 0;
  const isDev = ((_a2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a2.isDev) || false;
  const disableSardineClientTokenFetch = isLoadingTokenMetadata;
  const { data, isLoading, isError: isError2 } = useSardineClientToken({
    order: creditCardCheckout,
    isDev,
    projectAccessKey: projectAccessKey2,
    tokenMetadata
  }, disableSardineClientTokenFetch);
  const authToken = data == null ? void 0 : data.token;
  const url = isDev ? `https://sardine-checkout-sandbox.sequence.info?api_url=https://sardine-api-sandbox.sequence.info&client_token=${authToken}&show_features=true` : `https://sardine-checkout.sequence.info?api_url=https://sardine-api.sequence.info&client_token=${authToken}&show_features=true`;
  const pollForOrderStatus = async () => {
    var _a3;
    try {
      if (!data) {
        return;
      }
      const { orderId } = data;
      console.log("Polling for transaction status");
      const isDev2 = (creditCardCheckout == null ? void 0 : creditCardCheckout.isDev) || false;
      const pollResponse = await fetchSardineOrderStatus(orderId, isDev2, projectAccessKey2);
      const status = pollResponse.resp.status;
      const transactionHash = (_a3 = pollResponse.resp) == null ? void 0 : _a3.transactionHash;
      console.log("transaction status poll response:", status);
      if (status === "Draft") {
        return;
      }
      if (status === "Complete") {
        setNavigation && setNavigation({
          location: "transaction-success",
          params: {
            transactionHash
          }
        });
        return;
      }
      if (status === "Declined" || status === "Cancelled") {
        setNavigation && setNavigation({
          location: "transaction-error",
          params: {
            error: new Error("Failed to transfer collectible")
          }
        });
        return;
      }
    } catch (e2) {
      console.error("An error occurred while fetching the transaction status");
      setNavigation && setNavigation({
        location: "transaction-error",
        params: {
          error: e2
        }
      });
    }
  };
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      pollForOrderStatus();
    }, POLLING_TIME);
    return () => {
      clearInterval(interval);
    };
  }, []);
  if (isError2) {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "6", style: {
      height: "650px",
      width: "380px"
    }, children: jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "An error has occurred" }) }) });
  }
  if (isLoading || !authToken) {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "6", style: {
      height: "650px",
      width: "380px"
    }, children: jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Spinner, { size: "lg" }) }) });
  }
  return jsxRuntimeExports$1.jsx(Box, { alignItems: "center", justifyContent: "center", style: { height: "770px" }, children: jsxRuntimeExports$1.jsx("iframe", { src: url, style: {
    maxHeight: "650px",
    height: "100%",
    maxWidth: "380px",
    width: "100%"
  } }) });
};
const TransactionSuccess = () => {
  var _a2, _b2, _c2;
  const { settings } = useCheckoutModal();
  const nav = useNavigation$1();
  const navigation = nav.navigation;
  const chainId = ((_a2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a2.chainId) || ChainId$1.POLYGON;
  const network2 = allNetworks$1.find((n2) => n2.chainId === chainId);
  reactExports.useEffect(() => {
    var _a3, _b3, _c3, _d2;
    ((_a3 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a3.onSuccess) && ((_b3 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _b3.onSuccess(navigation.params.transactionHash, settings == null ? void 0 : settings.creditCardCheckout));
    ((_c3 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _c3.onSuccess) && ((_d2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _d2.onSuccess(navigation.params.transactionHash, settings == null ? void 0 : settings.creditCardCheckout));
  }, []);
  return jsxRuntimeExports$1.jsx(Box, { style: { height: "650px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", position: "absolute", style: { top: "50%", right: "50%", transform: "translate(50%, -50%)" }, children: [jsxRuntimeExports$1.jsx(NotificationSuccessIcon, {}), jsxRuntimeExports$1.jsx(Text, { variant: "xlarge", children: "Success!" }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", textAlign: "center", color: "text80", children: "Purchase was successful, item was sent to your wallet." }), navigation.params.transactionHash && jsxRuntimeExports$1.jsxs(Text, { as: "a", variant: "small", underline: true, marginTop: "6", color: "text100", href: `${(_b2 = network2 == null ? void 0 : network2.blockExplorer) == null ? void 0 : _b2.rootUrl}/tx/${navigation.params.transactionHash}`, target: "_blank", rel: "noreferrer", children: ["View on ", (_c2 = network2 == null ? void 0 : network2.blockExplorer) == null ? void 0 : _c2.name] })] }) });
};
const NotificationSuccessIcon = () => jsxRuntimeExports$1.jsx(Box, { color: "white", background: "positive", alignItems: "center", justifyContent: "center", width: "16", height: "16", borderRadius: "circle", marginBottom: "2", children: jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { size: "xl" }) });
const TransactionError = () => {
  const { closeCheckout, settings } = useCheckoutModal();
  const nav = useNavigation$1();
  const navigation = nav.navigation;
  reactExports.useEffect(() => {
    setTimeout(() => {
      var _a2, _b2;
      closeCheckout();
      ((_a2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a2.onError) && ((_b2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _b2.onError(navigation.params.error, settings == null ? void 0 : settings.creditCardCheckout));
    }, 3e3);
  }, []);
  return jsxRuntimeExports$1.jsx(Box, { style: { height: "650px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", position: "absolute", style: { top: "50%", right: "50%", transform: "translate(50%, -50%)" }, children: [jsxRuntimeExports$1.jsx(NotificationErrorIcon, {}), jsxRuntimeExports$1.jsx(Text, { variant: "xlarge", children: "Error" }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", textAlign: "center", color: "text80", children: "An error occurred while processing the transaction." })] }) });
};
const NotificationErrorIcon = () => jsxRuntimeExports$1.jsx(Box, { color: "white", alignItems: "center", justifyContent: "center", width: "16", height: "16", borderRadius: "circle", marginBottom: "2", background: "negative", children: jsxRuntimeExports$1.jsx(SvgCloseIcon, { size: "xl" }) });
const OrderSummaryItem = ({ contractAddress, tokenId, quantityRaw, chainId }) => {
  const { data: tokenMetadata, isPending: isPendingTokenMetadata } = useTokenMetadata(chainId, contractAddress, [tokenId]);
  const { data: contractInfo, isPending: isPendingContractInfo } = useContractInfo(chainId, contractAddress);
  const isPending = isPendingTokenMetadata || isPendingContractInfo;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(OrderSummarySkeleton, {});
  }
  const { name: name2 = "unknown", image, decimals = 0 } = (tokenMetadata == null ? void 0 : tokenMetadata[0]) ?? {};
  const { logoURI: collectionLogoURI, name: collectionName = "Unknown Collection" } = contractInfo || {};
  const balanceFormatted = formatUnits$1(quantityRaw, decimals);
  return jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", alignItems: "flex-start", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Box, { aspectRatio: "1/1", height: "full", justifyContent: "center", alignItems: "center", style: { width: "80px" }, children: jsxRuntimeExports$1.jsx(Image$1, { src: image, borderRadius: "md", style: { maxWidth: "80px", height: "80px", objectFit: "cover" } }) }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsxs(Box, { gap: "1", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: collectionLogoURI, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { marginLeft: "1", variant: "small", color: "text80", fontWeight: "bold", children: collectionName }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", justifyContent: "center", style: {
    width: "180px"
  }, children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", children: name2 }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", children: `#${tokenId}` })] })] })] }), jsxRuntimeExports$1.jsx(Box, { height: "full", children: jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", fontWeight: "bold", children: `x${formatDisplay$1(balanceFormatted)}` }) })] });
};
const OrderSummarySkeleton = () => {
  return jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", alignItems: "flex-start", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "80px", height: "80px" } }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "100px", height: "14px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "180px", height: "34px" } })] })] }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "14px", height: "14px" } })] });
};
const CheckoutSelection = () => {
  var _a2, _b2, _c2, _d2, _e2;
  const { chains: chains2 } = useConfig();
  const { setNavigation } = useNavigation$1();
  const { closeCheckout, settings } = useCheckoutModal();
  const { address: accountAddress } = useAccount();
  const cryptoCheckoutSettings = settings == null ? void 0 : settings.cryptoCheckout;
  const creditCardCheckoutSettings = settings == null ? void 0 : settings.creditCardCheckout;
  const displayCreditCardCheckout = !!creditCardCheckoutSettings;
  const displayCryptoCheckout = !!cryptoCheckoutSettings;
  const { data: contractInfoData, isLoading: isPendingContractInfo } = useContractInfo((cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.chainId) || 1, ((_a2 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _a2.contractAddress) || "");
  const { data: balancesData, isPending: isPendingBalances } = useBalances({
    chainIds: [(cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.chainId) || 1],
    accountAddress: accountAddress || ""
  });
  const isPending = (isPendingContractInfo || isPendingBalances) && cryptoCheckoutSettings;
  const isNativeToken = compareAddress$1(((_b2 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _b2.contractAddress) || "", ZeroAddress);
  const nativeTokenInfo = getNativeTokenInfoByChainId((cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.chainId) || 1, chains2);
  const coinDecimals = isNativeToken ? nativeTokenInfo.decimals : (contractInfoData == null ? void 0 : contractInfoData.decimals) || 0;
  const coinSymbol = isNativeToken ? nativeTokenInfo.symbol : (contractInfoData == null ? void 0 : contractInfoData.symbol) || "COIN";
  const coinImageUrl = isNativeToken ? nativeTokenInfo.logoURI : (contractInfoData == null ? void 0 : contractInfoData.logoURI) || "";
  const coinBalance = balancesData == null ? void 0 : balancesData.find((balance) => {
    var _a3;
    return compareAddress$1(balance.contractAddress, ((_a3 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _a3.contractAddress) || "");
  });
  const userBalanceRaw = coinBalance ? coinBalance.balance : "0";
  const requestedAmountRaw = ((_c2 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _c2.amountRequiredRaw) || "0";
  const userBalance = formatUnits$1(userBalanceRaw, coinDecimals);
  const requestAmount = formatUnits$1(requestedAmountRaw, coinDecimals);
  const isInsufficientBalance = BigInt(userBalanceRaw) < BigInt(requestedAmountRaw);
  const orderSummaryItems = (settings == null ? void 0 : settings.orderSummaryItems) || [];
  const chainId = ((_d2 = settings == null ? void 0 : settings.cryptoCheckout) == null ? void 0 : _d2.chainId) || ((_e2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _e2.chainId) || 1;
  const triggerSardineTransaction = async () => {
    console.log("trigger sardine transaction");
    if (settings == null ? void 0 : settings.creditCardCheckout) {
      setNavigation({
        location: "transaction-pending",
        params: {
          creditCardCheckout: settings.creditCardCheckout
        }
      });
    }
  };
  const onClickPayWithCard = () => {
    if (settings == null ? void 0 : settings.creditCardCheckout) {
      triggerSardineTransaction();
    } else {
      setNavigation({
        location: "transaction-form"
      });
    }
  };
  const onClickPayWithCrypto = () => {
    var _a3;
    console.log("trigger transaction");
    const transaction2 = (_a3 = settings == null ? void 0 : settings.cryptoCheckout) == null ? void 0 : _a3.triggerTransaction;
    transaction2 && transaction2();
    closeCheckout();
  };
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "5", paddingBottom: "5", style: {
    marginTop: HEADER_HEIGHT$1
  }, flexDirection: "column", gap: "3", children: [orderSummaryItems.length > 0 && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", children: "Order summary" }), jsxRuntimeExports$1.jsx(Tooltip, { vOffset: -2, side: "bottom", message: jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: ["Please note that NFTs are digital assets", jsxRuntimeExports$1.jsx("br", {}), " ,and as such, cannot be delivered physically."] }), children: jsxRuntimeExports$1.jsx(Box, { width: "5", height: "5", children: jsxRuntimeExports$1.jsx(SvgHelpIcon, { color: "text80" }) }) })] }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: orderSummaryItems.map((orderSummaryItem, index2) => {
    return jsxRuntimeExports$1.jsx(OrderSummaryItem, { ...orderSummaryItem, chainId }, index2);
  }) }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", children: jsxRuntimeExports$1.jsx(Divider, { color: "backgroundSecondary", style: {
    margin: "0px"
  } }) })] }), displayCryptoCheckout && jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", children: "Total" }), isPending ? jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "100px", height: "17px" } }) : jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "1", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: coinImageUrl, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", children: `${formatDisplay$1(requestAmount)} ${coinSymbol}` })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "2", children: [displayCreditCardCheckout && jsxRuntimeExports$1.jsx(Button, { style: {
    borderRadius: vars.radii.md,
    height: "56px"
  }, width: "full", borderRadius: "md", leftIcon: SvgPaymentsIcon, variant: "primary", label: "Pay with credit card", rightIcon: SvgChevronRightIcon, onClick: onClickPayWithCard }), displayCryptoCheckout && !isInsufficientBalance && !isPending && jsxRuntimeExports$1.jsx(Button, { style: {
    borderRadius: vars.radii.md,
    height: "56px"
  }, width: "full", leftIcon: () => jsxRuntimeExports$1.jsx(TokenImage, { src: coinImageUrl, size: "sm" }), variant: "primary", label: `Pay with ${coinSymbol}`, rightIcon: SvgChevronRightIcon, onClick: onClickPayWithCrypto }), displayCryptoCheckout && (isInsufficientBalance || isPending) && jsxRuntimeExports$1.jsx(Button, { shape: "square", width: "full", variant: "glass", label: jsxRuntimeExports$1.jsxs(Box, { placeItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: coinImageUrl, size: "sm" }), jsxRuntimeExports$1.jsxs(Text, { children: ["Insufficient $", coinSymbol] })] }), onClick: onClickPayWithCrypto, disabled: true })] }), displayCryptoCheckout && jsxRuntimeExports$1.jsx(Box, { width: "full", justifyContent: "flex-end", children: isPending ? jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "102px", height: "14px" } }) : jsxRuntimeExports$1.jsxs(Text, { variant: "small", fontWeight: "bold", color: "text50", children: ["Balance: ", `${formatDisplay$1(userBalance)} ${coinSymbol}`] }) })] });
};
const TRANSAK_API_KEY = "5911d9ec-46b5-48fa-a755-d59a715ff0cf";
const getTransakLink = (addFundsSettings) => {
  const defaultNetworks = "ethereum,mainnet,arbitrum,optimism,polygon,polygonzkevm,zksync,base,bnb,oasys,astar,avaxcchain";
  const options = {
    apiKey: TRANSAK_API_KEY,
    referrerDomain: window.location.origin,
    walletAddress: addFundsSettings.walletAddress,
    fiatCurrency: addFundsSettings == null ? void 0 : addFundsSettings.fiatCurrency,
    disableWalletAddressForm: "true",
    defaultFiatAmount: (addFundsSettings == null ? void 0 : addFundsSettings.defaultFiatAmount) || "50",
    defaultCryptoCurrency: (addFundsSettings == null ? void 0 : addFundsSettings.defaultCryptoCurrency) || "USDC",
    networks: (addFundsSettings == null ? void 0 : addFundsSettings.networks) || defaultNetworks
  };
  const url = new URL("https://global.transak.com");
  Object.keys(options).forEach((k2) => {
    const option = options[k2];
    if (option) {
      url.searchParams.append(k2, option);
    }
  });
  return url.href;
};
const AddFundsContent = () => {
  const { addFundsSettings } = useAddFundsModal();
  if (!addFundsSettings) {
    return;
  }
  const link = getTransakLink(addFundsSettings);
  return jsxRuntimeExports$1.jsx(Box, { alignItems: "center", width: "full", paddingX: "4", paddingBottom: "4", height: "full", style: {
    height: "600px",
    paddingTop: HEADER_HEIGHT$1
  }, children: jsxRuntimeExports$1.jsx(Box, { as: "iframe", width: "full", height: "full", borderWidth: "none", src: link }) });
};
const Footer$1 = () => {
  const { selectPaymentSettings } = useSelectPaymentModal();
  return jsxRuntimeExports$1.jsxs(Box, { paddingBottom: "6", paddingTop: "5", marginTop: "1", width: "full", justifyContent: "center", alignItems: "center", flexDirection: "column", children: [(selectPaymentSettings == null ? void 0 : selectPaymentSettings.copyrightText) && jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", fontWeight: "bold", children: selectPaymentSettings.copyrightText }), jsxRuntimeExports$1.jsxs(Box, { gap: "4", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Box, { as: "a", href: "https://support.sequence.xyz/en/", rel: "noopener noreferrer", target: "_blank", textDecoration: "none", opacity: { hover: "80" }, cursor: "pointer", children: jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", fontWeight: "bold", children: "Help" }) }), jsxRuntimeExports$1.jsx(Box, { as: "a", href: "https://sequence.xyz/privacy", rel: "noopener noreferrer", target: "_blank", textDecoration: "none", opacity: { hover: "80" }, cursor: "pointer", children: jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", fontWeight: "bold", children: "Privacy Policy" }) }), jsxRuntimeExports$1.jsx(Box, { as: "a", href: "https://sequence.xyz/terms", rel: "noopener noreferrer", target: "_blank", textDecoration: "none", opacity: { hover: "80" }, cursor: "pointer", children: jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", fontWeight: "bold", children: "Terms of Service" }) })] })] });
};
const OrderSummary = () => {
  var _a2;
  const { selectPaymentSettings } = useSelectPaymentModal();
  const chain = selectPaymentSettings.chain;
  const network2 = findSupportedNetwork(chain);
  const chainId = (network2 == null ? void 0 : network2.chainId) || 137;
  const collectionAddress = selectPaymentSettings.collectionAddress;
  const tokenIds = (selectPaymentSettings == null ? void 0 : selectPaymentSettings.collectibles.map((c2) => c2.tokenId)) || [];
  const { data: tokenMetadatas, isLoading: isLoadingTokenMetadatas } = useTokenMetadata(chainId, collectionAddress, tokenIds);
  const { data: dataCollectionInfo, isLoading: isLoadingCollectionInfo } = useContractInfo(chainId, selectPaymentSettings.collectionAddress);
  const { data: dataCurrencyInfo, isLoading: isLoadingCurrencyInfo } = useContractInfo(chainId, selectPaymentSettings.currencyAddress);
  const { data: dataCoinPrices, isLoading: isLoadingCoinPrices } = useCoinPrices([
    {
      chainId,
      contractAddress: selectPaymentSettings.currencyAddress
    }
  ]);
  const isLoading = isLoadingTokenMetadatas || isLoadingCollectionInfo || isLoadingCurrencyInfo || isLoadingCoinPrices;
  if (isLoading) {
    return jsxRuntimeExports$1.jsx(Box, { marginBottom: "2", gap: "3", style: { height: "72px" }, children: jsxRuntimeExports$1.jsx(Spinner, {}) });
  }
  const formattedPrice = formatUnits$2(BigInt(selectPaymentSettings.price), (dataCurrencyInfo == null ? void 0 : dataCurrencyInfo.decimals) || 0);
  const totalQuantity = (selectPaymentSettings == null ? void 0 : selectPaymentSettings.collectibles.reduce((accumulator, collectible) => {
    const quantity = formatUnits$2(BigInt(collectible.quantity), Number(collectible.decimals || 0));
    return accumulator + Number(quantity);
  }, 0)) || 0;
  const fiatExchangeRate = ((_a2 = dataCoinPrices == null ? void 0 : dataCoinPrices[0].price) == null ? void 0 : _a2.value) || 0;
  const priceFiat = (fiatExchangeRate * Number(formattedPrice)).toFixed(2);
  return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "5", children: [jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { variant: "small", fontWeight: "bold", color: "text100", children: `${totalQuantity} ${totalQuantity > 1 ? "items" : "item"}` }) }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "row", gap: "1", children: selectPaymentSettings.collectibles.map((collectible) => {
    const collectibleQuantity = Number(formatUnits$2(BigInt(collectible.quantity), Number(collectible.decimals || 0)));
    const tokenMetadata = tokenMetadatas == null ? void 0 : tokenMetadatas.find((tokenMetadata2) => tokenMetadata2.tokenId === collectible.tokenId);
    return jsxRuntimeExports$1.jsxs(Box, { gap: "3", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Box, { borderRadius: "md", style: {
      height: "36px",
      width: "36px"
    }, children: jsxRuntimeExports$1.jsx(CollectibleTileImage$1, { imageUrl: tokenMetadata == null ? void 0 : tokenMetadata.image }) }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "0.5", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text80", fontWeight: "medium", children: (dataCollectionInfo == null ? void 0 : dataCollectionInfo.name) || null }), jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text100", fontWeight: "bold", children: `${(tokenMetadata == null ? void 0 : tokenMetadata.name) || "Collectible"} ${collectibleQuantity > 1 ? `x${collectibleQuantity}` : null}` })] })] }, collectible.tokenId);
  }) }), jsxRuntimeExports$1.jsxs(Box, { gap: "1", flexDirection: "column", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", alignItems: "center", children: [jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "sm" }), jsxRuntimeExports$1.jsx(Text, { color: "white", variant: "large", fontWeight: "bold", children: `${formattedPrice} ${dataCurrencyInfo == null ? void 0 : dataCurrencyInfo.symbol}` })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", fontWeight: "normal", children: `$${priceFiat} estimated total` }) })] }), jsxRuntimeExports$1.jsx(NetworkBadge$1, { chainId })] });
};
const PayWithCreditCard = ({ settings, disableButtons }) => {
  const { chain, currencyAddress, targetContractAddress, price, txData, collectibles, collectionAddress, isDev = false, onSuccess = () => {
  }, onError = () => {
  }, creditCardProviders = [] } = settings;
  const { address: userAddress } = useAccount();
  useMediaQuery("isMobile");
  const { clearCachedBalances } = useClearCachedBalances();
  const { closeSelectPaymentModal } = useSelectPaymentModal();
  const { triggerCheckout } = useCheckoutModal();
  const network2 = findSupportedNetwork(chain);
  const chainId = (network2 == null ? void 0 : network2.chainId) || 137;
  const { data: currencyInfoData, isLoading: isLoadingContractInfo } = useContractInfo(chainId, currencyAddress);
  const [selectedPaymentProvider, setSelectedPaymentProvider] = reactExports.useState();
  const isLoading = isLoadingContractInfo;
  reactExports.useEffect(() => {
    if (selectedPaymentProvider) {
      payWithSelectedProvider();
    }
  }, [selectedPaymentProvider]);
  const payWithSelectedProvider = () => {
    switch (selectedPaymentProvider) {
      case "sardine":
        onPurchaseSardine();
        return;
      default:
        return;
    }
  };
  const onPurchaseSardine = () => {
    if (!userAddress || !currencyInfoData) {
      return;
    }
    const collectible = collectibles[0];
    const checkoutSettings = {
      creditCardCheckout: {
        onSuccess: (txHash) => {
          clearCachedBalances();
          onSuccess(txHash);
        },
        onError,
        chainId,
        recipientAddress: userAddress,
        contractAddress: targetContractAddress,
        currencyQuantity: price,
        currencySymbol: currencyInfoData.symbol,
        currencyAddress,
        currencyDecimals: String((currencyInfoData == null ? void 0 : currencyInfoData.decimals) || 0),
        nftId: collectible.tokenId,
        nftAddress: collectionAddress,
        nftQuantity: collectible.quantity,
        nftDecimals: collectible.decimals,
        isDev,
        calldata: txData,
        approvedSpenderAddress: targetContractAddress
      }
    };
    closeSelectPaymentModal();
    triggerCheckout(checkoutSettings);
  };
  const Options = () => {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "2", width: "full", children: creditCardProviders.map((creditCardProvider) => {
      switch (creditCardProvider) {
        case "sardine":
          return jsxRuntimeExports$1.jsxs(Card, { justifyContent: "space-between", alignItems: "center", padding: "4", onClick: () => {
            setSelectedPaymentProvider("sardine");
          }, opacity: {
            hover: "80",
            base: "100"
          }, cursor: "pointer", disabled: disableButtons, children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "3", alignItems: "center", children: [jsxRuntimeExports$1.jsx(SvgPaymentsIcon, { color: "white" }), jsxRuntimeExports$1.jsx(Text, { color: "text100", variant: "normal", fontWeight: "bold", children: "Pay with credit or debit card" })] }), jsxRuntimeExports$1.jsx(Box, { style: { transform: "rotate(-45deg)" }, children: jsxRuntimeExports$1.jsx(SvgArrowRightIcon, { color: "white" }) })] }, "sardine");
        default:
          return null;
      }
    }) });
  };
  return jsxRuntimeExports$1.jsx(Box, { width: "full", children: isLoading ? jsxRuntimeExports$1.jsx(Box, { width: "full", paddingTop: "5", justifyContent: "center", alignItems: "center", children: jsxRuntimeExports$1.jsx(Spinner, {}) }) : jsxRuntimeExports$1.jsx(Options, {}) });
};
const SelectedIndicator$1 = (props) => {
  const { selected } = props;
  return jsxRuntimeExports$1.jsx(Box, { borderStyle: "solid", borderColor: selected ? "white" : "text50", background: selected ? "white" : "transparent", position: "relative", alignItems: "center", justifyContent: "center", flexShrink: "0", borderRadius: "circle", width: "7", height: "7", style: {
    borderWidth: "2px"
  }, children: selected && jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { color: "black", size: "md" }) });
};
const CryptoOption = ({ currencyName, chainId, iconUrl, symbol, price, onClick, isSelected, isInsufficientFunds, disabled }) => {
  const onClickCard = () => {
    if (!isInsufficientFunds && !disabled) {
      onClick();
    }
  };
  return jsxRuntimeExports$1.jsxs(Card, { width: "full", justifyContent: "space-between", padding: "4", onClick: onClickCard, opacity: {
    hover: disabled || isInsufficientFunds ? "50" : "80",
    base: disabled || isInsufficientFunds ? "50" : "100"
  }, cursor: "pointer", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "3", children: [jsxRuntimeExports$1.jsx(Box, { width: "fit", children: jsxRuntimeExports$1.jsx(TokenImage, { src: iconUrl, size: "lg", symbol, withNetwork: chainId, disableAnimation: true }) }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", whiteSpace: "nowrap", ellipsis: true, style: {
    overflow: "hidden",
    width: "100px"
  }, children: currencyName }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", whiteSpace: "nowrap", ellipsis: true, style: {
    overflow: "hidden",
    width: "100px"
  }, children: `${price} ${symbol}` })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "3", children: [jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", justifyContent: "space-between", alignItems: "flex-end", children: isInsufficientFunds ? jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "negative", children: "Insufficient funds" }) : null }), jsxRuntimeExports$1.jsx(SelectedIndicator$1, { selected: isSelected })] })] });
};
const PayWithCrypto = ({ settings, disableButtons, selectedCurrency, setSelectedCurrency, isLoading }) => {
  const { enableSwapPayments = true, enableMainCurrencyPayment = true } = settings;
  const { chain, currencyAddress, price } = settings;
  const { address: userAddress } = useAccount();
  const { clearCachedBalances } = useClearCachedBalances();
  const network2 = findSupportedNetwork(chain);
  const chainId = (network2 == null ? void 0 : network2.chainId) || 137;
  const { data: currencyBalanceData, isLoading: currencyBalanceIsLoading } = useBalances({
    chainIds: [chainId],
    contractAddress: currencyAddress,
    accountAddress: userAddress || "",
    // includeMetadata must be false to work around a bug
    includeMetadata: false
  });
  const { data: currencyInfoData, isLoading: isLoadingCurrencyInfo } = useContractInfo(chainId, currencyAddress);
  const buyCurrencyAddress = compareAddress$2(settings == null ? void 0 : settings.currencyAddress, zeroAddress) ? NATIVE_TOKEN_ADDRESS_0X : settings == null ? void 0 : settings.currencyAddress;
  const { data: swapPrices = [], isLoading: swapPricesIsLoading } = useSwapPrices({
    userAddress: userAddress ?? "",
    buyCurrencyAddress,
    chainId,
    buyAmount: price,
    withContractInfo: true
  }, { disabled: !enableSwapPayments });
  const isLoadingOptions = currencyBalanceIsLoading || isLoadingCurrencyInfo || isLoading;
  const swapsIsLoading = swapPricesIsLoading;
  const coins = [
    {
      index: 0,
      name: (currencyInfoData == null ? void 0 : currencyInfoData.name) || "Unknown",
      symbol: (currencyInfoData == null ? void 0 : currencyInfoData.symbol) || "",
      currencyAddress
    },
    ...swapPrices.map((price2, index2) => {
      var _a2, _b2, _c2;
      return {
        index: index2 + 1,
        name: ((_a2 = price2.info) == null ? void 0 : _a2.name) || "Unknown",
        symbol: ((_b2 = price2.info) == null ? void 0 : _b2.symbol) || "",
        currencyAddress: ((_c2 = price2.info) == null ? void 0 : _c2.address) || ""
      };
    })
  ];
  const priceFormatted = formatUnits$2(BigInt(price), (currencyInfoData == null ? void 0 : currencyInfoData.decimals) || 0);
  const balanceInfo = currencyBalanceData == null ? void 0 : currencyBalanceData.find((balanceData) => compareAddress$2(currencyAddress, balanceData.contractAddress));
  const balance = BigInt((balanceInfo == null ? void 0 : balanceInfo.balance) || "0");
  Number(formatUnits$2(balance, (currencyInfoData == null ? void 0 : currencyInfoData.decimals) || 0));
  const isNotEnoughFunds = BigInt(price) > balance;
  reactExports.useEffect(() => {
    clearCachedBalances();
  }, []);
  const Options = () => {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "2", width: "full", children: coins.map((coin) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      if (compareAddress$2(coin.currencyAddress, currencyAddress) && enableMainCurrencyPayment) {
        return jsxRuntimeExports$1.jsxs(reactExports.Fragment, { children: [jsxRuntimeExports$1.jsx(CryptoOption, { currencyName: (currencyInfoData == null ? void 0 : currencyInfoData.name) || "Unknown", chainId, iconUrl: currencyInfoData == null ? void 0 : currencyInfoData.logoURI, symbol: (currencyInfoData == null ? void 0 : currencyInfoData.symbol) || "", onClick: () => {
          setSelectedCurrency(currencyAddress);
        }, price: priceFormatted, disabled: disableButtons, isSelected: compareAddress$2(selectedCurrency || "", currencyAddress), isInsufficientFunds: isNotEnoughFunds }), swapsIsLoading && jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", alignItems: "center", width: "full", marginTop: "4", children: jsxRuntimeExports$1.jsx(Spinner, {}) })] }, currencyAddress);
      } else {
        const swapPrice = swapPrices == null ? void 0 : swapPrices.find((price2) => {
          var _a3;
          return compareAddress$2(((_a3 = price2.info) == null ? void 0 : _a3.address) || "", coin.currencyAddress);
        });
        const currencyInfoNotFound = !swapPrice || !swapPrice.info || ((_a2 = swapPrice == null ? void 0 : swapPrice.info) == null ? void 0 : _a2.decimals) === void 0 || !((_b2 = swapPrice.balance) == null ? void 0 : _b2.balance);
        if (currencyInfoNotFound || !enableSwapPayments) {
          return null;
        }
        const swapQuotePriceFormatted = formatUnits$2(BigInt(swapPrice.price.price), ((_c2 = swapPrice.info) == null ? void 0 : _c2.decimals) || 18);
        const swapQuoteAddress = ((_d2 = swapPrice.info) == null ? void 0 : _d2.address) || "";
        return jsxRuntimeExports$1.jsx(CryptoOption, { currencyName: ((_e2 = swapPrice.info) == null ? void 0 : _e2.name) || "Unknown", chainId, iconUrl: (_f2 = swapPrice.info) == null ? void 0 : _f2.logoURI, symbol: ((_g2 = swapPrice.info) == null ? void 0 : _g2.symbol) || "", onClick: () => {
          setSelectedCurrency(swapQuoteAddress);
        }, price: String(Number(swapQuotePriceFormatted).toPrecision(4)), disabled: disableButtons, isSelected: compareAddress$2(selectedCurrency || "", swapQuoteAddress), isInsufficientFunds: false }, swapQuoteAddress);
      }
    }) });
  };
  const gutterHeight = 8;
  const optionHeight = 72;
  const displayedOptionsAmount = Math.min(coins.length, 3);
  const displayedGuttersAmount = displayedOptionsAmount - 1;
  const viewheight = swapsIsLoading ? "174px" : `${24 + optionHeight * displayedOptionsAmount + gutterHeight * displayedGuttersAmount}px`;
  return jsxRuntimeExports$1.jsxs(Box, { width: "full", children: [jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { variant: "small", fontWeight: "medium", color: "white", children: "Pay with crypto" }) }), jsxRuntimeExports$1.jsx(Scroll, { paddingY: "3", style: {
    height: viewheight,
    marginBottom: "-12px",
    scrollbarColor: "gray black",
    scrollbarWidth: "thin"
  }, children: isLoadingOptions ? jsxRuntimeExports$1.jsx(Box, { width: "full", paddingTop: "5", justifyContent: "center", alignItems: "center", children: jsxRuntimeExports$1.jsx(Spinner, {}) }) : jsxRuntimeExports$1.jsx(Options, {}) })] });
};
var Component = {};
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range2) {
        selection.addRange(range2);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$1(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text2, options) {
  var debug2, message, reselectPrevious, range2, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug2 = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range2 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text2;
    mark.ariaHidden = "true";
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug2 && console.warn("unable to use e.clipboardData");
          debug2 && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text2);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text2);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range2.selectNodeContents(mark);
    selection.addRange(range2);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug2 && console.error("unable to copy using execCommand: ", err);
    debug2 && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text2);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug2 && console.error("unable to copy using clipboardData: ", err2);
      debug2 && console.error("falling back to prompt");
      message = format$1("message" in options ? options.message : defaultMessage);
      window.prompt(message, text2);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range2);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy;
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
Object.defineProperty(Component, "__esModule", {
  value: true
});
Component.CopyToClipboard = void 0;
var _react = _interopRequireDefault(reactExports);
var _copyToClipboard = _interopRequireDefault(copyToClipboard);
var _excluded = ["text", "onCopy", "options", "children"];
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var CopyToClipboard$1 = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(CopyToClipboard2, _React$PureComponent);
  var _super = _createSuper(CopyToClipboard2);
  function CopyToClipboard2() {
    var _this;
    _classCallCheck(this, CopyToClipboard2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
      var _this$props = _this.props, text2 = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
      var elem = _react["default"].Children.only(children);
      var result = (0, _copyToClipboard["default"])(text2, options);
      if (onCopy) {
        onCopy(text2, result);
      }
      if (elem && elem.props && typeof elem.props.onClick === "function") {
        elem.props.onClick(event);
      }
    });
    return _this;
  }
  _createClass(CopyToClipboard2, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props;
      _this$props2.text;
      _this$props2.onCopy;
      _this$props2.options;
      var children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
      var elem = _react["default"].Children.only(children);
      return /* @__PURE__ */ _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
        onClick: this.onClick
      }));
    }
  }]);
  return CopyToClipboard2;
}(_react["default"].PureComponent);
Component.CopyToClipboard = CopyToClipboard$1;
_defineProperty(CopyToClipboard$1, "defaultProps", {
  onCopy: void 0,
  options: void 0
});
var _require = Component, CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib = CopyToClipboard;
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */
var qrcodegen;
((qrcodegen2) => {
  const _QrCode = class _QrCode2 {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(version2, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version2;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version2 < _QrCode2.MIN_VERSION || version2 > _QrCode2.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7)
        throw new RangeError("Mask value out of range");
      this.size = version2 * 4 + 17;
      let row = [];
      for (let i = 0; i < this.size; i++)
        row.push(false);
      for (let i = 0; i < this.size; i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i = 0; i < 8; i++) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i);
        }
      }
      assert2(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(text2, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text2);
      return _QrCode2.encodeSegments(segs, ecl);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return _QrCode2.encodeSegments([seg], ecl);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask2 = -1, boostEcl = true) {
      if (!(_QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode2.MAX_VERSION) || mask2 < -1 || mask2 > 7)
        throw new RangeError("Invalid value");
      let version2;
      let dataUsedBits;
      for (version2 = minVersion; ; version2++) {
        const dataCapacityBits2 = _QrCode2.getNumDataCodewords(version2, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version2);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version2 >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [_QrCode2.Ecc.MEDIUM, _QrCode2.Ecc.QUARTILE, _QrCode2.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= _QrCode2.getNumDataCodewords(version2, newEcl) * 8)
          ecl = newEcl;
      }
      let bb2 = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb2);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb2);
        for (const b2 of seg.getData())
          bb2.push(b2);
      }
      assert2(bb2.length == dataUsedBits);
      const dataCapacityBits = _QrCode2.getNumDataCodewords(version2, ecl) * 8;
      assert2(bb2.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb2.length), bb2);
      appendBits(0, (8 - bb2.length % 8) % 8, bb2);
      assert2(bb2.length % 8 == 0);
      for (let padByte = 236; bb2.length < dataCapacityBits; padByte ^= 236 ^ 17)
        appendBits(padByte, 8, bb2);
      let dataCodewords = [];
      while (dataCodewords.length * 8 < bb2.length)
        dataCodewords.push(0);
      bb2.forEach((b2, i) => dataCodewords[i >>> 3] |= b2 << 7 - (i & 7));
      return new _QrCode2(version2, ecl, dataCodewords, mask2);
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(x2, y2) {
      return 0 <= x2 && x2 < this.size && 0 <= y2 && y2 < this.size && this.modules[y2][x2];
    }
    // Modified to expose modules for easy access
    getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; i++) {
        for (let j2 = 0; j2 < numAlign; j2++) {
          if (!(i == 0 && j2 == 0 || i == 0 && j2 == numAlign - 1 || i == numAlign - 1 && j2 == 0))
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j2]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(mask2) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask2;
      let rem = data;
      for (let i = 0; i < 10; i++)
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert2(bits >>> 15 == 0);
      for (let i = 0; i <= 5; i++)
        this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; i++)
        this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; i++)
        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; i++)
        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7)
        return;
      let rem = this.version;
      for (let i = 0; i < 12; i++)
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert2(bits >>> 18 == 0);
      for (let i = 0; i < 18; i++) {
        const color2 = getBit(bits, i);
        const a2 = this.size - 11 + i % 3;
        const b2 = Math.floor(i / 3);
        this.setFunctionModule(a2, b2, color2);
        this.setFunctionModule(b2, a2, color2);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(x2, y2) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist2 = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x2 + dx;
          const yy = y2 + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
            this.setFunctionModule(xx, yy, dist2 != 2 && dist2 != 4);
        }
      }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(x2, y2) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x2 + dx, y2 + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(x2, y2, isDark) {
      this.modules[y2][x2] = isDark;
      this.isFunction[y2][x2] = true;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != _QrCode2.getNumDataCodewords(ver, ecl))
        throw new RangeError("Invalid argument");
      const numBlocks = _QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = _QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(_QrCode2.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      let blocks = [];
      const rsDiv = _QrCode2.reedSolomonComputeDivisor(blockEccLen);
      for (let i = 0, k2 = 0; i < numBlocks; i++) {
        let dat = data.slice(k2, k2 + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k2 += dat.length;
        const ecc = _QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks)
          dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      let result = [];
      for (let i = 0; i < blocks[0].length; i++) {
        blocks.forEach((block, j2) => {
          if (i != shortBlockLen - blockEccLen || j2 >= numShortBlocks)
            result.push(block[i]);
        });
      }
      assert2(result.length == rawCodewords);
      return result;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(data) {
      if (data.length != Math.floor(_QrCode2.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let i = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6)
          right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j2 = 0; j2 < 2; j2++) {
            const x2 = right - j2;
            const upward = (right + 1 & 2) == 0;
            const y2 = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y2][x2] && i < data.length * 8) {
              this.modules[y2][x2] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert2(i == data.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(mask2) {
      if (mask2 < 0 || mask2 > 7)
        throw new RangeError("Mask value out of range");
      for (let y2 = 0; y2 < this.size; y2++) {
        for (let x2 = 0; x2 < this.size; x2++) {
          let invert2;
          switch (mask2) {
            case 0:
              invert2 = (x2 + y2) % 2 == 0;
              break;
            case 1:
              invert2 = y2 % 2 == 0;
              break;
            case 2:
              invert2 = x2 % 3 == 0;
              break;
            case 3:
              invert2 = (x2 + y2) % 3 == 0;
              break;
            case 4:
              invert2 = (Math.floor(x2 / 3) + Math.floor(y2 / 2)) % 2 == 0;
              break;
            case 5:
              invert2 = x2 * y2 % 2 + x2 * y2 % 3 == 0;
              break;
            case 6:
              invert2 = (x2 * y2 % 2 + x2 * y2 % 3) % 2 == 0;
              break;
            case 7:
              invert2 = ((x2 + y2) % 2 + x2 * y2 % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y2][x2] && invert2)
            this.modules[y2][x2] = !this.modules[y2][x2];
        }
      }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let result = 0;
      for (let y2 = 0; y2 < this.size; y2++) {
        let runColor = false;
        let runX = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x2 = 0; x2 < this.size; x2++) {
          if (this.modules[y2][x2] == runColor) {
            runX++;
            if (runX == 5)
              result += _QrCode2.PENALTY_N1;
            else if (runX > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode2.PENALTY_N3;
            runColor = this.modules[y2][x2];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode2.PENALTY_N3;
      }
      for (let x2 = 0; x2 < this.size; x2++) {
        let runColor = false;
        let runY = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y2 = 0; y2 < this.size; y2++) {
          if (this.modules[y2][x2] == runColor) {
            runY++;
            if (runY == 5)
              result += _QrCode2.PENALTY_N1;
            else if (runY > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode2.PENALTY_N3;
            runColor = this.modules[y2][x2];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode2.PENALTY_N3;
      }
      for (let y2 = 0; y2 < this.size - 1; y2++) {
        for (let x2 = 0; x2 < this.size - 1; x2++) {
          const color2 = this.modules[y2][x2];
          if (color2 == this.modules[y2][x2 + 1] && color2 == this.modules[y2 + 1][x2] && color2 == this.modules[y2 + 1][x2 + 1])
            result += _QrCode2.PENALTY_N2;
        }
      }
      let dark2 = 0;
      for (const row of this.modules)
        dark2 = row.reduce((sum, color2) => sum + (color2 ? 1 : 0), dark2);
      const total = this.size * this.size;
      const k2 = Math.ceil(Math.abs(dark2 * 20 - total * 10) / total) - 1;
      assert2(0 <= k2 && k2 <= 9);
      result += k2 * _QrCode2.PENALTY_N4;
      assert2(0 <= result && result <= 2568888);
      return result;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        let result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step)
          result.splice(1, 0, pos);
        return result;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(ver) {
      if (ver < _QrCode2.MIN_VERSION || ver > _QrCode2.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7)
          result -= 36;
      }
      assert2(208 <= result && result <= 29648);
      return result;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(_QrCode2.getNumRawDataModules(ver) / 8) - _QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255)
        throw new RangeError("Degree out of range");
      let result = [];
      for (let i = 0; i < degree - 1; i++)
        result.push(0);
      result.push(1);
      let root2 = 1;
      for (let i = 0; i < degree; i++) {
        for (let j2 = 0; j2 < result.length; j2++) {
          result[j2] = _QrCode2.reedSolomonMultiply(result[j2], root2);
          if (j2 + 1 < result.length)
            result[j2] ^= result[j2 + 1];
        }
        root2 = _QrCode2.reedSolomonMultiply(root2, 2);
      }
      return result;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(data, divisor) {
      let result = divisor.map((_) => 0);
      for (const b2 of data) {
        const factor = b2 ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i) => result[i] ^= _QrCode2.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(x2, y2) {
      if (x2 >>> 8 != 0 || y2 >>> 8 != 0)
        throw new RangeError("Byte out of range");
      let z2 = 0;
      for (let i = 7; i >= 0; i--) {
        z2 = z2 << 1 ^ (z2 >>> 7) * 285;
        z2 ^= (y2 >>> i & 1) * x2;
      }
      assert2(z2 >>> 8 == 0);
      return z2;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(runHistory) {
      const n2 = runHistory[1];
      assert2(n2 <= this.size * 3);
      const core2 = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
      return (core2 && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core2 && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0)
        currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  };
  _QrCode.MIN_VERSION = 1;
  _QrCode.MAX_VERSION = 40;
  _QrCode.PENALTY_N1 = 3;
  _QrCode.PENALTY_N2 = 3;
  _QrCode.PENALTY_N3 = 40;
  _QrCode.PENALTY_N4 = 10;
  _QrCode.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    // Low
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    // Medium
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    // Quartile
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
    // High
  ];
  _QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    // Low
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    // Medium
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    // Quartile
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
    // High
  ];
  qrcodegen2.QrCode = _QrCode;
  function appendBits(val, len, bb2) {
    if (len < 0 || len > 31 || val >>> len != 0)
      throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--)
      bb2.push(val >>> i & 1);
  }
  function getBit(x2, i) {
    return (x2 >>> i & 1) != 0;
  }
  function assert2(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  const _QrSegment = class _QrSegment2 {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0)
        throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(data) {
      let bb2 = [];
      for (const b2 of data)
        appendBits(b2, 8, bb2);
      return new _QrSegment2(_QrSegment2.Mode.BYTE, data.length, bb2);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(digits) {
      if (!_QrSegment2.isNumeric(digits))
        throw new RangeError("String contains non-numeric characters");
      let bb2 = [];
      for (let i = 0; i < digits.length; ) {
        const n2 = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substring(i, i + n2), 10), n2 * 3 + 1, bb2);
        i += n2;
      }
      return new _QrSegment2(_QrSegment2.Mode.NUMERIC, digits.length, bb2);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(text2) {
      if (!_QrSegment2.isAlphanumeric(text2))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let bb2 = [];
      let i;
      for (i = 0; i + 2 <= text2.length; i += 2) {
        let temp = _QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)) * 45;
        temp += _QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i + 1));
        appendBits(temp, 11, bb2);
      }
      if (i < text2.length)
        appendBits(_QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)), 6, bb2);
      return new _QrSegment2(_QrSegment2.Mode.ALPHANUMERIC, text2.length, bb2);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(text2) {
      if (text2 == "")
        return [];
      else if (_QrSegment2.isNumeric(text2))
        return [_QrSegment2.makeNumeric(text2)];
      else if (_QrSegment2.isAlphanumeric(text2))
        return [_QrSegment2.makeAlphanumeric(text2)];
      else
        return [_QrSegment2.makeBytes(_QrSegment2.toUtf8ByteArray(text2))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(assignVal) {
      let bb2 = [];
      if (assignVal < 0)
        throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7)
        appendBits(assignVal, 8, bb2);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb2);
        appendBits(assignVal, 14, bb2);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb2);
        appendBits(assignVal, 21, bb2);
      } else
        throw new RangeError("ECI assignment value out of range");
      return new _QrSegment2(_QrSegment2.Mode.ECI, 0, bb2);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(text2) {
      return _QrSegment2.NUMERIC_REGEX.test(text2);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(text2) {
      return _QrSegment2.ALPHANUMERIC_REGEX.test(text2);
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(segs, version2) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version2);
        if (seg.numChars >= 1 << ccbits)
          return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      let result = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%")
          result.push(str.charCodeAt(i));
        else {
          result.push(parseInt(str.substring(i + 1, i + 3), 16));
          i += 2;
        }
      }
      return result;
    }
  };
  _QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  _QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  _QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  let QrSegment = _QrSegment;
  qrcodegen2.QrSegment = _QrSegment;
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrCode2) => {
    const _Ecc = class _Ecc {
      // The QR Code can tolerate about 30% erroneous codewords
      /*-- Constructor and fields --*/
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    };
    _Ecc.LOW = new _Ecc(0, 1);
    _Ecc.MEDIUM = new _Ecc(1, 0);
    _Ecc.QUARTILE = new _Ecc(2, 3);
    _Ecc.HIGH = new _Ecc(3, 2);
    QrCode2.Ecc = _Ecc;
  })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrSegment2) => {
    const _Mode = class _Mode {
      /*-- Constructor and fields --*/
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    };
    _Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
    _Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
    _Mode.BYTE = new _Mode(4, [8, 16, 16]);
    _Mode.KANJI = new _Mode(8, [8, 10, 12]);
    _Mode.ECI = new _Mode(7, [0, 0, 0]);
    QrSegment2.Mode = _Mode;
  })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
  const ops = [];
  modules.forEach(function(row, y2) {
    let start = null;
    row.forEach(function(cell, x2) {
      if (!cell && start !== null) {
        ops.push(
          `M${start + margin} ${y2 + margin}h${x2 - start}v1H${start + margin}z`
        );
        start = null;
        return;
      }
      if (x2 === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x2 + margin},${y2 + margin} h1v1H${x2 + margin}z`);
        } else {
          ops.push(
            `M${start + margin},${y2 + margin} h${x2 + 1 - start}v1H${start + margin}z`
          );
        }
        return;
      }
      if (cell && start === null) {
        start = x2;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y2) => {
    if (y2 < excavation.y || y2 >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x2) => {
      if (x2 < excavation.x || x2 >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size2, margin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size2 * DEFAULT_IMG_SCALE);
  const scale2 = numCells / size2;
  const w2 = (imageSettings.width || defaultSize) * scale2;
  const h2 = (imageSettings.height || defaultSize) * scale2;
  const x2 = imageSettings.x == null ? cells.length / 2 - w2 / 2 : imageSettings.x * scale2;
  const y2 = imageSettings.y == null ? cells.length / 2 - h2 / 2 : imageSettings.y * scale2;
  const opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
  let excavation = null;
  if (imageSettings.excavate) {
    let floorX = Math.floor(x2);
    let floorY = Math.floor(y2);
    let ceilW = Math.ceil(w2 + x2 - floorX);
    let ceilH = Math.ceil(h2 + y2 - floorY);
    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };
  }
  const crossOrigin = imageSettings.crossOrigin;
  return { x: x2, y: y2, h: h2, w: w2, excavation, opacity, crossOrigin };
}
function getMarginSize(includeMargin, marginSize) {
  if (marginSize != null) {
    return Math.max(Math.floor(marginSize), 0);
  }
  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
}
function useQRCode({
  value,
  level,
  minVersion,
  includeMargin,
  marginSize,
  imageSettings,
  size: size2
}) {
  let qrcode = React.useMemo(() => {
    const segments = qrcodegen_default.QrSegment.makeSegments(value);
    return qrcodegen_default.QrCode.encodeSegments(
      segments,
      ERROR_LEVEL_MAP[level],
      minVersion
    );
  }, [value, level, minVersion]);
  const { cells, margin, numCells, calculatedImageSettings } = React.useMemo(() => {
    let cells2 = qrcode.getModules();
    const margin2 = getMarginSize(includeMargin, marginSize);
    const numCells2 = cells2.length + margin2 * 2;
    const calculatedImageSettings2 = getImageSettings(
      cells2,
      size2,
      margin2,
      imageSettings
    );
    return {
      cells: cells2,
      margin: margin2,
      numCells: numCells2,
      calculatedImageSettings: calculatedImageSettings2
    };
  }, [qrcode, size2, imageSettings, includeMargin, marginSize]);
  return {
    qrcode,
    margin,
    cells,
    numCells,
    calculatedImageSettings
  };
}
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e2) {
    return false;
  }
  return true;
}();
var QRCodeCanvas = React.forwardRef(
  function QRCodeCanvas2(props, forwardedRef) {
    const _a2 = props, {
      value,
      size: size2 = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      minVersion = DEFAULT_MINVERSION,
      marginSize,
      imageSettings
    } = _a2, extraProps = __objRest(_a2, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "marginSize",
      "imageSettings"
    ]);
    const _b2 = extraProps, { style } = _b2, otherProps = __objRest(_b2, ["style"]);
    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;
    const _canvas = React.useRef(null);
    const _image = React.useRef(null);
    const setCanvasRef = React.useCallback(
      (node) => {
        _canvas.current = node;
        if (typeof forwardedRef === "function") {
          forwardedRef(node);
        } else if (forwardedRef) {
          forwardedRef.current = node;
        }
      },
      [forwardedRef]
    );
    const [isImgLoaded, setIsImageLoaded] = React.useState(false);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
      value,
      level,
      minVersion,
      includeMargin,
      marginSize,
      imageSettings,
      size: size2
    });
    React.useEffect(() => {
      if (_canvas.current != null) {
        const canvas = _canvas.current;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return;
        }
        let cellsToDraw = cells;
        const image = _image.current;
        const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
        if (haveImageToRender) {
          if (calculatedImageSettings.excavation != null) {
            cellsToDraw = excavateModules(
              cells,
              calculatedImageSettings.excavation
            );
          }
        }
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size2 * pixelRatio;
        const scale2 = size2 / numCells * pixelRatio;
        ctx.scale(scale2, scale2);
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;
        if (SUPPORTS_PATH2D) {
          ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
        } else {
          cells.forEach(function(row, rdx) {
            row.forEach(function(cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }
        if (calculatedImageSettings) {
          ctx.globalAlpha = calculatedImageSettings.opacity;
        }
        if (haveImageToRender) {
          ctx.drawImage(
            image,
            calculatedImageSettings.x + margin,
            calculatedImageSettings.y + margin,
            calculatedImageSettings.w,
            calculatedImageSettings.h
          );
        }
      }
    });
    React.useEffect(() => {
      setIsImageLoaded(false);
    }, [imgSrc]);
    const canvasStyle = __spreadValues({ height: size2, width: size2 }, style);
    let img2 = null;
    if (imgSrc != null) {
      img2 = /* @__PURE__ */ React.createElement(
        "img",
        {
          src: imgSrc,
          key: imgSrc,
          style: { display: "none" },
          onLoad: () => {
            setIsImageLoaded(true);
          },
          ref: _image,
          crossOrigin: calculatedImageSettings == null ? void 0 : calculatedImageSettings.crossOrigin
        }
      );
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "canvas",
      __spreadValues({
        style: canvasStyle,
        height: size2,
        width: size2,
        ref: setCanvasRef,
        role: "img"
      }, otherProps)
    ), img2);
  }
);
QRCodeCanvas.displayName = "QRCodeCanvas";
var QRCodeSVG = React.forwardRef(
  function QRCodeSVG2(props, forwardedRef) {
    const _a2 = props, {
      value,
      size: size2 = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      minVersion = DEFAULT_MINVERSION,
      title,
      marginSize,
      imageSettings
    } = _a2, otherProps = __objRest(_a2, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "title",
      "marginSize",
      "imageSettings"
    ]);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
      value,
      level,
      minVersion,
      includeMargin,
      marginSize,
      imageSettings,
      size: size2
    });
    let cellsToDraw = cells;
    let image = null;
    if (imageSettings != null && calculatedImageSettings != null) {
      if (calculatedImageSettings.excavation != null) {
        cellsToDraw = excavateModules(
          cells,
          calculatedImageSettings.excavation
        );
      }
      image = /* @__PURE__ */ React.createElement(
        "image",
        {
          href: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none",
          opacity: calculatedImageSettings.opacity,
          crossOrigin: calculatedImageSettings.crossOrigin
        }
      );
    }
    const fgPath = generatePath(cellsToDraw, margin);
    return /* @__PURE__ */ React.createElement(
      "svg",
      __spreadValues({
        height: size2,
        width: size2,
        viewBox: `0 0 ${numCells} ${numCells}`,
        ref: forwardedRef,
        role: "img"
      }, otherProps),
      !!title && /* @__PURE__ */ React.createElement("title", null, title),
      /* @__PURE__ */ React.createElement(
        "path",
        {
          fill: bgColor,
          d: `M0,0 h${numCells}v${numCells}H0z`,
          shapeRendering: "crispEdges"
        }
      ),
      /* @__PURE__ */ React.createElement("path", { fill: fgColor, d: fgPath, shapeRendering: "crispEdges" }),
      image
    );
  }
);
QRCodeSVG.displayName = "QRCodeSVG";
const TransferFunds = () => {
  const { address: userAddress } = useAccount();
  const [isCopied, setCopy] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isCopied) {
      setTimeout(() => {
        setCopy(false);
      }, 4e3);
    }
  }, [isCopied]);
  const handleCopy = () => {
    setCopy(true);
  };
  return jsxRuntimeExports$1.jsxs(Box, { width: "full", children: [jsxRuntimeExports$1.jsx(Box, { marginBottom: "3", children: jsxRuntimeExports$1.jsx(Text, { variant: "small", fontWeight: "medium", color: "white", children: "Transfer funds to your connected wallet" }) }), jsxRuntimeExports$1.jsxs(Card, { width: "full", justifyContent: "space-between", padding: "4", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "3", children: [jsxRuntimeExports$1.jsx(Box, { background: "white", padding: "4", borderRadius: "xs", style: { width: 40, height: 40 }, children: jsxRuntimeExports$1.jsx(QRCodeCanvas, { value: userAddress || "", size: 36, bgColor: "white", fgColor: "black", "data-id": "qr-code", style: { position: "relative", top: "-14px", left: "-14px" } }) }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", justifyContent: "center", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text80", children: "Transfer Funds" }) }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", fontSize: "small", children: truncateAddress(userAddress || "", 12, 4) }) })] })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(lib.CopyToClipboard, { text: userAddress || "", onCopy: handleCopy, children: jsxRuntimeExports$1.jsx(IconButton, { color: "text50", variant: "base", size: "md", icon: isCopied ? () => jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { size: "lg" }) : () => jsxRuntimeExports$1.jsx(SvgCopyIcon, { size: "lg" }) }) }) })] })] });
};
const ERC_20_CONTRACT_ABI = [
  {
    type: "function",
    name: "allowance",
    inputs: [
      { name: "owner", type: "address", internalType: "address" },
      { name: "spender", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      { name: "spender", type: "address", internalType: "address" },
      { name: "amount", type: "uint256", internalType: "uint256" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "nonpayable"
  }
];
const PaymentSelection = () => {
  return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(PaymentSelectionHeader, {}), jsxRuntimeExports$1.jsx(PaymentSelectionContent, {})] });
};
const PaymentSelectionHeader = () => {
  return jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Checkout" });
};
const PaymentSelectionContent = () => {
  const { selectPaymentSettings } = useSelectPaymentModal();
  const [disableButtons, setDisableButtons] = reactExports.useState(false);
  const [isError2, setIsError] = reactExports.useState(false);
  if (!selectPaymentSettings) {
    return null;
  }
  const { chain, currencyAddress, targetContractAddress, price, txData, enableTransferFunds = true, enableMainCurrencyPayment = true, enableSwapPayments = true, creditCardProviders = [], transactionConfirmations = TRANSACTION_CONFIRMATIONS_DEFAULT, onSuccess = () => {
  }, onError = () => {
  } } = selectPaymentSettings;
  const isNativeToken = compareAddress$2(currencyAddress, zeroAddress);
  const [selectedCurrency, setSelectedCurrency] = reactExports.useState();
  const network2 = findSupportedNetwork(chain);
  const chainId = (network2 == null ? void 0 : network2.chainId) || 137;
  const { address: userAddress, connector } = useAccount();
  const { data: walletClient } = useWalletClient();
  const publicClient = usePublicClient({
    chainId
  });
  const { clearCachedBalances } = useClearCachedBalances();
  const { closeSelectPaymentModal } = useSelectPaymentModal();
  const { data: allowanceData, isLoading: allowanceIsLoading, refetch: refechAllowance } = useReadContract({
    abi: ERC_20_CONTRACT_ABI,
    functionName: "allowance",
    chainId,
    address: currencyAddress,
    args: [userAddress, targetContractAddress],
    query: {
      enabled: !!userAddress
    }
  });
  const { data: currencyBalanceData, isLoading: currencyBalanceIsLoading } = useBalances({
    chainIds: [chainId],
    contractAddress: currencyAddress,
    accountAddress: userAddress || "",
    // includeMetadata must be false to work around a bug
    includeMetadata: false
  });
  const { data: currencyInfoData, isLoading: isLoadingCurrencyInfo } = useContractInfo(chainId, currencyAddress);
  const buyCurrencyAddress = compareAddress$2(currencyAddress, zeroAddress) ? NATIVE_TOKEN_ADDRESS_0X : currencyAddress;
  const { data: swapPrices = [], isLoading: swapPricesIsLoading } = useSwapPrices({
    userAddress: userAddress ?? "",
    buyCurrencyAddress,
    chainId,
    buyAmount: price,
    withContractInfo: true
  }, { disabled: !enableSwapPayments });
  const disableSwapQuote = !selectedCurrency || compareAddress$2(currencyAddress, selectedCurrency || "");
  const swapQuotesSellCurrency = compareAddress$2(currencyAddress || "", zeroAddress) ? NATIVE_TOKEN_ADDRESS_0X : selectedCurrency || "";
  const { data: swapQuote, isLoading: isLoadingSwapQuote } = useSwapQuote({
    userAddress: userAddress ?? "",
    buyCurrencyAddress: currencyAddress,
    buyAmount: price,
    chainId,
    sellCurrencyAddress: swapQuotesSellCurrency,
    includeApprove: true
  }, {
    disabled: !selectedCurrency
  });
  const isLoading = allowanceIsLoading || currencyBalanceIsLoading || isLoadingCurrencyInfo;
  const isApproved = allowanceData >= BigInt(price) || isNativeToken;
  const balanceInfo = currencyBalanceData == null ? void 0 : currencyBalanceData.find((balanceData) => compareAddress$2(currencyAddress, balanceData.contractAddress));
  const balance = BigInt((balanceInfo == null ? void 0 : balanceInfo.balance) || "0");
  Number(formatUnits$2(balance, (currencyInfoData == null ? void 0 : currencyInfoData.decimals) || 0));
  reactExports.useEffect(() => {
    clearCachedBalances();
  }, []);
  const onPurchaseMainCurrency = async () => {
    if (!walletClient || !userAddress || !publicClient || !userAddress || !connector) {
      return;
    }
    setIsError(false);
    setDisableButtons(true);
    try {
      const walletClientChainId = await walletClient.getChainId();
      if (walletClientChainId !== chainId) {
        await walletClient.switchChain({ id: chainId });
      }
      const approveTxData = encodeFunctionData({
        abi: ERC_20_CONTRACT_ABI,
        functionName: "approve",
        args: [targetContractAddress, price]
      });
      const transactions2 = [
        ...isApproved ? [] : [
          {
            to: currencyAddress,
            data: approveTxData,
            chainId
          }
        ],
        {
          to: targetContractAddress,
          data: txData,
          chainId,
          ...isNativeToken ? {
            value: BigInt(price)
          } : {}
        }
      ];
      const txHash = await sendTransactions({
        chainId,
        senderAddress: userAddress,
        publicClient,
        walletClient,
        connector,
        transactions: transactions2,
        transactionConfirmations
      });
      closeSelectPaymentModal();
      refechAllowance();
      clearCachedBalances();
      onSuccess(txHash);
    } catch (e2) {
      console.error("Failed to purchase...", e2);
      onError(e2);
      setIsError(true);
    }
    setDisableButtons(false);
  };
  const onClickPurchaseSwap = async (swapPrice) => {
    if (!walletClient || !userAddress || !publicClient || !userAddress || !connector || !swapQuote) {
      return;
    }
    setIsError(false);
    setDisableButtons(true);
    try {
      const walletClientChainId = await walletClient.getChainId();
      if (walletClientChainId !== chainId) {
        await walletClient.switchChain({ id: chainId });
      }
      const approveTxData = encodeFunctionData({
        abi: ERC_20_CONTRACT_ABI,
        functionName: "approve",
        args: [targetContractAddress, price]
      });
      const isSwapNativeToken = compareAddress$2(NATIVE_TOKEN_ADDRESS_0X, swapPrice.price.currencyAddress);
      const transactions2 = [
        // Swap quote optional approve step
        ...(swapQuote == null ? void 0 : swapQuote.approveData) && !isSwapNativeToken ? [
          {
            to: swapPrice.price.currencyAddress,
            data: swapQuote.approveData,
            chain: chainId
          }
        ] : [],
        // Swap quote tx
        {
          to: swapQuote.to,
          data: swapQuote.transactionData,
          chain: chainId,
          ...isSwapNativeToken ? {
            value: BigInt(swapQuote.transactionValue)
          } : {}
        },
        // Actual transaction optional approve step
        ...isApproved || isNativeToken ? [] : [
          {
            to: currencyAddress,
            data: approveTxData,
            chainId
          }
        ],
        // transaction on the contract
        {
          to: targetContractAddress,
          data: txData,
          chainId,
          ...isNativeToken ? {
            value: BigInt(price)
          } : {}
        }
      ];
      const txHash = await sendTransactions({
        chainId,
        senderAddress: userAddress,
        publicClient,
        walletClient,
        connector,
        transactions: transactions2,
        transactionConfirmations
      });
      closeSelectPaymentModal();
      refechAllowance();
      clearCachedBalances();
      onSuccess(txHash);
    } catch (e2) {
      console.error("Failed to purchase...", e2);
      onError(e2);
      setIsError(true);
    }
    setDisableButtons(false);
  };
  const onClickPurchase = () => {
    if (compareAddress$2(selectedCurrency || "", currencyAddress)) {
      onPurchaseMainCurrency();
    } else {
      const foundSwap = swapPrices == null ? void 0 : swapPrices.find((price2) => {
        var _a2;
        return ((_a2 = price2.info) == null ? void 0 : _a2.address) === selectedCurrency;
      });
      if (foundSwap) {
        onClickPurchaseSwap(foundSwap);
      }
    }
  };
  return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", alignItems: "flex-start", width: "full", paddingBottom: "0", paddingX: "6", height: "full", style: {
    paddingTop: HEADER_HEIGHT$1
  }, children: [jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", width: "full", gap: "2", children: jsxRuntimeExports$1.jsx(OrderSummary, {}) }), (enableMainCurrencyPayment || enableSwapPayments) && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Divider, { width: "full", marginY: "3" }), jsxRuntimeExports$1.jsx(PayWithCrypto, { settings: selectPaymentSettings, disableButtons, selectedCurrency, setSelectedCurrency, isLoading })] }), (creditCardProviders == null ? void 0 : creditCardProviders.length) > 0 && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Divider, { width: "full", marginY: "3" }), jsxRuntimeExports$1.jsx(PayWithCreditCard, { settings: selectPaymentSettings, disableButtons })] }), enableTransferFunds && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Divider, { width: "full", marginY: "3" }), jsxRuntimeExports$1.jsx(TransferFunds, {})] }), (enableMainCurrencyPayment || enableSwapPayments) && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [isError2 && jsxRuntimeExports$1.jsx(Box, { width: "full", style: { marginBottom: "-18px" }, children: jsxRuntimeExports$1.jsx(Text, { color: "negative", variant: "small", children: "A problem occurred while executing the transaction." }) }), jsxRuntimeExports$1.jsxs(Box, { width: "full", children: [jsxRuntimeExports$1.jsx(Button, { onClick: onClickPurchase, disabled: isLoading || disableButtons || !selectedCurrency || !disableSwapQuote && isLoadingSwapQuote, marginTop: "6", shape: "square", variant: "primary", width: "full", label: "Complete Purchase" }), jsxRuntimeExports$1.jsxs(Box, { width: "full", justifyContent: "center", alignItems: "center", gap: "0.5", marginY: "2", children: [jsxRuntimeExports$1.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "13", height: "12", viewBox: "0 0 13 12", fill: "none", children: jsxRuntimeExports$1.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8.82807 5.24497V3.52873C8.82807 2.24258 7.78549 1.19995 6.49934 1.19995C5.21319 1.19995 4.17057 2.24258 4.17057 3.52873L4.17057 5.24497H3.9832C3.32046 5.24497 2.7832 5.78223 2.7832 6.44497V9.49529C2.7832 10.158 3.32046 10.6953 3.9832 10.6953H9.01546C9.6782 10.6953 10.2155 10.158 10.2155 9.49529V6.44497C10.2155 5.78223 9.6782 5.24497 9.01546 5.24497H8.82807ZM6.49934 2.06705C5.69209 2.06705 5.03769 2.72144 5.03766 3.52867L5.03767 5.24497H7.96097V3.52867C7.96094 2.72144 7.30658 2.06705 6.49934 2.06705Z", fill: "#6D6D6D" }) }), jsxRuntimeExports$1.jsx(Text, { variant: "xsmall", color: "text50", marginTop: "0.5", children: "Secure Checkout" })] })] })] })] }), jsxRuntimeExports$1.jsx(Divider, { marginY: "0" }), jsxRuntimeExports$1.jsx(Footer$1, {})] });
};
const CopyButton$1 = (props) => {
  const { text: text2, size: size2 = "xs", inline = false, ...rest } = props;
  const [isCopied, setCopy] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isCopied) {
      setTimeout(() => {
        setCopy(false);
      }, 4e3);
    }
  }, [isCopied]);
  const handleCopy = () => {
    setCopy(true);
  };
  return jsxRuntimeExports$1.jsx(lib.CopyToClipboard, { text: text2, onCopy: handleCopy, children: inline ? jsxRuntimeExports$1.jsx(Button, { size: size2, variant: "text", leftIcon: isCopied ? SvgCheckmarkIcon : SvgCopyIcon }) : jsxRuntimeExports$1.jsx(Button, { size: size2, leftIcon: isCopied ? SvgCheckmarkIcon : SvgCopyIcon, label: isCopied ? "Copied" : "Copy", ...rest }) });
};
const QRCode = (props) => {
  const { value } = props;
  return jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", flexDirection: "column", gap: "4", children: [value ? jsxRuntimeExports$1.jsx(Box, { background: "white", padding: "4", borderRadius: "sm", style: { width: 232, height: 232 }, children: jsxRuntimeExports$1.jsx(QRCodeCanvas, { value, size: 200, bgColor: "white", fgColor: "black", "data-id": "qr-code" }) }) : jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 232, height: 232 } }), jsxRuntimeExports$1.jsx(CopyButton$1, { text: value || "", disabled: !value })] });
};
const TransferToWallet = () => {
  const { address: userAddress } = useAccount();
  const { transferFundsSettings } = useTransferFundsModal();
  const address = (transferFundsSettings == null ? void 0 : transferFundsSettings.walletAddress) || userAddress || "";
  return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", alignItems: "center", justifyContent: "center", width: "full", paddingX: "4", paddingBottom: "4", height: "full", style: { paddingTop: HEADER_HEIGHT$1 }, children: jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", alignItems: "center", paddingX: "4", paddingBottom: "4", minHeight: "full", children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", placeItems: "center", width: "full", children: [jsxRuntimeExports$1.jsx(Text, { as: "p", variant: "normal", color: "text50", textAlign: "center", children: "Share your wallet address to receive coins" }), jsxRuntimeExports$1.jsx(Box, { marginY: "4", children: jsxRuntimeExports$1.jsx(QRCode, { value: address, "data-id": "receiveQR" }) }), jsxRuntimeExports$1.jsx(Text, { as: "div", width: "full", variant: "normal", color: "text50", textAlign: "center", "data-id": "receiveAddress", children: address })] }) }) });
};
const KitCheckoutProvider = (props) => {
  const queryClient = new QueryClient();
  return jsxRuntimeExports$1.jsx(QueryClientProvider, { client: queryClient, children: jsxRuntimeExports$1.jsx(KitCheckoutContent, { ...props }) });
};
const KitCheckoutContent = ({ children }) => {
  const { theme, position } = useTheme();
  const [openCheckoutModal, setOpenCheckoutModal] = reactExports.useState(false);
  const [openAddFundsModal, setOpenAddFundsModal] = reactExports.useState(false);
  const [openTransferFundsModal, setOpenTransferFundsModal] = reactExports.useState(false);
  const [openPaymentSelectionModal, setOpenPaymentSelectionModal] = reactExports.useState(false);
  const [settings, setSettings] = reactExports.useState();
  const [selectPaymentSettings, setSelectPaymentSettings] = reactExports.useState();
  const [addFundsSettings, setAddFundsSettings] = reactExports.useState();
  const [transferFundsSettings, setTransferFundsSettings] = reactExports.useState();
  const [history, setHistory] = reactExports.useState([]);
  const getDefaultLocation = () => {
    const orderSummaryItems = (settings == null ? void 0 : settings.orderSummaryItems) || [];
    const creditCardSettings = settings == null ? void 0 : settings.creditCardCheckout;
    if (orderSummaryItems.length === 0 && creditCardSettings) {
      return {
        location: "transaction-pending",
        params: {
          creditCardCheckout: creditCardSettings
        }
      };
    } else {
      return {
        location: "select-method-checkout"
      };
    }
  };
  const navigation = history.length > 0 ? history[history.length - 1] : getDefaultLocation();
  const triggerCheckout = (settings2) => {
    setSettings(settings2);
    setOpenCheckoutModal(true);
  };
  const closeCheckout = () => {
    setOpenCheckoutModal(false);
  };
  const triggerAddFunds = (settings2) => {
    setAddFundsSettings(settings2);
    setOpenAddFundsModal(true);
  };
  const closeAddFunds = () => {
    setOpenAddFundsModal(false);
    if (addFundsSettings == null ? void 0 : addFundsSettings.onClose) {
      addFundsSettings.onClose();
    }
  };
  const openTransferFunds = (settings2) => {
    setTransferFundsSettings(settings2);
    setOpenTransferFundsModal(true);
  };
  const closeTransferFunds = () => {
    if (openTransferFundsModal) {
      setOpenTransferFundsModal(false);
      if (transferFundsSettings == null ? void 0 : transferFundsSettings.onClose) {
        transferFundsSettings.onClose();
      }
    }
  };
  const openSelectPaymentModal = (settings2) => {
    setSelectPaymentSettings(settings2);
    setOpenPaymentSelectionModal(true);
  };
  const closeSelectPaymentModal = () => {
    setOpenPaymentSelectionModal(false);
  };
  const getCheckoutContent = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      case "select-method-checkout":
        return jsxRuntimeExports$1.jsx(CheckoutSelection, {});
      case "transaction-pending":
        return jsxRuntimeExports$1.jsx(PendingTransaction, {});
      case "transaction-success":
        return jsxRuntimeExports$1.jsx(TransactionSuccess, {});
      case "transaction-error":
        return jsxRuntimeExports$1.jsx(TransactionError, {});
      case "transaction-form":
      default:
        return jsxRuntimeExports$1.jsx(CheckoutSelection, {});
    }
  };
  const getCheckoutHeader = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      case "select-method-checkout":
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Checkout" });
      case "transaction-success":
      case "transaction-error":
      case "transaction-pending":
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { disableBack: true, primaryText: "Pay with credit or debit card" });
      case "transaction-form":
      default:
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Pay with credit or debit card" });
    }
  };
  const getAddFundsHeader = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      default:
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Add funds with credit card or debit card" });
    }
  };
  const getAddFundsContent = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      default:
        return jsxRuntimeExports$1.jsx(AddFundsContent, {});
    }
  };
  reactExports.useEffect(() => {
    if (openCheckoutModal || openAddFundsModal || openPaymentSelectionModal) {
      setHistory([]);
    }
  }, [openCheckoutModal, openAddFundsModal, openPaymentSelectionModal]);
  return jsxRuntimeExports$1.jsx(SelectPaymentContextProvider, { value: {
    openSelectPaymentModal,
    closeSelectPaymentModal,
    selectPaymentSettings
  }, children: jsxRuntimeExports$1.jsx(AddFundsContextProvider, { value: {
    triggerAddFunds,
    closeAddFunds,
    addFundsSettings
  }, children: jsxRuntimeExports$1.jsx(CheckoutModalContextProvider, { value: {
    triggerCheckout,
    closeCheckout,
    settings,
    theme
  }, children: jsxRuntimeExports$1.jsx(TransferFundsContextProvider, { value: {
    openTransferFundsModal: openTransferFunds,
    closeTransferFundsModal: closeTransferFunds,
    transferFundsSettings
  }, children: jsxRuntimeExports$1.jsxs(NavigationContextProvider$1, { value: { history, setHistory, defaultLocation: getDefaultLocation() }, children: [jsxRuntimeExports$1.jsx("div", { id: "kit-checkout", children: jsxRuntimeExports$1.jsx(ThemeProvider, { root: "#kit-checkout", scope: "kit", theme, children: jsxRuntimeExports$1.jsxs(AnimatePresence, { children: [openCheckoutModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      maxWidth: "400px",
      height: "auto",
      ...getModalPositionCss(position)
    }
  }, scroll: false, backdropColor: "backgroundBackdrop", onClose: () => setOpenCheckoutModal(false), children: jsxRuntimeExports$1.jsxs(Box, { id: "sequence-kit-checkout-content", children: [getCheckoutHeader(), getCheckoutContent()] }) }), openAddFundsModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      maxWidth: "400px",
      height: "auto",
      ...getModalPositionCss(position)
    }
  }, scroll: false, backdropColor: "backgroundBackdrop", onClose: closeAddFunds, children: jsxRuntimeExports$1.jsxs(Box, { id: "sequence-kit-add-funds-content", children: [getAddFundsHeader(), getAddFundsContent()] }) }), openPaymentSelectionModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      maxWidth: "420px",
      ...getModalPositionCss(position),
      scrollbarColor: "gray black",
      scrollbarWidth: "thin"
    }
  }, backdropColor: "backgroundBackdrop", onClose: () => setOpenPaymentSelectionModal(false), children: jsxRuntimeExports$1.jsx(Box, { id: "sequence-kit-payment-selection-content", children: jsxRuntimeExports$1.jsx(PaymentSelection, {}) }) }), openTransferFundsModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      height: "auto",
      ...getModalPositionCss(position)
    }
  }, backdropColor: "backgroundBackdrop", onClose: closeTransferFunds, children: jsxRuntimeExports$1.jsxs(Box, { id: "sequence-kit-transfer-funds-modal", children: [jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Receive" }), jsxRuntimeExports$1.jsx(TransferToWallet, {})] }) })] }) }) }), children] }) }) }) }) });
};
const ERC_1155_ABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "_amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ERC_20_ABI = [
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ERC_721_ABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const supportedFiatCurrencies = [
  { symbol: "USD", sign: "$", name: { message: "US Dollar" }, decimals: 2 },
  { symbol: "CAD", sign: "$", name: { message: "Canadian Dollar" }, decimals: 2 },
  { symbol: "GBP", sign: "", name: { message: "British Pound Sterling" }, decimals: 2 },
  { symbol: "EUR", sign: "", name: { message: "Euro" }, decimals: 2 },
  { symbol: "CNY", sign: "", name: { message: "Chinese Yuan" }, decimals: 2 },
  { symbol: "JPY", sign: "", name: { message: "Japanese Yen" }, decimals: 2 },
  { symbol: "KRW", sign: "", name: { message: "South Korean Won" }, decimals: 2 },
  { symbol: "SGD", sign: "$", name: { message: "Singapore Dollar" }, decimals: 2 },
  { symbol: "CHF", sign: "CHF ", name: { message: "Swiss Franc" }, decimals: 2 },
  { symbol: "AUD", sign: "$", name: { message: "Australian Dollar" }, decimals: 2 },
  { symbol: "NZD", sign: "$", name: { message: "New Zealand Dollar" }, decimals: 2 },
  { symbol: "SEK", sign: "kr ", name: { message: "Swedish Krona" }, decimals: 2 },
  { symbol: "NOK", sign: "kr ", name: { message: "Norwegian Krone" }, decimals: 2 },
  { symbol: "MXN", sign: "$", name: { message: "Mexican Peso" }, decimals: 2 },
  { symbol: "INR", sign: "", name: { message: "Indian Rupee" }, decimals: 2 },
  { symbol: "ZAR", sign: "R ", name: { message: "South African Rand" }, decimals: 2 },
  { symbol: "TRY", sign: "", name: { message: "Turkish Lira" }, decimals: 2 },
  { symbol: "BRL", sign: "R$", name: { message: "Brazilian Real" }, decimals: 2 },
  { symbol: "DKK", sign: "kr ", name: { message: "Danish Krone" }, decimals: 2 },
  { symbol: "PLN", sign: "z ", name: { message: "Polish Zloty" }, decimals: 2 },
  { symbol: "THB", sign: "", name: { message: "Thai Baht" }, decimals: 2 },
  { symbol: "IDR", sign: "Rp", name: { message: "Indonesian Rupiah" }, decimals: 2 }
];
const defaultFiatCurrency = supportedFiatCurrencies[0];
const HEADER_HEIGHT = "54px";
const createGenericContext = () => {
  const genericContext = reactExports.createContext(void 0);
  const useGenericContext = () => {
    const contextIsDefined = reactExports.useContext(genericContext);
    if (!contextIsDefined) {
      throw new Error("useGenericContext must be used within a Provider");
    }
    return contextIsDefined;
  };
  return [useGenericContext, genericContext.Provider];
};
const [useWalletModalContext, WalletModalContextProvider] = createGenericContext();
const [useNavigationContext, NavigationContextProvider] = createGenericContext();
const useOpenWalletModal = () => {
  const { setOpenWalletModal, openWalletModalState } = useWalletModalContext();
  return { setOpenWalletModal, openWalletModalState };
};
const compareAddress = (a2, b2) => {
  return a2.toLowerCase() === b2.toLowerCase();
};
const truncateAtMiddle = (text2, truncateAt) => {
  let finalText = text2;
  if (text2.length >= truncateAt) {
    finalText = text2.slice(0, truncateAt / 2) + "..." + text2.slice(text2.length - truncateAt / 2, text2.length);
  }
  return finalText;
};
const formatAddress = (text2) => {
  return `0x${truncateAtMiddle((text2 == null ? void 0 : text2.substring(2)) || "", 8)}`;
};
var ValueType;
(function(ValueType2) {
  ValueType2[ValueType2["VERY_LARGE"] = 0] = "VERY_LARGE";
  ValueType2[ValueType2["FRACTION"] = 1] = "FRACTION";
  ValueType2[ValueType2["VERY_TINY"] = 2] = "VERY_TINY";
  ValueType2[ValueType2["MIXED"] = 3] = "MIXED";
})(ValueType || (ValueType = {}));
const formatDisplay = (_val2) => {
  if (isNaN(Number(_val2))) {
    console.error(`display format error ${_val2} is not a number`);
    return "NaN";
  }
  const val = Number(_val2);
  if (val === 0) {
    return "0";
  }
  let valMode;
  if (val > 1e8) {
    valMode = ValueType.VERY_LARGE;
  } else if (val < 1e-10) {
    valMode = ValueType.VERY_TINY;
  } else if (val < 1) {
    valMode = ValueType.FRACTION;
  } else {
    valMode = ValueType.MIXED;
  }
  let notation = void 0;
  let config2;
  switch (valMode) {
    case ValueType.VERY_LARGE:
      notation = "compact";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType.VERY_TINY:
      notation = "scientific";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType.FRACTION:
      notation = "standard";
      config2 = {
        maximumSignificantDigits: 4
      };
      break;
    default:
      notation = "standard";
      config2 = {
        maximumFractionDigits: 2
      };
  }
  return Intl.NumberFormat("en-US", {
    notation,
    ...config2
  }).format(val);
};
const limitDecimals = (value, decimals) => {
  const splitValue = value.split(".");
  if (splitValue.length === 1) {
    return value;
  }
  return `${splitValue[0]}.${splitValue[1].slice(0, decimals)}`;
};
const isEthAddress = (value) => {
  const ethAddressRegEx = /0x[a-fA-F0-9]{40}/;
  const isEthAddress2 = ethAddressRegEx.test(value);
  return isEthAddress2;
};
const sampleSize = (collection, n2) => {
  const random = seededRandom(1);
  const length = collection.length;
  if (!length || n2 < 1) {
    return [];
  }
  n2 = n2 > length ? length : n2;
  const sampled = new Array(n2);
  const indexes = /* @__PURE__ */ new Set();
  while (indexes.size < n2) {
    indexes.add(Math.floor(random() * length));
  }
  for (const [idx, value] of Array.from(indexes).entries()) {
    sampled[idx] = collection[value];
  }
  return sampled;
};
const isTruthy = (value) => Boolean(value);
const seededRandom = (seed) => {
  return () => {
    const x2 = Math.sin(seed++) * 1e4;
    return x2 - Math.floor(x2);
  };
};
const getPercentageColor = (value) => {
  if (value > 0) {
    return vars.colors.positive;
  } else if (value < 0) {
    return vars.colors.negative;
  } else {
    return vars.colors.text50;
  }
};
const getPercentagePriceChange = (balance, prices) => {
  var _a2;
  const priceForToken = prices.find((p2) => compareAddress(p2.token.contractAddress, balance.contractAddress));
  if (!priceForToken) {
    return 0;
  }
  const price24HourChange = ((_a2 = priceForToken == null ? void 0 : priceForToken.price24hChange) == null ? void 0 : _a2.value) || 0;
  return price24HourChange;
};
const computeBalanceFiat = ({ balance, prices, decimals, conversionRate }) => {
  var _a2;
  let totalUsd = 0;
  const priceForToken = prices.find((p2) => compareAddress(p2.token.contractAddress, balance.contractAddress));
  if (!priceForToken) {
    return "0.00";
  }
  const priceFiat = ((_a2 = priceForToken.price) == null ? void 0 : _a2.value) || 0;
  const valueFormatted = formatUnits$1(balance.balance, decimals);
  const usdValue = parseFloat(valueFormatted) * priceFiat;
  totalUsd += usdValue;
  const fiatValue = totalUsd * conversionRate;
  return `${fiatValue.toFixed(2)}`;
};
const compareTokenBalanceIds = (a2, b2) => {
  return (a2.tokenID || "").localeCompare(b2.tokenID || "");
};
const sortBalancesByType = (balances) => {
  const nativeTokens = [];
  const erc20Tokens = [];
  const collectibles = [];
  balances.forEach((balance) => {
    if (balance.contractAddress === ZeroAddress) {
      nativeTokens.push(balance);
    } else if (balance.contractType === "ERC20") {
      erc20Tokens.push(balance);
    } else if (balance.contractType === "ERC721" || balance.contractType === "ERC1155") {
      collectibles.push(balance);
    }
  });
  const sortedNativeTokens = nativeTokens.sort(compareTokenBalanceIds);
  const sortedErc20Tokens = erc20Tokens.sort(compareTokenBalanceIds);
  const sortedCollectibles = collectibles.sort(compareTokenBalanceIds);
  return {
    nativeTokens: sortedNativeTokens,
    erc20Tokens: sortedErc20Tokens,
    collectibles: sortedCollectibles
  };
};
const flattenPaginatedTransactionHistory = (transactionHistoryData) => {
  const transactionHistory = [];
  transactionHistoryData == null ? void 0 : transactionHistoryData.pages.forEach((page) => {
    transactionHistory.push(...page.transactions);
  });
  return transactionHistory;
};
const time = {
  oneSecond: 1 * 1e3,
  oneMinute: 60 * 1e3,
  oneHour: 60 * 60 * 1e3
};
const getBalancesAssetsSummary = async (apiClient, metadataClient, indexerClients, { accountAddress, displayAssets, hideCollectibles, verifiedOnly }) => {
  const indexerClientsArr = Array.from(indexerClients.entries());
  const MAX_COLLECTIBLES_AMOUNTS = 10;
  let tokenBalances = [];
  const customDisplayAssets = displayAssets.length > 0;
  try {
    if (customDisplayAssets) {
      const nativeTokens2 = displayAssets.filter((asset) => compareAddress(asset.contractAddress, ZeroAddress));
      const otherAssets = displayAssets.filter((asset) => !compareAddress(asset.contractAddress, ZeroAddress));
      const nativeTokensByChainId = {};
      const otherAssetsByChainId = {};
      nativeTokens2.forEach((asset) => {
        if (!nativeTokensByChainId[asset.chainId]) {
          nativeTokensByChainId[asset.chainId] = [];
        }
        nativeTokensByChainId[asset.chainId].push(asset);
      });
      otherAssets.forEach((asset) => {
        if (!otherAssetsByChainId[asset.chainId]) {
          otherAssetsByChainId[asset.chainId] = [];
        }
        otherAssetsByChainId[asset.chainId].push(asset);
      });
      tokenBalances = (await Promise.all([
        ...Object.keys(nativeTokensByChainId).map((chainId) => {
          const indexerClient = indexerClients.get(Number(chainId));
          if (!indexerClient) {
            console.error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
            return null;
          }
          return getNativeTokenBalance(indexerClient, Number(chainId), accountAddress);
        }),
        ...Object.keys(otherAssetsByChainId).map((chainId) => otherAssetsByChainId[Number(chainId)].map((asset) => {
          const indexerClient = indexerClients.get(Number(chainId));
          if (!indexerClient) {
            console.error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
            return [];
          }
          return getTokenBalances(indexerClient, {
            accountAddress,
            contractAddress: asset.contractAddress,
            includeMetadata: false,
            hideCollectibles,
            verifiedOnly
          });
        })).flat()
      ])).flat().filter(isTruthy);
    } else {
      tokenBalances = (await Promise.all([
        ...indexerClientsArr.map(([chainId, indexerClient]) => getNativeTokenBalance(indexerClient, chainId, accountAddress)),
        ...indexerClientsArr.map(([_chainId4, indexerClient]) => getTokenBalances(indexerClient, {
          accountAddress,
          hideCollectibles,
          includeMetadata: false,
          verifiedOnly
        }))
      ])).flat();
    }
    const { nativeTokens, erc20Tokens, collectibles: collectionBalances } = sortBalancesByType(tokenBalances);
    const fetchPricesPromise = new Promise(async (resolve) => {
      if (erc20Tokens.length > 0) {
        const tokens = erc20Tokens.map((token) => ({
          chainId: token.chainId,
          contractAddress: token.contractAddress
        }));
        const prices2 = await getCoinPrices(apiClient, tokens) || [];
        resolve(prices2);
      } else {
        resolve([]);
      }
    });
    const fetchCollectiblesPromises = collectionBalances.map(async (collectionBalance) => {
      if (customDisplayAssets) {
        return collectionBalance;
      }
      const indexerClient = indexerClients.get(collectionBalance.chainId);
      if (!indexerClient) {
        throw new Error(`Indexer client not found for chainId: ${collectionBalance.chainId}, did you forget to add this Chain?`);
      }
      const balance = await getCollectionBalance(indexerClient, {
        accountAddress,
        chainId: collectionBalance.chainId,
        contractAddress: collectionBalance.contractAddress,
        includeMetadata: false
      });
      return balance;
    });
    const fetchErc20ContractInfoPromise = async () => {
      const contractInfoMapByChainId2 = {};
      const erc20BalanceByChainId = {};
      erc20Tokens.forEach((erc20Token) => {
        if (!erc20BalanceByChainId[erc20Token.chainId]) {
          erc20BalanceByChainId[erc20Token.chainId] = [erc20Token];
        } else {
          erc20BalanceByChainId[erc20Token.chainId].push(erc20Token);
        }
      });
      const contractInfoPromises = Object.keys(erc20BalanceByChainId).map(async (chainId) => {
        const tokenBalances2 = erc20BalanceByChainId[Number(chainId)];
        const contractAddresses = tokenBalances2.map((balance) => balance.contractAddress);
        const result = await metadataClient.getContractInfoBatch({
          chainID: String(chainId),
          contractAddresses
        });
        contractInfoMapByChainId2[Number(chainId)] = result;
      });
      await Promise.all([...contractInfoPromises]);
      return contractInfoMapByChainId2;
    };
    const [prices, contractInfoMapByChainId, ...collectionCollectibles] = await Promise.all([
      fetchPricesPromise,
      fetchErc20ContractInfoPromise(),
      ...fetchCollectiblesPromises
    ]);
    const erc20HighestValue = erc20Tokens.sort((a2, b2) => {
      var _a2, _b2;
      const aPriceData = prices.find((price) => compareAddress(price.token.contractAddress, a2.contractAddress));
      const bPriceData = prices.find((price) => compareAddress(price.token.contractAddress, b2.contractAddress));
      const aPrice = (aPriceData == null ? void 0 : aPriceData.price) ? aPriceData.price.value : 0;
      const bPrice = (bPriceData == null ? void 0 : bPriceData.price) ? bPriceData.price.value : 0;
      const aDecimals = (_a2 = contractInfoMapByChainId[a2.chainId].contractInfoMap[a2.contractAddress]) == null ? void 0 : _a2.decimals;
      const bDecimals = (_b2 = contractInfoMapByChainId[b2.chainId].contractInfoMap[b2.contractAddress]) == null ? void 0 : _b2.decimals;
      const aFormattedBalance = aDecimals === void 0 ? 0 : Number(formatUnits$1(a2.balance, aDecimals));
      const bFormattedBalance = bDecimals === void 0 ? 0 : Number(formatUnits$1(b2.balance, bDecimals));
      const aValue = aFormattedBalance * aPrice;
      const bValue = bFormattedBalance * bPrice;
      return bValue - aValue;
    });
    const collectibles = sampleSize(collectionCollectibles.flat(), MAX_COLLECTIBLES_AMOUNTS).sort((a2, b2) => {
      return a2.contractAddress.localeCompare(b2.contractAddress);
    });
    if (hideCollectibles) {
      const summaryBalances2 = [
        ...nativeTokens.length > 0 ? [nativeTokens[0]] : [],
        // the spots normally occupied by collectibles will be filled by erc20 tokens
        ...erc20HighestValue.length > 0 ? erc20HighestValue.slice(0, MAX_COLLECTIBLES_AMOUNTS + 1) : []
      ];
      return summaryBalances2;
    }
    const summaryBalances = [
      ...nativeTokens.length > 0 ? [nativeTokens[0]] : [],
      ...erc20HighestValue.length > 0 ? [erc20HighestValue[0]] : [],
      ...collectibles.length > 0 ? [...collectibles] : []
    ];
    return summaryBalances;
  } catch (e2) {
    console.error(e2);
    return [];
  }
};
const useBalancesAssetsSummary = (args) => {
  const apiClient = useAPIClient();
  const metadataClient = useMetadataClient();
  const indexerClients = useIndexerClients(args.chainIds);
  return useQuery$1({
    queryKey: ["balancesAssetsSummary", args],
    queryFn: () => getBalancesAssetsSummary(apiClient, metadataClient, indexerClients, args),
    retry: true,
    refetchInterval: time.oneSecond * 30,
    refetchOnMount: true,
    staleTime: time.oneSecond,
    enabled: args.chainIds.length > 0 && !!args.accountAddress
  });
};
const getTransactionHistorySummary = async (indexerClients, { accountAddress }) => {
  const histories = await Promise.all(Array.from(indexerClients.values()).map((indexerClient) => getTransactionHistory(indexerClient, {
    accountAddress,
    page: {
      page: 1
    }
  })));
  const unorderedTransactions = histories.map((history) => history.transactions).flat();
  const orderedTransactions = unorderedTransactions.sort((a2, b2) => {
    const firstDate = new Date(a2.timestamp).getTime();
    const secondDate = new Date(b2.timestamp).getTime();
    return secondDate - firstDate;
  });
  return orderedTransactions;
};
const useTransactionHistorySummary = (args) => {
  const indexerClients = useIndexerClients(args.chainIds);
  return useQuery$1({
    queryKey: ["transactionHistorySummary", args],
    queryFn: () => getTransactionHistorySummary(indexerClients, args),
    retry: true,
    staleTime: time.oneSecond,
    refetchOnMount: true,
    enabled: args.chainIds.length > 0 && !!args.accountAddress
  });
};
const useNavigation = () => {
  const { setHistory, history } = useNavigationContext();
  const setNavigation = (navigation) => {
    const childElement = document.getElementById("sequence-kit-wallet-content");
    const parentElement = childElement == null ? void 0 : childElement.parentElement;
    parentElement == null ? void 0 : parentElement.scrollTo(0, 0);
    const newHistory = navigation.location === "home" ? [] : [...history, navigation];
    setHistory(newHistory);
  };
  const goBack = () => {
    const newHistory = [...history];
    newHistory.pop();
    setHistory(newHistory);
  };
  return { setNavigation, history, setHistory, goBack };
};
const useSettings = () => {
  const { chains: chains2 } = useConfig();
  const getSettingsFromStorage = () => {
    let hideUnlistedTokens = true;
    let hideCollectibles = false;
    let fiatCurrency = defaultFiatCurrency;
    let selectedNetworks = chains2.map((chain) => chain.id);
    try {
      const settingsStorage = localStorage.getItem(LocalStorageKey.Settings);
      const settings2 = JSON.parse(settingsStorage || "{}");
      if ((settings2 == null ? void 0 : settings2.hideUnlistedTokens) !== void 0) {
        hideUnlistedTokens = settings2 == null ? void 0 : settings2.hideUnlistedTokens;
      }
      if ((settings2 == null ? void 0 : settings2.hideCollectibles) !== void 0) {
        hideCollectibles = settings2 == null ? void 0 : settings2.hideCollectibles;
      }
      if ((settings2 == null ? void 0 : settings2.fiatCurrency) !== void 0) {
        fiatCurrency = settings2 == null ? void 0 : settings2.fiatCurrency;
      }
      if ((settings2 == null ? void 0 : settings2.selectedNetworks) !== void 0) {
        let areSelectedNetworksValid = true;
        settings2.selectedNetworks.forEach((chainId) => {
          if (chains2.find((chain) => chain.id === chainId) === void 0) {
            areSelectedNetworksValid = false;
          }
        });
        if (areSelectedNetworksValid) {
          selectedNetworks = settings2 == null ? void 0 : settings2.selectedNetworks;
        }
      }
    } catch (e2) {
      console.error(e2, "Failed to fetch settings");
    }
    return {
      hideUnlistedTokens,
      hideCollectibles,
      fiatCurrency,
      selectedNetworks
    };
  };
  const defaultSettings = getSettingsFromStorage();
  const [settings, setSettings] = reactExports.useState(defaultSettings);
  const setHideUnlistedTokens = (newState) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      hideUnlistedTokens: newState
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  const setHideCollectibles = (newState) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      hideCollectibles: newState
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  const setFiatCurrency = (newFiatCurrency) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      fiatCurrency: newFiatCurrency
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  const setSelectedNetworks = (newSelectedNetworks) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      selectedNetworks: newSelectedNetworks
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  return {
    ...settings,
    setFiatCurrency,
    setHideCollectibles,
    setHideUnlistedTokens,
    setSelectedNetworks
  };
};
const CoinTileContent = ({ logoUrl, tokenName, balance, balanceFiat, priceChangePercentage, symbol, chainId }) => {
  const { fiatCurrency } = useSettings();
  const priceChangeSymbol = priceChangePercentage > 0 ? "+" : "";
  return jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", width: "full", height: "full", borderRadius: "md", padding: "4", flexDirection: "column", justifyContent: "center", alignItems: "flex-start", gap: "1", children: [jsxRuntimeExports$1.jsx(Box, { marginBottom: "1", children: jsxRuntimeExports$1.jsx(TokenImage, { src: logoUrl, symbol, size: "xl" }) }), jsxRuntimeExports$1.jsxs(Box, { marginBottom: "3", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "1", justifyContent: "flex-start", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", whiteSpace: "nowrap", color: "text100", style: { maxWidth: "130px", textOverflow: "ellipsis", overflow: "hidden" }, children: tokenName }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] }), jsxRuntimeExports$1.jsx(Text, { color: "text50", whiteSpace: "nowrap", style: { display: "block", maxWidth: "150px", textOverflow: "ellipsis", overflow: "hidden" }, children: `${balance} ${symbol}` })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", color: "text100", children: `${fiatCurrency.sign}${balanceFiat}` }) }), jsxRuntimeExports$1.jsx(Text, { style: { color: getPercentageColor(priceChangePercentage) }, children: `${priceChangeSymbol}${priceChangePercentage.toFixed(2)}%` })] })] });
};
const CoinTile = ({ balance }) => {
  const { chains: chains2 } = useConfig();
  const { fiatCurrency } = useSettings();
  const isNativeToken = compareAddress(balance.contractAddress, ZeroAddress);
  const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
  const { data: dataCoinPrices = [], isPending: isPendingCoinPrice } = useCoinPrices([
    {
      chainId: balance.chainId,
      contractAddress: balance.contractAddress
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const { data: contractInfo, isPending: isPendingContractInfo } = useContractInfo(balance.chainId, balance.contractAddress);
  const isPending = isPendingCoinPrice || isPendingConversionRate || isPendingContractInfo;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", width: "full", height: "full", borderRadius: "md" });
  }
  if (isNativeToken) {
    const computedBalance2 = computeBalanceFiat({
      balance,
      prices: dataCoinPrices,
      conversionRate,
      decimals: nativeTokenInfo.decimals
    });
    const priceChangePercentage2 = getPercentagePriceChange(balance, dataCoinPrices);
    const formattedBalance2 = formatUnits$1(balance.balance, nativeTokenInfo.decimals);
    const balanceDisplayed2 = formatDisplay(formattedBalance2);
    return jsxRuntimeExports$1.jsx(CoinTileContent, { chainId: balance.chainId, logoUrl: nativeTokenInfo.logoURI, tokenName: nativeTokenInfo.name, balance: balanceDisplayed2, balanceFiat: computedBalance2, priceChangePercentage: priceChangePercentage2, symbol: nativeTokenInfo.symbol });
  }
  const decimals = (contractInfo == null ? void 0 : contractInfo.decimals) ?? 18;
  const computedBalance = computeBalanceFiat({
    balance,
    prices: dataCoinPrices,
    conversionRate,
    decimals
  });
  const priceChangePercentage = getPercentagePriceChange(balance, dataCoinPrices);
  const formattedBalance = formatUnits$1(balance.balance, decimals);
  const balanceDisplayed = formatDisplay(formattedBalance);
  const name2 = (contractInfo == null ? void 0 : contractInfo.name) || "Unknown";
  const symbol = (contractInfo == null ? void 0 : contractInfo.name) || "TOKEN";
  const url = contractInfo == null ? void 0 : contractInfo.logoURI;
  return jsxRuntimeExports$1.jsx(CoinTileContent, { chainId: balance.chainId, logoUrl: url, tokenName: name2, balance: balanceDisplayed, balanceFiat: computedBalance, priceChangePercentage, symbol });
};
const CollectibleTileImage = ({ imageUrl }) => {
  return jsxRuntimeExports$1.jsx(Card, { padding: "0", aspectRatio: "1/1", justifyContent: "center", alignItems: "center", overflow: "hidden", borderRadius: "sm", background: "backgroundSecondary", children: jsxRuntimeExports$1.jsx(Image$1, { style: { height: "100%" }, src: imageUrl }) });
};
const CollectibleTile = ({ balance }) => {
  var _a2;
  const { data: tokenMetadata } = useTokenMetadata(balance.chainId, balance.contractAddress, [balance.tokenID || ""]);
  const imageUrl = (_a2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _a2.image;
  return jsxRuntimeExports$1.jsx(CollectibleTileImage, { imageUrl });
};
const SkeletonTiles = () => {
  return jsxRuntimeExports$1.jsx(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, children: Array(12).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Skeleton, { height: "full", width: "full", aspectRatio: "1/1" }) }, i)) });
};
const AssetSummary = () => {
  const { address } = useAccount();
  const { setNavigation } = useNavigation();
  const { displayedAssets } = useWalletSettings();
  const { hideUnlistedTokens, hideCollectibles, selectedNetworks } = useSettings();
  const { data: balances = [], isPending: isPendingBalances } = useBalancesAssetsSummary({
    accountAddress: address || "",
    chainIds: selectedNetworks,
    displayAssets: displayedAssets,
    hideCollectibles,
    verifiedOnly: hideUnlistedTokens
  });
  if (isPendingBalances) {
    return jsxRuntimeExports$1.jsx(SkeletonTiles, {});
  }
  const { nativeTokens, erc20Tokens, collectibles } = sortBalancesByType(balances);
  const onClickItem = (balance) => {
    if (balance.contractType === "ERC1155" || balance.contractType === "ERC721") {
      setNavigation && setNavigation({
        location: "collectible-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId,
          tokenId: balance.tokenID || ""
        }
      });
    } else if (balance.contractType === "ERC20") {
      setNavigation && setNavigation({
        location: "coin-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    } else {
      setNavigation && setNavigation({
        location: "coin-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, children: [nativeTokens.map((balance, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, aspectRatio: "1/1", onClick: () => onClickItem(balance), children: jsxRuntimeExports$1.jsx(CoinTile, { balance }) }, index2);
  }), erc20Tokens.map((balance, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, aspectRatio: "1/1", onClick: () => onClickItem(balance), children: jsxRuntimeExports$1.jsx(CoinTile, { balance }) }, index2);
  }), collectibles.map((balance, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, aspectRatio: "1/1", onClick: () => onClickItem(balance), children: jsxRuntimeExports$1.jsx(CollectibleTile, { balance }) }, index2);
  })] });
};
const Home = () => {
  return jsxRuntimeExports$1.jsx(Box, { paddingX: "4", paddingBottom: "5", gap: "4", flexDirection: "column", children: jsxRuntimeExports$1.jsx(AssetSummary, {}) });
};
const Receive = () => {
  const { address, chain } = useAccount();
  const { chains: chains2 } = useConfig();
  const [isCopied, setCopied] = reactExports.useState(false);
  const nativeTokenInfo = getNativeTokenInfoByChainId((chain == null ? void 0 : chain.id) || 1, chains2);
  reactExports.useEffect(() => {
    if (isCopied) {
      setTimeout(() => {
        setCopied(false);
      }, 4e3);
    }
  }, [isCopied]);
  const onClickCopy = () => {
    setCopied(true);
  };
  const onClickShare = () => {
    if (typeof window !== "undefined") {
      window.open(`https://twitter.com/intent/tweet?text=Here%20is%20my%20address%20${address}`);
    }
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "4", children: [jsxRuntimeExports$1.jsx(Box, { marginTop: "1", width: "fit", background: "white", borderRadius: "md", alignItems: "center", justifyContent: "center", padding: "4", children: jsxRuntimeExports$1.jsx(QRCodeCanvas, { value: address || "", size: 200, bgColor: "white", fgColor: "black", "data-id": "receiveQR" }) }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", textAlign: "center", lineHeight: "inherit", style: { fontWeight: "700" }, children: "My Wallet" }), jsxRuntimeExports$1.jsx(Image$1, { width: "5", src: nativeTokenInfo.logoURI, alt: "icon" })] }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", style: { maxWidth: "180px", textAlign: "center" }, children: jsxRuntimeExports$1.jsx(Text, { textAlign: "center", color: "text50", style: {
    fontSize: "14px",
    maxWidth: "180px",
    overflowWrap: "anywhere"
  }, children: address }) })] }), jsxRuntimeExports$1.jsxs(Box, { gap: "3", children: [jsxRuntimeExports$1.jsx(lib.CopyToClipboard, { text: address || "", children: jsxRuntimeExports$1.jsx(Button, { onClick: onClickCopy, leftIcon: SvgCopyIcon, label: isCopied ? "Copied!" : "Copy" }) }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickShare, leftIcon: SvgShareIcon, label: "Share" })] }), jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", alignItems: "center", style: { maxWidth: "260px", textAlign: "center" }, children: jsxRuntimeExports$1.jsx(Text, { color: "text100", variant: "small", style: {
    maxWidth: "260px",
    overflowWrap: "anywhere"
  }, children: `This is a ${nativeTokenInfo.name} address. Please only send assets on the ${nativeTokenInfo.name} network.` }) })] }) });
};
const SendItemInfo = ({ imageUrl, name: name2, decimals, balance, symbol, fiatValue, chainId, showSquareImage }) => {
  const { fiatCurrency } = useSettings();
  const formattedBalance = formatUnits$1(balance, decimals);
  const balanceDisplayed = formatDisplay(formattedBalance);
  return jsxRuntimeExports$1.jsxs(Box, { alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", gap: "2", children: [showSquareImage ? jsxRuntimeExports$1.jsx(Box, { style: { width: "40px" }, children: jsxRuntimeExports$1.jsx(CollectibleTileImage, { imageUrl }) }) : jsxRuntimeExports$1.jsx(TokenImage, { src: imageUrl, size: "lg" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", gap: "1", children: [jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: name2 }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] }), jsxRuntimeExports$1.jsxs(Text, { color: "text50", variant: "normal", children: [" ", `${balanceDisplayed} ${symbol} available`] })] })] }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", alignItems: "flex-end", justifyContent: "flex-end", children: fiatValue && jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", children: `${fiatCurrency.sign}${fiatValue}` }) })] });
};
const SendCoin = ({ chainId, contractAddress }) => {
  var _a2, _b2, _c2, _d2, _e2;
  const { setNavigation } = useNavigation();
  const { analytics } = useAnalyticsContext();
  const { chains: chains2 } = useConfig();
  const connectedChainId = useChainId();
  const { address: accountAddress = "", connector } = useAccount();
  const isConnectorSequenceBased = !!((_a2 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a2.isSequenceBased);
  const isCorrectChainId = connectedChainId === chainId;
  const showSwitchNetwork = !isCorrectChainId && !isConnectorSequenceBased;
  const { switchChainAsync } = useSwitchChain();
  const amountInputRef = reactExports.useRef(null);
  const { fiatCurrency } = useSettings();
  const [amount, setAmount] = reactExports.useState("0");
  const [toAddress, setToAddress] = reactExports.useState("");
  const { sendTransaction: sendTransaction2 } = useSendTransaction();
  const [isSendTxnPending, setIsSendTxnPending] = reactExports.useState(false);
  const { data: balances = [], isPending: isPendingBalances } = useBalances({
    chainIds: [chainId],
    accountAddress,
    contractAddress
  });
  const nativeTokenInfo = getNativeTokenInfoByChainId(chainId, chains2);
  const tokenBalance = balances.find((b2) => b2.contractAddress === contractAddress);
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices([
    {
      chainId,
      contractAddress
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingBalances || isPendingCoinPrices || isPendingConversionRate;
  if (isPending) {
    return null;
  }
  const isNativeCoin = compareAddress(contractAddress, ZeroAddress);
  const decimals = isNativeCoin ? nativeTokenInfo.decimals : ((_b2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _b2.decimals) || 18;
  const name2 = isNativeCoin ? nativeTokenInfo.name : ((_c2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _c2.name) || "";
  const imageUrl = isNativeCoin ? nativeTokenInfo.logoURI : (_d2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _d2.logoURI;
  const symbol = isNativeCoin ? nativeTokenInfo.symbol : ((_e2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _e2.symbol) || "";
  const amountToSendFormatted = amount === "" ? "0" : amount;
  const amountRaw = parseUnits$2(amountToSendFormatted, decimals);
  const amountToSendFiat = computeBalanceFiat({
    balance: {
      ...tokenBalance,
      balance: amountRaw.toString()
    },
    prices: coinPrices,
    conversionRate,
    decimals
  });
  const insufficientFunds = amountRaw > BigInt((tokenBalance == null ? void 0 : tokenBalance.balance) || "0");
  const isNonZeroAmount = amountRaw > 0n;
  const handleChangeAmount = (ev) => {
    const { value } = ev.target;
    const formattedValue = limitDecimals(value, decimals);
    setAmount(formattedValue);
  };
  const handleMax = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const maxAmount = formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals).toString();
    setAmount(maxAmount);
  };
  const handlePaste = async () => {
    const result = await navigator.clipboard.readText();
    setToAddress(result);
  };
  const handleToAddressClear = () => {
    setToAddress("");
  };
  const executeTransaction = async (e2) => {
    var _a3, _b3;
    if (!isCorrectChainId && isConnectorSequenceBased) {
      await switchChainAsync({ chainId });
    }
    e2.preventDefault();
    const sendAmount = parseUnits$2(amountToSendFormatted, decimals);
    if (isNativeCoin) {
      analytics == null ? void 0 : analytics.track({
        event: "SEND_TRANSACTION_REQUEST",
        props: {
          walletClient: ((_a3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a3.id) || "unknown",
          source: "sequence-kit/wallet"
        }
      });
      setIsSendTxnPending(true);
      sendTransaction2({
        to: toAddress,
        value: BigInt(sendAmount.toString()),
        gas: null
      }, {
        onSettled: (result) => {
          if (result) {
            setNavigation({
              location: "home"
            });
          }
          setIsSendTxnPending(false);
        }
      });
    } else {
      analytics == null ? void 0 : analytics.track({
        event: "SEND_TRANSACTION_REQUEST",
        props: {
          walletClient: ((_b3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _b3.id) || "unknown",
          source: "sequence-kit/wallet"
        }
      });
      setIsSendTxnPending(true);
      sendTransaction2({
        to: tokenBalance == null ? void 0 : tokenBalance.contractAddress,
        data: new Interface(ERC_20_ABI).encodeFunctionData("transfer", [
          toAddress,
          toQuantity(sendAmount)
        ]),
        gas: null
      }, {
        onSettled: (result) => {
          if (result) {
            setNavigation({
              location: "home"
            });
          }
          setIsSendTxnPending(false);
        }
      });
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", style: {
    marginTop: HEADER_HEIGHT
  }, gap: "2", flexDirection: "column", as: "form", onSubmit: executeTransaction, pointerEvents: isSendTxnPending ? "none" : "auto", children: [jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(SendItemInfo, { imageUrl, decimals, name: name2, symbol, balance: (tokenBalance == null ? void 0 : tokenBalance.balance) || "0", fiatValue: computeBalanceFiat({
    balance: tokenBalance,
    prices: coinPrices,
    conversionRate,
    decimals
  }), chainId }), jsxRuntimeExports$1.jsx(NumericInput, { ref: amountInputRef, style: { fontSize: vars.fontSizes.xlarge, fontWeight: vars.fontWeights.bold }, name: "amount", value: amount, onChange: handleChangeAmount, controls: jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", whiteSpace: "nowrap", children: `~${fiatCurrency.sign}${amountToSendFiat}` }), jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Max", onClick: handleMax, "data-id": "maxCoin", flexShrink: "0" }), jsxRuntimeExports$1.jsx(Text, { variant: "xlarge", fontWeight: "bold", color: "text100", children: symbol })] }) }), insufficientFunds && jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "negative", marginTop: "2", children: "Insufficient Funds" })] }), jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", children: "To" }), isEthAddress(toAddress) ? jsxRuntimeExports$1.jsxs(Card, { clickable: true, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", onClick: handleToAddressClear, style: { height: "52px" }, children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: toAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle(toAddress.substring(2), 8)}` })] }), jsxRuntimeExports$1.jsx(SvgCloseIcon, { size: "xs" })] }) : jsxRuntimeExports$1.jsx(TextInput, { value: toAddress, onChange: (ev) => setToAddress(ev.target.value), placeholder: `${nativeTokenInfo.name} Address (0x...)`, name: "to-address", "data-1p-ignore": true, controls: jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Paste", onClick: handlePaste, "data-id": "to-address", flexShrink: "0", leftIcon: SvgCopyIcon }) })] }), showSwitchNetwork && jsxRuntimeExports$1.jsxs(Box, { marginTop: "3", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "negative", marginBottom: "2", children: "The wallet is connected to the wrong network. Please switch network before proceeding" }), jsxRuntimeExports$1.jsx(Button, { marginTop: "2", width: "full", variant: "primary", type: "button", label: "Switch Network", onClick: async () => await switchChainAsync({ chainId }), disabled: isCorrectChainId, style: { height: "52px", borderRadius: vars.radii.md } })] }), jsxRuntimeExports$1.jsx(Box, { style: { height: "52px" }, alignItems: "center", justifyContent: "center", children: isSendTxnPending ? jsxRuntimeExports$1.jsx(Spinner, {}) : jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "3", width: "full", variant: "primary", type: "submit", disabled: !isNonZeroAmount || !isEthAddress(toAddress) || insufficientFunds || !isCorrectChainId && !isConnectorSequenceBased, label: "Send", rightIcon: SvgChevronRightIcon, style: { height: "52px", borderRadius: vars.radii.md } }) })] });
};
const SendCollectible = ({ chainId, contractAddress, tokenId }) => {
  var _a2, _b2, _c2, _d2, _e2;
  const { setNavigation } = useNavigation();
  const { analytics } = useAnalyticsContext();
  const { chains: chains2 } = useConfig();
  const connectedChainId = useChainId();
  const { address: accountAddress = "", connector } = useAccount();
  const isConnectorSequenceBased = !!((_a2 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a2.isSequenceBased);
  const isCorrectChainId = connectedChainId === chainId;
  const showSwitchNetwork = !isCorrectChainId && !isConnectorSequenceBased;
  const { switchChain: switchChain2 } = useSwitchChain();
  const amountInputRef = reactExports.useRef(null);
  const [amount, setAmount] = reactExports.useState("0");
  const [toAddress, setToAddress] = reactExports.useState("");
  const [showAmountControls, setShowAmountControls] = reactExports.useState(false);
  const { sendTransaction: sendTransaction2 } = useSendTransaction();
  const [isSendTxnPending, setIsSendTxnPending] = reactExports.useState(false);
  const { data: tokenBalance, isPending: isPendingBalances } = useCollectibleBalance({
    accountAddress,
    chainId,
    contractAddress,
    tokenId,
    verifiedOnly: false
  });
  const { contractType } = tokenBalance;
  reactExports.useEffect(() => {
    if (tokenBalance) {
      if (contractType === "ERC721") {
        setAmount("1");
        setShowAmountControls(false);
      } else if (contractType === "ERC1155") {
        if (Number(formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals)) >= 1) {
          setAmount("1");
        }
        setShowAmountControls(true);
      }
    }
  }, [tokenBalance]);
  const nativeTokenInfo = getNativeTokenInfoByChainId(chainId, chains2);
  const isPending = isPendingBalances;
  if (isPending) {
    return null;
  }
  const decimals = ((_b2 = tokenBalance == null ? void 0 : tokenBalance.tokenMetadata) == null ? void 0 : _b2.decimals) || 0;
  const name2 = ((_c2 = tokenBalance == null ? void 0 : tokenBalance.tokenMetadata) == null ? void 0 : _c2.name) || "Unknown";
  const imageUrl = ((_d2 = tokenBalance == null ? void 0 : tokenBalance.tokenMetadata) == null ? void 0 : _d2.image) || ((_e2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _e2.logoURI) || "";
  const amountToSendFormatted = amount === "" ? "0" : amount;
  const amountRaw = parseUnits$2(amountToSendFormatted, decimals);
  const insufficientFunds = amountRaw > BigInt((tokenBalance == null ? void 0 : tokenBalance.balance) || "0");
  const isNonZeroAmount = amountRaw > 0n;
  const handleChangeAmount = (ev) => {
    const { value } = ev.target;
    const formattedValue = limitDecimals(value, decimals);
    setAmount(formattedValue);
  };
  const handleSubtractOne = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const decrementedAmount = Number(amount) - 1;
    const newAmount = Math.max(decrementedAmount, 0).toString();
    setAmount(newAmount);
  };
  const handleAddOne = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const incrementedAmount = Number(amount) + 1;
    const maxAmount2 = Number(formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals));
    const newAmount = Math.min(incrementedAmount, maxAmount2).toString();
    setAmount(newAmount);
  };
  const handleMax = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const maxAmount2 = formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals).toString();
    setAmount(maxAmount2);
  };
  const handlePaste = async () => {
    const result = await navigator.clipboard.readText();
    setToAddress(result);
  };
  const handleToAddressClear = () => {
    setToAddress("");
  };
  const executeTransaction = async (e2) => {
    var _a3, _b3;
    e2.preventDefault();
    if (!isCorrectChainId && isConnectorSequenceBased) {
      switchChain2({ chainId });
    }
    const sendAmount = parseUnits$2(amountToSendFormatted, decimals);
    switch (contractType) {
      case "ERC721":
        analytics == null ? void 0 : analytics.track({
          event: "SEND_TRANSACTION_REQUEST",
          props: {
            walletClient: ((_a3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a3.id) || "unknown",
            source: "sequence-kit/wallet"
          }
        });
        setIsSendTxnPending(true);
        sendTransaction2({
          to: tokenBalance.contractAddress,
          data: new Interface(ERC_721_ABI).encodeFunctionData("safeTransferFrom", [
            accountAddress,
            toAddress,
            tokenId
          ]),
          gas: null
        }, {
          onSettled: (result) => {
            if (result) {
              setNavigation({
                location: "home"
              });
            }
            setIsSendTxnPending(false);
          }
        });
        break;
      case "ERC1155":
      default:
        analytics == null ? void 0 : analytics.track({
          event: "SEND_TRANSACTION_REQUEST",
          props: {
            walletClient: ((_b3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _b3.id) || "unknown",
            source: "sequence-kit/wallet"
          }
        });
        setIsSendTxnPending(true);
        sendTransaction2({
          to: tokenBalance.contractAddress,
          data: new Interface(ERC_1155_ABI).encodeFunctionData("safeBatchTransferFrom", [
            accountAddress,
            toAddress,
            [tokenId],
            [toQuantity(sendAmount)],
            []
          ]),
          gas: null
        }, {
          onSettled: (result) => {
            if (result) {
              setNavigation({
                location: "home"
              });
            }
            setIsSendTxnPending(false);
          }
        });
    }
  };
  const maxAmount = formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals).toString();
  const isMinimum = Number(amount) === 0;
  const isMaximum = Number(amount) >= Number(maxAmount);
  return jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", style: {
    marginTop: HEADER_HEIGHT
  }, gap: "2", flexDirection: "column", as: "form", onSubmit: executeTransaction, pointerEvents: isSendTxnPending ? "none" : "auto", children: [jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(SendItemInfo, { imageUrl, showSquareImage: true, decimals, name: name2, symbol: "", balance: (tokenBalance == null ? void 0 : tokenBalance.balance) || "0", chainId }), jsxRuntimeExports$1.jsx(NumericInput, { ref: amountInputRef, style: { fontSize: vars.fontSizes.xlarge, fontWeight: vars.fontWeights.bold }, name: "amount", value: amount, onChange: handleChangeAmount, disabled: !showAmountControls, controls: jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: showAmountControls && jsxRuntimeExports$1.jsxs(Box, { gap: "2", children: [jsxRuntimeExports$1.jsx(Button, { disabled: isMinimum, size: "xs", onClick: handleSubtractOne, leftIcon: SvgSubtractIcon }), jsxRuntimeExports$1.jsx(Button, { disabled: isMaximum, size: "xs", onClick: handleAddOne, leftIcon: SvgAddIcon }), jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Max", onClick: handleMax, "data-id": "maxCoin", flexShrink: "0" })] }) }) }), insufficientFunds && jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "negative", marginTop: "2", children: "Insufficient Balance" })] }), jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", children: "To" }), isEthAddress(toAddress) ? jsxRuntimeExports$1.jsxs(Card, { clickable: true, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", onClick: handleToAddressClear, style: { height: "52px" }, children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: toAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle(toAddress.substring(2), 8)}` })] }), jsxRuntimeExports$1.jsx(SvgCloseIcon, { size: "xs" })] }) : jsxRuntimeExports$1.jsx(TextInput, { value: toAddress, onChange: (ev) => setToAddress(ev.target.value), placeholder: `${nativeTokenInfo.name} Address (0x...)`, name: "to-address", "data-1p-ignore": true, controls: jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Paste", onClick: handlePaste, "data-id": "to-address", flexShrink: "0", leftIcon: SvgCopyIcon }) })] }), showSwitchNetwork && jsxRuntimeExports$1.jsxs(Box, { marginTop: "3", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "negative", marginBottom: "2", children: "The wallet is connected to the wrong network. Please switch network before proceeding" }), jsxRuntimeExports$1.jsx(Button, { marginTop: "2", width: "full", variant: "primary", type: "button", label: "Switch Network", onClick: () => switchChain2({ chainId }), disabled: isCorrectChainId, style: { height: "52px", borderRadius: vars.radii.md } })] }), jsxRuntimeExports$1.jsx(Box, { style: { height: "52px" }, alignItems: "center", justifyContent: "center", children: isSendTxnPending ? jsxRuntimeExports$1.jsx(Spinner, {}) : jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "3", width: "full", variant: "primary", type: "submit", disabled: !isNonZeroAmount || !isEthAddress(toAddress) || insufficientFunds || !isCorrectChainId && !isConnectorSequenceBased, label: "Send", rightIcon: SvgChevronRightIcon, style: { height: "52px", borderRadius: vars.radii.md } }) })] });
};
var dayjs_min = { exports: {} };
(function(module2, exports) {
  !function(t2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v3 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t3(e3, n3) {
      if (e3.date() < n3.date()) return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c2), s3 = n3 - i2 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p2]);
    }, w2 = function t3(e3, n3, r3) {
      var i2;
      if (!e3) return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i2 = s3), n3 && (D2[s3] = n3, i2 = s3);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1) return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i2 = a3;
      }
      return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;
    }, O2 = function(t3, e3) {
      if (S2(t3)) return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _(n3);
    }, b2 = v3;
    b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _ = function() {
      function M3(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3) return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e3)) return /* @__PURE__ */ new Date();
          if (e3 instanceof Date) return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($);
            if (r3) {
              var i2 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n3 = O2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m3.$g = function(t3, e3, n3) {
        return b2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
          var i2 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i2 : i2.endOf(a2);
        }, $2 = function(t4, e4) {
          return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return $2(v5 + "Hours", 0);
          case u2:
            return $2(v5 + "Minutes", 1);
          case s2:
            return $2(v5 + "Seconds", 2);
          case i:
            return $2(v5 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[b2.p(t3)]();
      }, m3.add = function(r3, f3) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $2 = b2.p(f3), y3 = function(t3) {
          var e3 = O2(l3);
          return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($2 === c2) return this.set(c2, this.$M + r3);
        if ($2 === h2) return this.set(h2, this.$y + r3);
        if ($2 === a2) return y3(1);
        if ($2 === o2) return y3(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
        return b2.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid()) return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i3, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s4);
        }, d3 = function(t4) {
          return b2.s(s3 % 12 || 12, t4, "0");
        }, $2 = f3 || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $2(s3, u3, true);
              case "A":
                return $2(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $2, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v5 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
          return b2.m(y3, m4);
        };
        switch (M4) {
          case h2:
            $2 = D3() / 12;
            break;
          case c2:
            $2 = D3();
            break;
          case f2:
            $2 = D3() / 3;
            break;
          case o2:
            $2 = (g3 - v5) / 6048e5;
            break;
          case a2:
            $2 = (g3 - v5) / 864e5;
            break;
          case u2:
            $2 = g3 / n2;
            break;
          case s2:
            $2 = g3 / e2;
            break;
          case i:
            $2 = g3 / t2;
            break;
          default:
            $2 = g3;
        }
        return l3 ? $2 : b2.a($2);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3) return this.$L;
        var n3 = this.clone(), r3 = w2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return b2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _.prototype;
    return O2.prototype = k2, [["$ms", r2], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
      k2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _, O2), t3.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs$1(dayjs_minExports);
const TransactionHistoryItem = ({ transaction: transaction2 }) => {
  var _a2;
  const { chains: chains2 } = useConfig();
  const { fiatCurrency } = useSettings();
  const { setNavigation } = useNavigation();
  const onClickTransaction = () => {
    setNavigation({
      location: "transaction-details",
      params: {
        transaction: transaction2
      }
    });
  };
  const tokenContractAddresses = [];
  (_a2 = transaction2.transfers) == null ? void 0 : _a2.forEach((transfer) => {
    const tokenContractAddress = transfer.contractAddress;
    if (!tokenContractAddresses.includes(tokenContractAddress)) {
      tokenContractAddresses.push(tokenContractAddress);
    }
  });
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices(tokenContractAddresses.map((contractAddress) => ({
    contractAddress,
    chainId: transaction2.chainId
  })));
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingCoinPrices || isPendingConversionRate;
  const { transfers } = transaction2;
  const getTransactionIconByType = (transferType) => {
    switch (transferType) {
      case TxnTransferType.SEND:
        return jsxRuntimeExports$1.jsx(SvgArrowRightIcon, { style: {
          transform: "rotate(270deg)",
          width: "16px"
        } });
      case TxnTransferType.RECEIVE:
        return jsxRuntimeExports$1.jsx(SvgArrowRightIcon, { style: {
          transform: "rotate(90deg)",
          width: "16px"
        } });
      case TxnTransferType.UNKNOWN:
      default:
        return jsxRuntimeExports$1.jsx(SvgTransactionIcon, { style: { width: "14px" } });
    }
  };
  const getTansactionLabelByType = (transferType) => {
    switch (transferType) {
      case TxnTransferType.SEND:
        return "Sent";
      case TxnTransferType.RECEIVE:
        return "Received";
      case TxnTransferType.UNKNOWN:
      default:
        return "Transacted";
    }
  };
  const getTransferAmountLabel = (amount, symbol, transferType) => {
    let sign = "";
    if (transferType === TxnTransferType.SEND) {
      sign = "-";
    } else if (transferType === TxnTransferType.RECEIVE) {
      sign = "+";
    }
    let textColor = "text50";
    if (transferType === TxnTransferType.SEND) {
      textColor = vars.colors.negative;
    } else if (transferType === TxnTransferType.RECEIVE) {
      textColor = vars.colors.positive;
    }
    return jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", style: { color: textColor }, children: `${sign}${amount} ${symbol}` });
  };
  const getTransfer = ({ transfer, isFirstItem }) => {
    const { amounts } = transfer;
    const date = dayjs(transaction2.timestamp).format("MMM DD, YYYY");
    return jsxRuntimeExports$1.jsxs(Box, { gap: "2", width: "full", flexDirection: "column", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { color: "text50", gap: "1", flexDirection: "row", justifyContent: "center", alignItems: "center", children: [getTransactionIconByType(transfer.transferType), jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text100", children: getTansactionLabelByType(transfer.transferType) }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId: transaction2.chainId, size: "xs" })] }), isFirstItem && jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: date }) })] }), amounts.map((amount, index2) => {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
      const nativeTokenInfo = getNativeTokenInfoByChainId(transaction2.chainId, chains2);
      const isNativeToken = compareAddress(transfer.contractAddress, ZeroAddress);
      const isCollectible = ((_a3 = transfer.contractInfo) == null ? void 0 : _a3.type) === "ERC721" || ((_b2 = transfer.contractInfo) == null ? void 0 : _b2.type) === "ERC1155";
      let decimals;
      const tokenId = (_c2 = transfer.tokenIds) == null ? void 0 : _c2[index2];
      if (isCollectible && tokenId) {
        decimals = ((_e2 = (_d2 = transfer.tokenMetadata) == null ? void 0 : _d2[tokenId]) == null ? void 0 : _e2.decimals) || 0;
      } else {
        decimals = isNativeToken ? nativeTokenInfo.decimals : (_f2 = transfer.contractInfo) == null ? void 0 : _f2.decimals;
      }
      const amountValue = formatUnits$1(amount, decimals);
      const symbol = isNativeToken ? nativeTokenInfo.symbol : ((_g2 = transfer.contractInfo) == null ? void 0 : _g2.symbol) || "";
      const tokenLogoUri = isNativeToken ? nativeTokenInfo.logoURI : (_h2 = transfer.contractInfo) == null ? void 0 : _h2.logoURI;
      const fiatConversionRate = (_j2 = (_i2 = coinPrices.find((coinPrice) => compareAddress(coinPrice.token.contractAddress, transfer.contractAddress))) == null ? void 0 : _i2.price) == null ? void 0 : _j2.value;
      return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", justifyContent: "center", alignItems: "center", children: [tokenLogoUri && jsxRuntimeExports$1.jsx(Image$1, { src: tokenLogoUri, width: "5", alt: "token logo" }), getTransferAmountLabel(formatDisplay(amountValue), symbol, transfer.transferType)] }), isPending && jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "35px", height: "20px" } }), fiatConversionRate && jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: `${fiatCurrency.sign}${(Number(amountValue) * fiatConversionRate * conversionRate).toFixed(2)}` })] }, index2);
    })] });
  };
  return jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, onClick: () => onClickTransaction(), children: transfers == null ? void 0 : transfers.map((transfer, position) => {
    return jsxRuntimeExports$1.jsx(Box, { width: "full", children: getTransfer({
      transfer,
      isFirstItem: position === 0
    }) }, `${transaction2.txnHash}-${position}`);
  }) });
};
const TransactionHistorySkeleton = () => {
  const getTransactionItem = () => {
    return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", width: "full", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "65px", height: "20px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "75px", height: "17px" } })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "120px", height: "20px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "35px", height: "17px" } })] })] });
  };
  return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "70px", height: "17px" } }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: Array(8).fill(null).map((_, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { borderRadius: "md", padding: "4", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", background: "backgroundSecondary", children: getTransactionItem() }, index2);
  }) })] });
};
const TransactionHistoryList = ({ transactions: transactions2, isPending, isFetchingNextPage }) => {
  const transactionPeriods = [
    {
      id: "today",
      label: "Today"
    },
    {
      id: "yesterday",
      label: "Yesterday"
    },
    {
      id: "week",
      label: "Last Week"
    },
    {
      id: "month",
      label: "Last Month"
    },
    {
      id: "year",
      label: "Last Year"
    },
    {
      id: "years",
      label: "Past Years"
    }
  ];
  const transactionsByTime = reactExports.useMemo(() => {
    const todayTreshold = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0)).getTime();
    const yesterdayTreshold = new Date((/* @__PURE__ */ new Date()).setDate(new Date(todayTreshold).getDate() - 1)).getTime();
    const weekTreshold = new Date((/* @__PURE__ */ new Date()).setDate((/* @__PURE__ */ new Date()).getDate() - 7)).getTime();
    const monthTreshold = new Date((/* @__PURE__ */ new Date()).setDate((/* @__PURE__ */ new Date()).getDate() - 30)).getTime();
    const yearTreshold = new Date((/* @__PURE__ */ new Date()).setDate((/* @__PURE__ */ new Date()).getDate() - 365)).getTime();
    const transactionsByTime2 = {
      today: [],
      yesterday: [],
      week: [],
      month: [],
      year: [],
      years: []
    };
    transactions2.forEach((transaction2) => {
      const transactionTime = new Date(transaction2.timestamp).getTime();
      if (transactionTime > todayTreshold) {
        transactionsByTime2.today.push(transaction2);
      } else if (transactionTime > yesterdayTreshold) {
        transactionsByTime2.yesterday.push(transaction2);
      } else if (transactionTime > weekTreshold) {
        transactionsByTime2.week.push(transaction2);
      } else if (transactionTime > monthTreshold) {
        transactionsByTime2.month.push(transaction2);
      } else if (transactionTime > yearTreshold) {
        transactionsByTime2.year.push(transaction2);
      } else {
        transactionsByTime2.years.push(transaction2);
      }
    });
    return transactionsByTime2;
  }, [transactions2]);
  if (isPending) {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: jsxRuntimeExports$1.jsx(TransactionHistorySkeleton, {}) });
  }
  const TimeLabel = ({ label }) => {
    return jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: label }) });
  };
  const TransactionsList = ({ transactions: transactions3 }) => {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: transactions3.map((transaction2, index2) => {
      return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: jsxRuntimeExports$1.jsx(TransactionHistoryItem, { transaction: transaction2 }) }, `${transaction2.txnHash}-${index2}`);
    }) });
  };
  return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "5", children: [transactionPeriods.map((period) => {
    const txs = transactionsByTime[period.id];
    if (txs.length === 0) {
      return null;
    }
    return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [jsxRuntimeExports$1.jsx(TimeLabel, { label: period.label }), jsxRuntimeExports$1.jsx(TransactionsList, { transactions: txs })] }, period.id);
  }), transactions2.length === 0 && jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [jsxRuntimeExports$1.jsx(TimeLabel, { label: "History" }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No Recent Transaction History Found" })] }), isFetchingNextPage && jsxRuntimeExports$1.jsx(Box, { margin: "4", alignItems: "center", justifyContent: "center", children: jsxRuntimeExports$1.jsx(Spinner, {}) })] });
};
const History = () => {
  const { selectedNetworks } = useSettings();
  const { address: accountAddress } = useAccount();
  const { data: transactionHistory = [], isPending: isPendingTransactionHistory } = useTransactionHistorySummary({
    accountAddress: accountAddress || "",
    chainIds: selectedNetworks
  });
  return jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", children: jsxRuntimeExports$1.jsx(TransactionHistoryList, { transactions: transactionHistory, isPending: isPendingTransactionHistory, isFetchingNextPage: false }) }) });
};
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
const MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name2 = key.name;
    src = name2;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
      }
    }
    path = createKeyPath(name2);
    id2 = createKeyId(name2);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list2 = [];
  let arr = false;
  const deepGet = (obj2, path2, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index2]) {
      list2.push(obj2);
    } else {
      let key = path2[index2];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index2 === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list2.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index2 + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index2 + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list2 : list2[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache2 = /* @__PURE__ */ new Map();
  const m2 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache2.has(numTokens)) {
        return cache2.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n2 = parseFloat(Math.round(norm2 * m2) / m2);
      cache2.set(numTokens, n2);
      return n2;
    },
    clear() {
      cache2.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item2, keyId) {
    return item2[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item2, k2) => {
              stack.push({
                nestedArrIndex: k2,
                value: item2
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors: errors2 = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance: distance2 = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors2 / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance2) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance2;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location: location2 = Config.location,
  distance: distance2 = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index2 + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask2 = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance: distance2,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j2 = finish; j2 >= start; j2 -= 1) {
      let currentLocation = j2 - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];
      }
      if (bitArr[j2] & mask2) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance: distance2,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask2 = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask2[char] = (mask2[char] || 0) | 1 << len - i - 1;
  }
  return mask2;
}
class BitapSearch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance: distance2,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location2 + startIndex,
        distance: distance2,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index2 = text2.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location2 = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text2.indexOf(this.pattern, location2)) > -1) {
      location2 = index2 + patternLen;
      indices.push([index2, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item2) => {
    let query = item2.trim().split(SPACE_RE).filter((item3) => item3 && !!item3.trim());
    let results2 = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results2.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results2.push(new searcher(token, options));
          break;
        }
      }
    }
    return results2;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance: distance2
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {
        const searcher = searchers2[j2];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse$1(query, options, { auto: auto2 = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item2) => {
          node.children.push(next(item2));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results2, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results2.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results2, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results2.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index2) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results2 = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results2.push(doc);
      }
    }
    return results2;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results2 = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results2, { ignoreFieldNorm });
    if (shouldSort) {
      results2.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results2 = results2.slice(0, limit);
    }
    return format(results2, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results2 = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results2.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results2;
  }
  _searchLogical(query) {
    const expression = parse$1(query, this.options);
    const evaluate2 = (node, item2, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item2, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item: item2,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate2(child, item2, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results2 = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (isDefined(item2)) {
        let expResults = evaluate2(expression, item2, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item: item2, matches: [] };
            results2.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results2;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results2 = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (!isDefined(item2)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item2[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results2.push({
          idx,
          item: item2,
          matches
        });
      }
    });
    return results2;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse$1;
}
{
  register(ExtendedSearch);
}
const BalanceItem = ({ balance }) => {
  var _a2, _b2, _c2;
  const { chains: chains2 } = useConfig();
  const { setNavigation } = useNavigation();
  const isNativeToken = compareAddress(balance.contractAddress, ZeroAddress);
  const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
  const logoURI = isNativeToken ? nativeTokenInfo.logoURI : (_a2 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _a2.logoURI;
  const tokenName = isNativeToken ? nativeTokenInfo.name : ((_b2 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _b2.name) || "Unknown";
  const symbol = isNativeToken ? nativeTokenInfo.symbol : (_c2 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _c2.symbol;
  const getQuantity = () => {
    var _a3, _b3;
    if (balance.contractType === "ERC721" || balance.contractType === "ERC1155") {
      return balance.balance;
    }
    const decimals = isNativeToken ? nativeTokenInfo.decimals : (_a3 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _a3.decimals;
    const bal = formatUnits$1(balance.balance, decimals || 0);
    const displayBalance = formatDisplay(bal);
    const symbol2 = isNativeToken ? nativeTokenInfo.symbol : (_b3 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _b3.symbol;
    return `${displayBalance} ${symbol2}`;
  };
  const onClick = () => {
    const isCollection = balance.contractType === "ERC721" || balance.contractType === "ERC1155";
    if (isCollection) {
      setNavigation({
        location: "collection-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    } else {
      setNavigation({
        location: "coin-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { onClick, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsxs(Box, { gap: "3", flexDirection: "row", alignItems: "center", justifyContent: "center", minWidth: "0", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: logoURI, symbol, size: "md", withNetwork: balance.chainId }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", fontWeight: "bold", overflow: "hidden", whiteSpace: "nowrap", ellipsis: true, children: tokenName })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "1", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "bold", textAlign: "right", whiteSpace: "nowrap", children: getQuantity() }), jsxRuntimeExports$1.jsx(SvgChevronRightIcon, { color: "text50" })] })] }, balance.contractAddress);
};
const WalletLink = ({ toLocation, label }) => {
  const { setNavigation } = useNavigation();
  const onClick = () => {
    setNavigation(toLocation);
  };
  return jsxRuntimeExports$1.jsxs(Box, { onClick, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: label }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: "View all" }), jsxRuntimeExports$1.jsx(SvgChevronRightIcon, { color: "text50", size: "sm" })] })] });
};
const SearchWallet = () => {
  const { chains: chains2 } = useConfig();
  const { fiatCurrency, hideUnlistedTokens, selectedNetworks } = useSettings();
  const [search2, setSearch] = reactExports.useState("");
  const { address: accountAddress } = useAccount();
  const { data: tokenBalancesData, isPending: isPendingTokenBalances } = useBalances({
    chainIds: selectedNetworks,
    accountAddress: accountAddress || "",
    verifiedOnly: hideUnlistedTokens
  });
  const coinBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC20" || compareAddress(b2.contractAddress, ZeroAddress))) || [];
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices(coinBalancesUnordered.map((token) => ({
    chainId: token.chainId,
    contractAddress: token.contractAddress
  })));
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const coinBalances = coinBalancesUnordered.sort((a2, b2) => {
    var _a2, _b2;
    const isHigherFiat = Number(computeBalanceFiat({
      balance: b2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_a2 = b2.contractInfo) == null ? void 0 : _a2.decimals) || 18
    })) - Number(computeBalanceFiat({
      balance: a2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_b2 = b2.contractInfo) == null ? void 0 : _b2.decimals) || 18
    }));
    return isHigherFiat;
  });
  const collectionBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC721" || b2.contractType === "ERC1155")) || [];
  const collectionBalances = collectionBalancesUnordered.sort((a2, b2) => {
    return Number(b2.balance) - Number(a2.balance);
  });
  const isPending = isPendingTokenBalances || isPendingCoinPrices || isPendingConversionRate;
  const indexedCollectionBalances = collectionBalances.map((balance, index2) => {
    var _a2;
    return {
      index: index2,
      name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
    };
  });
  const indexedCoinBalances = coinBalances.map((balance, index2) => {
    var _a2;
    if (compareAddress(balance.contractAddress, ZeroAddress)) {
      const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
      return {
        index: index2,
        name: nativeTokenInfo.name
      };
    } else {
      return {
        index: index2,
        name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
      };
    }
  });
  const coinBalancesAmount = coinBalances.length;
  const collectionBalancesAmount = collectionBalances.length;
  const fuzzySearchCoinBalances = new Fuse(indexedCoinBalances, {
    keys: ["name"]
  });
  const fuzzySearchCollections = new Fuse(indexedCollectionBalances, {
    keys: ["name"]
  });
  const foundCoinBalances = (search2 === "" ? indexedCoinBalances : fuzzySearchCoinBalances.search(search2).map((result) => result.item)).slice(0, 5);
  const foundCollectionBalances = (search2 === "" ? indexedCollectionBalances : fuzzySearchCollections.search(search2).map((result) => result.item)).slice(0, 5);
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", flexDirection: "column", gap: "10", alignItems: "center", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(Box, { width: "full", children: jsxRuntimeExports$1.jsx(TextInput, { autoFocus: true, name: "search wallet", leftIcon: SvgSearchIcon, value: search2, onChange: (ev) => setSearch(ev.target.value), placeholder: "Search your wallet", "data-1p-ignore": true }) }), jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "5", children: [jsxRuntimeExports$1.jsx(WalletLink, { toLocation: {
    location: "search-view-all",
    params: {
      defaultTab: "collections"
    }
  }, label: `Collections (${collectionBalancesAmount})` }), isPending ? Array(5).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", height: "8" }, i)) : foundCollectionBalances.length === 0 ? jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No collections found" }) : foundCollectionBalances.map((indexedItem, index2) => {
    const balance = collectionBalances[indexedItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance }, index2);
  })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "5", children: [jsxRuntimeExports$1.jsx(WalletLink, { toLocation: {
    location: "search-view-all",
    params: {
      defaultTab: "coins"
    }
  }, label: `Coins (${coinBalancesAmount})` }), isPending ? Array(5).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", height: "8" }, i)) : foundCoinBalances.length === 0 ? jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No coins found" }) : foundCoinBalances.map((indexItem, index2) => {
    const balance = coinBalances[indexItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance }, index2);
  })] })] });
};
const SearchWalletViewAll = ({ defaultTab }) => {
  const { chains: chains2 } = useConfig();
  const { fiatCurrency, hideUnlistedTokens, selectedNetworks } = useSettings();
  const [search2, setSearch] = reactExports.useState("");
  const [selectedTab, setSelectedTab] = reactExports.useState(defaultTab);
  reactExports.useEffect(() => {
    setSearch("");
  }, [selectedTab]);
  const { address: accountAddress } = useAccount();
  const { data: tokenBalancesData, isPending: isPendingTokenBalances } = useBalances({
    chainIds: selectedNetworks,
    accountAddress: accountAddress || "",
    verifiedOnly: hideUnlistedTokens
  });
  const coinBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC20" || compareAddress(b2.contractAddress, ZeroAddress))) || [];
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices(coinBalancesUnordered.map((token) => ({
    chainId: token.chainId,
    contractAddress: token.contractAddress
  })));
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const coinBalances = coinBalancesUnordered.sort((a2, b2) => {
    var _a2, _b2;
    const isHigherFiat = Number(computeBalanceFiat({
      balance: b2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_a2 = b2.contractInfo) == null ? void 0 : _a2.decimals) || 18
    })) - Number(computeBalanceFiat({
      balance: a2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_b2 = a2.contractInfo) == null ? void 0 : _b2.decimals) || 18
    }));
    return isHigherFiat;
  });
  const collectionBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC721" || b2.contractType === "ERC1155")) || [];
  const collectionBalances = collectionBalancesUnordered.sort((a2, b2) => {
    return Number(b2.balance) - Number(a2.balance);
  });
  const coinBalancesAmount = coinBalances.length;
  const collectionBalancesAmount = collectionBalances.length;
  const isPending = isPendingTokenBalances || isPendingCoinPrices || isPendingConversionRate;
  const indexedCollectionBalances = collectionBalances.map((balance, index2) => {
    var _a2;
    return {
      index: index2,
      name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
    };
  });
  const indexedCoinBalances = coinBalances.map((balance, index2) => {
    var _a2;
    if (compareAddress(balance.contractAddress, ZeroAddress)) {
      const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
      return {
        index: index2,
        name: nativeTokenInfo.name
      };
    } else {
      return {
        index: index2,
        name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
      };
    }
  });
  const fuzzySearchCoinBalances = new Fuse(indexedCoinBalances, {
    keys: ["name"]
  });
  const fuzzySearchCollections = new Fuse(indexedCollectionBalances, {
    keys: ["name"]
  });
  const foundCoinBalances = search2 === "" ? indexedCoinBalances : fuzzySearchCoinBalances.search(search2).map((result) => result.item);
  const foundCollectionBalances = search2 === "" ? indexedCollectionBalances : fuzzySearchCollections.search(search2).map((result) => result.item);
  const TabsHeaderSkeleton = () => {
    return jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "360px", height: "48px" } });
  };
  const ItemsSkeletons = () => {
    return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: Array(8).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", height: "8" }, i)) });
  };
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", flexDirection: "column", gap: "5", alignItems: "center", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(Box, { width: "full", children: jsxRuntimeExports$1.jsx(TextInput, { autoFocus: true, name: "search wallet", leftIcon: SvgSearchIcon, value: search2, onChange: (ev) => setSearch(ev.target.value), placeholder: "Search your wallet", "data-1p-ignore": true }) }), jsxRuntimeExports$1.jsx(Box, { width: "full", children: jsxRuntimeExports$1.jsxs(TabsRoot, { value: selectedTab, onValueChange: (value) => setSelectedTab(value), children: [jsxRuntimeExports$1.jsxs(Box, { marginBottom: "5", children: [!isPending && jsxRuntimeExports$1.jsx(TabsHeader, { value: selectedTab, tabs: [
    { label: `Collections (${collectionBalancesAmount})`, value: "collections" },
    { label: `Coins (${coinBalancesAmount})`, value: "coins" }
  ] }), isPending && jsxRuntimeExports$1.jsx(TabsHeaderSkeleton, {})] }), jsxRuntimeExports$1.jsx(TabsContent, { value: "collections", children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [isPending && jsxRuntimeExports$1.jsx(ItemsSkeletons, {}), !isPending && foundCollectionBalances.length === 0 && jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No Collectibles Found" }), !isPending && foundCollectionBalances.length > 0 && foundCollectionBalances.map((indexItem, index2) => {
    const collectionBalance = collectionBalances[indexItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance: collectionBalance }, index2);
  })] }) }), jsxRuntimeExports$1.jsx(TabsContent, { value: "coins", children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [isPending && jsxRuntimeExports$1.jsx(ItemsSkeletons, {}), !isPending && coinBalances.length == 0 && jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No Coins Found" }), !isPending && foundCoinBalances.length > 0 && foundCoinBalances.map((indexedItem, index2) => {
    const coinBalance = coinBalances[indexedItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance: coinBalance }, index2);
  })] }) })] }) })] });
};
const SettingsMenu = () => {
  const { setNavigation } = useNavigation();
  const onClickGeneral = () => {
    setNavigation({
      location: "settings-general"
    });
  };
  const onClickCurrency = () => {
    setNavigation({
      location: "settings-currency"
    });
  };
  const onClickNetworks = () => {
    setNavigation({
      location: "settings-networks"
    });
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsx(Box, { padding: "5", paddingTop: "3", children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", children: [jsxRuntimeExports$1.jsx(Button, { onClick: onClickGeneral, leftIcon: SvgSettingsIcon, rightIcon: SvgChevronRightIcon, width: "full", label: "General", style: {
    height: "52px",
    borderRadius: vars.radii.md
  } }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickCurrency, leftIcon: SvgCurrencyIcon, rightIcon: SvgChevronRightIcon, width: "full", label: "Currency", style: {
    height: "52px",
    borderRadius: vars.radii.md
  } }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickNetworks, leftIcon: SvgNetworkIcon, rightIcon: SvgChevronRightIcon, width: "full", label: "Networks", style: {
    height: "52px",
    borderRadius: vars.radii.md
  } })] }) }) });
};
const SettingsGeneral = () => {
  const { hideUnlistedTokens, setHideUnlistedTokens, hideCollectibles, setHideCollectibles } = useSettings();
  const onChangeHideUnlistedTokens = () => {
    setHideUnlistedTokens(!hideUnlistedTokens);
  };
  const onChangeHideCollectibles = () => {
    setHideCollectibles(!hideCollectibles);
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { gap: "2", padding: "5", paddingTop: "3", flexDirection: "column", children: [jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", children: "Hide unlisted tokens" }), jsxRuntimeExports$1.jsx(Switch, { checked: hideUnlistedTokens, onCheckedChange: onChangeHideUnlistedTokens })] }), jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", children: "Hide collectibles" }), jsxRuntimeExports$1.jsx(Switch, { checked: hideCollectibles, onCheckedChange: onChangeHideCollectibles })] })] }) });
};
const SelectedIndicator = (props) => {
  const { selected, className, squareIndicator = false } = props;
  return jsxRuntimeExports$1.jsx(Box, { borderStyle: "solid", borderColor: squareIndicator && selected ? "transparent" : "borderNormal", borderWidth: "thin", position: "relative", alignItems: "center", justifyContent: "center", flexShrink: "0", className, style: {
    borderRadius: squareIndicator ? "4px" : vars.radii.circle,
    width: "20px",
    height: "20px"
  }, children: jsxRuntimeExports$1.jsx(Box, { as: motion.div, background: squareIndicator ? "borderNormal" : "backgroundInverse", position: "absolute", color: "textInverse100", initial: { opacity: selected ? 1 : 0, scale: selected ? 1 : 0.5 }, animate: { opacity: selected ? 1 : 0, scale: selected ? 1 : 0.5 }, transition: { ease: "backOut" }, style: {
    borderRadius: squareIndicator ? "4px" : vars.radii.circle,
    width: squareIndicator ? "20px" : "14px",
    height: squareIndicator ? "20px" : "14px"
  }, justifyContent: "center", alignItems: "center", children: squareIndicator && jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { color: "white", style: { width: "14px", height: "14px" } }) }) });
};
const SelectButton = (props) => {
  const { value, selected, children, disabled, onClick, className, hideIndicator, squareIndicator = false, ...rest } = props;
  return jsxRuntimeExports$1.jsxs(Card, { as: "button", clickable: true, className, disabled, onClick: () => onClick(value), userSelect: "none", alignItems: "center", justifyContent: "space-between", textAlign: "left", width: "full", border: "none", style: {
    appearance: "none"
  }, ...rest, children: [children, !hideIndicator && jsxRuntimeExports$1.jsx(SelectedIndicator, { selected, squareIndicator })] });
};
const SettingsCurrency = () => {
  const { fiatCurrency, setFiatCurrency } = useSettings();
  return jsxRuntimeExports$1.jsx(Box, { paddingBottom: "5", paddingX: "4", paddingTop: "3", children: jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: supportedFiatCurrencies.map((currency) => {
    return jsxRuntimeExports$1.jsx(SelectButton, { value: currency.symbol, selected: currency.symbol === fiatCurrency.symbol, onClick: () => setFiatCurrency && setFiatCurrency(currency), children: jsxRuntimeExports$1.jsxs(Box, { gap: "2", justifyContent: "flex-start", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", children: currency.symbol }), jsxRuntimeExports$1.jsx(Text, { color: "text50", children: currency.name.message })] }) }, currency.symbol);
  }) }) });
};
const SettingsNetwork = () => {
  const { selectedNetworks, setSelectedNetworks } = useSettings();
  const { chains: chains2 } = useConfig();
  const onClickNetwork = (chainId) => {
    if (selectedNetworks.includes(chainId)) {
      if (selectedNetworks.length === 1) {
        return;
      }
      setSelectedNetworks(selectedNetworks.filter((id2) => id2 !== chainId));
    } else {
      setSelectedNetworks([...selectedNetworks, chainId]);
    }
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", fontWeight: "bold", color: "text50", children: "Networks" }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", marginTop: "4", children: chains2.map((chain) => {
    return jsxRuntimeExports$1.jsx(SelectButton, { disabled: selectedNetworks.length === 1 && selectedNetworks.includes(chain.id), selected: selectedNetworks.includes(chain.id), onClick: () => onClickNetwork(chain.id), value: chain.id, squareIndicator: true, children: jsxRuntimeExports$1.jsxs(Box, { gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: `https://assets.sequence.info/images/networks/medium/${chain.id}.webp` }), jsxRuntimeExports$1.jsx(Text, { color: "text100", variant: "normal", fontWeight: "bold", children: chain.name })] }) }, chain.id);
  }) })] }) });
};
const useIntersectionObserver = (ref, options) => {
  const [entry, setEntry] = reactExports.useState(null);
  const observer = reactExports.useMemo(() => new IntersectionObserver(([entry2]) => setEntry(entry2), options), []);
  reactExports.useEffect(() => {
    if (ref.current) {
      observer.observe(ref.current);
    }
    return () => {
      if (ref.current) {
        observer.disconnect();
      }
    };
  }, [ref.current, observer]);
  return (entry == null ? void 0 : entry.isIntersecting) ?? false;
};
const InfiniteScroll = (props) => {
  const { onLoad, hasMore = true, children } = props;
  const [pageNumber, setPageNumber] = reactExports.useState(0);
  const [isLoading, setLoading] = reactExports.useState(false);
  const bottomRef = reactExports.useRef(null);
  const isBottom = useIntersectionObserver(bottomRef);
  reactExports.useEffect(() => {
    if (isBottom && hasMore && !isLoading) {
      handleLoad();
    }
  }, [isBottom]);
  const handleLoad = async () => {
    setLoading(true);
    await onLoad(pageNumber);
    setPageNumber((pageNumber2) => pageNumber2 + 1);
    setLoading(false);
  };
  return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [children, jsxRuntimeExports$1.jsx("div", { ref: bottomRef })] });
};
const NetworkBadge = ({ chainId }) => {
  const network2 = getNetwork(chainId);
  const chainColor = getNetworkColor(chainId);
  const chainBGColor = getNetworkBackgroundColor(chainId);
  return jsxRuntimeExports$1.jsxs(Box, { height: "6", paddingX: "2", gap: "1", style: {
    background: chainBGColor
  }, borderRadius: "xs", flexDirection: "row", justifyContent: "center", alignItems: "center", width: "fit", children: [jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { variant: "xsmall", fontWeight: "bold", capitalize: true, ellipsis: true, style: {
    color: chainColor
  }, children: network2.title ?? network2.name })] });
};
const CoinDetailsSkeleton = ({ chainId }) => {
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: { marginTop: "-20px" }, children: [jsxRuntimeExports$1.jsxs(Box, { marginBottom: "10", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "32px", height: "32px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { height: "24px", width: "70px" } }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "150px", height: "36px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "33px", height: "17px" } })] })] }), jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "4", marginBottom: "10", width: "full", variant: "primary", leftIcon: SvgSendIcon, label: "Send", disabled: true, onClick: () => {
  } }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(TransactionHistorySkeleton, {}) })] }) });
};
const CoinDetails = ({ contractAddress, chainId }) => {
  var _a2, _b2, _c2, _d2;
  const { chains: chains2 } = useConfig();
  const { setNavigation } = useNavigation();
  const { fiatCurrency, hideUnlistedTokens } = useSettings();
  const { address: accountAddress } = useAccount();
  const { data: dataTransactionHistory, isPending: isPendingTransactionHistory, fetchNextPage, hasNextPage: hasNextPage2, isFetchingNextPage } = useTransactionHistory({
    chainId,
    accountAddress: accountAddress || "",
    contractAddress
  });
  const transactionHistory = flattenPaginatedTransactionHistory(dataTransactionHistory);
  const { data: dataCoinBalance, isPending: isPendingCoinBalance } = useCoinBalance({
    accountAddress: accountAddress || "",
    contractAddress,
    chainId,
    verifiedOnly: hideUnlistedTokens
  });
  const { data: dataCoinPrices, isPending: isPendingCoinPrices } = useCoinPrices([
    {
      chainId,
      contractAddress
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingCoinBalance || isPendingCoinPrices || isPendingConversionRate;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(CoinDetailsSkeleton, { chainId });
  }
  const isNativeToken = compareAddress(contractAddress, ZeroAddress);
  const logo = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).logoURI : (_a2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _a2.logoURI;
  const symbol = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).symbol : (_b2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _b2.symbol;
  const name2 = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).name : (_c2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _c2.name;
  const decimals = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).decimals : (_d2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _d2.decimals;
  const formattedBalance = formatUnits$1((dataCoinBalance == null ? void 0 : dataCoinBalance.balance) || "0", decimals);
  const balanceDisplayed = formatDisplay(formattedBalance);
  const coinBalanceFiat = dataCoinBalance ? computeBalanceFiat({
    balance: dataCoinBalance,
    prices: dataCoinPrices || [],
    conversionRate,
    decimals: decimals || 0
  }) : "0";
  const onClickSend = () => {
    setNavigation({
      location: "send-coin",
      params: {
        chainId,
        contractAddress
      }
    });
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: { marginTop: "-20px" }, children: [jsxRuntimeExports$1.jsxs(Box, { marginBottom: "10", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: logo, size: "xl" }), jsxRuntimeExports$1.jsx(Text, { variant: "large", color: "text100", fontWeight: "bold", children: name2 }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Text, { variant: "xlarge", fontWeight: "bold", color: "text100", children: `${balanceDisplayed} ${symbol}` }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: `${fiatCurrency.sign}${coinBalanceFiat}` })] })] }), jsxRuntimeExports$1.jsx(Button, { width: "full", variant: "primary", leftIcon: SvgSendIcon, color: "text100", label: "Send", onClick: onClickSend }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(InfiniteScroll, { onLoad: () => fetchNextPage(), hasMore: hasNextPage2, children: jsxRuntimeExports$1.jsx(TransactionHistoryList, { transactions: transactionHistory, isPending: isPendingTransactionHistory, isFetchingNextPage }) }) })] }) });
};
const CollectionDetailsSkeleton = ({ chainId }) => {
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", marginTop: "8", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "10", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "32px", height: "32px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "100px", height: "24px" } }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "142px", height: "17px" } })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "168px", height: "20px" } }), jsxRuntimeExports$1.jsx(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, width: "full", marginTop: "3", children: Array(8).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", aspectRatio: "1/1" }, i)) })] })] });
};
const CollectionDetails = ({ chainId, contractAddress }) => {
  var _a2;
  const { setNavigation } = useNavigation();
  const { address: accountAddress } = useAccount();
  const { data: collectionBalanceData, isPending: isPendingCollectionBalance } = useCollectionBalance({
    chainId,
    accountAddress: accountAddress || "",
    contractAddress
  });
  const contractInfo = (_a2 = collectionBalanceData == null ? void 0 : collectionBalanceData[0]) == null ? void 0 : _a2.contractInfo;
  const collectionLogoURI = contractInfo == null ? void 0 : contractInfo.logoURI;
  if (isPendingCollectionBalance) {
    return jsxRuntimeExports$1.jsx(CollectionDetailsSkeleton, { chainId });
  }
  const onClickItem = (balance) => {
    setNavigation && setNavigation({
      location: "collectible-details",
      params: {
        contractAddress: balance.contractAddress,
        chainId: balance.chainId,
        tokenId: balance.tokenID || ""
      }
    });
  };
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", marginTop: "8", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "10", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: collectionLogoURI, size: "lg" }), jsxRuntimeExports$1.jsx(Text, { variant: "large", fontWeight: "bold", color: "text100", children: (contractInfo == null ? void 0 : contractInfo.name) || "Unknown" }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: `${(collectionBalanceData == null ? void 0 : collectionBalanceData.length) || 0} Unique Collectibles` })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: `Owned (${(collectionBalanceData == null ? void 0 : collectionBalanceData.length) || 0})` }), jsxRuntimeExports$1.jsx(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, width: "full", marginTop: "3", children: collectionBalanceData == null ? void 0 : collectionBalanceData.map((balance, index2) => {
    var _a3, _b2, _c2;
    const unformattedBalance = balance.balance;
    const decimals = ((_a3 = balance == null ? void 0 : balance.tokenMetadata) == null ? void 0 : _a3.decimals) || 0;
    const formattedBalance = formatDisplay(formatUnits$1(unformattedBalance, decimals));
    return jsxRuntimeExports$1.jsxs(Box, { onClick: () => onClickItem(balance), userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", aspectRatio: "1/1", width: "full", borderRadius: "md", justifyContent: "center", alignItems: "center", marginBottom: "2", children: jsxRuntimeExports$1.jsx(Image$1, { style: { height: "100%" }, src: (_b2 = balance.tokenMetadata) == null ? void 0 : _b2.image }) }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: `${(_c2 = balance.tokenMetadata) == null ? void 0 : _c2.name}` }) }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsxs(Text, { variant: "normal", marginTop: "1", fontWeight: "medium", color: "text50", children: [formattedBalance, " Owned"] }) })] }, index2);
  }) })] })] });
};
const CollectibleDetailsSkeleton = () => {
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: {
    marginTop: "-20px"
  }, children: [jsxRuntimeExports$1.jsxs(Box, { gap: "3", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "120px", height: "30px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "140px", height: "40px" } })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "347px", height: "347px" } }) }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "44px", height: "36px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "34px", height: "17px" } })] })] }), jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "4", width: "full", variant: "primary", leftIcon: SvgSendIcon, label: "Send", onClick: () => {
  } })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: "This week" }), jsxRuntimeExports$1.jsx(TransactionHistorySkeleton, {})] })] }) });
};
const CollectibleDetails = ({ contractAddress, chainId, tokenId }) => {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const { address: accountAddress } = useAccount();
  const { fiatCurrency } = useSettings();
  const { setNavigation } = useNavigation();
  const { data: dataTransactionHistory, isPending: isPendingTransactionHistory, fetchNextPage, hasNextPage: hasNextPage2, isFetchingNextPage } = useTransactionHistory({
    chainId,
    accountAddress: accountAddress || "",
    contractAddress,
    tokenId
  });
  const transactionHistory = flattenPaginatedTransactionHistory(dataTransactionHistory);
  const { data: dataCollectibleBalance, isPending: isPendingCollectibleBalance } = useCollectibleBalance({
    accountAddress: accountAddress || "",
    contractAddress,
    chainId,
    tokenId,
    verifiedOnly: false
  });
  const { data: dataCollectiblePrices, isPending: isPendingCollectiblePrices } = useCollectiblePrices([
    {
      chainId,
      contractAddress,
      tokenId
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingCollectibleBalance || isPendingCollectiblePrices || isPendingConversionRate;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(CollectibleDetailsSkeleton, {});
  }
  const onClickSend = () => {
    setNavigation({
      location: "send-collectible",
      params: {
        chainId,
        contractAddress,
        tokenId
      }
    });
  };
  const collectionLogo = (_a2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.contractInfo) == null ? void 0 : _a2.logoURI;
  const collectionName = ((_b2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.contractInfo) == null ? void 0 : _b2.name) || "Unknown Collection";
  const decimals = ((_c2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.tokenMetadata) == null ? void 0 : _c2.decimals) || 0;
  const rawBalance = (dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.balance) || "0";
  const balance = formatUnits$1(rawBalance, decimals);
  const formattedBalance = formatDisplay(Number(balance));
  const valueFiat = dataCollectibleBalance ? computeBalanceFiat({
    balance: dataCollectibleBalance,
    prices: dataCollectiblePrices || [],
    conversionRate,
    decimals
  }) : "0";
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: {
    marginTop: "-20px"
  }, children: [jsxRuntimeExports$1.jsxs(Box, { gap: "3", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Image$1, { borderRadius: "circle", width: "8", src: collectionLogo, alt: "collection logo", style: {
    objectFit: "cover"
  } }), jsxRuntimeExports$1.jsxs(Box, { gap: "1", flexDirection: "row", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", fontWeight: "bold", color: "text100", children: collectionName }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { variant: "large", color: "text100", fontWeight: "bold", children: ((_d2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.tokenMetadata) == null ? void 0 : _d2.name) || "Unknown Collectible" }), jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", fontWeight: "medium", children: `#${tokenId}` })] })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(CollectibleTileImage, { imageUrl: (_e2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.tokenMetadata) == null ? void 0 : _e2.image }) }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Text, { variant: "xlarge", fontWeight: "bold", color: "text100", children: formattedBalance }), dataCollectiblePrices && ((_f2 = dataCollectiblePrices[0].price) == null ? void 0 : _f2.value) && jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: `${fiatCurrency.symbol} ${valueFiat}` })] })] }), jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "4", width: "full", variant: "primary", leftIcon: SvgSendIcon, label: "Send", onClick: onClickSend })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(InfiniteScroll, { onLoad: () => fetchNextPage(), hasMore: hasNextPage2, children: jsxRuntimeExports$1.jsx(TransactionHistoryList, { transactions: transactionHistory, isPending: isPendingTransactionHistory, isFetchingNextPage }) }) })] }) });
};
const CopyButton = (props) => {
  const { buttonVariant = "icon", text: text2, size: size2 = "xs", ...rest } = props;
  const [isCopied, setCopy] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isCopied) {
      setTimeout(() => {
        setCopy(false);
      }, 4e3);
    }
  }, [isCopied]);
  const handleCopy = () => {
    setCopy(true);
  };
  const label = isCopied ? "Copied!" : "Copy";
  const backgroundColor = buttonVariant === "icon" ? "rgba(0,0,0,0)" : vars.colors.buttonGlass;
  return jsxRuntimeExports$1.jsx(lib.CopyToClipboard, { text: text2, onCopy: handleCopy, children: jsxRuntimeExports$1.jsx(IconButton, { size: size2, icon: isCopied ? SvgCheckmarkIcon : SvgCopyIcon, ...rest, style: { background: backgroundColor, ...props == null ? void 0 : props.style }, label: buttonVariant === "with-label" ? label : void 0 }) });
};
const TransactionDetails = ({ transaction: transaction2 }) => {
  var _a2, _b2;
  const { chains: chains2 } = useConfig();
  const { fiatCurrency } = useSettings();
  const coins = [];
  const collectibles = [];
  (_a2 = transaction2.transfers) == null ? void 0 : _a2.forEach((transfer) => {
    var _a3, _b3, _c2, _d2;
    if (((_a3 = transfer.contractInfo) == null ? void 0 : _a3.type) === "ERC721" || ((_b3 = transfer.contractInfo) == null ? void 0 : _b3.type) === "ERC1155") {
      (_c2 = transfer.tokenIds) == null ? void 0 : _c2.forEach((tokenId) => {
        var _a4;
        const foundCollectible = collectibles.find((collectible) => {
          var _a5;
          return collectible.chainId === transaction2.chainId && compareAddress(collectible.contractAddress, ((_a5 = transfer.contractInfo) == null ? void 0 : _a5.address) || "") && collectible.tokenId === tokenId;
        });
        if (!foundCollectible) {
          collectibles.push({
            chainId: transaction2.chainId,
            contractAddress: ((_a4 = transfer.contractInfo) == null ? void 0 : _a4.address) || "",
            tokenId
          });
        }
      });
    } else {
      const contractAddress = ((_d2 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _d2.address) || ZeroAddress;
      const foundCoin = coins.find((coin) => coin.chainId === transaction2.chainId && compareAddress(coin.contractAddress, contractAddress));
      if (!foundCoin) {
        coins.push({
          chainId: transaction2.chainId,
          contractAddress
        });
      }
    }
  });
  const { data: coinPricesData, isPending: isPendingCoinPrices } = useCoinPrices(coins);
  const { data: collectiblePricesData, isPending: isPendingCollectiblePrices } = useCollectiblePrices(collectibles);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const arePricesLoading = coins.length > 0 && isPendingCoinPrices || collectibles.length > 0 && isPendingCollectiblePrices || isPendingConversionRate;
  const nativeTokenInfo = getNativeTokenInfoByChainId(transaction2.chainId, chains2);
  const date = dayjs(transaction2.timestamp).format("ddd MMM DD YYYY, h:m:s a");
  const onClickBlockExplorer = () => {
    if (typeof window !== "undefined") {
      window.open(`${nativeTokenInfo.blockExplorerUrl}/tx/${transaction2.txnHash}`, "_blank");
    }
  };
  const Transfer = ({ transfer }) => {
    var _a3, _b3, _c2, _d2;
    const recipientAddress = transfer.to;
    const recipientAddressFormatted = recipientAddress.substring(0, 10) + "..." + recipientAddress.substring(transfer.to.length - 4, transfer.to.length);
    const isNativeToken = compareAddress(((_a3 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _a3.address) || "", ZeroAddress);
    const logoURI = isNativeToken ? nativeTokenInfo.logoURI : (_b3 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _b3.logoURI;
    const symbol = isNativeToken ? nativeTokenInfo.symbol : ((_c2 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _c2.symbol) || "";
    return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: (_d2 = transfer.amounts) == null ? void 0 : _d2.map((amount, index2) => {
      var _a4, _b4, _c3, _d3, _e2, _f2, _g2, _h2;
      const isCollectible = transfer.contractType === "ERC721" || transfer.contractType === "ERC1155";
      const tokenId = ((_a4 = transfer.tokenIds) == null ? void 0 : _a4[index2]) || "0";
      const collectibleDecimals = ((_c3 = (_b4 = transfer == null ? void 0 : transfer.tokenMetadata) == null ? void 0 : _b4[tokenId]) == null ? void 0 : _c3.decimals) || 0;
      const coinDecimals = isNativeToken ? nativeTokenInfo.decimals : ((_d3 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _d3.decimals) || 0;
      const decimals = isCollectible ? collectibleDecimals : coinDecimals;
      const formattedBalance = formatUnits$1(amount, decimals);
      const balanceDisplayed = formatDisplay(formattedBalance);
      const fiatPrice = isCollectible ? (_f2 = (_e2 = collectiblePricesData == null ? void 0 : collectiblePricesData.find((collectible) => {
        var _a5, _b5;
        return compareAddress(collectible.token.contractAddress, ((_a5 = transfer.contractInfo) == null ? void 0 : _a5.address) || "") && collectible.token.tokenId === ((_b5 = transfer.tokenIds) == null ? void 0 : _b5[index2]) && collectible.token.chainId === transaction2.chainId;
      })) == null ? void 0 : _e2.price) == null ? void 0 : _f2.value : (_h2 = (_g2 = coinPricesData == null ? void 0 : coinPricesData.find((coin) => {
        var _a5;
        return compareAddress(coin.token.contractAddress, ((_a5 = transfer.contractInfo) == null ? void 0 : _a5.address) || ZeroAddress) && coin.token.chainId === transaction2.chainId;
      })) == null ? void 0 : _g2.price) == null ? void 0 : _h2.value;
      const fiatValue = (parseFloat(formattedBalance) * (conversionRate * (fiatPrice || 0))).toFixed(2);
      return jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "row", gap: "2", justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "flex-start", alignItems: "center", gap: "2", height: "12", borderRadius: "md", background: "buttonGlass", padding: "2", style: { flexBasis: "100%" }, children: [jsxRuntimeExports$1.jsx(TokenImage, { src: logoURI, symbol, size: "sm" }), jsxRuntimeExports$1.jsxs(Box, { gap: "0.5", flexDirection: "column", alignItems: "flex-start", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(Text, { variant: "xsmall", fontWeight: "bold", color: "text100", children: `${balanceDisplayed} ${symbol}` }), arePricesLoading ? jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "44px", height: "12px" } }) : jsxRuntimeExports$1.jsx(Text, { variant: "xsmall", fontWeight: "bold", color: "text50", children: fiatPrice ? `${fiatCurrency.sign}${fiatValue}` : "" })] })] }), jsxRuntimeExports$1.jsx(SvgArrowRightIcon, { color: "text50", style: { width: "16px" } }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "flex-start", alignItems: "center", gap: "2", height: "12", borderRadius: "md", background: "buttonGlass", padding: "2", style: { flexBasis: "100%" }, children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: recipientAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { variant: "xsmall", fontWeight: "bold", color: "text100", children: recipientAddressFormatted })] })] }, index2);
    }) });
  };
  return jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "10", marginTop: "5", children: [jsxRuntimeExports$1.jsxs(Box, { marginTop: "6", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "1", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text100", children: "Transaction details" }), jsxRuntimeExports$1.jsx(Text, { variant: "small", marginBottom: "1", fontWeight: "medium", color: "text50", children: date }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId: transaction2.chainId })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "4", width: "full", padding: "4", background: "backgroundSecondary", borderRadius: "md", children: [jsxRuntimeExports$1.jsxs(Box, { width: "full", gap: "1", flexDirection: "row", alignItems: "center", justifyContent: "flex-start", children: [jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text50", children: "Transfer" }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId: transaction2.chainId, size: "xs" })] }), (_b2 = transaction2.transfers) == null ? void 0 : _b2.map((transfer, index2) => jsxRuntimeExports$1.jsx(Box, { width: "full", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "4", children: jsxRuntimeExports$1.jsx(Transfer, { transfer }) }, `transfer-${index2}`))] }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickBlockExplorer, width: "full", borderRadius: "md", rightIcon: SvgLinkIcon, label: `View on ${nativeTokenInfo.blockExplorerName}` }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Divider, { width: "full", margin: "0", style: { marginBottom: "-4px" } }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: "Status" }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "medium", color: "text100", children: "Complete" })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Divider, { width: "full", margin: "0", style: { marginBottom: "-4px" } }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: "Transaction Hash" }), jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", fontWeight: "medium", style: { overflowWrap: "anywhere" }, children: transaction2.txnHash }), jsxRuntimeExports$1.jsx(CopyButton, { marginTop: "2", buttonVariant: "with-label", text: transaction2.txnHash })] })] })] });
};
const NavigationHeader = ({ secondaryText, primaryText }) => {
  const { goBack, history } = useNavigation();
  const onClickBack = () => {
    goBack();
  };
  return jsxRuntimeExports$1.jsxs(Box, { background: "backgroundPrimary", zIndex: "20", position: "fixed", width: "full", flexDirection: "row", alignItems: "center", justifyContent: "space-between", paddingX: "4", style: {
    height: HEADER_HEIGHT,
    paddingTop: "6px"
  }, children: [history.length > 0 ? jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickBack, icon: SvgChevronLeftIcon, size: "xs" }) : jsxRuntimeExports$1.jsx(Box, {}), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text50", children: secondaryText }), jsxRuntimeExports$1.jsx(index$2$1.Title, { asChild: true, children: jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text100", children: primaryText }) })] }), jsxRuntimeExports$1.jsx(Box, { style: {
    width: "44px"
  } })] });
};
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts2 = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts2.length;
    defaultContexts2 = [...defaultContexts2, defaultContext];
    function Provider2(props) {
      const { scope, children, ...context2 } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(() => context2, Object.values(context2));
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context2 = reactExports.useContext(Context);
      if (context2) return context2;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope2 = () => {
    const scopeContexts = defaultContexts2.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope2.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope2, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope2 = () => {
    const scopeHooks = scopes.map((createScope22) => ({
      useScope: createScope22(),
      scopeName: createScope22.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope2.scopeName = baseScope.scopeName;
  return createScope2;
}
var Slot = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (reactExports.isValidElement(children)) {
    const childrenRef = getElementRef$1(children);
    return reactExports.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children });
};
function isSlottable(child) {
  return reactExports.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context2 = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context2.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context2.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context2.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context2.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context2.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context2.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context2.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context2.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context2.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context2.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context2]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context2.layers.delete(node);
        context2.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context2]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context2 = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context2.branches.add(node);
      return () => {
        context2.branches.delete(node);
      };
    }
  }, [context2.branches]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count$1 = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$1++;
    return () => {
      if (count$1 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$1--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a2;
      stack = arrayRemove(stack, focusScope);
      (_a2 = stack[0]) == null ? void 0 : _a2.resume();
    }
  };
}
function arrayRemove(array, item2) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item2);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item2) => item2.tagName !== "A");
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
var useReactId = React$1["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v3) => ({
  x: v3,
  y: v3
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
    }
  }
  return list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getPaddingObject(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding: padding2 = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding2);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$12 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$12, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element.matches(selector2);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll2.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll2.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll2 = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll2.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll2.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x2 = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  let htmlX = 0;
  let htmlY = 0;
  if (documentElement && !isOffsetParentAnElement && !isFixed) {
    const htmlRect = documentElement.getBoundingClientRect();
    htmlY = htmlRect.top + scroll2.scrollTop;
    htmlX = htmlRect.left + scroll2.scrollLeft - // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect);
  }
  const x2 = rect.left + scroll2.scrollLeft - offsets.x - htmlX;
  const y2 = rect.top + scroll2.scrollTop - offsets.y - htmlY;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a2[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding: padding2
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding: padding2
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding: padding2
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports$1.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME;
var Root = Arrow$1;
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context2 = usePopperContext(ANCHOR_NAME$1, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context2.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports$1.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$1 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context2 = usePopperContext(CONTENT_NAME$1, __scopePopper);
    const [content2, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context2.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle2 = elements.floating.style;
            contentStyle2.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle2.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle2.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle2.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
    const arrowY = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content2) setContentZIndex(window.getComputedStyle(content2).zIndex);
    }, [content2]);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d2 = middlewareData.transformOrigin) == null ? void 0 : _d2.x,
            (_e2 = middlewareData.transformOrigin) == null ? void 0 : _e2.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f2 = middlewareData.hide) == null ? void 0 : _f2.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$1;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow22(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a2, _b2, _c2;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$1 = "Portal";
var Portal$1 = reactExports.forwardRef((props, forwardedRef) => {
  var _a2;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports$1.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$1.displayName = PORTAL_NAME$1;
function useStateMachine(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          reactDomExports.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent2, targets) {
  return targets.map(function(target) {
    if (parent2.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent2.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent2, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent2) {
    if (!parent2 || elementsToStop.has(parent2)) {
      return;
    }
    Array.prototype.forEach.call(parent2.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item2 = middleware(data, assigned);
      buffer2.push(item2);
      return function() {
        buffer2 = buffer2.filter(function(x2) {
          return x2 !== item2;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
      }
      buffer2 = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign$2({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest$1(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign$2({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest$1(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign$2(__assign$2({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$2(__assign$2({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign$2({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle2(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), s2 = _a2[1], d2 = _a2[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray$1([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent2) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent2, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event2) {
    var event = _event2;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign$2({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: reactExports.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: reactExports.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context2 = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context2;
    reactExports.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME = "PopoverTrigger";
var PopoverTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context2 = usePopoverContext(TRIGGER_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context2.triggerRef);
    const trigger2 = /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context2.open,
        "aria-controls": context2.contentId,
        "data-state": getState(context2.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context2.onOpenToggle)
      }
    );
    return context2.hasCustomAnchor ? trigger2 : /* @__PURE__ */ jsxRuntimeExports$1.jsx(Anchor, { asChild: true, ...popperScope, children: trigger2 });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "PopoverPortal";
var [PortalProvider, usePortalContext] = createPopoverContext(PORTAL_NAME, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context2 = usePopoverContext(PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(PortalProvider, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Presence, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Portal$1, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "PopoverContent";
var PopoverContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context2 = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Presence, { present: forceMount || context2.open, children: context2.modal ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME;
var PopoverContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const content2 = contentRef.current;
      if (content2) return hideOthers(content2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context2.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a2 = context2.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b2 = context2.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context2.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context2 = usePopoverContext(CONTENT_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context2.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
              Content,
              {
                "data-state": getState(context2.open),
                role: "dialog",
                id: context2.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context2 = usePopoverContext(CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context2.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME = "PopoverArrow";
var PopoverArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var Root2 = Popover;
var Anchor2 = PopoverAnchor;
var Trigger = PopoverTrigger;
var Portal = PopoverPortal;
var Content2 = PopoverContent;
const AccountInformation = reactExports.forwardRef(({ onClickAccount }, ref) => {
  const { address } = useAccount();
  return jsxRuntimeExports$1.jsx(Box, { gap: "2", alignItems: "center", children: jsxRuntimeExports$1.jsx(Box, { width: "full", flexDirection: "column", alignItems: "center", justifyContent: "center", children: jsxRuntimeExports$1.jsxs(Box, {
    onClick: onClickAccount,
    gap: "2",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    userSelect: "none",
    cursor: "pointer",
    opacity: { hover: "80" },
    // @ts-ignore-next-line
    ref,
    children: [jsxRuntimeExports$1.jsx(GradientAvatar, { size: "sm", address: address || "" }), jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "medium", variant: "normal", children: formatAddress(address || "") }), jsxRuntimeExports$1.jsx(SvgChevronDownIcon, { color: "text100" })]
  }) }) });
});
const WalletDropdownContent = reactExports.forwardRef(({ setOpenWalletDropdown }, ref) => {
  const { setNavigation } = useNavigation();
  const { setOpenWalletModal } = useOpenWalletModal();
  const { address } = useAccount();
  const { disconnect: disconnect2 } = useDisconnect();
  const { theme } = useTheme();
  const onClickReceive = () => {
    setOpenWalletDropdown(false);
    setNavigation({
      location: "receive"
    });
  };
  const onClickHistory = () => {
    setOpenWalletDropdown(false);
    setNavigation({
      location: "history"
    });
  };
  const onClickSettings = () => {
    setOpenWalletDropdown(false);
    setNavigation({
      location: "settings"
    });
  };
  const onClickSignout = () => {
    setOpenWalletModal(false);
    setOpenWalletDropdown(false);
    disconnect2();
  };
  const getDropdownBackgroundColor = () => {
    switch (theme) {
      case "dark":
        return "rgba(38, 38, 38, 0.85)";
      case "light":
        return "rgba(217, 217, 217, 0.85)";
      default:
        return vars.colors.transparent;
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { padding: "3", ref, zIndex: "30", borderRadius: "md", style: {
    position: "relative",
    pointerEvents: "auto",
    width: "370px",
    backdropFilter: "blur(12.5px)",
    top: "16px",
    left: "15px",
    background: getDropdownBackgroundColor()
  }, children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "3", marginLeft: "2", color: "text100", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { style: { width: "28px" }, size: "md", address: address || "" }), jsxRuntimeExports$1.jsx(Text, { variant: "large", fontWeight: "bold", color: "text100", children: formatAddress(address || "") }), jsxRuntimeExports$1.jsx(CopyButton, { buttonVariant: "icon", size: "md", text: address || "", color: "text100", style: { marginLeft: "-16px" } })] }), jsxRuntimeExports$1.jsx(IconButton, { onClick: () => setOpenWalletDropdown(false), size: "xs", background: "buttonGlass", icon: SvgCloseIcon })] }), jsxRuntimeExports$1.jsxs(Box, { gap: "2", marginTop: "3", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Button, { variant: "glass", style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgQrCodeIcon, label: "Receive", onClick: onClickReceive }), jsxRuntimeExports$1.jsx(Button, { style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgTransactionIcon, label: "History", onClick: onClickHistory }), jsxRuntimeExports$1.jsx(Button, { style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgSettingsIcon, label: "Settings", onClick: onClickSettings }), jsxRuntimeExports$1.jsx(Button, { label: "Sign Out", style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgSignoutIcon, onClick: onClickSignout })] })] });
});
const WalletHeader = () => {
  const { openWalletModalState } = useOpenWalletModal();
  const [openWalletDropdown, setOpenWalletDropdown] = reactExports.useState(false);
  const { goBack, history, setNavigation } = useNavigation();
  const hasDropdownOpened = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (!openWalletModalState) {
      setOpenWalletDropdown(false);
    }
  }, [openWalletModalState]);
  reactExports.useEffect(() => {
    if (openWalletDropdown) {
      if (!hasDropdownOpened.current) {
        hasDropdownOpened.current = true;
      } else {
        setOpenWalletDropdown(false);
      }
    } else {
      hasDropdownOpened.current = false;
    }
  }, [history.length, openWalletDropdown]);
  const onClickAccount = () => {
    setOpenWalletDropdown(true);
  };
  const onClickBack = () => {
    goBack();
  };
  const onClickSearch = () => {
    setNavigation({
      location: "search"
    });
  };
  return jsxRuntimeExports$1.jsx(Box, { as: motion.div, children: jsxRuntimeExports$1.jsxs(Root2, { open: openWalletDropdown, children: [jsxRuntimeExports$1.jsx(Anchor2, {}), jsxRuntimeExports$1.jsxs(Box, { background: "backgroundPrimary", zIndex: "20", position: "fixed", flexDirection: "row", alignItems: "center", justifyContent: "space-between", width: "full", paddingX: "4", style: {
    height: HEADER_HEIGHT,
    paddingTop: "6px"
  }, children: [history.length > 0 ? jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickBack, icon: SvgChevronLeftIcon, size: "xs" }) : jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickSearch, icon: SvgSearchIcon, size: "xs" }), jsxRuntimeExports$1.jsx(Trigger, { asChild: true, children: jsxRuntimeExports$1.jsx(AccountInformation, { onClickAccount }) }), jsxRuntimeExports$1.jsx(Box, { style: { width: "44px" } })] }), jsxRuntimeExports$1.jsx(AnimatePresence, { children: openWalletDropdown && jsxRuntimeExports$1.jsx(Content2, { asChild: true, side: "bottom", align: "start", children: jsxRuntimeExports$1.jsx(WalletDropdownContent, { setOpenWalletDropdown }) }) })] }) });
};
const getContent = (navigation) => {
  const { location: location2 } = navigation;
  switch (location2) {
    case "send-coin":
      return jsxRuntimeExports$1.jsx(SendCoin, { chainId: navigation.params.chainId, contractAddress: navigation.params.contractAddress });
    case "send-collectible":
      return jsxRuntimeExports$1.jsx(SendCollectible, { chainId: navigation.params.chainId, contractAddress: navigation.params.contractAddress, tokenId: navigation.params.tokenId });
    case "receive":
      return jsxRuntimeExports$1.jsx(Receive, {});
    case "history":
      return jsxRuntimeExports$1.jsx(History, {});
    case "search":
      return jsxRuntimeExports$1.jsx(SearchWallet, {});
    case "search-view-all":
      return jsxRuntimeExports$1.jsx(SearchWalletViewAll, { defaultTab: navigation.params.defaultTab });
    case "settings":
      return jsxRuntimeExports$1.jsx(SettingsMenu, {});
    case "settings-general":
      return jsxRuntimeExports$1.jsx(SettingsGeneral, {});
    case "settings-currency":
      return jsxRuntimeExports$1.jsx(SettingsCurrency, {});
    case "settings-networks":
      return jsxRuntimeExports$1.jsx(SettingsNetwork, {});
    case "coin-details":
      return jsxRuntimeExports$1.jsx(CoinDetails, { contractAddress: navigation.params.contractAddress, chainId: navigation.params.chainId });
    case "collectible-details":
      return jsxRuntimeExports$1.jsx(CollectibleDetails, { contractAddress: navigation.params.contractAddress, chainId: navigation.params.chainId, tokenId: navigation.params.tokenId });
    case "collection-details":
      return jsxRuntimeExports$1.jsx(CollectionDetails, { contractAddress: navigation.params.contractAddress, chainId: navigation.params.chainId });
    case "transaction-details":
      return jsxRuntimeExports$1.jsx(TransactionDetails, { transaction: navigation.params.transaction });
    case "home":
    default:
      return jsxRuntimeExports$1.jsx(Home, {});
  }
};
const getHeader = (navigation) => {
  const { location: location2 } = navigation;
  switch (location2) {
    case "search":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { primaryText: "Search wallet" });
    case "search-view-all":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Search wallet / ", primaryText: "View all" });
    case "settings":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "Settings" });
    case "settings-general":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / Settings / ", primaryText: "General" });
    case "settings-currency":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / Settings / ", primaryText: "Currency" });
    case "settings-networks":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / Settings / ", primaryText: "Networks" });
    case "receive":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "Receive" });
    case "history":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "History" });
    case "coin-details":
      return jsxRuntimeExports$1.jsx(WalletHeader, {});
    case "collectible-details":
      return jsxRuntimeExports$1.jsx(WalletHeader, {});
    case "transaction-details":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "", primaryText: "" });
    case "send-collectible":
    case "send-coin":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "Send" });
    case "home":
    default:
      return jsxRuntimeExports$1.jsx(WalletHeader, {});
  }
};
const DEFAULT_LOCATION = {
  location: "home"
};
const KitWalletProvider = (props) => {
  const queryClient = new QueryClient();
  return jsxRuntimeExports$1.jsx(QueryClientProvider, { client: queryClient, children: jsxRuntimeExports$1.jsx(KitWalletContent, { ...props }) });
};
const KitWalletContent = ({ children }) => {
  const { theme, position } = useTheme();
  const [openWalletModal, setOpenWalletModal] = reactExports.useState(false);
  const [history, setHistory] = reactExports.useState([]);
  const navigation = history.length > 0 ? history[history.length - 1] : DEFAULT_LOCATION;
  const displayScrollbar = navigation.location === "home" || navigation.location === "collection-details" || navigation.location === "collectible-details" || navigation.location === "coin-details" || navigation.location === "history" || navigation.location === "search" || navigation.location === "search-view-all" || navigation.location === "settings-currency";
  reactExports.useEffect(() => {
    if (openWalletModal) {
      setHistory([]);
    }
  }, [openWalletModal]);
  return jsxRuntimeExports$1.jsx(WalletModalContextProvider, { value: { setOpenWalletModal, openWalletModalState: openWalletModal }, children: jsxRuntimeExports$1.jsxs(NavigationContextProvider, { value: { setHistory, history }, children: [jsxRuntimeExports$1.jsx("div", { id: "kit-wallet", children: jsxRuntimeExports$1.jsx(ThemeProvider, { root: "#kit-wallet", scope: "kit", theme, children: jsxRuntimeExports$1.jsx(AnimatePresence, { children: openWalletModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      maxWidth: "400px",
      height: "fit-content",
      ...getModalPositionCss(position)
    }
  }, scroll: false, backdropColor: "backgroundBackdrop", onClose: () => setOpenWalletModal(false), children: jsxRuntimeExports$1.jsxs(Box, { id: "sequence-kit-wallet-content", children: [getHeader(navigation), displayScrollbar ? jsxRuntimeExports$1.jsx(Scroll, { style: { paddingTop: HEADER_HEIGHT, height: "min(800px, 80vh)" }, children: getContent(navigation) }) : getContent(navigation)] }) }) }) }) }), children] }) });
};
const Header = () => {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    Box,
    {
      position: "fixed",
      top: "0",
      width: "full",
      padding: "4",
      justifyContent: "space-between",
      background: "backgroundOverlay",
      backdropFilter: "blur",
      zIndex: "1",
      style: { borderBottom: "1px solid #222" },
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "3", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Image$1, { style: { width: "36px" }, src: "images/kit-logo.svg", alt: "Sequence kit", disableAnimation: true }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Image$1,
            {
              style: {
                width: "24px"
                // filter: theme === 'dark' ? 'invert(0)' : 'invert(1)'
              },
              src: "images/kit-logo-text.svg",
              alt: "Sequence Kit Text Logo",
              disableAnimation: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", alignItems: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(NetworkSelect, {}),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(AccountMenu, {})
        ] })
      ]
    }
  );
};
const AccountMenu = () => {
  const [isOpen, toggleOpen] = reactExports.useState(false);
  const { address, connector } = useAccount();
  const { disconnect: disconnect2 } = useDisconnect();
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Root2, { open: isOpen, onOpenChange: toggleOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Trigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Box,
      {
        borderColor: isOpen ? "borderFocus" : "borderNormal",
        borderWidth: "thin",
        borderStyle: "solid",
        borderRadius: "md",
        paddingX: "4",
        paddingY: "3",
        cursor: "pointer",
        gap: "2",
        alignItems: "center",
        userSelect: "none",
        opacity: { hover: "80" },
        style: { height: 52 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", justifyContent: "flex-end", alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(GradientAvatar, { address: String(address), size: "sm" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: truncateAddress(String(address), 4) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { color: "text50", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SvgChevronDownIcon, {}) })
        ]
      }
    ) }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Content2, { side: "bottom", sideOffset: 8, align: "end", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Card,
      {
        zIndex: "20",
        background: "backgroundRaised",
        backdropFilter: "blur",
        position: "relative",
        padding: "2",
        style: { minWidth: 360 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Card, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", justifyContent: "space-between", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: "Account" }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: connector == null ? void 0 : connector.name })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { as: "div", marginTop: "2", variant: "normal", color: "text80", children: address })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { marginTop: "2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Button,
            {
              width: "full",
              shape: "square",
              variant: "emphasis",
              rightIcon: SvgSignoutIcon,
              label: "Sign out",
              onClick: () => disconnect2()
            }
          ) })
        ]
      }
    ) }) })
  ] });
};
const NetworkSelect = () => {
  var _a2;
  const chains2 = useChains();
  const chainId = useChainId();
  const { switchChain: switchChain2 } = useSwitchChain();
  const [isOpen, toggleOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Root2, { open: isOpen, onOpenChange: toggleOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Trigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Box,
      {
        borderColor: isOpen ? "borderFocus" : "borderNormal",
        borderWidth: "thin",
        borderStyle: "solid",
        borderRadius: "md",
        paddingX: "4",
        paddingY: "3",
        cursor: "pointer",
        gap: "2",
        alignItems: "center",
        userSelect: "none",
        opacity: { hover: "80" },
        style: { height: 52 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", gap: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "sm" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { display: { sm: "none", lg: "block" }, variant: "normal", fontWeight: "bold", color: "text100", children: ((_a2 = chains2.find((chain) => chain.id === chainId)) == null ? void 0 : _a2.name) || chainId })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { color: "text50", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SvgChevronDownIcon, {}) })
        ]
      }
    ) }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Content2, { side: "bottom", sideOffset: 8, align: "end", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Card,
      {
        zIndex: "20",
        background: "backgroundRaised",
        backdropFilter: "blur",
        position: "relative",
        padding: "2",
        flexDirection: "column",
        gap: "2",
        children: chains2.map((chain) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Button,
          {
            width: "full",
            shape: "square",
            onClick: () => {
              switchChain2({ chainId: chain.id });
              toggleOpen(false);
            },
            leftIcon: () => /* @__PURE__ */ jsxRuntimeExports$1.jsx(NetworkImage, { chainId: chain.id, size: "sm" }),
            label: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { alignItems: "center", gap: "2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: chain.name }) })
          },
          chain.id
        ))
      }
    ) }) })
  ] });
};
const bottomPageLinks = [
  {
    label: "Terms",
    url: "https://sequence.xyz/terms"
  },
  {
    label: "About",
    url: "https://github.com/0xsequence/kit"
  },
  {
    label: "Blog",
    url: "https://sequence.xyz/blog"
  },
  {
    label: "Builder",
    url: "https://sequence.build"
  },
  {
    label: "Docs",
    url: "https://docs.sequence.xyz/wallet/connectors/kit/kit/overview"
  }
];
const socialLinks = [
  {
    id: "discord",
    url: "https://discord.gg/sequence",
    icon: "images/discord.svg"
  },
  {
    id: "twitter",
    url: "https://www.twitter.com/0xsequence",
    icon: "images/twitter.svg"
  },
  {
    id: "youtube",
    url: "https://www.youtube.com/channel/UC1zHgUyV-doddTcnFNqt62Q",
    icon: "images/youtube.svg"
  },
  {
    id: "github",
    url: "https://github.com/0xsequence",
    icon: "images/github.svg"
  }
];
const Footer = () => {
  const { theme } = useTheme$1();
  const onClickLinkUrl = (url) => {
    if (typeof window !== "undefined") {
      window.open(url);
    }
  };
  const Links = () => {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { flexDirection: "row", gap: "4", children: bottomPageLinks.map((link, index2) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Button,
      {
        variant: "text",
        onClick: () => onClickLinkUrl(link.url),
        gap: "4",
        label: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "small", children: link.label })
      },
      index2
    )) });
  };
  const Socials = () => {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { gap: "4", justifyContent: "center", alignItems: "center", children: socialLinks.map((socialLink, index2) => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        Box,
        {
          cursor: "pointer",
          opacity: { hover: "80" },
          onClick: () => {
            if (typeof window !== "undefined") {
              window.open(socialLink.url);
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Image$1,
            {
              height: "3",
              src: socialLink.icon,
              alt: socialLink.id,
              style: {
                filter: theme === "dark" ? "invert(0)" : "invert(1)"
              },
              disableAnimation: true
            }
          )
        },
        index2
      );
    }) });
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    Box,
    {
      padding: "5",
      style: { height: "60px", borderTop: "1px solid #222" },
      position: "fixed",
      bottom: "0",
      width: "full",
      justifyContent: "space-between",
      background: "backgroundOverlay",
      backdropFilter: "blur",
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Links, {}),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Socials, {})
      ]
    }
  );
};
const CardButton = (props) => {
  const { title, description: description2, onClick, isPending } = props;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Card, { clickable: true, onClick, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: title }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "text50", marginTop: "2", children: description2 }),
    isPending && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", alignItems: "center", marginTop: "4", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Spinner, { size: "sm" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: "Pending..." })
    ] })
  ] });
};
let ChainId = /* @__PURE__ */ function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["ROPSTEN"] = 3] = "ROPSTEN";
  ChainId2[ChainId2["RINKEBY"] = 4] = "RINKEBY";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["KOVAN"] = 42] = "KOVAN";
  ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["POLYGON_ZKEVM"] = 1101] = "POLYGON_ZKEVM";
  ChainId2[ChainId2["POLYGON_AMOY"] = 80002] = "POLYGON_AMOY";
  ChainId2[ChainId2["BSC"] = 56] = "BSC";
  ChainId2[ChainId2["BSC_TESTNET"] = 97] = "BSC_TESTNET";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISM_KOVAN"] = 69] = "OPTIMISM_KOVAN";
  ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM"] = 42161] = "ARBITRUM";
  ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId2[ChainId2["ARBITRUM_SEPOLIA"] = 421614] = "ARBITRUM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM_NOVA"] = 42170] = "ARBITRUM_NOVA";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["AVALANCHE_TESTNET"] = 43113] = "AVALANCHE_TESTNET";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["BASE"] = 8453] = "BASE";
  ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId2[ChainId2["BASE_SEPOLIA"] = 84532] = "BASE_SEPOLIA";
  ChainId2[ChainId2["HOMEVERSE_TESTNET"] = 40875] = "HOMEVERSE_TESTNET";
  ChainId2[ChainId2["HOMEVERSE"] = 19011] = "HOMEVERSE";
  ChainId2[ChainId2["XAI"] = 660279] = "XAI";
  ChainId2[ChainId2["XAI_SEPOLIA"] = 37714555429] = "XAI_SEPOLIA";
  ChainId2[ChainId2["ASTAR_ZKEVM"] = 3776] = "ASTAR_ZKEVM";
  ChainId2[ChainId2["ASTAR_ZKYOTO"] = 6038361] = "ASTAR_ZKYOTO";
  ChainId2[ChainId2["XR_SEPOLIA"] = 2730] = "XR_SEPOLIA";
  ChainId2[ChainId2["TELOS"] = 40] = "TELOS";
  ChainId2[ChainId2["B3_SEPOLIA"] = 1993] = "B3_SEPOLIA";
  ChainId2[ChainId2["APECHAIN_TESTNET"] = 33111] = "APECHAIN_TESTNET";
  ChainId2[ChainId2["BLAST"] = 81457] = "BLAST";
  ChainId2[ChainId2["BLAST_SEPOLIA"] = 168587773] = "BLAST_SEPOLIA";
  ChainId2[ChainId2["BORNE_TESTNET"] = 94984] = "BORNE_TESTNET";
  ChainId2[ChainId2["SKALE_NEBULA_TESTNET"] = 37084624] = "SKALE_NEBULA_TESTNET";
  ChainId2[ChainId2["SONEIUM_MINATO"] = 1946] = "SONEIUM_MINATO";
  ChainId2[ChainId2["HARDHAT"] = 31337] = "HARDHAT";
  ChainId2[ChainId2["HARDHAT_2"] = 31338] = "HARDHAT_2";
  return ChainId2;
}({});
let NetworkType = /* @__PURE__ */ function(NetworkType2) {
  NetworkType2["MAINNET"] = "mainnet";
  NetworkType2["TESTNET"] = "testnet";
  return NetworkType2;
}({});
const networks = {
  [ChainId.MAINNET]: {
    chainId: ChainId.MAINNET,
    type: NetworkType.MAINNET,
    name: "mainnet",
    title: "Ethereum",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.MAINNET}.webp`,
    blockExplorer: {
      name: "Etherscan",
      rootUrl: "https://etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  [ChainId.ROPSTEN]: {
    chainId: ChainId.ROPSTEN,
    type: NetworkType.TESTNET,
    name: "ropsten",
    title: "Ropsten",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ROPSTEN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Ropsten)",
      rootUrl: "https://ropsten.etherscan.io/"
    },
    nativeToken: {
      symbol: "roETH",
      name: "Ropsten Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId.RINKEBY]: {
    chainId: ChainId.RINKEBY,
    type: NetworkType.TESTNET,
    name: "rinkeby",
    title: "Rinkeby",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.RINKEBY}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Rinkeby)",
      rootUrl: "https://rinkeby.etherscan.io/"
    },
    nativeToken: {
      symbol: "rETH",
      name: "Rinkeby Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId.GOERLI]: {
    chainId: ChainId.GOERLI,
    type: NetworkType.TESTNET,
    name: "goerli",
    title: "Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Goerli)",
      rootUrl: "https://goerli.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId.KOVAN]: {
    chainId: ChainId.KOVAN,
    type: NetworkType.TESTNET,
    name: "kovan",
    title: "Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.KOVAN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Kovan)",
      rootUrl: "https://kovan.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.SEPOLIA]: {
    chainId: ChainId.SEPOLIA,
    type: NetworkType.TESTNET,
    name: "sepolia",
    title: "Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Sepolia)",
      rootUrl: "https://sepolia.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.POLYGON]: {
    chainId: ChainId.POLYGON,
    type: NetworkType.MAINNET,
    name: "polygon",
    title: "Polygon",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON}.webp`,
    blockExplorer: {
      name: "Polygonscan",
      rootUrl: "https://polygonscan.com/"
    },
    nativeToken: {
      symbol: "POL",
      name: "POL",
      decimals: 18
    }
  },
  [ChainId.POLYGON_MUMBAI]: {
    chainId: ChainId.POLYGON_MUMBAI,
    type: NetworkType.TESTNET,
    name: "mumbai",
    title: "Polygon Mumbai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_MUMBAI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Polygonscan (Mumbai)",
      rootUrl: "https://mumbai.polygonscan.com/"
    },
    nativeToken: {
      symbol: "mMATIC",
      name: "Mumbai Polygon",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.POLYGON_AMOY]: {
    chainId: ChainId.POLYGON_AMOY,
    type: NetworkType.TESTNET,
    name: "amoy",
    title: "Polygon Amoy",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_AMOY}.webp`,
    testnet: true,
    blockExplorer: {
      name: "OKLink (Amoy)",
      rootUrl: "https://www.oklink.com/amoy/"
    },
    nativeToken: {
      symbol: "aPOL",
      name: "Amoy POL",
      decimals: 18
    }
  },
  [ChainId.POLYGON_ZKEVM]: {
    chainId: ChainId.POLYGON_ZKEVM,
    type: NetworkType.MAINNET,
    name: "polygon-zkevm",
    title: "Polygon zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_ZKEVM}.webp`,
    blockExplorer: {
      name: "Polygonscan (zkEVM)",
      rootUrl: "https://zkevm.polygonscan.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.BSC]: {
    chainId: ChainId.BSC,
    type: NetworkType.MAINNET,
    name: "bsc",
    title: "BNB Smart Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BSC}.webp`,
    blockExplorer: {
      name: "BSCScan",
      rootUrl: "https://bscscan.com/"
    },
    nativeToken: {
      symbol: "BNB",
      name: "BNB",
      decimals: 18
    }
  },
  [ChainId.BSC_TESTNET]: {
    chainId: ChainId.BSC_TESTNET,
    type: NetworkType.TESTNET,
    name: "bsc-testnet",
    title: "BNB Smart Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BSC_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "BSCScan (Testnet)",
      rootUrl: "https://testnet.bscscan.com/"
    },
    nativeToken: {
      symbol: "tBNB",
      name: "Testnet BNB",
      decimals: 18
    }
  },
  [ChainId.OPTIMISM]: {
    chainId: ChainId.OPTIMISM,
    type: NetworkType.MAINNET,
    name: "optimism",
    title: "Optimism",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM}.webp`,
    blockExplorer: {
      name: "Etherscan (Optimism)",
      rootUrl: "https://optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.OPTIMISM_KOVAN]: {
    chainId: ChainId.OPTIMISM_KOVAN,
    type: NetworkType.TESTNET,
    name: "optimism-kovan",
    title: "Optimism Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_KOVAN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Kovan)",
      rootUrl: "https://kovan-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.OPTIMISM_GOERLI]: {
    chainId: ChainId.OPTIMISM_GOERLI,
    type: NetworkType.TESTNET,
    name: "optimism-goerli",
    title: "Optimism Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Goerli)",
      rootUrl: "https://goerli-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.OPTIMISM_SEPOLIA]: {
    chainId: ChainId.OPTIMISM_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "optimism-sepolia",
    title: "Optimism Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Sepolia)",
      rootUrl: "https://sepolia-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.ARBITRUM]: {
    chainId: ChainId.ARBITRUM,
    type: NetworkType.MAINNET,
    name: "arbitrum",
    title: "Arbitrum One",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM}.webp`,
    blockExplorer: {
      name: "Arbiscan",
      rootUrl: "https://arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.ARBITRUM_GOERLI]: {
    chainId: ChainId.ARBITRUM_GOERLI,
    type: NetworkType.TESTNET,
    name: "arbitrum-goerli",
    title: "Arbitrum Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Arbiscan (Goerli Testnet)",
      rootUrl: "https://testnet.arbiscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.ARBITRUM_SEPOLIA]: {
    chainId: ChainId.ARBITRUM_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "arbitrum-sepolia",
    title: "Arbitrum Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Arbiscan (Sepolia Testnet)",
      rootUrl: "https://sepolia.arbiscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.ARBITRUM_NOVA]: {
    chainId: ChainId.ARBITRUM_NOVA,
    type: NetworkType.MAINNET,
    name: "arbitrum-nova",
    title: "Arbitrum Nova",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_NOVA}.webp`,
    blockExplorer: {
      name: "Arbiscan Nova",
      rootUrl: "https://nova.arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.AVALANCHE]: {
    chainId: ChainId.AVALANCHE,
    type: NetworkType.MAINNET,
    name: "avalanche",
    title: "Avalanche",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.AVALANCHE}.webp`,
    blockExplorer: {
      name: "Snowtrace",
      rootUrl: "https://subnets.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "AVAX",
      name: "AVAX",
      decimals: 18
    }
  },
  [ChainId.AVALANCHE_TESTNET]: {
    chainId: ChainId.AVALANCHE_TESTNET,
    type: NetworkType.TESTNET,
    name: "avalanche-testnet",
    title: "Avalanche Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.AVALANCHE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Snowtrace (Testnet)",
      rootUrl: "https://subnets-test.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "tAVAX",
      name: "Testnet AVAX",
      decimals: 18
    }
  },
  [ChainId.GNOSIS]: {
    chainId: ChainId.GNOSIS,
    type: NetworkType.MAINNET,
    name: "gnosis",
    title: "Gnosis Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.GNOSIS}.webp`,
    blockExplorer: {
      name: "Gnosis Chain Explorer",
      rootUrl: "https://blockscout.com/xdai/mainnet/"
    },
    nativeToken: {
      symbol: "XDAI",
      name: "XDAI",
      decimals: 18
    }
  },
  [ChainId.BASE]: {
    chainId: ChainId.BASE,
    type: NetworkType.MAINNET,
    name: "base",
    title: "Base (Coinbase)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE}.webp`,
    blockExplorer: {
      name: "Base Explorer",
      rootUrl: "https://basescan.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.BASE_GOERLI]: {
    chainId: ChainId.BASE_GOERLI,
    type: NetworkType.TESTNET,
    name: "base-goerli",
    title: "Base Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Base Goerli Explorer",
      rootUrl: "https://goerli.basescan.org/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.BASE_SEPOLIA]: {
    chainId: ChainId.BASE_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "base-sepolia",
    title: "Base Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Base Sepolia Explorer",
      rootUrl: "https://base-sepolia.blockscout.com/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.HOMEVERSE]: {
    chainId: ChainId.HOMEVERSE,
    type: NetworkType.MAINNET,
    name: "homeverse",
    title: "Oasys Homeverse",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.HOMEVERSE}.webp`,
    blockExplorer: {
      name: "Oasys Homeverse Explorer",
      rootUrl: "https://explorer.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "OAS",
      name: "OAS",
      decimals: 18
    }
  },
  [ChainId.HOMEVERSE_TESTNET]: {
    chainId: ChainId.HOMEVERSE_TESTNET,
    type: NetworkType.TESTNET,
    name: "homeverse-testnet",
    title: "Oasys Homeverse Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.HOMEVERSE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Oasys Homeverse Explorer (Testnet)",
      rootUrl: "https://explorer.testnet.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "tOAS",
      name: "Testnet OAS",
      decimals: 18
    }
  },
  [ChainId.XAI]: {
    chainId: ChainId.XAI,
    type: NetworkType.MAINNET,
    name: "xai",
    title: "Xai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XAI}.webp`,
    blockExplorer: {
      name: "Xai Explorer",
      rootUrl: "https://explorer.xai-chain.net/"
    },
    nativeToken: {
      symbol: "XAI",
      name: "XAI",
      decimals: 18
    }
  },
  [ChainId.XAI_SEPOLIA]: {
    chainId: ChainId.XAI_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "xai-sepolia",
    title: "Xai Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XAI_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Xai Sepolia Explorer",
      rootUrl: "https://testnet-explorer-v2.xai-chain.net/"
    },
    nativeToken: {
      symbol: "sXAI",
      name: "Sepolia XAI",
      decimals: 18
    }
  },
  [ChainId.ASTAR_ZKEVM]: {
    chainId: ChainId.ASTAR_ZKEVM,
    type: NetworkType.MAINNET,
    name: "astar-zkevm",
    title: "Astar zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ASTAR_ZKEVM}.webp`,
    blockExplorer: {
      name: "Astar zkEVM Explorer",
      rootUrl: "https://astar-zkevm.explorer.startale.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.ASTAR_ZKYOTO]: {
    chainId: ChainId.ASTAR_ZKYOTO,
    type: NetworkType.TESTNET,
    name: "astar-zkyoto",
    title: "Astar zKyoto Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ASTAR_ZKYOTO}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Astar zKyoto Explorer",
      rootUrl: "https://astar-zkyoto.blockscout.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.XR_SEPOLIA]: {
    chainId: ChainId.XR_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "xr-sepolia",
    title: "XR Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XR_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "XR Sepolia Explorer",
      rootUrl: "https://xr-sepolia-testnet.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "tXR",
      name: "Sepolia XR",
      decimals: 18
    }
  },
  [ChainId.B3_SEPOLIA]: {
    chainId: ChainId.B3_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "b3-sepolia",
    title: "B3 Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.B3_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "B3 Sepolia Explorer",
      rootUrl: "https://sepolia.explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.APECHAIN_TESTNET]: {
    chainId: ChainId.APECHAIN_TESTNET,
    type: NetworkType.TESTNET,
    name: "apechain-testnet",
    title: "APE Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.APECHAIN_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://curtis.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [ChainId.BLAST]: {
    chainId: ChainId.BLAST,
    type: NetworkType.MAINNET,
    name: "blast",
    title: "Blast",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BLAST}.webp`,
    blockExplorer: {
      name: "Blast Explorer",
      rootUrl: "https://blastscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.BLAST_SEPOLIA]: {
    chainId: ChainId.BLAST_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "blast-sepolia",
    title: "Blast Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BLAST_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Blast Sepolia Explorer",
      rootUrl: "https://sepolia.blastexplorer.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.TELOS]: {
    chainId: ChainId.TELOS,
    type: NetworkType.MAINNET,
    name: "telos",
    title: "Telos",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.TELOS}.webp`,
    blockExplorer: {
      name: "Telos Explorer",
      rootUrl: "https://explorer.telos.net/network/"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [ChainId.BORNE_TESTNET]: {
    chainId: ChainId.BORNE_TESTNET,
    type: NetworkType.TESTNET,
    name: "borne-testnet",
    title: "Borne Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BORNE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Borne Testnet Explorer",
      rootUrl: "https://subnets-test.avax.network/bornegfdn"
    },
    nativeToken: {
      symbol: "BORNE",
      name: "BORNE",
      decimals: 18
    }
  },
  [ChainId.SKALE_NEBULA_TESTNET]: {
    chainId: ChainId.SKALE_NEBULA_TESTNET,
    type: NetworkType.TESTNET,
    name: "skale-nebula-testnet",
    title: "SKALE Nebula Gaming Hub Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SKALE_NEBULA_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "SKALE Nebula Gaming Hub Testnet Explorer",
      rootUrl: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com/"
    },
    nativeToken: {
      symbol: "sFUEL",
      name: "SKALE Fuel",
      decimals: 18
    }
  },
  [ChainId.SONEIUM_MINATO]: {
    chainId: ChainId.SONEIUM_MINATO,
    type: NetworkType.TESTNET,
    name: "soneium-minato",
    title: "Soneium Minato (Testnet)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SONEIUM_MINATO}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Soneium Minato Explorer",
      rootUrl: "https://explorer-testnet.soneium.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.HARDHAT]: {
    chainId: ChainId.HARDHAT,
    name: "hardhat",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.HARDHAT_2]: {
    chainId: ChainId.HARDHAT_2,
    name: "hardhat2",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  }
};
BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var logLevel = /* @__PURE__ */ function(logLevel2) {
  logLevel2[logLevel2["DEBUG"] = 1] = "DEBUG";
  logLevel2[logLevel2["INFO"] = 2] = "INFO";
  logLevel2[logLevel2["WARN"] = 3] = "WARN";
  logLevel2[logLevel2["ERROR"] = 4] = "ERROR";
  logLevel2[logLevel2["DISABLED"] = 5] = "DISABLED";
  return logLevel2;
}(logLevel || {});
class Logger2 {
  constructor(config2) {
    this.config = config2;
    this.logLevel = void 0;
    this.configure(config2);
  }
  configure(config2) {
    this.config = _extends$1({}, this.config, config2);
    switch (this.config.logLevel) {
      case "DEBUG":
        this.logLevel = logLevel.DEBUG;
        break;
      case "INFO":
        this.logLevel = logLevel.INFO;
        break;
      case "WARN":
        this.logLevel = logLevel.WARN;
        break;
      case "ERROR":
        this.logLevel = logLevel.ERROR;
        break;
      case "DISABLED":
        this.logLevel = logLevel.DISABLED;
        break;
      default:
        this.logLevel = logLevel.INFO;
        break;
    }
    if (this.config.silence === void 0) {
      this.config.silence = false;
    }
  }
  debug(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel === logLevel.DEBUG) {
      console.log(message, ...optionalParams);
    }
  }
  info(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel.INFO) {
      console.log(message, ...optionalParams);
    }
  }
  warn(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel.WARN) {
      console.warn(message, ...optionalParams);
      if (this.config.onwarn) {
        this.config.onwarn(message, optionalParams);
      }
    }
  }
  error(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel.ERROR) {
      console.error(message, ...optionalParams);
      if (this.config.onerror) {
        this.config.onerror(message, optionalParams);
      }
    }
  }
}
new Logger2({
  logLevel: "INFO",
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: true
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
const isValidNetworkConfig = (networkConfig, raise = false, skipRelayerCheck = false) => {
  if (!networkConfig) throw new Error(`invalid network config: empty config`);
  const configs = [];
  if (Array.isArray(networkConfig)) {
    configs.push(...networkConfig);
  } else {
    configs.push(networkConfig);
  }
  if (configs.length === 0) {
    if (raise) throw new Error(`invalid network config: empty config`);
    return false;
  }
  const chainIds = configs.map((c2) => c2.chainId).sort();
  const dupes = chainIds.filter((c2, i) => chainIds.indexOf(c2) !== i);
  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }
  configs.forEach((c2) => c2.name = c2.name.toLowerCase());
  const names2 = configs.map((c2) => c2.name).sort();
  const nameDupes = names2.filter((c2, i) => names2.indexOf(c2) !== i);
  if (nameDupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`);
    return false;
  }
  let defaultChain = false;
  for (let i = 0; i < configs.length; i++) {
    const c2 = configs[i];
    if ((!c2.rpcUrl || c2.rpcUrl === "") && !c2.provider) {
      if (raise) throw new Error(`invalid network config for chainId ${c2.chainId}: rpcUrl or provider must be provided`);
      return false;
    }
    if (!skipRelayerCheck) {
      if (!c2.relayer) {
        if (raise) throw new Error(`invalid network config for chainId ${c2.chainId}: relayer must be provided`);
        return false;
      }
    }
    if (c2.isDefaultChain) {
      if (defaultChain) {
        if (raise) throw new Error(`invalid network config for chainId ${c2.chainId}: DefaultChain is already set by another config`);
        return false;
      }
      defaultChain = true;
    }
  }
  if (!defaultChain) {
    if (raise) throw new Error(`invalid network config: DefaultChain must be set`);
    return false;
  }
  return true;
};
const ensureValidNetworks = (networks2, skipRelayerCheck = false) => {
  isValidNetworkConfig(networks2, true, skipRelayerCheck);
  return networks2;
};
const validateAndSortNetworks = (networks2) => {
  return ensureValidNetworks(sortNetworks(networks2));
};
const sortNetworks = (networks2) => {
  if (!networks2) {
    return [];
  }
  const config2 = networks2.sort((a2, b2) => {
    if (a2.chainId === b2.chainId) return 0;
    return a2.chainId < b2.chainId ? -1 : 1;
  });
  const defaultConfigIdx = config2.findIndex((c2) => c2.isDefaultChain);
  if (defaultConfigIdx > 0) config2.splice(0, 0, config2.splice(defaultConfigIdx, 1)[0]);
  return config2;
};
const stringTemplate = (sTemplate, mData) => {
  if (typeof sTemplate === "string") {
    mData = mData ? mData : {};
    return sTemplate.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(fullMath, grp) {
      let val = mData[grp];
      if (typeof val === "function") {
        val = val();
      } else if (val === null || val === void 0) {
        val = "";
      } else if (typeof val === "object" || typeof val === "symbol") {
        val = val.toString();
      } else {
        val = val.valueOf();
      }
      return val;
    });
  }
  return "";
};
const indexerURL = (network2) => stringTemplate("https://${network}-indexer.sequence.app", {
  network: network2
});
const relayerURL = (network2) => stringTemplate("https://${network}-relayer.sequence.app", {
  network: network2
});
const nodesURL = (network2) => stringTemplate("https://nodes.sequence.app/${network}", {
  network: network2
});
const createNetworkConfig = (chainId, options) => {
  const network2 = networks[chainId];
  if (!network2) {
    throw new Error(`Network with chainId ${chainId} not found`);
  }
  const rpcUrl = nodesURL(network2.name);
  return _extends({}, network2, {
    rpcUrl,
    indexerUrl: indexerURL(network2.name),
    relayer: {
      url: relayerURL(network2.name),
      provider: {
        url: rpcUrl
      }
    }
  }, options);
};
const hardhatNetworks = [_extends({}, networks[ChainId.HARDHAT], {
  rpcUrl: "http://localhost:8545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:8545"
    }
  }
}), _extends({}, networks[ChainId.HARDHAT_2], {
  rpcUrl: "http://localhost:9545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:9545"
    }
  }
})];
const allNetworks = validateAndSortNetworks([_extends({}, createNetworkConfig(ChainId.POLYGON), {
  isDefaultChain: true,
  isAuthChain: true
}), createNetworkConfig(ChainId.MAINNET), createNetworkConfig(ChainId.BSC), createNetworkConfig(ChainId.AVALANCHE), createNetworkConfig(ChainId.ARBITRUM), createNetworkConfig(ChainId.ARBITRUM_NOVA), createNetworkConfig(ChainId.OPTIMISM), createNetworkConfig(ChainId.OPTIMISM_SEPOLIA), createNetworkConfig(ChainId.POLYGON_ZKEVM), createNetworkConfig(ChainId.GNOSIS), createNetworkConfig(ChainId.RINKEBY, {
  disabled: true
}), createNetworkConfig(ChainId.GOERLI, {
  disabled: true
}), createNetworkConfig(ChainId.SEPOLIA), createNetworkConfig(ChainId.POLYGON_MUMBAI, {
  disabled: true
}), createNetworkConfig(ChainId.POLYGON_AMOY), createNetworkConfig(ChainId.BSC_TESTNET), createNetworkConfig(ChainId.ARBITRUM_SEPOLIA), createNetworkConfig(ChainId.BASE), createNetworkConfig(ChainId.BASE_SEPOLIA), createNetworkConfig(ChainId.HOMEVERSE), createNetworkConfig(ChainId.HOMEVERSE_TESTNET), createNetworkConfig(ChainId.XAI), createNetworkConfig(ChainId.XAI_SEPOLIA), createNetworkConfig(ChainId.AVALANCHE_TESTNET), createNetworkConfig(ChainId.ASTAR_ZKEVM), createNetworkConfig(ChainId.ASTAR_ZKYOTO), createNetworkConfig(ChainId.XR_SEPOLIA), createNetworkConfig(ChainId.B3_SEPOLIA), createNetworkConfig(ChainId.APECHAIN_TESTNET), createNetworkConfig(ChainId.BLAST), createNetworkConfig(ChainId.BLAST_SEPOLIA), createNetworkConfig(ChainId.TELOS), createNetworkConfig(ChainId.BORNE_TESTNET), createNetworkConfig(ChainId.SKALE_NEBULA_TESTNET), createNetworkConfig(ChainId.SONEIUM_MINATO), ...hardhatNetworks]);
const messageToSign = "Two roads diverged in a yellow wood";
const abi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "address", name: "owner", type: "address" }
    ],
    name: "ERC721IncorrectOwner",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "ERC721InsufficientApproval",
    type: "error"
  },
  { inputs: [{ internalType: "address", name: "approver", type: "address" }], name: "ERC721InvalidApprover", type: "error" },
  { inputs: [{ internalType: "address", name: "operator", type: "address" }], name: "ERC721InvalidOperator", type: "error" },
  { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "ERC721InvalidOwner", type: "error" },
  { inputs: [{ internalType: "address", name: "receiver", type: "address" }], name: "ERC721InvalidReceiver", type: "error" },
  { inputs: [{ internalType: "address", name: "sender", type: "address" }], name: "ERC721InvalidSender", type: "error" },
  { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "ERC721NonexistentToken", type: "error" },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "owner", type: "address" },
      { indexed: true, internalType: "address", name: "approved", type: "address" },
      { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "owner", type: "address" },
      { indexed: true, internalType: "address", name: "operator", type: "address" },
      { indexed: false, internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint256", name: "_fromTokenId", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "_toTokenId", type: "uint256" }
    ],
    name: "BatchMetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [{ indexed: false, internalType: "uint256", name: "_tokenId", type: "uint256" }],
    name: "MetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "player", type: "address" },
      { internalType: "string", name: "tokenURI", type: "string" }
    ],
    name: "awardItem",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "getApproved",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "operator", type: "address" }
    ],
    name: "isApprovedForAll",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "ownerOf",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "tokenURI",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const orderbookAbi = [
  {
    inputs: [
      { internalType: "uint256", name: "requestId", type: "uint256" },
      { internalType: "uint256", name: "quantity", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256[]", name: "additionalFees", type: "uint256[]" },
      { internalType: "address[]", name: "additionalFeeRecipients", type: "address[]" }
    ],
    name: "acceptRequest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const delay = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
const getCheckoutSettings = (args) => {
  const checkoutSettings = {
    creditCardCheckout: {
      defaultPaymentMethodType: "us_debit",
      onSuccess: (hash2) => {
        console.log("credit card checkout success", hash2);
      },
      onError: (e2) => {
        console.log("credit card checkout error", e2);
      },
      ...args
    }
    // orderSummaryItems: [
    //   {
    //     chainId: args.chainId,
    //     contractAddress: args.nftAddress,
    //     tokenId: args.nftId,
    //     quantityRaw: String(args.nftQuantity)
    //   }
    // ]
  };
  return checkoutSettings;
};
const getOrderbookCalldata = ({ orderId, quantity, recipient }) => {
  const calldata = encodeFunctionData({
    abi: orderbookAbi,
    functionName: "acceptRequest",
    args: [BigInt(orderId), BigInt(quantity), recipient, [], []]
  });
  return calldata;
};
const searchParams$2 = new URLSearchParams(location.search);
const isDebugMode$1 = searchParams$2.has("debug");
const Connected = () => {
  var _a2;
  const { address } = useAccount();
  const { setOpenWalletModal } = useOpenWalletModal();
  const { triggerCheckout } = useCheckoutModal();
  const { triggerAddFunds } = useAddFundsModal();
  const { openERC1155SaleContractPaymentModal } = useERC1155SaleContractPaymentModal();
  const { data: walletClient } = useWalletClient();
  const storage = useStorage();
  const [isCheckoutInfoModalOpen, setIsCheckoutInfoModalOpen] = React.useState(false);
  const [checkoutOrderId, setCheckoutOrderId] = React.useState("");
  const [checkoutTokenContractAddress, setCheckoutTokenContractAddress] = React.useState("");
  const [checkoutTokenId, setCheckoutTokenId] = React.useState("");
  const connections = useConnections();
  const isWaasConnection = connections.find((c2) => c2.connector.id.includes("waas")) !== void 0;
  const { data: txnData, sendTransaction: sendTransaction2, isPending: isPendingSendTxn, error: sendTransactionError } = useSendTransaction();
  const { data: txnData2, isPending: isPendingMintTxn, writeContract: writeContract2 } = useWriteContract();
  const [isSigningMessage, setIsSigningMessage] = React.useState(false);
  const [isMessageValid, setIsMessageValid] = React.useState();
  const [messageSig, setMessageSig] = React.useState();
  const [lastTxnDataHash, setLastTxnDataHash] = React.useState();
  const [lastTxnDataHash2, setLastTxnDataHash2] = React.useState();
  const [confirmationEnabled, setConfirmationEnabled] = React.useState(
    localStorage.getItem("confirmationEnabled") === "true"
  );
  const [pendingFeeOptionConfirmation, confirmPendingFeeOption] = useWaasFeeOptions();
  const [selectedFeeOptionTokenName, setSelectedFeeOptionTokenName] = React.useState();
  reactExports.useEffect(() => {
    if (pendingFeeOptionConfirmation) {
      setSelectedFeeOptionTokenName(pendingFeeOptionConfirmation.options[0].token.name);
    }
  }, [pendingFeeOptionConfirmation]);
  reactExports.useEffect(() => {
    if (!sendTransactionError) {
      return;
    }
    if (sendTransactionError instanceof Error) {
      console.error(sendTransactionError.cause);
    } else {
      console.error(sendTransactionError);
    }
  }, [sendTransactionError]);
  const chainId = useChainId();
  const indexerClient = useIndexerClient(chainId);
  const [feeOptionBalances, setFeeOptionBalances] = React.useState([]);
  const [feeOptionAlert, setFeeOptionAlert] = React.useState(void 0);
  reactExports.useEffect(() => {
    checkTokenBalancesForFeeOptions();
  }, [pendingFeeOptionConfirmation]);
  const checkTokenBalancesForFeeOptions = async () => {
    if (pendingFeeOptionConfirmation && walletClient) {
      const [account2] = await walletClient.getAddresses();
      const nativeTokenBalance = await indexerClient.getEtherBalance({ accountAddress: account2 });
      const tokenBalances = await indexerClient.getTokenBalances({
        accountAddress: account2
      });
      const balances = pendingFeeOptionConfirmation.options.map((option) => {
        var _a3;
        if (option.token.contractAddress === null) {
          return {
            tokenName: option.token.name,
            decimals: option.token.decimals || 0,
            balance: nativeTokenBalance.balance.balanceWei
          };
        } else {
          return {
            tokenName: option.token.name,
            decimals: option.token.decimals || 0,
            balance: ((_a3 = tokenBalances.balances.find((b2) => {
              var _a4;
              return b2.contractAddress.toLowerCase() === ((_a4 = option.token.contractAddress) == null ? void 0 : _a4.toLowerCase());
            })) == null ? void 0 : _a3.balance) || "0"
          };
        }
      });
      setFeeOptionBalances(balances);
    }
  };
  const networkForCurrentChainId = allNetworks.find((n2) => n2.chainId === chainId);
  const publicClient = usePublicClient({ chainId });
  const generateEthAuthProof = async () => {
    if (!walletClient || !publicClient || !storage) {
      return;
    }
    try {
      const proof = await signEthAuthProof(walletClient, storage);
      console.log("proof:", proof);
      const isValid2 = await validateEthProof(walletClient, publicClient, proof);
      console.log("isValid?:", isValid2);
    } catch (e2) {
      console.error(e2);
    }
  };
  reactExports.useEffect(() => {
    if (txnData) {
      setLastTxnDataHash(txnData.hash ?? txnData);
    }
    if (txnData2) {
      setLastTxnDataHash2(txnData2.hash ?? txnData);
    }
  }, [txnData, txnData2]);
  const signMessage2 = async () => {
    if (!walletClient || !publicClient) {
      return;
    }
    setIsSigningMessage(true);
    try {
      const message = messageToSign;
      const sig = await walletClient.signMessage({
        account: address || "",
        message
      });
      console.log("address", address);
      console.log("signature:", sig);
      console.log("chainId in homepage", chainId);
      const [account2] = await walletClient.getAddresses();
      const isValid2 = await publicClient.verifyMessage({
        address: account2,
        message,
        signature: sig
      });
      setIsSigningMessage(false);
      setIsMessageValid(isValid2);
      setMessageSig(sig);
      console.log("isValid?", isValid2);
    } catch (e2) {
      setIsSigningMessage(false);
      if (e2 instanceof Error) {
        console.error(e2.cause);
      } else {
        console.error(e2);
      }
    }
  };
  const runSendTransaction = async () => {
    if (!walletClient) {
      return;
    }
    const contractAbiInterface = new Interface(["function demo()"]);
    const data = contractAbiInterface.encodeFunctionData("demo", []);
    sendTransaction2({
      to: "0x37470dac8a0255141745906c972e414b1409b470",
      data,
      gas: null
    });
  };
  const runMintNFT = async () => {
    if (!walletClient) {
      return;
    }
    const [account2] = await walletClient.getAddresses();
    writeContract2({
      address: "0x0d402C63cAe0200F0723B3e6fa0914627a48462E",
      abi,
      functionName: "awardItem",
      args: [account2, "https://dev-metadata.sequence.app/projects/277/collections/62/tokens/0.json"]
    });
  };
  const onClickCheckout = () => {
    setIsCheckoutInfoModalOpen(true);
  };
  const onClickSelectPayment = () => {
    if (!address) {
      return;
    }
    const currencyAddress = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359";
    const salesContractAddress = "0xe65b75eb7c58ffc0bf0e671d64d0e1c6cd0d3e5b";
    const collectionAddress = "0xdeb398f41ccd290ee5114df7e498cf04fac916cb";
    const price = "20000";
    const chainId2 = 137;
    openERC1155SaleContractPaymentModal({
      collectibles: [
        {
          tokenId: "1",
          quantity: "1"
        }
      ],
      chain: chainId2,
      price,
      targetContractAddress: salesContractAddress,
      recipientAddress: address,
      currencyAddress,
      collectionAddress,
      creditCardProviders: ["sardine"],
      isDev: true,
      copyrightText: "2024 Sequence",
      onSuccess: (txnHash) => {
        console.log("success!", txnHash);
      },
      onError: (error) => {
        console.error(error);
      }
    });
  };
  const onCheckoutInfoConfirm = () => {
    setIsCheckoutInfoModalOpen(false);
    if (checkoutOrderId !== "" && checkoutTokenContractAddress !== "" && checkoutTokenId !== "") {
      const chainId2 = ChainId.POLYGON;
      const orderbookAddress = "0xB537a160472183f2150d42EB1c3DD6684A55f74c";
      const recipientAddress = address || "";
      const nftQuantity = "1";
      const checkoutSettings = getCheckoutSettings({
        chainId: chainId2,
        contractAddress: orderbookAddress,
        recipientAddress,
        currencyQuantity: "100000",
        currencySymbol: "USDC",
        currencyAddress: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
        currencyDecimals: "6",
        nftId: checkoutTokenId,
        nftAddress: checkoutTokenContractAddress,
        nftQuantity,
        isDev: true,
        approvedSpenderAddress: orderbookAddress,
        calldata: getOrderbookCalldata({
          orderId: checkoutOrderId,
          quantity: nftQuantity,
          recipient: recipientAddress
        })
      });
      triggerCheckout(checkoutSettings);
    }
  };
  const onClickAddFunds = () => {
    triggerAddFunds({
      walletAddress: address || ""
    });
  };
  reactExports.useEffect(() => {
    setLastTxnDataHash(void 0);
    setLastTxnDataHash2(void 0);
    setIsMessageValid(void 0);
  }, [chainId]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { paddingX: "4", flexDirection: "column", justifyContent: "center", alignItems: "center", style: { margin: "140px 0" }, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "4", style: { maxWidth: breakpoints.md }, children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", fontWeight: "medium", children: "Demos" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Inventory",
            description: "Connect a Sequence wallet to view, swap, send, and receive collections",
            onClick: () => setOpenWalletModal(true)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Send transaction",
            description: "Send a transaction with your wallet",
            isPending: isPendingSendTxn,
            onClick: runSendTransaction
          }
        ),
        networkForCurrentChainId.blockExplorer && lastTxnDataHash && ((txnData == null ? void 0 : txnData.chainId) === chainId || txnData) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
          Text,
          {
            as: "a",
            marginLeft: "4",
            variant: "small",
            underline: true,
            href: `${networkForCurrentChainId.blockExplorer.rootUrl}/tx/${txnData.hash ?? txnData}`,
            target: "_blank",
            rel: "noreferrer",
            children: [
              "View on ",
              networkForCurrentChainId.blockExplorer.name
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Sign message",
            description: "Sign a message with your wallet",
            onClick: signMessage2,
            isPending: isSigningMessage
          }
        ),
        isMessageValid && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Card, { style: { width: "332px" }, color: "text100", flexDirection: "column", gap: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", children: "Signed message:" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { children: messageToSign }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", children: "Signature:" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "code", as: "p", ellipsis: true, children: messageSig }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Text, { variant: "medium", children: [
            "isValid: ",
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "code", children: isMessageValid.toString() })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(CardButton, { title: "Add Funds", description: "Buy Cryptocurrency with a Credit Card", onClick: () => onClickAddFunds() }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Mint an NFT",
            description: "Test minting an NFT to your wallet",
            isPending: isPendingMintTxn,
            onClick: runMintNFT
          }
        ),
        networkForCurrentChainId.blockExplorer && lastTxnDataHash2 && ((txnData2 == null ? void 0 : txnData2.chainId) === chainId || txnData2) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
          Text,
          {
            as: "a",
            marginLeft: "4",
            variant: "small",
            underline: true,
            href: `${networkForCurrentChainId.blockExplorer.rootUrl}/tx/${txnData2.hash ?? txnData2}`,
            target: "_blank",
            rel: "noreferrer",
            children: [
              "View on ",
              networkForCurrentChainId.blockExplorer.name
            ]
          }
        ),
        isDebugMode$1 && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(CardButton, { title: "Generate EthAuth proof", description: "Generate EthAuth proof", onClick: generateEthAuthProof }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            CardButton,
            {
              title: "NFT Checkout",
              description: "Set orderbook order id, token contract address and token id to test checkout (on Polygon)",
              onClick: onClickCheckout
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Checkout with Sequence Pay",
            description: "Purchase an NFT through various purchase methods",
            onClick: onClickSelectPayment
          }
        )
      ] }),
      pendingFeeOptionConfirmation && feeOptionBalances.length > 0 && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { marginY: "3", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Select,
          {
            name: "feeOption",
            labelLocation: "top",
            label: "Pick a fee option",
            onValueChange: (val) => {
              var _a3;
              const selected = (_a3 = pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.options) == null ? void 0 : _a3.find((option) => option.token.name === val);
              if (selected) {
                setSelectedFeeOptionTokenName(selected.token.name);
                setFeeOptionAlert(void 0);
              }
            },
            value: selectedFeeOptionTokenName,
            options: [
              ...(_a2 = pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.options) == null ? void 0 : _a2.map((option) => {
                var _a3;
                return {
                  label: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { alignItems: "flex-start", flexDirection: "column", children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", children: [
                      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Text, { variant: "xsmall", children: [
                        "Fee (in ",
                        option.token.name,
                        "): "
                      ] }),
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "xsmall", children: formatUnits$2(BigInt(option.value), option.token.decimals || 0) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", children: [
                      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Text, { children: [
                        "Wallet balance for ",
                        option.token.name,
                        ": "
                      ] }),
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { children: formatUnits$2(
                        BigInt(((_a3 = feeOptionBalances.find((b2) => b2.tokenName === option.token.name)) == null ? void 0 : _a3.balance) || "0"),
                        option.token.decimals || 0
                      ) })
                    ] })
                  ] }),
                  value: option.token.name
                };
              })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { marginY: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Button,
            {
              onClick: () => {
                var _a3, _b2;
                const selected = (_a3 = pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.options) == null ? void 0 : _a3.find(
                  (option) => option.token.name === selectedFeeOptionTokenName
                );
                if ((selected == null ? void 0 : selected.token.contractAddress) !== void 0) {
                  const balance = parseUnits$3(
                    ((_b2 = feeOptionBalances.find((b2) => b2.tokenName === selected.token.name)) == null ? void 0 : _b2.balance) || "0",
                    selected.token.decimals || 0
                  );
                  const feeOptionValue = parseUnits$3(selected.value, selected.token.decimals || 0);
                  if (balance && balance < feeOptionValue) {
                    setFeeOptionAlert({
                      title: "Insufficient balance",
                      description: `You do not have enough balance to pay the fee with ${selected.token.name}, please make sure you have enough balance in your wallet for the selected fee option.`,
                      secondaryDescription: "You can also switch network to Arbitrum Sepolia to test a gasless transaction.",
                      variant: "warning"
                    });
                    return;
                  }
                  confirmPendingFeeOption(pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.id, selected.token.contractAddress);
                }
              },
              label: "Confirm fee option"
            }
          ),
          feeOptionAlert && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { marginTop: "3", style: { maxWidth: "332px" }, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Alert,
            {
              title: feeOptionAlert.title,
              description: feeOptionAlert.description,
              secondaryDescription: feeOptionAlert.secondaryDescription,
              variant: feeOptionAlert.variant,
              buttonProps: feeOptionAlert.buttonProps
            }
          ) })
        ] })
      ] }),
      isWaasConnection && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { marginY: "3", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { as: "label", flexDirection: "row", alignItems: "center", justifyContent: "space-between", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { fontWeight: "semibold", variant: "small", color: "text50", children: "Confirmations" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { alignItems: "center", gap: "2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Switch,
          {
            name: "confirmations",
            checked: confirmationEnabled,
            onCheckedChange: async (checked) => {
              if (checked) {
                localStorage.setItem("confirmationEnabled", "true");
                setConfirmationEnabled(true);
              } else {
                localStorage.removeItem("confirmationEnabled");
                setConfirmationEnabled(false);
              }
              await delay(300);
              window.location.reload();
            }
          }
        ) })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(AnimatePresence, { children: isCheckoutInfoModalOpen && /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Modal,
      {
        contentProps: {
          style: {
            maxWidth: "400px",
            height: "auto",
            ...getModalPositionCss("center")
          }
        },
        scroll: false,
        backdropColor: "backgroundBackdrop",
        onClose: () => setIsCheckoutInfoModalOpen(false),
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { id: "sequence-kit-checkout-info-modal", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { paddingTop: "16", paddingBottom: "8", paddingX: "6", gap: "2", flexDirection: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text50", children: "Order ID" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            TextInput,
            {
              autoFocus: true,
              name: "orderId",
              value: checkoutOrderId,
              onChange: (ev) => setCheckoutOrderId(ev.target.value),
              placeholder: "Order Id",
              "data-1p-ignore": true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text50", children: "Token Contract Address" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            TextInput,
            {
              autoFocus: true,
              name: "tokenContractAddress",
              value: checkoutTokenContractAddress,
              onChange: (ev) => setCheckoutTokenContractAddress(ev.target.value),
              placeholder: "Token Contract Address",
              "data-1p-ignore": true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text50", children: "Token ID" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            TextInput,
            {
              autoFocus: true,
              name: "tokenId",
              value: checkoutTokenId,
              onChange: (ev) => setCheckoutTokenId(ev.target.value),
              placeholder: "Token Id",
              "data-1p-ignore": true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Button,
            {
              marginTop: "4",
              onClick: () => {
                onCheckoutInfoConfirm();
              },
              label: "Trigger checkout"
            }
          )
        ] }) })
      }
    ) })
  ] });
};
const Alert = ({ title, description: description2, secondaryDescription, variant, buttonProps, children }) => {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { borderRadius: "md", background: variant, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    Box,
    {
      background: "backgroundOverlay",
      borderRadius: "md",
      paddingX: { sm: "4", md: "5" },
      paddingY: "4",
      width: "full",
      flexDirection: "column",
      gap: "3",
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: { sm: "column", md: "row" }, gap: "2", justifyContent: "space-between", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "1", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", fontWeight: "medium", children: title }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: description2 }),
            secondaryDescription && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text80", fontWeight: "medium", children: secondaryDescription })
          ] }),
          buttonProps ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { background: variant, borderRadius: "sm", width: "min", height: "min", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Button, { variant: "emphasis", shape: "square", flexShrink: "0", ...buttonProps }) }) : null
        ] }),
        children
      ]
    }
  ) });
};
const searchParams$1 = new URLSearchParams(location.search);
const walletType$1 = searchParams$1.get("type") === "universal" ? "universal" : "waas";
const Homepage = () => {
  const { theme } = useTheme$1();
  const { isConnected } = useAccount();
  const { setOpenConnectModal } = useOpenConnectModal();
  const handleSwitchWalletType = (type) => {
    const searchParams2 = new URLSearchParams();
    searchParams2.set("type", type);
    window.location.search = searchParams2.toString();
  };
  const onClickConnect = () => {
    setOpenConnectModal(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("main", { children: [
    !isConnected ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "5", height: "vh", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "3", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Image$1, { style: { width: "48px" }, src: "images/kit-logo.svg" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Image$1,
          {
            style: {
              width: "32px",
              filter: theme === "dark" ? "invert(0)" : "invert(1)"
            },
            src: "images/kit-logo-text.svg"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { gap: "2", flexDirection: "row", alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Button, { onClick: onClickConnect, variant: "feature", label: "Connect" }) }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", flexDirection: "column", paddingX: "4", marginTop: "10", width: "full", style: { maxWidth: breakpoints.md }, children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          WalletTypeSelect,
          {
            type: "waas",
            title: "Embedded Wallet (WaaS)",
            description: "Connect to an embedded wallet for a seamless experience.",
            onClick: handleSwitchWalletType
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          WalletTypeSelect,
          {
            type: "universal",
            title: "Universal Wallet",
            description: "Connect to the universal sequence wallet or EIP6963 Injected wallet providers (web extension wallets).",
            onClick: handleSwitchWalletType
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(Connected, {}),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Footer, {})
  ] });
};
const WalletTypeSelect = (props) => {
  const { type, title, description: description2, onClick } = props;
  const isSelected = walletType$1 === type;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    Card,
    {
      width: "full",
      clickable: true,
      outlined: true,
      borderWidth: "thick",
      style: {
        boxShadow: isSelected ? "0 0 24px rgb(127 59 158 / 0.8)" : "none",
        borderColor: isSelected ? "rgb(127 59 200)" : "var(--seq-colors-border-normal)"
      },
      onClick: () => onClick(type),
      children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: isSelected ? "text100" : "text80", children: title }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "text50", marginTop: "2", children: description2 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { size: "md", style: { color: "rgb(127 59 200)" }, visibility: isSelected ? "visible" : "hidden" })
      ] })
    }
  );
};
const searchParams = new URLSearchParams(location.search);
const walletType = searchParams.get("type") === "universal" ? "universal" : "waas";
const isDebugMode = searchParams.has("debug");
const projectAccessKey = isDebugMode ? "AQAAAAAAAAK2JvvZhWqZ51riasWBftkrVXE" : "AQAAAAAAAEGvyZiWA9FMslYeG_yayXaHnSI";
const walletConnectProjectId = "c65a6cb1aa83c4e24500130f23a437d8";
const kitConfig = {
  projectAccessKey,
  defaultTheme: "dark",
  signIn: {
    projectName: "Kit Demo",
    useMock: isDebugMode
  },
  isDev: isDebugMode,
  displayedAssets: [
    // Native token
    {
      contractAddress: zeroAddress,
      chainId: ChainId.ARBITRUM_NOVA
    },
    // Native token
    {
      contractAddress: zeroAddress,
      chainId: ChainId.ARBITRUM_SEPOLIA
    },
    // Waas demo NFT
    {
      contractAddress: "0x0d402c63cae0200f0723b3e6fa0914627a48462e",
      chainId: ChainId.ARBITRUM_NOVA
    },
    // Waas demo NFT
    {
      contractAddress: "0x0d402c63cae0200f0723b3e6fa0914627a48462e",
      chainId: ChainId.ARBITRUM_SEPOLIA
    },
    // Skyweaver assets
    {
      contractAddress: "0x631998e91476da5b870d741192fc5cbc55f5a52e",
      chainId: ChainId.POLYGON
    }
  ]
};
const config = walletType === "waas" ? createConfig("waas", {
  ...kitConfig,
  appName: "Kit Demo",
  chainIds: [ChainId.ARBITRUM_NOVA, ChainId.ARBITRUM_SEPOLIA, ChainId.POLYGON],
  defaultChainId: ChainId.ARBITRUM_NOVA,
  waasConfigKey: isDebugMode ? "eyJwcm9qZWN0SWQiOjY5NCwicnBjU2VydmVyIjoiaHR0cHM6Ly9kZXYtd2Fhcy5zZXF1ZW5jZS5hcHAiLCJlbWFpbFJlZ2lvbiI6ImNhLWNlbnRyYWwtMSIsImVtYWlsQ2xpZW50SWQiOiI1NGF0bjV1cGk2M3FjNTlhMWVtM3ZiaHJzbiJ9" : "eyJwcm9qZWN0SWQiOjE2ODE1LCJlbWFpbFJlZ2lvbiI6ImNhLWNlbnRyYWwtMSIsImVtYWlsQ2xpZW50SWQiOiI2N2V2NXVvc3ZxMzVmcGI2OXI3NnJoYnVoIiwicnBjU2VydmVyIjoiaHR0cHM6Ly93YWFzLnNlcXVlbmNlLmFwcCJ9",
  enableConfirmationModal: localStorage.getItem("confirmationEnabled") === "true",
  google: {
    clientId: isDebugMode ? "603294233249-6h5saeg2uiu8akpcbar3r2aqjp6j7oem.apps.googleusercontent.com" : "970987756660-35a6tc48hvi8cev9cnknp0iugv9poa23.apps.googleusercontent.com"
  },
  apple: {
    clientId: "com.horizon.sequence.waas",
    redirectURI: window.location.origin + window.location.pathname
  },
  walletConnect: {
    projectId: walletConnectProjectId
  }
}) : createConfig("universal", {
  ...kitConfig,
  appName: "Kit Demo",
  chainIds: [ChainId.ARBITRUM_NOVA, ChainId.ARBITRUM_SEPOLIA, ChainId.POLYGON],
  defaultChainId: ChainId.ARBITRUM_NOVA,
  walletConnect: {
    projectId: walletConnectProjectId
  }
});
const App = () => {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(ThemeProvider, { theme: "dark", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SequenceKit, { config, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(KitWalletProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(KitCheckoutProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Homepage, {}) }) }) }) });
};
console.log("VERSION:", "1.0.4");
const root = client.createRoot(document.getElementById("root"));
root.render(/* @__PURE__ */ jsxRuntimeExports$1.jsx(App, {}));
export {
  Buffer2 as B,
  HttpRequestError as H,
  __vitePreload as _,
  getAugmentedNamespace as a,
  global$1 as b,
  commonjsGlobal as c,
  dist$1 as d,
  eventemitter3Exports as e,
  BaseError$3 as f,
  getDefaultExportFromCjs$1 as g,
  getUrl as h,
  decodeErrorResult as i,
  isAddressEqual as j,
  call as k,
  concat$1 as l,
  encodeAbiParameters as m,
  isHex as n,
  process$1 as p,
  stringify$3 as s,
  tslib_es6$1 as t
};
