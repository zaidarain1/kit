const __vite__fileDeps=["./index-BIKT5yla.js","./hooks.module-oQhvMlVp.js","./___vite-browser-external_commonjs-proxy-w52G4zHZ.js","./index-l3XLtm4P.js","./index.es-DNjTQ7Rd.js"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _dispatch, dispatch_fn, _d, _queries, _e, _observers, _mutationCache, _retryer2, _dispatch2, dispatch_fn2, _f, _mutations, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _executeFetch, executeFetch_fn, _updateStaleTimeout, updateStaleTimeout_fn, _computeRefetchInterval, computeRefetchInterval_fn, _updateRefetchInterval, updateRefetchInterval_fn, _updateTimers, updateTimers_fn, _clearStaleTimeout, clearStaleTimeout_fn, _clearRefetchInterval, clearRefetchInterval_fn, _updateQuery, updateQuery_fn, _notify, notify_fn, _i, _client2, _currentResult2, _currentMutation, _mutateOptions, _updateResult, updateResult_fn, _notify2, notify_fn2, _j;
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime$1 = { exports: {} };
var reactJsxRuntime_production_min$1 = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$4 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$7 = Symbol.for("react.profiler"), t$3 = Symbol.for("react.provider"), u$3 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$1(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$2 && a2[z$2] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$1.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$2(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$3;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$1 = /\/+/g;
function Q$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$3:
          case n$4:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$1(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$1(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$1(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$2 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a2, b2, e2) {
  S$1(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$1(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$1(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$1(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$7;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$3, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$3, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a2) {
  var b2 = M$1.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: y, _payload: { _status: -1, _result: a2 }, _init: T$1 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$1, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a2();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a2, b2) {
  return U$1.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$1.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$1.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$1.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$1.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$1.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$1.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$1.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$1.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$1.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$1.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$1.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs$1(reactExports);
const $2AODx$react = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$3 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: true, ref: true, __self: true, __source: true };
function q$3(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$3.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$3.current };
}
reactJsxRuntime_production_min$1.Fragment = l$2;
reactJsxRuntime_production_min$1.jsx = q$3;
reactJsxRuntime_production_min$1.jsxs = q$3;
{
  jsxRuntime$1.exports = reactJsxRuntime_production_min$1;
}
var jsxRuntimeExports$1 = jsxRuntime$1.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x, C2) ? (a2[d2] = x, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x, c2))
            a2[d2] = x, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v3 = null, y2 = 3, z = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v3 = h2(r2); null !== v3 && (!(v3.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v3.callback;
        if ("function" === typeof d2) {
          v3.callback = null;
          y2 = v3.priorityLevel;
          var e2 = d2(v3.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v3.callback = e2 : v3 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v3 = h2(r2);
      }
      if (null !== v3)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v3 = null, y2 = c2, z = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$2(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$1[a2] = new v$2(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$1[b2] = new v$2(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$1[a2] = new v$2(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$1[b2] = new v$2(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$3(91));
  return A({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$3(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$3(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$3(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$3(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$3(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$3(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$3(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$3(190));
  }
  if (3 !== c2.tag)
    throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec$1 = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id$3, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$3, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id$3 = null;
function Yc(a2, b2, c2, d2) {
  id$3 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$3 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec$1()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We[a2])
    return a2;
  var b2 = We[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x && (F2 = Kb(w2, x), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x = vf(x), u2--;
                for (; w2--; ) {
                  if (t2 === x || null !== x && t2 === x.alternate)
                    break b;
                  t2 = vf(t2);
                  x = vf(x);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$3(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$3(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a2, b2, c2) {
  if (H.current !== Vf)
    throw Error(p$3(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$3(108, Ra(a2) || "Unknown", e2));
  return A({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a2);
  G(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2;
      I = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I)
    return Fg(a2), I = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$3(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$3(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$3(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$3(284));
    if (!c2._owner)
      throw Error(p$3(290, a2));
  }
  return a2;
}
function Mg(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function Ng(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function Og(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = Pg(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Lg(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
      Mg(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      Mg(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x = u2, u2 = null) : x = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x = y2(u2, e3, w2, h3[w2], k3), null !== x && (a2 && null !== x.alternate && u2.delete(null === x.key ? w2 : x.key), g3 = f2(x, g3, w2), null === m3 ? l3 = x : m3.sibling = x, m3 = x);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$3(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x = m3, m3 = null) : x = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      Mg(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a2) {
  var b2 = Wg.current;
  E(Wg);
  a2._currentValue = b2;
}
function bh(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function ch(a2, b2) {
  Xg = a2;
  Zg = Yg = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
}
function eh(a2) {
  var b2 = a2._currentValue;
  if (Zg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg)
        throw Error(p$3(308));
      Yg = a2;
      Xg.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Yg = Yg.next = a2;
  return b2;
}
var fh = null;
function gh(a2) {
  null === fh ? fh = [a2] : fh.push(a2);
}
function hh(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a2, d2);
}
function ih(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function mh(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a2, c2);
}
function oh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function ph(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    rh$1 |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function sh$1(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$3(191, e2));
        e2.call(d2);
      }
    }
}
var th = {}, uh = Uf(th), vh$1 = Uf(th), wh = Uf(th);
function xh(a2) {
  if (a2 === th)
    throw Error(p$3(174));
  return a2;
}
function yh(a2, b2) {
  G(wh, b2);
  G(vh$1, a2);
  G(uh, th);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh$1);
  E(wh);
}
function Ah(a2) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G(vh$1, a2), G(uh, c2));
}
function Bh(a2) {
  vh$1.current === a2 && (E(uh), E(vh$1));
}
var L = Uf(0);
function Ch(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a2 = 0; a2 < Dh.length; a2++)
    Dh[a2]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N$1 = null, O = null, Ih = false, Jh = false, Kh$1 = 0, Lh = 0;
function P() {
  throw Error(p$3(321));
}
function Mh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Nh(a2, b2, c2, d2, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
  a2 = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh$1 = 0;
      if (25 <= f2)
        throw Error(p$3(301));
      f2 += 1;
      O = N$1 = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a2 = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N$1 && null !== N$1.next;
  Hh = 0;
  O = N$1 = M = null;
  Ih = false;
  if (b2)
    throw Error(p$3(300));
  return a2;
}
function Sh() {
  var a2 = 0 !== Kh$1;
  Kh$1 = 0;
  return a2;
}
function Th() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a2 : O = O.next = a2;
  return O;
}
function Uh() {
  if (null === N$1) {
    var a2 = M.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = N$1.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2)
    O = b2, N$1 = a2;
  else {
    if (null === a2)
      throw Error(p$3(310));
    N$1 = a2;
    a2 = { memoizedState: N$1.memoizedState, baseState: N$1.baseState, baseQueue: N$1.baseQueue, queue: N$1.queue, next: null };
    null === O ? M.memoizedState = O = a2 : O = O.next = a2;
  }
  return O;
}
function Vh(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Wh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = N$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh$1 |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, M.lanes |= f2, rh$1 |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a2, b2) {
  var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q)
      throw Error(p$3(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function ci(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a2);
}
function ai(a2, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a2);
  });
}
function ei(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a2) {
  var b2 = ih(a2, 1);
  null !== b2 && gi(b2, a2, 1, -1);
}
function hi(a2) {
  var b2 = Th();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ii.bind(null, M, a2);
  return [b2.memoizedState, a2];
}
function bi(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a2, b2, c2, d2) {
  var e2 = Th();
  M.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a2, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N$1) {
    var g2 = N$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a2, b2) {
  return ki(8390656, 8, a2, b2);
}
function $h(a2, b2) {
  return li(2048, 8, a2, b2);
}
function ni(a2, b2) {
  return li(4, 2, a2, b2);
}
function oi(a2, b2) {
  return li(4, 4, a2, b2);
}
function pi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function qi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return li(4, 4, pi.bind(null, b2, a2), c2);
}
function ri() {
}
function si(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ti(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function ui(a2, b2, c2) {
  if (0 === (Hh & 21))
    return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh$1 |= c2, a2.baseState = true);
  return b2;
}
function vi(a2, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a2, b2, c2) {
  var d2 = yi(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2))
    Ai(b2, c2);
  else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a2, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a2, b2, c2) {
  var d2 = yi(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2))
    Ai(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = hh(a2, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a2, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a2) {
  var b2 = a2.alternate;
  return a2 === M || null !== b2 && b2 === M;
}
function Ai(a2, b2) {
  Jh = Ih = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Bi(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
  Th().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ki(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ki(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = xi.bind(null, M, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = Th();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
  return Th().memoizedState = a2;
}, useTransition: function() {
  var a2 = hi(false), b2 = a2[0];
  a2 = vi.bind(null, a2[1]);
  Th().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = M, e2 = Th();
  if (I) {
    if (void 0 === c2)
      throw Error(p$3(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q)
      throw Error(p$3(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh$1++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a2) {
    var b2 = Uh();
    return ui(b2, N$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a2) {
  var b2 = Uh();
  return null === N$1 ? b2.memoizedState = a2 : ui(b2, N$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a2, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Di(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = R(), d2 = yi(a2), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a2, e2, d2);
  null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
} };
function Fi(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = {};
  kh(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function Ji(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Ki(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a2, b2);
  };
  return c2;
}
function Qi(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a2, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Ui(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Vi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
}
function Yi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a2, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a2 && !dh)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, d2, e2);
  return b2.child;
}
function $i(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
    a2 = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return Zi(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = Pg(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function bj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref)
      if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (dh = true);
      else
        return b2.lanes = a2.lanes, Zi(a2, b2, e2);
  }
  return cj(a2, b2, c2, d2, e2);
}
function dj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(ej, fj);
      fj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a2, b2, e2, c2);
  return b2.child;
}
function gj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a2, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a2 && !dh)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, c2, e2);
  return b2.child;
}
function hj(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode)
    ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a2, b2, c2, d2, f2, e2);
}
function jj(a2, b2, c2, d2, e2, f2) {
  gj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  yh(a2, b2.containerInfo);
}
function lj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a2, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function oj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G(L, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return rj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a2, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function sj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a2.child, null, c2);
  a2 = qj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function rj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Ki(Error(p$3(422))), sj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return sj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$3(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi(d2, a2, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$3(421)));
    return sj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a2.return, b2, c2);
}
function wj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a2, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && vj(a2, c2, b2);
          else if (19 === a2.tag)
            vj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        wj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        wj(b2, true, c2, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function ij(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  rh$1 |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$3(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = Pg(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return oj(a2, b2, c2);
        G(L, L.current & 1);
        a2 = Zi(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return xj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a2, b2, c2);
  }
  return Zi(a2, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A({}, e2, { value: void 0 });
        d2 = A({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Cj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a2, b2) {
  if (!I)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Ej(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a2, b2);
      S(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Bj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$3(166));
          S(b2);
          return null;
        }
        a2 = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          zj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a2);
                D("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a2
                );
                D("load", a2);
                e2 = d2;
                break;
              case "details":
                D("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A({}, d2, { value: void 0 });
                D("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Cj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$3(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(L);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$3(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$3(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return ah(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Dj(f2, false);
        else {
          if (0 !== T || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Ch(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Dj(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G(L, L.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Ch(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
              return S(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
function Ij(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$3(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Mj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a2, b2, d2);
  }
}
var Nj = false;
function Oj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V = a2;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x = b2.stateNode, w2 = x.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
                  x.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$3(163));
            }
        } catch (F2) {
          W(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V = a2;
          break;
        }
        V = b2.return;
      }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Sj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Sj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Tj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Uj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Vj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Vj(a2, b2, c2), a2 = a2.sibling;
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
var X = null, Xj = false;
function Yj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    Zj(a2, b2, c2), c2 = c2.sibling;
}
function Zj(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X, e2 = Xj;
      X = null;
      Yj(a2, b2, c2);
      X = d2;
      Xj = e2;
      null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Xj;
      X = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a2, b2, c2);
      X = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a2, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
      Yj(a2, b2, c2);
      break;
    case 21:
      Yj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a2, b2, c2), U = d2) : Yj(a2, b2, c2);
      break;
    default:
      Yj(a2, b2, c2);
  }
}
function ak(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Xj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Xj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$3(160));
        Zj(f2, g2, e2);
        X = null;
        Xj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      dk(b2, a2), b2 = b2.sibling;
}
function dk(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        try {
          Pj(3, a2, a2.return), Qj(3, a2);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        try {
          Pj(5, a2, a2.return);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$3(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      break;
    case 4:
      ck(b2, a2);
      ek(a2);
      break;
    case 13:
      ck(b2, a2);
      ek(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a2), U = l2) : ck(b2, a2);
      ek(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      ck(b2, a2);
      ek(a2);
      d2 & 4 && ak(a2);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a2
      ), ek(a2);
  }
}
function ek(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a2);
          Wj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
          Vj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function hk(a2, b2, c2) {
  V = a2;
  ik(a2);
}
function ik(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; )
          V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a2);
  }
}
function kk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && sh$1(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                sh$1(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$3(163));
          }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function gk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a2) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function jk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K$1 = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh$1 = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K$1 & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Bk && (Bk = yc()), Bk;
  a2 = C;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function gi(a2, b2, c2, d2) {
  if (50 < yk)
    throw yk = 0, zk = null, Error(p$3(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== Q)
    a2 === Q && (0 === (K$1 & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Gk(a2, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Hk() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Ik(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Jk();
    if (Q !== a2 || Z !== b2)
      uk = null, Gj = B() + 500, Kk(a2, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a2, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K$1 = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Nk(a2, e2)));
    if (1 === b2)
      throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
    if (6 === b2)
      Ck(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2))
        throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Pk(a2, tk, uk);
          break;
        case 3:
          Ck(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 4:
          Ck(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 5:
          Pk(a2, tk, uk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  Dk(a2, B());
  return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
}
function Nk(a2, b2) {
  var c2 = sk;
  a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
  a2 = Ik(a2, b2);
  2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a2;
}
function Fj(a2) {
  null === tk ? tk = a2 : tk.push.apply(tk, a2);
}
function Ok(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a2, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  Hk();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Dk(a2, B()), null;
  var c2 = Ik(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
  }
  if (1 === c2)
    throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B()), c2;
  if (6 === c2)
    throw Error(p$3(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Pk(a2, tk, uk);
  Dk(a2, B());
  return null;
}
function Qk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a2) {
  null !== wk && 0 === wk.tag && 0 === (K$1 & 6) && Hk();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a2)
      return a2();
  } finally {
    C = d2, ok.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
  Q = a2;
  Y = a2 = Pg(a2.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh$1 = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++)
      if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    fh = null;
  }
  return a2;
}
function Mk(a2, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N$1 = M = null;
      Jh = false;
      Kh$1 = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x = Ni(f2, k2, b2);
              ph(f2, x);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a2 = mk.current;
  mk.current = Rh;
  return null === a2 ? Rh : a2;
}
function tj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === Q || 0 === (rh$1 & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Jk();
  if (Q !== a2 || Z !== b2)
    uk = null, Kk(a2, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a2, e2);
    }
  while (1);
  $g();
  K$1 = c2;
  mk.current = d2;
  if (null !== Y)
    throw Error(p$3(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; )
    Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); )
    Uk(Y);
}
function Uk(a2) {
  var b2 = Vk(a2.alternate, a2, fj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Sk(a2) : Y = b2;
  nk.current = null;
}
function Sk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a2, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a2, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
function Wk(a2, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$3(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K$1;
    K$1 |= 4;
    nk.current = null;
    Oj(a2, c2);
    dk(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    hk(c2);
    dc();
    K$1 = h2;
    C = g2;
    ok.transition = f2;
  } else
    a2.current = c2;
  vk && (vk = false, wk = a2, xk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a2, B());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi)
    throw Oi = false, a2 = Pi, Pi = null, a2;
  0 !== (xk & 1) && 0 !== a2.tag && Hk();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a2 = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a2 ? 16 : a2;
      if (null === wk)
        var d2 = false;
      else {
        a2 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$3(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V = a2.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V = g2;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f2, f2.return);
                  }
                var x = f2.sibling;
                if (null !== x) {
                  x.return = f2.return;
                  V = x;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a2.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V = u2;
          else
            b:
              for (g2 = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a2, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a2, b2, 1);
  a2 = nh(a2, b2, 1);
  b2 = R();
  null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
}
function W(a2, b2, c2) {
  if (3 === a2.tag)
    Xk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a2 = Ji(c2, a2);
          a2 = Qi(b2, a2, 1);
          b2 = nh(b2, a2, 1);
          a2 = R();
          null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
  Dk(a2, b2);
}
function Yk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a2 = ih(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
}
function uj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a2, c2);
}
function bk(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a2, c2);
}
var Vk;
Vk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      dh = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return dh = false, yj(a2, b2, c2);
      dh = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a2, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a2 = Ci(d2, a2);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a2, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a2)
          throw Error(p$3(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a2, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ji(Error(p$3(423)), b2);
            b2 = lj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ji(Error(p$3(424)), b2);
            b2 = lj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
          Xi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return oj(a2, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a2, b2, d2, e2, c2);
    case 7:
      return Xi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = mh(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    bh(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$3(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                bh(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Xi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a2, b2, d2, e2, c2);
    case 15:
      return bj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a2, c2);
    case 19:
      return xj(a2, b2, c2);
    case 22:
      return dj(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
};
function Fk(a2, b2) {
  return ac(a2, b2);
}
function $k(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new $k(a2, b2, c2, d2);
}
function aj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function Zk(a2) {
  if ("function" === typeof a2)
    return aj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function Pg(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Rg(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    aj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Tg(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return pj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$3(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function pj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function Qg(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function Sg(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function al(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new al(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a2;
}
function cl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function dl(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$3(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function el(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = bl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = dl(null);
  c2 = a2.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Dk(a2, d2);
  return a2;
}
function fl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = nh(e2, b2, g2);
  null !== a2 && (gi(a2, e2, g2, f2), oh(a2, e2, g2));
  return g2;
}
function gl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function hl(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a2, b2) {
  hl(a2, b2);
  (a2 = a2.alternate) && hl(a2, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ll(a2) {
  this._internalRoot = a2;
}
ml.prototype.render = ll.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$3(409));
  fl(a2, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Rk(function() {
      fl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a2) {
  this._internalRoot = a2;
}
ml.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function nl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function pl() {
}
function ql(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = gl(g2);
        f2.call(a3);
      };
    }
    var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = gl(k2);
      h2.call(a3);
    };
  }
  var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = gl(g2);
        h2.call(a3);
      };
    }
    fl(b2, g2, a2, e2);
  } else
    g2 = ql(c2, b2, a2, e2, d2);
  return gl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K$1 & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a2, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a2, 1, c3);
        }
      }), il(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = ih(a2, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a2, 134217728, c2);
    }
    il(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = yi(a2), c2 = ih(a2, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a2, b2, d2);
    }
    il(a2, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a2, b2) {
  var c2 = C;
  try {
    return C = a2, b2();
  } finally {
    C = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$3(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber)
    try {
      kc = vl.inject(ul), lc = vl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2))
    throw Error(p$3(200));
  return cl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!nl(a2))
    throw Error(p$3(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$3(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$3(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Rk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!ol(b2))
    throw Error(p$3(200));
  return rl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!nl(a2))
    throw Error(p$3(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new ml(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!ol(b2))
    throw Error(p$3(200));
  return rl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!ol(a2))
    throw Error(p$3(40));
  return a2._reactRootContainer ? (Rk(function() {
    rl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!ol(c2))
    throw Error(p$3(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$3(38));
  return rl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const $7SXl2$reactdom = /* @__PURE__ */ getDefaultExportFromCjs$1(reactDomExports);
var m$2 = reactDomExports;
{
  client.createRoot = m$2.createRoot;
  client.hydrateRoot = m$2.hydrateRoot;
}
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = reactExports.createContext({});
function useVisualElementContext() {
  return reactExports.useContext(MotionContext).visualElement;
}
const PresenceContext = reactExports.createContext(null);
const isBrowser$2 = typeof document !== "undefined";
const useIsomorphicLayoutEffect$2 = isBrowser$2 ? reactExports.useLayoutEffect : reactExports.useEffect;
const LazyContext = reactExports.createContext({ strict: false });
function useVisualElement(Component2, visualState, props, createVisualElement) {
  const parent2 = useVisualElementContext();
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component2, {
      visualState,
      parent: parent2,
      props,
      presenceId: presenceContext ? presenceContext.id : void 0,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  useIsomorphicLayoutEffect$2(() => {
    visualElement && visualElement.render();
  });
  const useAnimateChangesEffect = window.HandoffAppearAnimations ? useIsomorphicLayoutEffect$2 : reactExports.useEffect;
  useAnimateChangesEffect(() => {
    if (visualElement && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  return visualElement;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v3) {
  return typeof v3 === "string" || Array.isArray(v3);
}
function isAnimationControls(v3) {
  return typeof v3 === "object" && typeof v3.start === "function";
}
const variantProps$1 = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps$1.some((name2) => isVariantLabel(props[name2]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context2) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== false ? context2 : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const createDefinition = (propNames) => ({
  isEnabled: (props) => propNames.some((name2) => !!props[name2])
});
const featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features) {
  for (const key2 in features) {
    if (key2 === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key2];
    } else {
      featureDefinitions[key2].Component = features[key2];
    }
  }
}
function useConstant(init3) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init3();
  }
  return ref.current;
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
let id$2 = 1;
function useProjectionId() {
  return useConstant(() => {
    if (globalProjectionState.hasEverUpdated) {
      return id$2++;
    }
  });
}
const LayoutGroupContext = reactExports.createContext({});
class VisualElementHandler extends React.Component {
  /**
   * Update visual element props as soon as we know this update is going to be commited.
   */
  getSnapshotBeforeUpdate() {
    const { visualElement, props } = this.props;
    if (visualElement)
      visualElement.setProps(props);
    return null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
const SwitchLayoutGroupContext = reactExports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component: Component2 }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    let features = null;
    const context2 = useCreateMotionContext(props);
    const projectionId = isStatic ? void 0 : useProjectionId();
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$2) {
      context2.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement);
      const lazyStrictMode = reactExports.useContext(LazyContext).strict;
      const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
      if (context2.visualElement) {
        features = context2.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          lazyStrictMode,
          preloadedFeatures,
          projectionId,
          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,
          initialLayoutGroupConfig
        );
      }
    }
    return reactExports.createElement(
      VisualElementHandler,
      { visualElement: context2.visualElement, props: configAndProps },
      features,
      reactExports.createElement(MotionContext.Provider, { value: context2 }, useRender(Component2, props, projectionId, useMotionRef(visualState, context2.visualElement, externalRef), visualState, isStatic, context2.visualElement))
    );
  }
  const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component2;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig2) {
  function custom2(Component2, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig2(Component2, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom2;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom2, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => {
      if (!componentCache.has(key2)) {
        componentCache.set(key2, custom2(key2));
      }
      return componentCache.get(key2);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component2) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component2)
  ) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key2, { layout, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}
const isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const sortTransformProps = (a2, b2) => transformPropOrder.indexOf(a2) - transformPropOrder.indexOf(b2);
function buildTransform({ transform, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  transformKeys2.sort(sortTransformProps);
  for (const key2 of transformKeys2) {
    transformString += `${translateAlias[key2] || key2}(${transform[key2]}) `;
  }
  if (enableHardwareAcceleration && !transform.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function isCSSVariable$1(key2) {
  return key2.startsWith("--");
}
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp$3 = (min2, max2, v3) => Math.min(Math.max(v3, min2), max2);
const number$1 = {
  test: (v3) => typeof v3 === "number",
  parse: parseFloat,
  transform: (v3) => v3
};
const alpha = {
  ...number$1,
  transform: (v3) => clamp$3(0, 1, v3)
};
const scale = {
  ...number$1,
  default: 1
};
const sanitize = (v3) => Math.round(v3 * 1e5) / 1e5;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$1(v3) {
  return typeof v3 === "string";
}
const createUnitType = (unit) => ({
  test: (v3) => isString$1(v3) && v3.endsWith(unit) && v3.split(" ").length === 1,
  parse: parseFloat,
  transform: (v3) => `${v3}${unit}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v3) => percent.parse(v3) / 100,
  transform: (v3) => percent.transform(v3 * 100)
};
const int = {
  ...number$1,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style, vars: vars2, transform, transformKeys: transformKeys2, transformOrigin: transformOrigin2 } = state;
  transformKeys2.length = 0;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (isCSSVariable$1(key2)) {
      vars2[key2] = value;
      continue;
    }
    const valueType = numberValueTypes[key2];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key2)) {
      hasTransform2 = true;
      transform[key2] = valueAsType;
      transformKeys2.push(key2);
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key2.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin2[key2] = valueAsType;
    } else {
      style[key2] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key2 in source) {
    if (!isMotionValue(source[key2]) && !isForcedMotionValue(key2, props)) {
      target[key2] = source[key2];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  htmlProps.style = style;
  return htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || validMotionProps.has(key2);
}
let shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a2) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props) {
    if (key2 === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key2) || forwardMotionProps === true && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key2.startsWith("onDrag")) {
      filteredProps[key2] = props[key2];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset2, size2) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset2);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component2), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component2, props, projectionId, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component2);
    const filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return reactExports.createElement(Component2, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars: vars2 }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key2 in vars2) {
    element.style.setProperty(key2, vars2[key2]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key2) ? camelToDash(key2) : key2, renderState.attrs[key2]);
  }
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style } = props;
  const newValues = {};
  for (const key2 in style) {
    if (isMotionValue(style[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props)) {
      newValues[key2] = style[key2];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key2 in props) {
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = key2 === "x" || key2 === "y" ? "attr" + key2.toUpperCase() : key2;
      newValues[targetKey] = props[key2];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom2, currentValues2 = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom2 !== void 0 ? custom2 : props.custom, currentValues2, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom2 !== void 0 ? custom2 : props.custom, currentValues2, currentVelocity);
  }
  return definition;
}
const isKeyframesTarget = (v3) => {
  return Array.isArray(v3);
};
const isCustomValue = (v3) => {
  return Boolean(v3 && typeof v3 === "object" && v3.mix && v3.toValue);
};
const resolveFinalValueInKeyframes = (v3) => {
  return isKeyframesTarget(v3) ? v3[v3.length - 1] || 0 : v3;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context2, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context2, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context2 = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config2, props, context2, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context2, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues) {
    values[key2] = resolveMotionValue(motionValues[key2]);
  }
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context2 && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context2.initial;
    if (animate2 === void 0)
      animate2 = context2.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list2.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key2 in target) {
        let valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values[key2] = valueTarget;
        }
      }
      for (const key2 in transitionEnd)
        values[key2] = transitionEnd[key2];
    });
  }
  return values;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e2) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component2, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  const baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    projectionNodeConstructor,
    Component: Component2
  };
}
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function useDomEvent(ref, eventName, handler, options) {
  reactExports.useEffect(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
function useFocusGesture({ whileFocus, visualElement }) {
  const { animationState } = visualElement;
  const onFocus = reactExports.useCallback(() => {
    animationState && animationState.setActive(AnimationType.Focus, true);
  }, [animationState]);
  const onBlur = reactExports.useCallback(() => {
    animationState && animationState.setActive(AnimationType.Focus, false);
  }, [animationState]);
  useDomEvent(visualElement, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement, "blur", whileFocus ? onBlur : void 0);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, eventName, handler && addPointerInfo(handler), options);
}
function createLock(name2) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name2;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
function createHoverEvent(visualElement, isActive, applyVariants, callback) {
  return (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    if (applyVariants && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Hover, isActive);
    }
    callback && callback(event, info);
  };
}
function useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement }) {
  usePointerEvent(visualElement, "pointerenter", reactExports.useMemo(() => {
    return onHoverStart || whileHover ? createHoverEvent(visualElement, true, Boolean(whileHover), onHoverStart) : void 0;
  }, [onHoverStart, Boolean(whileHover), visualElement]), { passive: !onHoverStart });
  usePointerEvent(visualElement, "pointerleave", reactExports.useMemo(() => {
    return onHoverEnd || whileHover ? createHoverEvent(visualElement, false, Boolean(whileHover), onHoverEnd) : void 0;
  }, [onHoverStart, Boolean(whileHover), visualElement]), { passive: !onHoverEnd });
}
const isNodeOrChild = (parent2, child) => {
  if (!child) {
    return false;
  } else if (parent2 === child) {
    return true;
  } else {
    return isNodeOrChild(parent2, child.parentElement);
  }
};
function useUnmountEffect(callback) {
  return reactExports.useEffect(() => () => callback(), []);
}
const combineFunctions = (a2, b2) => (v3) => b2(a2(v3));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, ...props }) {
  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  const isPressing = reactExports.useRef(false);
  const cancelPointerEndListeners = reactExports.useRef(null);
  const eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || props["onPointerDown"])
  };
  function removePointerEndListener() {
    cancelPointerEndListeners.current && cancelPointerEndListeners.current();
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    removePointerEndListener();
    isPressing.current = false;
    const latestProps = visualElement.getProps();
    if (latestProps.whileTap && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Tap, false);
    }
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    var _a2, _b2, _c2, _d2;
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement.current, event.target) ? (_b2 = (_a2 = visualElement.getProps()).onTapCancel) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info) : (_d2 = (_c2 = visualElement.getProps()).onTap) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, event, info);
  }
  function onPointerCancel(event, info) {
    var _a2, _b2;
    if (!checkPointerEnd())
      return;
    (_b2 = (_a2 = visualElement.getProps()).onTapCancel) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info);
  }
  const startPress = reactExports.useCallback((event, info) => {
    var _a2;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    const latestProps = visualElement.getProps();
    if (latestProps.whileTap && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Tap, true);
    }
    (_a2 = latestProps.onTapStart) === null || _a2 === void 0 ? void 0 : _a2.call(latestProps, event, info);
  }, [Boolean(onTapStart), visualElement]);
  usePointerEvent(visualElement, "pointerdown", hasPressListeners ? startPress : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key2 = JSON.stringify(options);
  if (!rootObservers[key2]) {
    rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
  }
  return rootObservers[key2];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
function useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {
  const state = reactExports.useRef({
    hasEnteredView: false,
    isInView: false
  });
  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state.current.hasEnteredView)
    shouldObserve = false;
  const useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver$1;
  useObserver(shouldObserve, state.current, visualElement, viewport);
}
const thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver$1(shouldObserve, state, visualElement, { root: root2, margin: rootMargin, amount = "some", once }) {
  reactExports.useEffect(() => {
    if (!shouldObserve || !visualElement.current)
      return;
    const options = {
      root: root2 === null || root2 === void 0 ? void 0 : root2.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const intersectionCallback = (entry) => {
      const { isIntersecting } = entry;
      if (state.isInView === isIntersecting)
        return;
      state.isInView = isIntersecting;
      if (once && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      if (visualElement.animationState) {
        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);
      }
      const props = visualElement.getProps();
      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(visualElement.current, options, intersectionCallback);
  }, [shouldObserve, root2, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback: fallback2 = true }) {
  reactExports.useEffect(() => {
    if (!shouldObserve || !fallback2)
      return;
    requestAnimationFrame(() => {
      state.hasEnteredView = true;
      const { onViewportEnter } = visualElement.getProps();
      onViewportEnter && onViewportEnter(null);
      if (visualElement.animationState) {
        visualElement.animationState.setActive(AnimationType.InView, true);
      }
    });
  }, [shouldObserve]);
}
const makeRenderlessComponent = (hook) => (props) => {
  hook(props);
  return null;
};
const gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};
function usePresence$1() {
  const context2 = reactExports.useContext(PresenceContext);
  if (context2 === null)
    return [true, null];
  const { isPresent, onExitComplete, register: register2 } = context2;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => register2(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}
const isNumericalString = (v3) => /^\-?\d*\.?\d+$/.test(v3);
const isZeroValueString = (v3) => /^0[^.\s]+$/.test(v3);
const frameData = {
  delta: 0,
  timestamp: 0
};
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer2 = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer2.indexOf(callback) === -1) {
        buffer2.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key2) => {
  acc[key2] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key2) => {
  const step = steps[key2];
  acc[key2] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key2) => {
  acc[key2] = steps[key2].cancel;
  return acc;
}, {});
const flushSync = stepsOrder.reduce((acc, key2) => {
  acc[key2] = () => steps[key2].process(frameData);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frameData);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frameData.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed), 1);
  frameData.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
function addUniqueItem(arr, item2) {
  if (arr.indexOf(item2) === -1)
    arr.push(item2);
}
function removeItem(arr, item2) {
  const index2 = arr.indexOf(item2);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a2, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init3, options = {}) {
    this.version = "8.5.5";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v3, render = true) => {
      this.prev = this.current;
      this.current = v3;
      const { delta, timestamp } = frameData;
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        sync.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => sync.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init3;
    this.canTrackVelocity = isFloat(this.current);
    this.owner = options.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        sync.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v3, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v3, render);
    } else {
      this.passiveEffect(v3, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = prev;
    this.timeDelta = delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v3) {
    this.updateAndNotify(v3);
    this.prev = v3;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve) || null;
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    this.animation = null;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init3, options) {
  return new MotionValue(init3, options);
}
const isColorString = (type, testProp) => (v3) => {
  return Boolean(isString$1(v3) && singleColorRegex.test(v3) && v3.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v3, testProp));
};
const splitColor = (aName, bName, cName) => (v3) => {
  if (!isString$1(v3))
    return v3;
  const [a2, b2, c2, alpha2] = v3.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v3) => clamp$3(0, 255, v3);
const rgbUnit = {
  ...number$1,
  transform: (v3) => Math.round(clampRgbUnit(v3))
};
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v3) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v3.length > 5) {
    r2 = v3.substring(1, 3);
    g2 = v3.substring(3, 5);
    b2 = v3.substring(5, 7);
    a2 = v3.substring(7, 9);
  } else {
    r2 = v3.substring(1, 2);
    g2 = v3.substring(2, 3);
    b2 = v3.substring(3, 4);
    a2 = v3.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v3) => rgba.test(v3) || hex.test(v3) || hsla.test(v3),
  parse: (v3) => {
    if (rgba.test(v3)) {
      return rgba.parse(v3);
    } else if (hsla.test(v3)) {
      return hsla.parse(v3);
    } else {
      return hex.parse(v3);
    }
  },
  transform: (v3) => {
    return isString$1(v3) ? v3 : v3.hasOwnProperty("red") ? rgba.transform(v3) : hsla.transform(v3);
  }
};
const colorToken = "${c}";
const numberToken = "${n}";
function test(v3) {
  var _a2, _b2;
  return isNaN(v3) && isString$1(v3) && (((_a2 = v3.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) || 0) + (((_b2 = v3.match(colorRegex)) === null || _b2 === void 0 ? void 0 : _b2.length) || 0) > 0;
}
function analyseComplexValue(v3) {
  if (typeof v3 === "number")
    v3 = `${v3}`;
  const values = [];
  let numColors = 0;
  let numNumbers = 0;
  const colors2 = v3.match(colorRegex);
  if (colors2) {
    numColors = colors2.length;
    v3 = v3.replace(colorRegex, colorToken);
    values.push(...colors2.map(color.parse));
  }
  const numbers = v3.match(floatRegex);
  if (numbers) {
    numNumbers = numbers.length;
    v3 = v3.replace(floatRegex, numberToken);
    values.push(...numbers.map(number$1.parse));
  }
  return { values, numColors, numNumbers, tokenised: v3 };
}
function parse$4(v3) {
  return analyseComplexValue(v3).values;
}
function createTransformer(source) {
  const { values, numColors, tokenised } = analyseComplexValue(source);
  const numValues = values.length;
  return (v3) => {
    let output2 = tokenised;
    for (let i = 0; i < numValues; i++) {
      output2 = output2.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v3[i]) : sanitize(v3[i]));
    }
    return output2;
  };
}
const convertNumbersToZero = (v3) => typeof v3 === "number" ? 0 : v3;
function getAnimatableNone$1(v3) {
  const parsed = parse$4(v3);
  const transformer = createTransformer(v3);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = { test, parse: parse$4, createTransformer, getAnimatableNone: getAnimatableNone$1 };
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v3) {
  const [name2, value] = v3.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v3;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v3;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name2 + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = {
  ...complex,
  getAnimatableNone: (v3) => {
    const functions = v3.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v3;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key2) => defaultValueTypes[key2];
function getAnimatableNone(key2, value) {
  var _a2;
  let defaultValueType = getDefaultValueType(key2);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a2 = defaultValueType.getAnimatableNone) === null || _a2 === void 0 ? void 0 : _a2.call(defaultValueType, value);
}
const testValueType = (v3) => (type) => type.test(v3);
const auto = {
  test: (v3) => v3 === "auto",
  parse: (v3) => v3
};
const dimensionValueTypes = [number$1, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v3) => dimensionValueTypes.find(testValueType(v3));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v3) => valueTypes.find(testValueType(v3));
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key2) => current[key2] = value.get());
  return current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key2) => velocity[key2] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom2) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom2 !== void 0 ? custom2 : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
function setMotionValue(visualElement, key2, value) {
  if (visualElement.hasValue(key2)) {
    visualElement.getValue(key2).set(value);
  } else {
    visualElement.addValue(key2, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a2, _b2;
  const newValueKeys = Object.keys(target).filter((key2) => !visualElement.hasValue(key2));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i = 0; i < numNewValues; i++) {
    const key2 = newValueKeys[i];
    const targetValue = target[key2];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b2 = (_a2 = origin[key2]) !== null && _a2 !== void 0 ? _a2 : visualElement.readValue(key2)) !== null && _b2 !== void 0 ? _b2 : target[key2];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key2, targetValue);
    }
    visualElement.addValue(key2, motionValue(value, { owner: visualElement }));
    if (origin[key2] === void 0) {
      origin[key2] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key2, value);
  }
}
function getOriginFromTransition(key2, transition) {
  if (!transition)
    return;
  const valueTransition = transition[key2] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement) {
  var _a2;
  const origin = {};
  for (const key2 in target) {
    const transitionOrigin = getOriginFromTransition(key2, transition);
    origin[key2] = transitionOrigin !== void 0 ? transitionOrigin : (_a2 = visualElement.getValue(key2)) === null || _a2 === void 0 ? void 0 : _a2.get();
  }
  return origin;
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
var invariant = function() {
};
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const instantAnimationState = {
  current: false
};
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const easeIn = (p2) => p2 * p2;
const easeOut = reverseEasing(easeIn);
const easeInOut = mirrorEasing(easeIn);
const mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from, to, v3) => {
  const fromExpo = from * from;
  return Math.sqrt(Math.max(0, v3 * (to * to - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v3) => colorTypes.find((type) => type.test(v3));
function asRGBA(color2) {
  const type = getColorType(color2);
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v3) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v3);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v3);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v3);
    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v3);
    return rgba.transform(blended);
  };
};
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v3) => mix(origin, target, v3);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
const mixArray = (from, to) => {
  const output2 = [...from];
  const numValues = output2.length;
  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v3) => {
    for (let i = 0; i < numValues; i++) {
      output2[i] = blendValue[i](v3);
    }
    return output2;
  };
};
const mixObject = (origin, target) => {
  const output2 = { ...origin, ...target };
  const blendValue = {};
  for (const key2 in output2) {
    if (origin[key2] !== void 0 && target[key2] !== void 0) {
      blendValue[key2] = getMixer(origin[key2], target[key2]);
    }
  }
  return (v3) => {
    for (const key2 in blendValue) {
      output2[key2] = blendValue[key2](v3);
    }
    return output2;
  };
};
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.values, targetStats.values), template);
  } else {
    return (p2) => `${p2 > 0 ? target : origin}`;
  }
};
const progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
const mixNumber = (from, to) => (p2) => mix(from, to, p2);
function detectMixerFactory(v3) {
  if (typeof v3 === "number") {
    return mixNumber;
  } else if (typeof v3 === "string") {
    if (color.test(v3)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v3)) {
    return mixArray;
  } else if (typeof v3 === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output2, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output2[0]);
  const numMixers = output2.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output2[i], output2[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input2, output2, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input2.length;
  invariant(inputLength === output2.length);
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1);
  if (input2[0] > input2[inputLength - 1]) {
    input2 = [...input2].reverse();
    output2 = [...output2].reverse();
  }
  const mixers = createMixers(output2, ease, mixer);
  const numMixers = mixers.length;
  const interpolator = (v3) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input2.length - 2; i++) {
        if (v3 < input2[i + 1])
          break;
      }
    }
    const progressInRange = progress(input2[i], input2[i + 1], v3);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v3) => interpolator(clamp$3(input2[0], input2[inputLength - 1], v3)) : interpolator;
}
const noop$3 = (any) => any;
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$3;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const easingLookup = {
  linear: noop$3,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0);
    return easingLookup[definition];
  }
  return definition;
};
const isEasingArray = (ease) => {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o2) => o2 * duration);
}
function keyframes({ keyframes: keyframeValues, ease = easeInOut, times, duration = 300 }) {
  keyframeValues = [...keyframeValues];
  const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  function createInterpolator() {
    return interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state.value = interpolator(t2);
      state.done = t2 >= duration;
      return state;
    },
    flipTarget: () => {
      keyframeValues.reverse();
      interpolator = createInterpolator();
    }
  };
}
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$3(minDamping, maxDamping, dampingRatio);
  duration = clamp$3(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key2) => options[key2] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
const velocitySampleDuration = 5;
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  let origin = keyframes2[0];
  let target = keyframes2[keyframes2.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let initialVelocity = velocity ? -(velocity / 1e3) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  function createSpring() {
    const initialDelta = target - origin;
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
    restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t2 !== 0) {
          if (dampingRatio < 1) {
            const prevT = Math.max(0, t2 - velocitySampleDuration);
            currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t2 - prevT);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    flipTarget: () => {
      initialVelocity = -initialVelocity;
      [origin, target] = [target, origin];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a2, b2) => typeof a2 === "string" || typeof b2 === "string";
const zero = (_t) => 0;
function decay({
  /**
   * The decay animation dynamically calculates an end of the animation
   * based on the initial keyframe, so we only need to define a single keyframe
   * as default.
   */
  keyframes: keyframes2 = [0],
  velocity = 0,
  power = 0.8,
  timeConstant = 350,
  restDelta = 0.5,
  modifyTarget
}) {
  const origin = keyframes2[0];
  const state = { done: false, value: origin };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}
const types$1 = {
  decay,
  keyframes,
  tween: keyframes,
  spring
};
function loopElapsed(elapsed, duration, delay2 = 0) {
  return elapsed - duration - delay2;
}
function reverseElapsed(elapsed, duration = 0, delay2 = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;
}
function hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;
}
const framesync = (update5) => {
  const passTimestamp = ({ delta }) => update5(delta);
  return {
    start: () => sync.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate$1({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, keyframes: keyframes$1, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type = "keyframes", ...options }) {
  var _a2, _b2;
  const initialElapsed = elapsed;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = duration;
  let isComplete2 = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = types$1[keyframes$1.length > 2 ? "keyframes" : type] || keyframes;
  const origin = keyframes$1[0];
  const target = keyframes$1[keyframes$1.length - 1];
  let state = { done: false, value: origin };
  if ((_b2 = (_a2 = animator).needsInterpolation) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, origin, target)) {
    interpolateFromNumber = interpolate([0, 100], [origin, target], {
      clamp: false
    });
    keyframes$1 = [0, 100];
  }
  const animation = animator({
    ...options,
    duration,
    keyframes: keyframes$1
  });
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete2 = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls && driverControls.stop();
    onComplete && onComplete();
  }
  function update5(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete2) {
      state = animation.next(Math.max(0, elapsed));
      if (interpolateFromNumber)
        state.value = interpolateFromNumber(state.value);
      isComplete2 = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate && onUpdate(state.value);
    if (isComplete2) {
      if (repeatCount === 0) {
        computedDuration = computedDuration !== void 0 ? computedDuration : elapsed;
      }
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay && onPlay();
    driverControls = driver(update5);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop && onStop();
      driverControls && driverControls.stop();
    },
    /**
     * Set the current time of the animation. This is purposefully
     * mirroring the WAAPI animation API to make them interchanagable.
     * Going forward this file should be ported more towards
     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts
     * Which behaviourally adheres to WAAPI as far as possible.
     *
     * WARNING: This is not safe to use for most animations. We currently
     * only use it for handoff from WAAPI within Framer.
     *
     * This animation function consumes time every frame rather than being sampled for time.
     * So the sample() method performs some headless frames to ensure
     * repeats are handled correctly. Ideally in the future we will replace
     * that method with this, once repeat calculations are pure.
     */
    set currentTime(t2) {
      elapsed = initialElapsed;
      update5(t2);
    },
    /**
     * animate() can't yet be sampled for time, instead it
     * consumes time. So to sample it we have to run a low
     * temporal-resolution version.
     */
    sample: (t2) => {
      elapsed = initialElapsed;
      const sampleResolution = duration && typeof duration === "number" ? Math.max(duration * 0.5, 50) : 50;
      let sampleElapsed = 0;
      update5(0);
      while (sampleElapsed <= t2) {
        const remaining = t2 - sampleElapsed;
        update5(Math.min(remaining, sampleResolution));
        sampleElapsed += sampleResolution;
      }
      return state;
    }
  };
}
function isWaapiSupportedEasing(easing) {
  return !easing || // Default easing
  Array.isArray(easing) || // Bezier curve
  typeof easing === "string" && supportedWaapiEasing[easing];
}
const cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return Array.isArray(easing) ? cubicBezierAsString(easing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease, times } = {}) {
  return element.animate({ [valueName]: keyframes2, offset: times }, {
    delay: delay2,
    duration,
    easing: mapEasingToNativeEasing(ease),
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
const featureTests = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
};
const results = {};
const supports = {};
for (const key2 in featureTests) {
  supports[key2] = () => {
    if (results[key2] === void 0)
      results[key2] = featureTests[key2]();
    return results[key2];
  };
}
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index2];
}
const acceleratedValues = /* @__PURE__ */ new Set(["opacity"]);
const sampleDelta = 10;
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
  const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0;
  if (!canAccelerateAnimation)
    return false;
  let { keyframes: keyframes2, duration = 300, elapsed = 0, ease } = options;
  if (options.type === "spring" || !isWaapiSupportedEasing(options.ease)) {
    if (options.repeat === Infinity)
      return;
    const sampleAnimation = animate$1({ ...options, elapsed: 0 });
    let state = { done: false, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state.done && t2 < 2e4) {
      state = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state.value);
      t2 += sampleDelta;
    }
    keyframes2 = pregeneratedKeyframes;
    duration = t2 - sampleDelta;
    ease = "linear";
  }
  const animation = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    delay: -elapsed,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease
  });
  animation.onfinish = () => {
    value.set(getFinalKeyframe(keyframes2, options));
    sync.update(() => animation.cancel());
    onComplete && onComplete();
  };
  return {
    get currentTime() {
      return animation.currentTime || 0;
    },
    set currentTime(t2) {
      animation.currentTime = t2;
    },
    stop: () => {
      const { currentTime } = animation;
      if (currentTime) {
        const sampleAnimation = animate$1({ ...options, autoplay: false });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      sync.update(() => animation.cancel());
    }
  };
}
function delay$1(callback, timeout) {
  const start = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelSync.read(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  sync.read(checkElapsed, true);
  return () => cancelSync.read(checkElapsed);
}
function createInstantAnimation({ keyframes: keyframes2, elapsed, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes2[keyframes2.length - 1]);
    onComplete && onComplete();
  };
  return elapsed ? { stop: delay$1(setValue, -elapsed) } : setValue();
}
function inertia({ keyframes: keyframes2, velocity = 0, min: min2, max: max2, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  const origin = keyframes2[0];
  let currentAnimation;
  function isOutOfBounds(v3) {
    return min2 !== void 0 && v3 < min2 || max2 !== void 0 && v3 > max2;
  }
  function findNearestBoundary(v3) {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v3) < Math.abs(max2 - v3) ? min2 : max2;
  }
  function startAnimation(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate$1({
      keyframes: [0, 1],
      velocity: 0,
      ...options,
      driver,
      onUpdate: (v3) => {
        var _a2;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v3);
        (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v3);
      },
      onComplete,
      onStop
    });
  }
  function startSpring(options) {
    startAnimation({
      type: "spring",
      stiffness: bounceStiffness,
      damping: bounceDamping,
      restDelta,
      ...options
    });
  }
  if (isOutOfBounds(origin)) {
    startSpring({
      velocity,
      keyframes: [origin, findNearestBoundary(origin)]
    });
  } else {
    let target = power * velocity + origin;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = findNearestBoundary(target);
    const heading = boundary === min2 ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = (v3) => {
      prev = current;
      current = v3;
      velocity = velocityPerSecond(v3 - prev, frameData.delta);
      if (heading === 1 && v3 > boundary || heading === -1 && v3 < boundary) {
        startSpring({ keyframes: [v3, boundary], velocity });
      }
    };
    startAnimation({
      type: "decay",
      keyframes: [origin, 0],
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}
const underDampedSpring = () => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
});
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const linearTween = () => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else {
    const factory2 = defaultTransitions[valueKey] || defaultTransitions.default;
    return factory2(keyframes2[1]);
  }
};
const isAnimatable = (key2, value) => {
  if (key2 === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone("", potentialUnitType);
}
function getValueTransition(transition, key2) {
  return transition[key2] || transition["default"] || transition;
}
function getKeyframes(value, valueName, target, transition) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let origin = transition.from !== void 0 ? transition.from : value.get();
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone(valueName, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  if (Array.isArray(target)) {
    if (target[0] === null) {
      target[0] = origin;
    }
    return target;
  } else {
    return [origin, target];
  }
}
const createMotionValueAnimation = (valueName, value, target, transition = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition, valueName) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const keyframes2 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes2[0];
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    let options = {
      keyframes: keyframes2,
      velocity: value.getVelocity(),
      ...valueTransition,
      elapsed,
      onUpdate: (v3) => {
        value.set(v3);
        valueTransition.onUpdate && valueTransition.onUpdate(v3);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(options);
    } else if (valueTransition.type === "inertia") {
      return inertia(options);
    }
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(valueName, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    const visualElement = value.owner;
    const element = visualElement && visualElement.current;
    if (visualElement && element instanceof HTMLElement && !(visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onUpdate)) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animate$1(options);
  };
};
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = animateTarget(visualElement, resolvedDefinition, options);
  }
  return animation.then(() => visualElement.notify("AnimationComplete", definition));
}
function animateVariant(visualElement, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(visualElement, variant, options.custom);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();
  const getChildAnimations = ((_a2 = visualElement.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.size) ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(last);
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a2;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && ((_a2 = visualElement.animationState) === null || _a2 === void 0 ? void 0 : _a2.getState()[type]);
  for (const key2 in target) {
    const value = visualElement.getValue(key2);
    const valueTarget = target[key2];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2)) {
      continue;
    }
    const valueTransition = { delay: delay2, elapsed: 0, ...transition };
    if (window.HandoffAppearAnimations && !value.hasAnimated) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key2, value, sync);
      }
    }
    let animation = value.start(createMotionValueAnimation(key2, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key2) ? { type: false } : valueTransition));
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key2);
      animation = animation.then(() => willChange.remove(key2));
    }
    animations2.push(animation);
  }
  return Promise.all(animations2).then(() => {
    transitionEnd && setTarget(visualElement, transitionEnd);
  });
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== true;
  needsAnimating[key2] = false;
  return shouldBlock;
}
const variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(options, changedActiveType) {
    const props = visualElement.getProps();
    const context2 = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context2[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context2[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key2) => {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (const key2 in allKeys) {
        const next = resolvedValues[key2];
        const prev = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key2);
            } else {
              typeState.protectedKeys[key2] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key2);
          } else {
            removedKeys.add(key2);
          }
        } else if (next !== void 0 && removedKeys.has(key2)) {
          markToAnimate(key2);
        } else {
          typeState.protectedKeys[key2] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key2] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a2;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach((child) => {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key2 in state) {
      state[key2].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    [AnimationType.Animate]: createTypeState(true),
    [AnimationType.InView]: createTypeState(),
    [AnimationType.Hover]: createTypeState(),
    [AnimationType.Tap]: createTypeState(),
    [AnimationType.Drag]: createTypeState(),
    [AnimationType.Focus]: createTypeState(),
    [AnimationType.Exit]: createTypeState()
  };
}
const animations = {
  animation: makeRenderlessComponent(({ visualElement, animate: animate2 }) => {
    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));
    if (isAnimationControls(animate2)) {
      reactExports.useEffect(() => animate2.subscribe(visualElement), [animate2]);
    }
  }),
  exit: makeRenderlessComponent((props) => {
    const { custom: custom2, visualElement } = props;
    const [isPresent, safeToRemove] = usePresence$1();
    const presenceContext = reactExports.useContext(PresenceContext);
    reactExports.useEffect(() => {
      visualElement.isPresent = isPresent;
      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent, {
        custom: presenceContext && presenceContext.custom || custom2
      });
      if (animation && !isPresent) {
        animation.then(safeToRemove);
      }
    }, [isPresent]);
  })
};
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x);
  const yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point4 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point4, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      sync.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point: point3 } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point3, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point: point3 }, history) {
  return {
    point: point3,
    delta: subtractPoint(point3, lastDevicePoint(history)),
    offset: subtractPoint(point3, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent2) {
  target.min = parent2.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent2) {
  calcRelativeAxis(target.x, relative.x, parent2.x);
  calcRelativeAxis(target.y, relative.y, parent2.y);
}
function calcRelativeAxisPosition(target, layout, parent2) {
  target.min = layout.min - parent2.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent2) {
  calcRelativeAxisPosition(target.x, layout.x, parent2.x);
  calcRelativeAxisPosition(target.y, layout.y, parent2.y);
}
function applyConstraints(point3, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point3 < min2) {
    point3 = elastic ? mix(min2, point3, elastic.min) : Math.max(point3, min2);
  } else if (max2 !== void 0 && point3 > max2) {
    point3 = elastic ? mix(max2, point3, elastic.max) : Math.min(point3, max2);
  }
  return point3;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$3(0, 1, origin);
}
function rebaseAxisConstraints(layout, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x, y: y2 }) {
  return { top: y2.min, right: x.max, bottom: y2.max, left: x.min };
}
function transformBoxPoints(point3, transformPoint2) {
  if (!transformPoint2)
    return point3;
  const topLeft = transformPoint2({ x: point3.left, y: point3.top });
  const bottomRight = transformPoint2({ x: point3.right, y: point3.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point3, scale2, originPoint) {
  const distanceFromOrigin = point3 - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point3, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point3 = scalePoint(point3, boxScale, originPoint);
  }
  return scalePoint(point3, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x, y: y2 }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  var _a2, _b2;
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    if (((_b2 = (_a2 = node.instance) === null || _a2 === void 0 ? void 0 : _a2.style) === null || _b2 === void 0 ? void 0 : _b2.display) === "contents")
      continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key2, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key2], transforms[scaleKey], originPoint, transforms.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys$1);
  transformAxis(box.y, transform, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    if (this.visualElement.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      var _a2;
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        var _a3, _b2;
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const measuredAxis = (_b2 = (_a3 = this.visualElement.projection) === null || _a3 === void 0 ? void 0 : _a3.layout) === null || _b2 === void 0 ? void 0 : _b2.layoutBox[axis];
          if (measuredAxis) {
            const length = calcLength(measuredAxis);
            current = length * (parseFloat(current) / 100);
          }
        }
        this.originPoint[axis] = current;
      });
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
      (_a2 = this.visualElement.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Drag, true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  }
  cancel() {
    var _a2, _b2;
    this.isDragging = false;
    if (this.visualElement.projection) {
      this.visualElement.projection.isAnimationBlocked = false;
    }
    (_a2 = this.panSession) === null || _a2 === void 0 ? void 0 : _a2.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_b2 = this.visualElement.animationState) === null || _b2 === void 0 ? void 0 : _b2.setActive(AnimationType.Drag, false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = (constraints === null || constraints === void 0 ? void 0 : constraints[axis]) || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(createMotionValueAnimation(axis, axisValue, 0, transition));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    var _a2;
    const dragKey = "_drag" + axis.toUpperCase();
    const externalMotionValue = this.visualElement.getProps()[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, ((_a2 = this.visualElement.getProps().initial) === null || _a2 === void 0 ? void 0 : _a2[axis]) || 0);
  }
  snapToCursor(point3) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point3[axis] - mix(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    var _a2;
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mix(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    var _a2;
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
function useDrag(props) {
  const { dragControls: groupDragControls, visualElement } = props;
  const dragControls = useConstant(() => new VisualElementDragControls(visualElement));
  reactExports.useEffect(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);
  reactExports.useEffect(() => dragControls.addListeners(), [dragControls]);
}
function usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement }) {
  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  const panSession = reactExports.useRef(null);
  const { transformPagePoint } = reactExports.useContext(MotionConfigContext);
  const handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: (event, info) => {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  reactExports.useEffect(() => {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(() => panSession.current && panSession.current.end());
}
const drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};
function isCSSVariable(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback2] = match;
  return [token, fallback2];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback2] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable(fallback2)) {
    return getVariableValue(fallback2, element, depth + 1);
  } else {
    return fallback2;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariable(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key2 in target) {
    const current = target[key2];
    if (!isCSSVariable(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key2] = resolved;
    if (transitionEnd && transitionEnd[key2] === void 0) {
      transitionEnd[key2] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
const isPositionalKey = (key2) => positionalKeys.has(key2);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const isNumOrPxType = (v3) => v3 === number$1 || v3 === px;
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (value !== void 0) {
      removedTransforms.push([key2, value.get()]);
      value.set(key2.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
const convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key2) => {
    origin[key2] = positionalValues[key2](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value && value.jump(origin[key2]);
    target[key2] = positionalValues[key2](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (!visualElement.hasValue(key2))
      return;
    let from = origin[key2];
    let fromType = findDimensionValueType(from);
    const to = target[key2];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = findDimensionValueType(from);
      for (let i = fromIndex; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
        } else {
          invariant(findDimensionValueType(to[i]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key2] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key2] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key2] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key2);
        transitionEnd[key2] = transitionEnd[key2] !== void 0 ? transitionEnd[key2] : target[key2];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key2, value]) => {
        visualElement.getValue(key2).set(value);
      });
    }
    visualElement.render();
    if (isBrowser$2 && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser$2)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next, prev) {
  const { willChange } = next;
  for (const key2 in next) {
    const nextValue = next[key2];
    const prevValue = prev[key2];
    if (isMotionValue(nextValue)) {
      element.addValue(key2, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key2);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key2, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key2);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key2 in prev) {
    if (next[key2] === void 0)
      element.removeValue(key2);
  }
  return next;
}
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  constructor({ parent: parent2, props, reducedMotionConfig, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.isPresent = true;
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => sync.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent2;
    this.props = props;
    this.depth = parent2 ? parent2.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent2 && parent2.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      if (latestValues[key2] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key2], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key2);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance) {
    var _a2;
    this.current = instance;
    if (this.projection) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.addVariantChild(this);
    }
    this.values.forEach((value, key2) => this.bindToMotionValue(key2, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.setProps(this.props);
  }
  unmount() {
    var _a2, _b2, _c2;
    (_a2 = this.projection) === null || _a2 === void 0 ? void 0 : _a2.unmount();
    cancelSync.update(this.notifyUpdate);
    cancelSync.render(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    (_b2 = this.removeFromVariantTree) === null || _b2 === void 0 ? void 0 : _b2.call(this);
    (_c2 = this.parent) === null || _c2 === void 0 ? void 0 : _c2.children.delete(this);
    for (const key2 in this.events) {
      this.events[key2].clear();
    }
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    const valueIsTransform = transformProps.has(key2);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue;
      this.props.onUpdate && sync.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key2, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type)
      return 0;
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {
    const features = [];
    for (let i = 0; i < numFeatures; i++) {
      const name2 = featureNames[i];
      const { isEnabled: isEnabled2, Component: Component2 } = featureDefinitions[name2];
      if (isEnabled2(renderedProps) && Component2) {
        features.push(reactExports.createElement(Component2, {
          key: name2,
          ...renderedProps,
          visualElement: this
        }));
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout === "string" ? layout : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return features;
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  setProps(props) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    const prevProps = this.props;
    this.props = props;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key2 = propEventHandlers[i];
      if (this.propEventSubscriptions[key2]) {
        this.propEventSubscriptions[key2]();
        delete this.propEventSubscriptions[key2];
      }
      const listener = props["on" + key2];
      if (listener) {
        this.propEventSubscriptions[key2] = this.on(key2, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name2) {
    var _a2;
    return (_a2 = this.props.variants) === null || _a2 === void 0 ? void 0 : _a2[name2];
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    var _a2;
    return this.isVariantNode ? this : (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.getClosestVariantNode();
  }
  getVariantContext(startAtParent = false) {
    var _a2, _b2;
    if (startAtParent)
      return (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.getVariantContext();
    if (!this.isControllingVariants) {
      const context22 = ((_b2 = this.parent) === null || _b2 === void 0 ? void 0 : _b2.getVariantContext()) || {};
      if (this.props.initial !== void 0) {
        context22.initial = this.props.initial;
      }
      return context22;
    }
    const context2 = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name2 = variantProps[i];
      const prop = this.props[name2];
      if (isVariantLabel(prop) || prop === false) {
        context2[name2] = prop;
      }
    }
    return context2;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    var _a2;
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      (_a2 = closestVariantNode.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    if (value !== this.values.get(key2)) {
      this.removeValue(key2);
      this.bindToMotionValue(key2, value);
    }
    this.values.set(key2, value);
    this.latestValues[key2] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    var _a2;
    this.values.delete(key2);
    (_a2 = this.valueSubscriptions.get(key2)) === null || _a2 === void 0 ? void 0 : _a2();
    this.valueSubscriptions.delete(key2);
    delete this.latestValues[key2];
    this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2]) {
      return this.props.values[key2];
    }
    let value = this.values.get(key2);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key2, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2) {
    return this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : this.readValueFromInstance(this.current, key2, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    var _a2;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a2 = resolveVariantFromProps(this.props, initial)) === null || _a2 === void 0 ? void 0 : _a2[key2] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key2);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    var _a2;
    (_a2 = this.events[eventName]) === null || _a2 === void 0 ? void 0 : _a2.notify(...args);
  }
}
const variantProps = ["initial", ...variantPriorityOrder];
const numVariantProps = variantProps.length;
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    var _a2;
    return (_a2 = props.style) === null || _a2 === void 0 ? void 0 : _a2[key2];
  }
  removeValueFromRenderState(key2, { vars: vars2, style }) {
    delete vars2[key2];
    delete style[key2];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target
    };
  }
}
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$2(instance);
      const value = (isCSSVariable$1(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options, props) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    var _a2;
    if (transformProps.has(key2)) {
      return ((_a2 = getDefaultValueType(key2)) === null || _a2 === void 0 ? void 0 : _a2.default) || 0;
    }
    key2 = !camelCaseAttributes.has(key2) ? camelToDash(key2) : key2;
    return instance.getAttribute(key2);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component2, options) => {
  return isSVGComponent(Component2) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    const y2 = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y2}%`;
  }
};
const varToken = "_$css";
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const containsCSSVariables = latest.includes("var(");
    const cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, (match) => {
        cssVariables.push(match);
        return varToken;
      });
    }
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    let output2 = template(shadow);
    if (containsCSSVariables) {
      let i = 0;
      output2 = output2.replace(varToken, () => {
        const cssVariable = cssVariables[i];
        i++;
        return cssVariable;
      });
    }
    return output2;
  }
};
class MeasureLayoutWithContext extends React.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        sync.postRender(() => {
          var _a2;
          if (!((_a2 = projection.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length)) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      if (!projection.currentAnimation && projection.isLead()) {
        this.safeToRemove();
      }
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence$1();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return React.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const layoutFeatures = {
  measureLayout: MeasureLayout
};
function animate(from, to, transition = {}) {
  const value = isMotionValue(from) ? from : motionValue(from);
  value.start(createMotionValueAnimation("", value, to, transition));
  return {
    stop: () => value.stop(),
    isAnimating: () => value.isAnimating()
  };
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop$3);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(progress(min2, max2, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point3, translate, scale2, originPoint, boxScale) {
  point3 -= translate;
  point3 = scalePoint(point3, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point3 = scalePoint(point3, 1 / boxScale, originPoint);
  }
  return point3;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    var _a2;
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if ((_a2 = node.root) === null || _a2 === void 0 ? void 0 : _a2.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      var _a2, _b2, _c2, _d2, _e2;
      (_b2 = (_a2 = node.options).onExitComplete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      (_e2 = (_c2 = node.resumingFrom) === null || _c2 === void 0 ? void 0 : (_d2 = _c2.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d2);
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id$1 = 0;
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(elementId, latestValues = {}, parent2 = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id$1++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isTransformDirty = false;
      this.isProjectionDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.potentialNodes = /* @__PURE__ */ new Map();
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.elementId = elementId;
      this.latestValues = latestValues;
      this.root = parent2 ? parent2.root || parent2 : this;
      this.path = parent2 ? [...parent2.path, parent2] : [];
      this.parent = parent2;
      this.depth = parent2 ? parent2.depth + 1 : 0;
      elementId && this.root.registerPotentialNode(elementId, this);
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name2, handler) {
      if (!this.eventHandlers.has(name2)) {
        this.eventHandlers.set(name2, new SubscriptionManager());
      }
      return this.eventHandlers.get(name2).add(handler);
    }
    notifyListeners(name2, ...args) {
      const subscriptionManager = this.eventHandlers.get(name2);
      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);
    }
    hasListeners(name2) {
      return this.eventHandlers.has(name2);
    }
    registerPotentialNode(elementId, node) {
      this.potentialNodes.set(elementId, node);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = false) {
      var _a2;
      if (this.instance)
        return;
      this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
      this.instance = instance;
      const { layoutId, layout, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.children.add(this);
      this.elementId && this.root.potentialNodes.delete(this.elementId);
      if (isLayoutDirty && (layout || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay$1(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          var _a3, _b2, _c2, _d2, _e2;
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = (_b2 = (_a3 = this.options.transition) !== null && _a3 !== void 0 ? _a3 : visualElement.getDefaultTransition()) !== null && _b2 !== void 0 ? _b2 : defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || ((_c2 = this.resumeFrom) === null || _c2 === void 0 ? void 0 : _c2.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged && this.animationProgress === 0) {
              finishAnimation(this);
            }
            this.isLead() && ((_e2 = (_d2 = this.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d2));
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      var _a2, _b2;
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.remove(this);
      (_b2 = this.parent) === null || _b2 === void 0 ? void 0 : _b2.children.delete(this);
      this.instance = void 0;
      cancelSync.preRender(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var _a2;
      return this.isAnimationBlocked || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimationBlocked()) || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      var _a2;
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      (_a2 = this.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      var _a2;
      return (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      var _a2, _b2, _c2;
      if (this.root.isUpdateBlocked()) {
        (_b2 = (_a2 = this.options).onExitComplete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout } = this.options;
      if (layoutId === void 0 && !layout)
        return;
      this.prevTransformTemplateValue = (_c2 = this.getTransformTemplate()) === null || _c2 === void 0 ? void 0 : _c2(this.latestValues, "");
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    // Note: Currently only running on root node
    didUpdate() {
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating)
        return;
      this.isUpdating = false;
      if (this.potentialNodes.size) {
        this.potentialNodes.forEach(mountNodeEarly);
        this.potentialNodes.clear();
      }
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      flushSync.update();
      flushSync.preRender();
      flushSync.render();
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      sync.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      sync.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      var _a2;
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.notify("LayoutMeasure", this.layout.layoutBox, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.layoutBox);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      var _a2;
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplateValue = (_a2 = this.getTransformTemplate()) === null || _a2 === void 0 ? void 0 : _a2(this.latestValues, "");
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll: scroll2 } = this.root;
      if (scroll2) {
        translateAxis(box.x, scroll2.offset.x);
        translateAxis(box.y, scroll2.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll: scroll2, options } = node;
        if (node !== this.root && scroll2 && options.layoutScroll) {
          if (scroll2.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      var _a2;
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a2 = node.snapshot) === null || _a2 === void 0 ? void 0 : _a2.layoutBox, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    /**
     *
     */
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.isProjectionDirty = true;
      this.root.scheduleUpdateProjection();
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    /**
     * Frame calculations
     */
    resolveTargetDelta() {
      var _a2;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      if (!this.isProjectionDirty && !this.attemptToResolveRelativeTarget)
        return;
      const { layout, layoutId } = this.options;
      if (!this.layout || !(layout || layoutId))
        return;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout) {
          this.relativeParent = relativeParent;
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.target)) {
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target) {
          this.relativeParent = relativeParent;
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if ((this.parent.relativeTarget || this.parent.targetDelta || this.parent.options.layoutRoot) && this.parent.layout) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    calcProjection() {
      var _a2;
      const { isProjectionDirty, isTransformDirty } = this;
      this.isProjectionDirty = this.isTransformDirty = false;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (isProjectionDirty)
        canSkip = false;
      if (isShared && isTransformDirty)
        canSkip = false;
      if (canSkip)
        return;
      const { layout, layoutId } = this.options;
      this.isTreeAnimating = Boolean(((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      const { target } = lead;
      if (!target)
        return;
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a2, _b2, _c2;
      (_b2 = (_a2 = this.options).scheduleRender) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      notifyAll && ((_c2 = this.getStack()) === null || _c2 === void 0 ? void 0 : _c2.scheduleRender());
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      var _a2, _b2;
      const snapshot = this.snapshot;
      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const isSharedLayoutAnimation = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.source) !== ((_a2 = this.layout) === null || _a2 === void 0 ? void 0 : _a2.source);
      const isOnlyMember = (((_b2 = this.getStack()) === null || _b2 === void 0 ? void 0 : _b2.members.length) || 0) <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      this.mixTargetDelta = (latest) => {
        var _a3;
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a3 = this.relativeParent) === null || _a3 === void 0 ? void 0 : _a3.layout)) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      var _a2, _b2;
      this.notifyListeners("animationStart");
      (_a2 = this.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      if (this.resumingFrom) {
        (_b2 = this.resumingFrom.currentAnimation) === null || _b2 === void 0 ? void 0 : _b2.stop();
      }
      if (this.pendingAnimation) {
        cancelSync.update(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = sync.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animate(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            var _a3;
            this.mixTargetDelta(latest);
            (_a3 = options.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(options, latest);
          },
          onComplete: () => {
            var _a3;
            (_a3 = options.onComplete) === null || _a3 === void 0 ? void 0 : _a3.call(options);
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var _a2;
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var _a2;
      if (this.currentAnimation) {
        (_a2 = this.mixTargetDelta) === null || _a2 === void 0 ? void 0 : _a2.call(this, animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout)
        return;
      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      var _a2, _b2, _c2;
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      node.promote({
        transition: (_a2 = node.options.initialPromotionConfig) === null || _a2 === void 0 ? void 0 : _a2.transition,
        preserveFollowOpacity: (_c2 = (_b2 = node.options.initialPromotionConfig) === null || _b2 === void 0 ? void 0 : _b2.shouldPreserveFollowOpacity) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, node)
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i = 0; i < transformAxes.length; i++) {
        const key2 = "rotate" + transformAxes[i];
        if (latestValues[key2]) {
          resetValues[key2] = latestValues[key2];
          visualElement.setStaticValue(key2, 0);
        }
      }
      visualElement === null || visualElement === void 0 ? void 0 : visualElement.render();
      for (const key2 in resetValues) {
        visualElement.setStaticValue(key2, resetValues[key2]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a2, _b2;
      const styles = {};
      if (!this.instance || this.isSVG)
        return styles;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles.visibility = "";
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b2 = (_a2 = valuesToRender.opacity) !== null && _a2 !== void 0 ? _a2 : this.latestValues.opacity) !== null && _b2 !== void 0 ? _b2 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key2];
        const corrected = styles.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key2] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a2;
        return (_a2 = node.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a2, _b2, _c2;
  const snapshot = ((_a2 = node.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_c2 = (_b2 = node.options).onExitComplete) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  node.isProjectionDirty || (node.isProjectionDirty = Boolean(node.parent && node.parent.isProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = Boolean(node.parent && node.parent.isTransformDirty));
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output2, delta, p2) {
  output2.translate = mix(delta.translate, 0, p2);
  output2.scale = mix(delta.scale, 1, p2);
  output2.origin = delta.origin;
  output2.originPoint = delta.originPoint;
}
function mixAxis(output2, from, to, p2) {
  output2.min = mix(from.min, to.min, p2);
  output2.max = mix(from.max, to.max, p2);
}
function mixBox(output2, from, to, p2) {
  mixAxis(output2.x, from.x, to.x, p2);
  mixAxis(output2.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, elementId) {
  let searchNode = node.root;
  for (let i = node.path.length - 1; i >= 0; i--) {
    if (Boolean(node.path[i].instance)) {
      searchNode = node.path[i];
      break;
    }
  }
  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  const element = searchElement.querySelector(`[data-projection-id="${elementId}"]`);
  if (element)
    node.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutFeatures
};
const motion = /* @__PURE__ */ createMotionProxy((Component2, config2) => createDomMotionConfig(Component2, config2, featureBundle, createDomVisualElement, HTMLProjectionNode));
function useIsMounted() {
  const isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect$2(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = reactExports.useState(0);
  const forceRender = reactExports.useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = reactExports.useCallback(() => sync.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size2 = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  reactExports.useInsertionEffect(() => {
    const { width, height, top, left } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return reactExports.createElement(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2 }, reactExports.cloneElement(children, { ref }));
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom: custom2, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const context2 = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom: custom2,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete2 of presenceChildren.values()) {
          if (!isComplete2)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_, key2) => presenceChildren.set(key2, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = reactExports.createElement(PopChild, { isPresent }, children);
  }
  return reactExports.createElement(PresenceContext.Provider, { value: context2 }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
const getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key2 = getChildKey(child);
    allChildren.set(key2, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom: custom2, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
  if (exitBeforeEnter) {
    mode = "wait";
  }
  let [forceRender] = useForceUpdate();
  const forceRenderLayoutGroup = reactExports.useContext(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exiting = /* @__PURE__ */ new Set();
  const presentChildren = reactExports.useRef(childrenToRender);
  const allChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = reactExports.useRef(true);
  useIsomorphicLayoutEffect$2(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return reactExports.createElement(reactExports.Fragment, null, childrenToRender.map((child) => reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key2 = presentKeys[i];
    if (targetKeys.indexOf(key2) === -1) {
      exiting.add(key2);
    }
  }
  if (mode === "wait" && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach((key2) => {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    const child = allChildren.get(key2);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key2);
    const onExit = () => {
      allChildren.delete(key2);
      exiting.delete(key2);
      const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key2);
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false)
          return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom2, presenceAffectsLayout, mode }, child));
  });
  childrenToRender = childrenToRender.map((child) => {
    const key2 = child.key;
    return exiting.has(key2) ? child : reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);
  });
  return reactExports.createElement(reactExports.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map((child) => reactExports.cloneElement(child)));
};
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
function __rest$2(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __decorate$1(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
}
function __param$1(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key2], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key2] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f2, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata$1(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter$f(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$2(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v3) {
      return step([n2, v3]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding$1 = Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
};
function __exportStar$1(m2, o2) {
  for (var p2 in m2)
    if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
      __createBinding$1(o2, m2, p2);
}
function __values$1(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread$1() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read$1(arguments[i]));
  return ar;
}
function __spreadArrays$1() {
  for (var s2 = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s2 += arguments[i].length;
  for (var r2 = Array(s2), k2 = 0, i = 0; i < il2; i++)
    for (var a2 = arguments[i], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray$1(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await$1(v3) {
  return this instanceof __await$1 ? (this.v = v3, this) : new __await$1(v3);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v3) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v3, a2, b2]) > 1 || resume(n2, v3);
        });
      };
  }
  function resume(n2, v3) {
    try {
      step(g2[n2](v3));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await$1 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v3) {
    if (f2(v3), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator$1(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v3) {
      return (p2 = !p2) ? { value: __await$1(o2[n2](v3)), done: false } : f2 ? f2(v3) : v3;
    } : f2;
  }
}
function __asyncValues$1(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values$1 === "function" ? __values$1(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o2[n2](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d2, v3) {
    Promise.resolve(v3).then(function(v5) {
      resolve({ value: v5, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject$1(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function(o2, v3) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
} : function(o2, v3) {
  o2["default"] = v3;
};
function __importStar$1(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
        __createBinding$1(result, mod2, k2);
  }
  __setModuleDefault(result, mod2);
  return result;
}
function __importDefault$1(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet$2(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet$1(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function __disposeResources(env) {
  function fail(e2) {
    env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
      } catch (e2) {
        fail(e2);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
const tslib_es6$1 = {
  __extends: __extends$1,
  __assign: __assign$3,
  __rest: __rest$2,
  __decorate: __decorate$1,
  __param: __param$1,
  __metadata: __metadata$1,
  __awaiter: __awaiter$f,
  __generator: __generator$2,
  __createBinding: __createBinding$1,
  __exportStar: __exportStar$1,
  __values: __values$1,
  __read: __read$1,
  __spread: __spread$1,
  __spreadArrays: __spreadArrays$1,
  __spreadArray: __spreadArray$1,
  __await: __await$1,
  __asyncGenerator: __asyncGenerator$1,
  __asyncDelegator: __asyncDelegator$1,
  __asyncValues: __asyncValues$1,
  __makeTemplateObject: __makeTemplateObject$1,
  __importStar: __importStar$1,
  __importDefault: __importDefault$1,
  __classPrivateFieldGet: __classPrivateFieldGet$2,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign$3;
  },
  __asyncDelegator: __asyncDelegator$1,
  __asyncGenerator: __asyncGenerator$1,
  __asyncValues: __asyncValues$1,
  __await: __await$1,
  __awaiter: __awaiter$f,
  __classPrivateFieldGet: __classPrivateFieldGet$2,
  __classPrivateFieldIn,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __createBinding: __createBinding$1,
  __decorate: __decorate$1,
  __disposeResources,
  __esDecorate,
  __exportStar: __exportStar$1,
  __extends: __extends$1,
  __generator: __generator$2,
  __importDefault: __importDefault$1,
  __importStar: __importStar$1,
  __makeTemplateObject: __makeTemplateObject$1,
  __metadata: __metadata$1,
  __param: __param$1,
  __propKey,
  __read: __read$1,
  __rest: __rest$2,
  __runInitializers,
  __setFunctionName,
  __spread: __spread$1,
  __spreadArray: __spreadArray$1,
  __spreadArrays: __spreadArrays$1,
  __values: __values$1,
  default: tslib_es6$1
}, Symbol.toStringTag, { value: "Module" }));
const defaultColors = {
  black: "#000000",
  white: "#ffffff",
  inherit: "inherit",
  transparent: "transparent",
  positive: "#1FC266",
  negative: "#C2501F",
  info: "#0076CC",
  warning: "#F4B03E",
  gradientBackdrop: `linear-gradient(
    243.18deg, 
    rgba(86, 52, 189, 0.85) 0%, 
    rgba(49, 41, 223, 0.85) 63.54%, 
    rgba(7, 98, 149, 0.85) 100%
  )`,
  gradientPrimary: `linear-gradient(89.69deg, #4411E1 0.27%, #7537F9 99.73%)`,
  gradientSecondary: `linear-gradient(32.51deg, #951990 -15.23%, #3A35B1 48.55%, #20A8B0 100%)`,
  arbitrumDark: "#212D44",
  arbitrumLight: "#93D4FF",
  avalanceDark: "#810C0C",
  avalanceLight: "#FF8080",
  bscDark: "#584508",
  bscLight: "#FCCF43",
  ethereumDark: "#132362",
  ethereumLight: "#AABBFF",
  gnosisDark: "#084246",
  gnosisLight: "#8CF6FD",
  polygonDark: "#350881",
  polygonLight: "#C7A6FF"
};
const dark = {
  ...defaultColors,
  text100: "rgba(255, 255, 255, 1)",
  text80: "rgba(255, 255, 255, 0.8)",
  text50: "rgba(255, 255, 255, 0.5)",
  textInverse100: "rgba(0, 0, 0, 1)",
  backgroundPrimary: "rgba(0, 0, 0, 1)",
  backgroundSecondary: "rgba(255, 255, 255, 0.1)",
  backgroundContrast: "rgba(0, 0, 0, 0.5)",
  backgroundMuted: "rgba(255, 255, 255, 0.05)",
  backgroundControl: "rgba(255, 255, 255, 0.25)",
  backgroundInverse: "rgba(255, 255, 255, 1)",
  backgroundBackdrop: "rgba(34, 34, 34, 0.9)",
  backgroundOverlay: "rgba(0, 0, 0, 0.7)",
  backgroundRaised: "rgba(54, 54, 54, 0.7)",
  buttonGlass: "rgba(255, 255, 255, 0.15)",
  buttonEmphasis: "rgba(0, 0, 0, 0.5)",
  buttonInverse: "rgba(255, 255, 255, 0.8)",
  borderNormal: "rgba(255, 255, 255, 0.25)",
  borderFocus: "rgba(255, 255, 255, 0.5)"
};
const light = {
  ...defaultColors,
  text100: "rgba(0, 0, 0, 1)",
  text80: "rgba(0, 0, 0, 0.8)",
  text50: "rgba(0, 0, 0, 0.5)",
  textInverse100: "rgba(255, 255, 255, 1)",
  backgroundPrimary: "rgba(244, 244, 244, 1)",
  backgroundSecondary: "rgba(0, 0, 0, 0.1)",
  backgroundContrast: "rgba(244, 244, 244, 0.5)",
  backgroundMuted: "rgba(0, 0, 0, 0.05)",
  backgroundControl: "rgba(0, 0, 0, 0.25)",
  backgroundInverse: "rgba(0, 0, 0, 1)",
  backgroundBackdrop: "rgba(221, 221, 221, 0.9)",
  backgroundOverlay: "rgba(244, 244, 244, 0.7)",
  backgroundRaised: "rgba(192, 192, 192, 0.7)",
  buttonGlass: "rgba(0, 0, 0, 0.15)",
  buttonEmphasis: "rgba(255, 255, 255, 0.5)",
  buttonInverse: "rgba(0, 0, 0, 0.8)",
  borderNormal: "rgba(0, 0, 0, 0.25)",
  borderFocus: "rgba(0, 0, 0, 0.5)"
};
const colors = {
  dark,
  light
};
const text = {
  inherit: {
    fontFamily: "inherit",
    fontSize: "inherit",
    lineHeight: "inherit",
    letterSpacing: "inherit",
    fontWeight: "inherit"
  },
  xlarge: {
    fontFamily: "body",
    fontSize: "xlarge",
    lineHeight: "9",
    letterSpacing: "none",
    fontWeight: "bold"
  },
  large: {
    fontFamily: "body",
    fontSize: "large",
    lineHeight: "7",
    letterSpacing: "normal",
    fontWeight: "semibold"
  },
  medium: {
    fontFamily: "body",
    fontSize: "medium",
    lineHeight: "6",
    letterSpacing: "normal",
    fontWeight: "bold"
  },
  normal: {
    fontFamily: "body",
    fontSize: "normal",
    lineHeight: "5",
    letterSpacing: "wide",
    fontWeight: "normal"
  },
  small: {
    fontFamily: "body",
    fontSize: "small",
    lineHeight: "4",
    letterSpacing: "wide",
    fontWeight: "medium"
  },
  xsmall: {
    fontFamily: "body",
    fontSize: "xsmall",
    lineHeight: "4",
    letterSpacing: "wide",
    fontWeight: "bold"
  },
  code: {
    fontFamily: "mono",
    fontSize: "normal",
    lineHeight: "5",
    letterSpacing: "none",
    fontWeight: "normal"
  }
};
const breakpoints = {
  sm: 0,
  md: 480,
  lg: 769,
  xl: 1281
};
var colorSchemeVars = { colors: { black: "var(--seq-colors-black)", white: "var(--seq-colors-white)", inherit: "var(--seq-colors-inherit)", transparent: "var(--seq-colors-transparent)", positive: "var(--seq-colors-positive)", negative: "var(--seq-colors-negative)", info: "var(--seq-colors-info)", warning: "var(--seq-colors-warning)", gradientBackdrop: "var(--seq-colors-gradient-backdrop)", gradientPrimary: "var(--seq-colors-gradient-primary)", gradientSecondary: "var(--seq-colors-gradient-secondary)", arbitrumDark: "var(--seq-colors-arbitrum-dark)", arbitrumLight: "var(--seq-colors-arbitrum-light)", avalanceDark: "var(--seq-colors-avalance-dark)", avalanceLight: "var(--seq-colors-avalance-light)", bscDark: "var(--seq-colors-bsc-dark)", bscLight: "var(--seq-colors-bsc-light)", ethereumDark: "var(--seq-colors-ethereum-dark)", ethereumLight: "var(--seq-colors-ethereum-light)", gnosisDark: "var(--seq-colors-gnosis-dark)", gnosisLight: "var(--seq-colors-gnosis-light)", polygonDark: "var(--seq-colors-polygon-dark)", polygonLight: "var(--seq-colors-polygon-light)", text100: "var(--seq-colors-text100)", text80: "var(--seq-colors-text80)", text50: "var(--seq-colors-text50)", textInverse100: "var(--seq-colors-text-inverse100)", backgroundPrimary: "var(--seq-colors-background-primary)", backgroundSecondary: "var(--seq-colors-background-secondary)", backgroundContrast: "var(--seq-colors-background-contrast)", backgroundMuted: "var(--seq-colors-background-muted)", backgroundControl: "var(--seq-colors-background-control)", backgroundInverse: "var(--seq-colors-background-inverse)", backgroundBackdrop: "var(--seq-colors-background-backdrop)", backgroundOverlay: "var(--seq-colors-background-overlay)", backgroundRaised: "var(--seq-colors-background-raised)", buttonGlass: "var(--seq-colors-button-glass)", buttonEmphasis: "var(--seq-colors-button-emphasis)", buttonInverse: "var(--seq-colors-button-inverse)", borderNormal: "var(--seq-colors-border-normal)", borderFocus: "var(--seq-colors-border-focus)" } };
var vars = { blur: { blur: "var(--seq-blur-blur)", none: "var(--seq-blur-none)" }, borderWidths: { none: "var(--seq-border-widths-none)", thin: "var(--seq-border-widths-thin)", thick: "var(--seq-border-widths-thick)" }, fonts: { inherit: "var(--seq-fonts-inherit)", body: "var(--seq-fonts-body)", mono: "var(--seq-fonts-mono)" }, fontSizes: { inherit: "var(--seq-font-sizes-inherit)", xsmall: "var(--seq-font-sizes-xsmall)", small: "var(--seq-font-sizes-small)", normal: "var(--seq-font-sizes-normal)", medium: "var(--seq-font-sizes-medium)", large: "var(--seq-font-sizes-large)", xlarge: "var(--seq-font-sizes-xlarge)" }, fontWeights: { inherit: "var(--seq-font-weights-inherit)", normal: "var(--seq-font-weights-normal)", medium: "var(--seq-font-weights-medium)", semibold: "var(--seq-font-weights-semibold)", bold: "var(--seq-font-weights-bold)" }, letterSpacings: { inherit: "var(--seq-letter-spacings-inherit)", none: "var(--seq-letter-spacings-none)", normal: "var(--seq-letter-spacings-normal)", wide: "var(--seq-letter-spacings-wide)" }, lineHeights: { "4": "var(--seq-line-heights-4)", "5": "var(--seq-line-heights-5)", "6": "var(--seq-line-heights-6)", "7": "var(--seq-line-heights-7)", "9": "var(--seq-line-heights-9)", inherit: "var(--seq-line-heights-inherit)" }, opacity: { "0": "var(--seq-opacity-0)", "50": "var(--seq-opacity-50)", "80": "var(--seq-opacity-80)", "100": "var(--seq-opacity-100)" }, radii: { none: "var(--seq-radii-none)", xs: "var(--seq-radii-xs)", sm: "var(--seq-radii-sm)", md: "var(--seq-radii-md)", lg: "var(--seq-radii-lg)", circle: "var(--seq-radii-circle)" }, space: { "0": "var(--seq-space-0)", "1": "var(--seq-space-1)", "2": "var(--seq-space-2)", "3": "var(--seq-space-3)", "4": "var(--seq-space-4)", "5": "var(--seq-space-5)", "6": "var(--seq-space-6)", "7": "var(--seq-space-7)", "8": "var(--seq-space-8)", "9": "var(--seq-space-9)", "10": "var(--seq-space-10)", "12": "var(--seq-space-12)", "14": "var(--seq-space-14)", "16": "var(--seq-space-16)", "0.25": "var(--seq-space-0_25)", "0.5": "var(--seq-space-0_5)", "1.5": "var(--seq-space-1_5)" }, colors: { black: "var(--seq-colors-black)", white: "var(--seq-colors-white)", inherit: "var(--seq-colors-inherit)", transparent: "var(--seq-colors-transparent)", positive: "var(--seq-colors-positive)", negative: "var(--seq-colors-negative)", info: "var(--seq-colors-info)", warning: "var(--seq-colors-warning)", gradientBackdrop: "var(--seq-colors-gradient-backdrop)", gradientPrimary: "var(--seq-colors-gradient-primary)", gradientSecondary: "var(--seq-colors-gradient-secondary)", arbitrumDark: "var(--seq-colors-arbitrum-dark)", arbitrumLight: "var(--seq-colors-arbitrum-light)", avalanceDark: "var(--seq-colors-avalance-dark)", avalanceLight: "var(--seq-colors-avalance-light)", bscDark: "var(--seq-colors-bsc-dark)", bscLight: "var(--seq-colors-bsc-light)", ethereumDark: "var(--seq-colors-ethereum-dark)", ethereumLight: "var(--seq-colors-ethereum-light)", gnosisDark: "var(--seq-colors-gnosis-dark)", gnosisLight: "var(--seq-colors-gnosis-light)", polygonDark: "var(--seq-colors-polygon-dark)", polygonLight: "var(--seq-colors-polygon-light)", text100: "var(--seq-colors-text100)", text80: "var(--seq-colors-text80)", text50: "var(--seq-colors-text50)", textInverse100: "var(--seq-colors-text-inverse100)", backgroundPrimary: "var(--seq-colors-background-primary)", backgroundSecondary: "var(--seq-colors-background-secondary)", backgroundContrast: "var(--seq-colors-background-contrast)", backgroundMuted: "var(--seq-colors-background-muted)", backgroundControl: "var(--seq-colors-background-control)", backgroundInverse: "var(--seq-colors-background-inverse)", backgroundBackdrop: "var(--seq-colors-background-backdrop)", backgroundOverlay: "var(--seq-colors-background-overlay)", backgroundRaised: "var(--seq-colors-background-raised)", buttonGlass: "var(--seq-colors-button-glass)", buttonEmphasis: "var(--seq-colors-button-emphasis)", buttonInverse: "var(--seq-colors-button-inverse)", borderNormal: "var(--seq-colors-border-normal)", borderFocus: "var(--seq-colors-border-focus)" } };
function toPrimitive$1(t2, r2) {
  if ("object" != typeof t2 || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey$1(t2) {
  var i = toPrimitive$1(t2, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty$1$1(obj, key2, value) {
  key2 = toPropertyKey$1(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys$1$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var createSprinkles$1 = (composeStyles2) => function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var sprinklesStyles = Object.assign({}, ...args.map((a2) => a2.styles));
  var sprinklesKeys = Object.keys(sprinklesStyles);
  var shorthandNames = sprinklesKeys.filter((property) => "mappings" in sprinklesStyles[property]);
  var sprinklesFn = (props) => {
    var classNames = [];
    var shorthands = {};
    var nonShorthands = _objectSpread2$1({}, props);
    var hasShorthands = false;
    for (var shorthand of shorthandNames) {
      var value = props[shorthand];
      if (value != null) {
        var sprinkle = sprinklesStyles[shorthand];
        hasShorthands = true;
        for (var propMapping of sprinkle.mappings) {
          shorthands[propMapping] = value;
          if (nonShorthands[propMapping] == null) {
            delete nonShorthands[propMapping];
          }
        }
      }
    }
    var finalProps = hasShorthands ? _objectSpread2$1(_objectSpread2$1({}, shorthands), nonShorthands) : props;
    var _loop = function _loop2() {
      var propValue = finalProps[prop];
      var sprinkle2 = sprinklesStyles[prop];
      try {
        if (sprinkle2.mappings) {
          return 1;
        }
        if (typeof propValue === "string" || typeof propValue === "number") {
          if (false)
            ;
          classNames.push(sprinkle2.values[propValue].defaultClass);
        } else if (Array.isArray(propValue)) {
          for (var responsiveIndex = 0; responsiveIndex < propValue.length; responsiveIndex++) {
            var responsiveValue = propValue[responsiveIndex];
            if (responsiveValue != null) {
              var conditionName = sprinkle2.responsiveArray[responsiveIndex];
              if (false)
                ;
              classNames.push(sprinkle2.values[responsiveValue].conditions[conditionName]);
            }
          }
        } else {
          for (var _conditionName in propValue) {
            var _value = propValue[_conditionName];
            if (_value != null) {
              if (false)
                ;
              classNames.push(sprinkle2.values[_value].conditions[_conditionName]);
            }
          }
        }
      } catch (e2) {
        throw e2;
      }
    };
    for (var prop in finalProps) {
      if (_loop())
        continue;
    }
    return composeStyles2(classNames.join(" "));
  };
  return Object.assign(sprinklesFn, {
    properties: new Set(sprinklesKeys)
  });
};
var composeStyles = (classList) => classList;
var createSprinkles = function createSprinkles2() {
  return createSprinkles$1(composeStyles)(...arguments);
};
var sprinkles = createSprinkles({ conditions: { defaultCondition: "sm", conditionNames: ["sm", "md", "lg", "xl"], responsiveArray: void 0 }, styles: { borderWidth: { mappings: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"] }, borderRadius: { mappings: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderLeftRadius: { mappings: ["borderBottomLeftRadius", "borderTopLeftRadius"] }, borderRightRadius: { mappings: ["borderBottomRightRadius", "borderTopRightRadius"] }, borderTopRadius: { mappings: ["borderTopLeftRadius", "borderTopRightRadius"] }, borderBottomRadius: { mappings: ["borderBottomLeftRadius", "borderBottomRightRadius"] }, margin: { mappings: ["marginTop", "marginBottom", "marginLeft", "marginRight"] }, marginX: { mappings: ["marginLeft", "marginRight"] }, marginY: { mappings: ["marginTop", "marginBottom"] }, overflow: { mappings: ["overflowX", "overflowY"] }, padding: { mappings: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"] }, paddingX: { mappings: ["paddingLeft", "paddingRight"] }, paddingY: { mappings: ["paddingTop", "paddingBottom"] }, placeItems: { mappings: ["justifyContent", "alignItems"] }, inset: { mappings: ["top", "bottom", "left", "right"] }, width: { values: { "0": { conditions: { sm: "fyvr10", md: "fyvr11", lg: "fyvr12", xl: "fyvr13" }, defaultClass: "fyvr10" }, "1": { conditions: { sm: "fyvr14", md: "fyvr15", lg: "fyvr16", xl: "fyvr17" }, defaultClass: "fyvr14" }, "2": { conditions: { sm: "fyvr18", md: "fyvr19", lg: "fyvr1a", xl: "fyvr1b" }, defaultClass: "fyvr18" }, "3": { conditions: { sm: "fyvr1c", md: "fyvr1d", lg: "fyvr1e", xl: "fyvr1f" }, defaultClass: "fyvr1c" }, "4": { conditions: { sm: "fyvr1g", md: "fyvr1h", lg: "fyvr1i", xl: "fyvr1j" }, defaultClass: "fyvr1g" }, "5": { conditions: { sm: "fyvr1k", md: "fyvr1l", lg: "fyvr1m", xl: "fyvr1n" }, defaultClass: "fyvr1k" }, "6": { conditions: { sm: "fyvr1o", md: "fyvr1p", lg: "fyvr1q", xl: "fyvr1r" }, defaultClass: "fyvr1o" }, "7": { conditions: { sm: "fyvr1s", md: "fyvr1t", lg: "fyvr1u", xl: "fyvr1v" }, defaultClass: "fyvr1s" }, "8": { conditions: { sm: "fyvr1w", md: "fyvr1x", lg: "fyvr1y", xl: "fyvr1z" }, defaultClass: "fyvr1w" }, "9": { conditions: { sm: "fyvr110", md: "fyvr111", lg: "fyvr112", xl: "fyvr113" }, defaultClass: "fyvr110" }, "10": { conditions: { sm: "fyvr114", md: "fyvr115", lg: "fyvr116", xl: "fyvr117" }, defaultClass: "fyvr114" }, "12": { conditions: { sm: "fyvr118", md: "fyvr119", lg: "fyvr11a", xl: "fyvr11b" }, defaultClass: "fyvr118" }, "14": { conditions: { sm: "fyvr11c", md: "fyvr11d", lg: "fyvr11e", xl: "fyvr11f" }, defaultClass: "fyvr11c" }, "16": { conditions: { sm: "fyvr11g", md: "fyvr11h", lg: "fyvr11i", xl: "fyvr11j" }, defaultClass: "fyvr11g" }, "0.25": { conditions: { sm: "fyvr11k", md: "fyvr11l", lg: "fyvr11m", xl: "fyvr11n" }, defaultClass: "fyvr11k" }, "0.5": { conditions: { sm: "fyvr11o", md: "fyvr11p", lg: "fyvr11q", xl: "fyvr11r" }, defaultClass: "fyvr11o" }, "1.5": { conditions: { sm: "fyvr11s", md: "fyvr11t", lg: "fyvr11u", xl: "fyvr11v" }, defaultClass: "fyvr11s" }, none: { conditions: { sm: "fyvr11w", md: "fyvr11x", lg: "fyvr11y", xl: "fyvr11z" }, defaultClass: "fyvr11w" }, px: { conditions: { sm: "fyvr120", md: "fyvr121", lg: "fyvr122", xl: "fyvr123" }, defaultClass: "fyvr120" }, auto: { conditions: { sm: "fyvr124", md: "fyvr125", lg: "fyvr126", xl: "fyvr127" }, defaultClass: "fyvr124" }, full: { conditions: { sm: "fyvr128", md: "fyvr129", lg: "fyvr12a", xl: "fyvr12b" }, defaultClass: "fyvr128" }, "1/2": { conditions: { sm: "fyvr12c", md: "fyvr12d", lg: "fyvr12e", xl: "fyvr12f" }, defaultClass: "fyvr12c" }, "1/3": { conditions: { sm: "fyvr12g", md: "fyvr12h", lg: "fyvr12i", xl: "fyvr12j" }, defaultClass: "fyvr12g" }, "2/3": { conditions: { sm: "fyvr12k", md: "fyvr12l", lg: "fyvr12m", xl: "fyvr12n" }, defaultClass: "fyvr12k" }, "1/4": { conditions: { sm: "fyvr12o", md: "fyvr12p", lg: "fyvr12q", xl: "fyvr12r" }, defaultClass: "fyvr12o" }, "3/4": { conditions: { sm: "fyvr12s", md: "fyvr12t", lg: "fyvr12u", xl: "fyvr12v" }, defaultClass: "fyvr12s" }, fit: { conditions: { sm: "fyvr12w", md: "fyvr12x", lg: "fyvr12y", xl: "fyvr12z" }, defaultClass: "fyvr12w" }, max: { conditions: { sm: "fyvr130", md: "fyvr131", lg: "fyvr132", xl: "fyvr133" }, defaultClass: "fyvr130" }, min: { conditions: { sm: "fyvr134", md: "fyvr135", lg: "fyvr136", xl: "fyvr137" }, defaultClass: "fyvr134" }, vw: { conditions: { sm: "fyvr138", md: "fyvr139", lg: "fyvr13a", xl: "fyvr13b" }, defaultClass: "fyvr138" }, vh: { conditions: { sm: "fyvr13c", md: "fyvr13d", lg: "fyvr13e", xl: "fyvr13f" }, defaultClass: "fyvr13c" } } }, height: { values: { "0": { conditions: { sm: "fyvr13g", md: "fyvr13h", lg: "fyvr13i", xl: "fyvr13j" }, defaultClass: "fyvr13g" }, "1": { conditions: { sm: "fyvr13k", md: "fyvr13l", lg: "fyvr13m", xl: "fyvr13n" }, defaultClass: "fyvr13k" }, "2": { conditions: { sm: "fyvr13o", md: "fyvr13p", lg: "fyvr13q", xl: "fyvr13r" }, defaultClass: "fyvr13o" }, "3": { conditions: { sm: "fyvr13s", md: "fyvr13t", lg: "fyvr13u", xl: "fyvr13v" }, defaultClass: "fyvr13s" }, "4": { conditions: { sm: "fyvr13w", md: "fyvr13x", lg: "fyvr13y", xl: "fyvr13z" }, defaultClass: "fyvr13w" }, "5": { conditions: { sm: "fyvr140", md: "fyvr141", lg: "fyvr142", xl: "fyvr143" }, defaultClass: "fyvr140" }, "6": { conditions: { sm: "fyvr144", md: "fyvr145", lg: "fyvr146", xl: "fyvr147" }, defaultClass: "fyvr144" }, "7": { conditions: { sm: "fyvr148", md: "fyvr149", lg: "fyvr14a", xl: "fyvr14b" }, defaultClass: "fyvr148" }, "8": { conditions: { sm: "fyvr14c", md: "fyvr14d", lg: "fyvr14e", xl: "fyvr14f" }, defaultClass: "fyvr14c" }, "9": { conditions: { sm: "fyvr14g", md: "fyvr14h", lg: "fyvr14i", xl: "fyvr14j" }, defaultClass: "fyvr14g" }, "10": { conditions: { sm: "fyvr14k", md: "fyvr14l", lg: "fyvr14m", xl: "fyvr14n" }, defaultClass: "fyvr14k" }, "12": { conditions: { sm: "fyvr14o", md: "fyvr14p", lg: "fyvr14q", xl: "fyvr14r" }, defaultClass: "fyvr14o" }, "14": { conditions: { sm: "fyvr14s", md: "fyvr14t", lg: "fyvr14u", xl: "fyvr14v" }, defaultClass: "fyvr14s" }, "16": { conditions: { sm: "fyvr14w", md: "fyvr14x", lg: "fyvr14y", xl: "fyvr14z" }, defaultClass: "fyvr14w" }, "0.25": { conditions: { sm: "fyvr150", md: "fyvr151", lg: "fyvr152", xl: "fyvr153" }, defaultClass: "fyvr150" }, "0.5": { conditions: { sm: "fyvr154", md: "fyvr155", lg: "fyvr156", xl: "fyvr157" }, defaultClass: "fyvr154" }, "1.5": { conditions: { sm: "fyvr158", md: "fyvr159", lg: "fyvr15a", xl: "fyvr15b" }, defaultClass: "fyvr158" }, none: { conditions: { sm: "fyvr15c", md: "fyvr15d", lg: "fyvr15e", xl: "fyvr15f" }, defaultClass: "fyvr15c" }, px: { conditions: { sm: "fyvr15g", md: "fyvr15h", lg: "fyvr15i", xl: "fyvr15j" }, defaultClass: "fyvr15g" }, auto: { conditions: { sm: "fyvr15k", md: "fyvr15l", lg: "fyvr15m", xl: "fyvr15n" }, defaultClass: "fyvr15k" }, full: { conditions: { sm: "fyvr15o", md: "fyvr15p", lg: "fyvr15q", xl: "fyvr15r" }, defaultClass: "fyvr15o" }, "1/2": { conditions: { sm: "fyvr15s", md: "fyvr15t", lg: "fyvr15u", xl: "fyvr15v" }, defaultClass: "fyvr15s" }, "1/3": { conditions: { sm: "fyvr15w", md: "fyvr15x", lg: "fyvr15y", xl: "fyvr15z" }, defaultClass: "fyvr15w" }, "2/3": { conditions: { sm: "fyvr160", md: "fyvr161", lg: "fyvr162", xl: "fyvr163" }, defaultClass: "fyvr160" }, "1/4": { conditions: { sm: "fyvr164", md: "fyvr165", lg: "fyvr166", xl: "fyvr167" }, defaultClass: "fyvr164" }, "3/4": { conditions: { sm: "fyvr168", md: "fyvr169", lg: "fyvr16a", xl: "fyvr16b" }, defaultClass: "fyvr168" }, fit: { conditions: { sm: "fyvr16c", md: "fyvr16d", lg: "fyvr16e", xl: "fyvr16f" }, defaultClass: "fyvr16c" }, max: { conditions: { sm: "fyvr16g", md: "fyvr16h", lg: "fyvr16i", xl: "fyvr16j" }, defaultClass: "fyvr16g" }, min: { conditions: { sm: "fyvr16k", md: "fyvr16l", lg: "fyvr16m", xl: "fyvr16n" }, defaultClass: "fyvr16k" }, vw: { conditions: { sm: "fyvr16o", md: "fyvr16p", lg: "fyvr16q", xl: "fyvr16r" }, defaultClass: "fyvr16o" }, vh: { conditions: { sm: "fyvr16s", md: "fyvr16t", lg: "fyvr16u", xl: "fyvr16v" }, defaultClass: "fyvr16s" } } }, maxWidth: { values: { "0": { conditions: { sm: "fyvr16w", md: "fyvr16x", lg: "fyvr16y", xl: "fyvr16z" }, defaultClass: "fyvr16w" }, "1": { conditions: { sm: "fyvr170", md: "fyvr171", lg: "fyvr172", xl: "fyvr173" }, defaultClass: "fyvr170" }, "2": { conditions: { sm: "fyvr174", md: "fyvr175", lg: "fyvr176", xl: "fyvr177" }, defaultClass: "fyvr174" }, "3": { conditions: { sm: "fyvr178", md: "fyvr179", lg: "fyvr17a", xl: "fyvr17b" }, defaultClass: "fyvr178" }, "4": { conditions: { sm: "fyvr17c", md: "fyvr17d", lg: "fyvr17e", xl: "fyvr17f" }, defaultClass: "fyvr17c" }, "5": { conditions: { sm: "fyvr17g", md: "fyvr17h", lg: "fyvr17i", xl: "fyvr17j" }, defaultClass: "fyvr17g" }, "6": { conditions: { sm: "fyvr17k", md: "fyvr17l", lg: "fyvr17m", xl: "fyvr17n" }, defaultClass: "fyvr17k" }, "7": { conditions: { sm: "fyvr17o", md: "fyvr17p", lg: "fyvr17q", xl: "fyvr17r" }, defaultClass: "fyvr17o" }, "8": { conditions: { sm: "fyvr17s", md: "fyvr17t", lg: "fyvr17u", xl: "fyvr17v" }, defaultClass: "fyvr17s" }, "9": { conditions: { sm: "fyvr17w", md: "fyvr17x", lg: "fyvr17y", xl: "fyvr17z" }, defaultClass: "fyvr17w" }, "10": { conditions: { sm: "fyvr180", md: "fyvr181", lg: "fyvr182", xl: "fyvr183" }, defaultClass: "fyvr180" }, "12": { conditions: { sm: "fyvr184", md: "fyvr185", lg: "fyvr186", xl: "fyvr187" }, defaultClass: "fyvr184" }, "14": { conditions: { sm: "fyvr188", md: "fyvr189", lg: "fyvr18a", xl: "fyvr18b" }, defaultClass: "fyvr188" }, "16": { conditions: { sm: "fyvr18c", md: "fyvr18d", lg: "fyvr18e", xl: "fyvr18f" }, defaultClass: "fyvr18c" }, "0.25": { conditions: { sm: "fyvr18g", md: "fyvr18h", lg: "fyvr18i", xl: "fyvr18j" }, defaultClass: "fyvr18g" }, "0.5": { conditions: { sm: "fyvr18k", md: "fyvr18l", lg: "fyvr18m", xl: "fyvr18n" }, defaultClass: "fyvr18k" }, "1.5": { conditions: { sm: "fyvr18o", md: "fyvr18p", lg: "fyvr18q", xl: "fyvr18r" }, defaultClass: "fyvr18o" }, none: { conditions: { sm: "fyvr18s", md: "fyvr18t", lg: "fyvr18u", xl: "fyvr18v" }, defaultClass: "fyvr18s" }, px: { conditions: { sm: "fyvr18w", md: "fyvr18x", lg: "fyvr18y", xl: "fyvr18z" }, defaultClass: "fyvr18w" }, auto: { conditions: { sm: "fyvr190", md: "fyvr191", lg: "fyvr192", xl: "fyvr193" }, defaultClass: "fyvr190" }, full: { conditions: { sm: "fyvr194", md: "fyvr195", lg: "fyvr196", xl: "fyvr197" }, defaultClass: "fyvr194" }, "1/2": { conditions: { sm: "fyvr198", md: "fyvr199", lg: "fyvr19a", xl: "fyvr19b" }, defaultClass: "fyvr198" }, "1/3": { conditions: { sm: "fyvr19c", md: "fyvr19d", lg: "fyvr19e", xl: "fyvr19f" }, defaultClass: "fyvr19c" }, "2/3": { conditions: { sm: "fyvr19g", md: "fyvr19h", lg: "fyvr19i", xl: "fyvr19j" }, defaultClass: "fyvr19g" }, "1/4": { conditions: { sm: "fyvr19k", md: "fyvr19l", lg: "fyvr19m", xl: "fyvr19n" }, defaultClass: "fyvr19k" }, "3/4": { conditions: { sm: "fyvr19o", md: "fyvr19p", lg: "fyvr19q", xl: "fyvr19r" }, defaultClass: "fyvr19o" }, fit: { conditions: { sm: "fyvr19s", md: "fyvr19t", lg: "fyvr19u", xl: "fyvr19v" }, defaultClass: "fyvr19s" }, max: { conditions: { sm: "fyvr19w", md: "fyvr19x", lg: "fyvr19y", xl: "fyvr19z" }, defaultClass: "fyvr19w" }, min: { conditions: { sm: "fyvr1a0", md: "fyvr1a1", lg: "fyvr1a2", xl: "fyvr1a3" }, defaultClass: "fyvr1a0" }, vw: { conditions: { sm: "fyvr1a4", md: "fyvr1a5", lg: "fyvr1a6", xl: "fyvr1a7" }, defaultClass: "fyvr1a4" }, vh: { conditions: { sm: "fyvr1a8", md: "fyvr1a9", lg: "fyvr1aa", xl: "fyvr1ab" }, defaultClass: "fyvr1a8" } } }, maxHeight: { values: { "0": { conditions: { sm: "fyvr1ac", md: "fyvr1ad", lg: "fyvr1ae", xl: "fyvr1af" }, defaultClass: "fyvr1ac" }, "1": { conditions: { sm: "fyvr1ag", md: "fyvr1ah", lg: "fyvr1ai", xl: "fyvr1aj" }, defaultClass: "fyvr1ag" }, "2": { conditions: { sm: "fyvr1ak", md: "fyvr1al", lg: "fyvr1am", xl: "fyvr1an" }, defaultClass: "fyvr1ak" }, "3": { conditions: { sm: "fyvr1ao", md: "fyvr1ap", lg: "fyvr1aq", xl: "fyvr1ar" }, defaultClass: "fyvr1ao" }, "4": { conditions: { sm: "fyvr1as", md: "fyvr1at", lg: "fyvr1au", xl: "fyvr1av" }, defaultClass: "fyvr1as" }, "5": { conditions: { sm: "fyvr1aw", md: "fyvr1ax", lg: "fyvr1ay", xl: "fyvr1az" }, defaultClass: "fyvr1aw" }, "6": { conditions: { sm: "fyvr1b0", md: "fyvr1b1", lg: "fyvr1b2", xl: "fyvr1b3" }, defaultClass: "fyvr1b0" }, "7": { conditions: { sm: "fyvr1b4", md: "fyvr1b5", lg: "fyvr1b6", xl: "fyvr1b7" }, defaultClass: "fyvr1b4" }, "8": { conditions: { sm: "fyvr1b8", md: "fyvr1b9", lg: "fyvr1ba", xl: "fyvr1bb" }, defaultClass: "fyvr1b8" }, "9": { conditions: { sm: "fyvr1bc", md: "fyvr1bd", lg: "fyvr1be", xl: "fyvr1bf" }, defaultClass: "fyvr1bc" }, "10": { conditions: { sm: "fyvr1bg", md: "fyvr1bh", lg: "fyvr1bi", xl: "fyvr1bj" }, defaultClass: "fyvr1bg" }, "12": { conditions: { sm: "fyvr1bk", md: "fyvr1bl", lg: "fyvr1bm", xl: "fyvr1bn" }, defaultClass: "fyvr1bk" }, "14": { conditions: { sm: "fyvr1bo", md: "fyvr1bp", lg: "fyvr1bq", xl: "fyvr1br" }, defaultClass: "fyvr1bo" }, "16": { conditions: { sm: "fyvr1bs", md: "fyvr1bt", lg: "fyvr1bu", xl: "fyvr1bv" }, defaultClass: "fyvr1bs" }, "0.25": { conditions: { sm: "fyvr1bw", md: "fyvr1bx", lg: "fyvr1by", xl: "fyvr1bz" }, defaultClass: "fyvr1bw" }, "0.5": { conditions: { sm: "fyvr1c0", md: "fyvr1c1", lg: "fyvr1c2", xl: "fyvr1c3" }, defaultClass: "fyvr1c0" }, "1.5": { conditions: { sm: "fyvr1c4", md: "fyvr1c5", lg: "fyvr1c6", xl: "fyvr1c7" }, defaultClass: "fyvr1c4" }, none: { conditions: { sm: "fyvr1c8", md: "fyvr1c9", lg: "fyvr1ca", xl: "fyvr1cb" }, defaultClass: "fyvr1c8" }, px: { conditions: { sm: "fyvr1cc", md: "fyvr1cd", lg: "fyvr1ce", xl: "fyvr1cf" }, defaultClass: "fyvr1cc" }, auto: { conditions: { sm: "fyvr1cg", md: "fyvr1ch", lg: "fyvr1ci", xl: "fyvr1cj" }, defaultClass: "fyvr1cg" }, full: { conditions: { sm: "fyvr1ck", md: "fyvr1cl", lg: "fyvr1cm", xl: "fyvr1cn" }, defaultClass: "fyvr1ck" }, "1/2": { conditions: { sm: "fyvr1co", md: "fyvr1cp", lg: "fyvr1cq", xl: "fyvr1cr" }, defaultClass: "fyvr1co" }, "1/3": { conditions: { sm: "fyvr1cs", md: "fyvr1ct", lg: "fyvr1cu", xl: "fyvr1cv" }, defaultClass: "fyvr1cs" }, "2/3": { conditions: { sm: "fyvr1cw", md: "fyvr1cx", lg: "fyvr1cy", xl: "fyvr1cz" }, defaultClass: "fyvr1cw" }, "1/4": { conditions: { sm: "fyvr1d0", md: "fyvr1d1", lg: "fyvr1d2", xl: "fyvr1d3" }, defaultClass: "fyvr1d0" }, "3/4": { conditions: { sm: "fyvr1d4", md: "fyvr1d5", lg: "fyvr1d6", xl: "fyvr1d7" }, defaultClass: "fyvr1d4" }, fit: { conditions: { sm: "fyvr1d8", md: "fyvr1d9", lg: "fyvr1da", xl: "fyvr1db" }, defaultClass: "fyvr1d8" }, max: { conditions: { sm: "fyvr1dc", md: "fyvr1dd", lg: "fyvr1de", xl: "fyvr1df" }, defaultClass: "fyvr1dc" }, min: { conditions: { sm: "fyvr1dg", md: "fyvr1dh", lg: "fyvr1di", xl: "fyvr1dj" }, defaultClass: "fyvr1dg" }, vw: { conditions: { sm: "fyvr1dk", md: "fyvr1dl", lg: "fyvr1dm", xl: "fyvr1dn" }, defaultClass: "fyvr1dk" }, vh: { conditions: { sm: "fyvr1do", md: "fyvr1dp", lg: "fyvr1dq", xl: "fyvr1dr" }, defaultClass: "fyvr1do" } } }, minWidth: { values: { "0": { conditions: { sm: "fyvr1ds", md: "fyvr1dt", lg: "fyvr1du", xl: "fyvr1dv" }, defaultClass: "fyvr1ds" }, "1": { conditions: { sm: "fyvr1dw", md: "fyvr1dx", lg: "fyvr1dy", xl: "fyvr1dz" }, defaultClass: "fyvr1dw" }, "2": { conditions: { sm: "fyvr1e0", md: "fyvr1e1", lg: "fyvr1e2", xl: "fyvr1e3" }, defaultClass: "fyvr1e0" }, "3": { conditions: { sm: "fyvr1e4", md: "fyvr1e5", lg: "fyvr1e6", xl: "fyvr1e7" }, defaultClass: "fyvr1e4" }, "4": { conditions: { sm: "fyvr1e8", md: "fyvr1e9", lg: "fyvr1ea", xl: "fyvr1eb" }, defaultClass: "fyvr1e8" }, "5": { conditions: { sm: "fyvr1ec", md: "fyvr1ed", lg: "fyvr1ee", xl: "fyvr1ef" }, defaultClass: "fyvr1ec" }, "6": { conditions: { sm: "fyvr1eg", md: "fyvr1eh", lg: "fyvr1ei", xl: "fyvr1ej" }, defaultClass: "fyvr1eg" }, "7": { conditions: { sm: "fyvr1ek", md: "fyvr1el", lg: "fyvr1em", xl: "fyvr1en" }, defaultClass: "fyvr1ek" }, "8": { conditions: { sm: "fyvr1eo", md: "fyvr1ep", lg: "fyvr1eq", xl: "fyvr1er" }, defaultClass: "fyvr1eo" }, "9": { conditions: { sm: "fyvr1es", md: "fyvr1et", lg: "fyvr1eu", xl: "fyvr1ev" }, defaultClass: "fyvr1es" }, "10": { conditions: { sm: "fyvr1ew", md: "fyvr1ex", lg: "fyvr1ey", xl: "fyvr1ez" }, defaultClass: "fyvr1ew" }, "12": { conditions: { sm: "fyvr1f0", md: "fyvr1f1", lg: "fyvr1f2", xl: "fyvr1f3" }, defaultClass: "fyvr1f0" }, "14": { conditions: { sm: "fyvr1f4", md: "fyvr1f5", lg: "fyvr1f6", xl: "fyvr1f7" }, defaultClass: "fyvr1f4" }, "16": { conditions: { sm: "fyvr1f8", md: "fyvr1f9", lg: "fyvr1fa", xl: "fyvr1fb" }, defaultClass: "fyvr1f8" }, "0.25": { conditions: { sm: "fyvr1fc", md: "fyvr1fd", lg: "fyvr1fe", xl: "fyvr1ff" }, defaultClass: "fyvr1fc" }, "0.5": { conditions: { sm: "fyvr1fg", md: "fyvr1fh", lg: "fyvr1fi", xl: "fyvr1fj" }, defaultClass: "fyvr1fg" }, "1.5": { conditions: { sm: "fyvr1fk", md: "fyvr1fl", lg: "fyvr1fm", xl: "fyvr1fn" }, defaultClass: "fyvr1fk" }, none: { conditions: { sm: "fyvr1fo", md: "fyvr1fp", lg: "fyvr1fq", xl: "fyvr1fr" }, defaultClass: "fyvr1fo" }, px: { conditions: { sm: "fyvr1fs", md: "fyvr1ft", lg: "fyvr1fu", xl: "fyvr1fv" }, defaultClass: "fyvr1fs" }, auto: { conditions: { sm: "fyvr1fw", md: "fyvr1fx", lg: "fyvr1fy", xl: "fyvr1fz" }, defaultClass: "fyvr1fw" }, full: { conditions: { sm: "fyvr1g0", md: "fyvr1g1", lg: "fyvr1g2", xl: "fyvr1g3" }, defaultClass: "fyvr1g0" }, "1/2": { conditions: { sm: "fyvr1g4", md: "fyvr1g5", lg: "fyvr1g6", xl: "fyvr1g7" }, defaultClass: "fyvr1g4" }, "1/3": { conditions: { sm: "fyvr1g8", md: "fyvr1g9", lg: "fyvr1ga", xl: "fyvr1gb" }, defaultClass: "fyvr1g8" }, "2/3": { conditions: { sm: "fyvr1gc", md: "fyvr1gd", lg: "fyvr1ge", xl: "fyvr1gf" }, defaultClass: "fyvr1gc" }, "1/4": { conditions: { sm: "fyvr1gg", md: "fyvr1gh", lg: "fyvr1gi", xl: "fyvr1gj" }, defaultClass: "fyvr1gg" }, "3/4": { conditions: { sm: "fyvr1gk", md: "fyvr1gl", lg: "fyvr1gm", xl: "fyvr1gn" }, defaultClass: "fyvr1gk" }, fit: { conditions: { sm: "fyvr1go", md: "fyvr1gp", lg: "fyvr1gq", xl: "fyvr1gr" }, defaultClass: "fyvr1go" }, max: { conditions: { sm: "fyvr1gs", md: "fyvr1gt", lg: "fyvr1gu", xl: "fyvr1gv" }, defaultClass: "fyvr1gs" }, min: { conditions: { sm: "fyvr1gw", md: "fyvr1gx", lg: "fyvr1gy", xl: "fyvr1gz" }, defaultClass: "fyvr1gw" }, vw: { conditions: { sm: "fyvr1h0", md: "fyvr1h1", lg: "fyvr1h2", xl: "fyvr1h3" }, defaultClass: "fyvr1h0" }, vh: { conditions: { sm: "fyvr1h4", md: "fyvr1h5", lg: "fyvr1h6", xl: "fyvr1h7" }, defaultClass: "fyvr1h4" } } }, minHeight: { values: { "0": { conditions: { sm: "fyvr1h8", md: "fyvr1h9", lg: "fyvr1ha", xl: "fyvr1hb" }, defaultClass: "fyvr1h8" }, "1": { conditions: { sm: "fyvr1hc", md: "fyvr1hd", lg: "fyvr1he", xl: "fyvr1hf" }, defaultClass: "fyvr1hc" }, "2": { conditions: { sm: "fyvr1hg", md: "fyvr1hh", lg: "fyvr1hi", xl: "fyvr1hj" }, defaultClass: "fyvr1hg" }, "3": { conditions: { sm: "fyvr1hk", md: "fyvr1hl", lg: "fyvr1hm", xl: "fyvr1hn" }, defaultClass: "fyvr1hk" }, "4": { conditions: { sm: "fyvr1ho", md: "fyvr1hp", lg: "fyvr1hq", xl: "fyvr1hr" }, defaultClass: "fyvr1ho" }, "5": { conditions: { sm: "fyvr1hs", md: "fyvr1ht", lg: "fyvr1hu", xl: "fyvr1hv" }, defaultClass: "fyvr1hs" }, "6": { conditions: { sm: "fyvr1hw", md: "fyvr1hx", lg: "fyvr1hy", xl: "fyvr1hz" }, defaultClass: "fyvr1hw" }, "7": { conditions: { sm: "fyvr1i0", md: "fyvr1i1", lg: "fyvr1i2", xl: "fyvr1i3" }, defaultClass: "fyvr1i0" }, "8": { conditions: { sm: "fyvr1i4", md: "fyvr1i5", lg: "fyvr1i6", xl: "fyvr1i7" }, defaultClass: "fyvr1i4" }, "9": { conditions: { sm: "fyvr1i8", md: "fyvr1i9", lg: "fyvr1ia", xl: "fyvr1ib" }, defaultClass: "fyvr1i8" }, "10": { conditions: { sm: "fyvr1ic", md: "fyvr1id", lg: "fyvr1ie", xl: "fyvr1if" }, defaultClass: "fyvr1ic" }, "12": { conditions: { sm: "fyvr1ig", md: "fyvr1ih", lg: "fyvr1ii", xl: "fyvr1ij" }, defaultClass: "fyvr1ig" }, "14": { conditions: { sm: "fyvr1ik", md: "fyvr1il", lg: "fyvr1im", xl: "fyvr1in" }, defaultClass: "fyvr1ik" }, "16": { conditions: { sm: "fyvr1io", md: "fyvr1ip", lg: "fyvr1iq", xl: "fyvr1ir" }, defaultClass: "fyvr1io" }, "0.25": { conditions: { sm: "fyvr1is", md: "fyvr1it", lg: "fyvr1iu", xl: "fyvr1iv" }, defaultClass: "fyvr1is" }, "0.5": { conditions: { sm: "fyvr1iw", md: "fyvr1ix", lg: "fyvr1iy", xl: "fyvr1iz" }, defaultClass: "fyvr1iw" }, "1.5": { conditions: { sm: "fyvr1j0", md: "fyvr1j1", lg: "fyvr1j2", xl: "fyvr1j3" }, defaultClass: "fyvr1j0" }, none: { conditions: { sm: "fyvr1j4", md: "fyvr1j5", lg: "fyvr1j6", xl: "fyvr1j7" }, defaultClass: "fyvr1j4" }, px: { conditions: { sm: "fyvr1j8", md: "fyvr1j9", lg: "fyvr1ja", xl: "fyvr1jb" }, defaultClass: "fyvr1j8" }, auto: { conditions: { sm: "fyvr1jc", md: "fyvr1jd", lg: "fyvr1je", xl: "fyvr1jf" }, defaultClass: "fyvr1jc" }, full: { conditions: { sm: "fyvr1jg", md: "fyvr1jh", lg: "fyvr1ji", xl: "fyvr1jj" }, defaultClass: "fyvr1jg" }, "1/2": { conditions: { sm: "fyvr1jk", md: "fyvr1jl", lg: "fyvr1jm", xl: "fyvr1jn" }, defaultClass: "fyvr1jk" }, "1/3": { conditions: { sm: "fyvr1jo", md: "fyvr1jp", lg: "fyvr1jq", xl: "fyvr1jr" }, defaultClass: "fyvr1jo" }, "2/3": { conditions: { sm: "fyvr1js", md: "fyvr1jt", lg: "fyvr1ju", xl: "fyvr1jv" }, defaultClass: "fyvr1js" }, "1/4": { conditions: { sm: "fyvr1jw", md: "fyvr1jx", lg: "fyvr1jy", xl: "fyvr1jz" }, defaultClass: "fyvr1jw" }, "3/4": { conditions: { sm: "fyvr1k0", md: "fyvr1k1", lg: "fyvr1k2", xl: "fyvr1k3" }, defaultClass: "fyvr1k0" }, fit: { conditions: { sm: "fyvr1k4", md: "fyvr1k5", lg: "fyvr1k6", xl: "fyvr1k7" }, defaultClass: "fyvr1k4" }, max: { conditions: { sm: "fyvr1k8", md: "fyvr1k9", lg: "fyvr1ka", xl: "fyvr1kb" }, defaultClass: "fyvr1k8" }, min: { conditions: { sm: "fyvr1kc", md: "fyvr1kd", lg: "fyvr1ke", xl: "fyvr1kf" }, defaultClass: "fyvr1kc" }, vw: { conditions: { sm: "fyvr1kg", md: "fyvr1kh", lg: "fyvr1ki", xl: "fyvr1kj" }, defaultClass: "fyvr1kg" }, vh: { conditions: { sm: "fyvr1kk", md: "fyvr1kl", lg: "fyvr1km", xl: "fyvr1kn" }, defaultClass: "fyvr1kk" } } }, top: { values: { "0": { conditions: { sm: "fyvr1ko", md: "fyvr1kp", lg: "fyvr1kq", xl: "fyvr1kr" }, defaultClass: "fyvr1ko" }, "1": { conditions: { sm: "fyvr1ks", md: "fyvr1kt", lg: "fyvr1ku", xl: "fyvr1kv" }, defaultClass: "fyvr1ks" }, "2": { conditions: { sm: "fyvr1kw", md: "fyvr1kx", lg: "fyvr1ky", xl: "fyvr1kz" }, defaultClass: "fyvr1kw" }, "3": { conditions: { sm: "fyvr1l0", md: "fyvr1l1", lg: "fyvr1l2", xl: "fyvr1l3" }, defaultClass: "fyvr1l0" }, "4": { conditions: { sm: "fyvr1l4", md: "fyvr1l5", lg: "fyvr1l6", xl: "fyvr1l7" }, defaultClass: "fyvr1l4" }, "5": { conditions: { sm: "fyvr1l8", md: "fyvr1l9", lg: "fyvr1la", xl: "fyvr1lb" }, defaultClass: "fyvr1l8" }, "6": { conditions: { sm: "fyvr1lc", md: "fyvr1ld", lg: "fyvr1le", xl: "fyvr1lf" }, defaultClass: "fyvr1lc" }, "7": { conditions: { sm: "fyvr1lg", md: "fyvr1lh", lg: "fyvr1li", xl: "fyvr1lj" }, defaultClass: "fyvr1lg" }, "8": { conditions: { sm: "fyvr1lk", md: "fyvr1ll", lg: "fyvr1lm", xl: "fyvr1ln" }, defaultClass: "fyvr1lk" }, "9": { conditions: { sm: "fyvr1lo", md: "fyvr1lp", lg: "fyvr1lq", xl: "fyvr1lr" }, defaultClass: "fyvr1lo" }, "10": { conditions: { sm: "fyvr1ls", md: "fyvr1lt", lg: "fyvr1lu", xl: "fyvr1lv" }, defaultClass: "fyvr1ls" }, "12": { conditions: { sm: "fyvr1lw", md: "fyvr1lx", lg: "fyvr1ly", xl: "fyvr1lz" }, defaultClass: "fyvr1lw" }, "14": { conditions: { sm: "fyvr1m0", md: "fyvr1m1", lg: "fyvr1m2", xl: "fyvr1m3" }, defaultClass: "fyvr1m0" }, "16": { conditions: { sm: "fyvr1m4", md: "fyvr1m5", lg: "fyvr1m6", xl: "fyvr1m7" }, defaultClass: "fyvr1m4" }, "0.25": { conditions: { sm: "fyvr1m8", md: "fyvr1m9", lg: "fyvr1ma", xl: "fyvr1mb" }, defaultClass: "fyvr1m8" }, "0.5": { conditions: { sm: "fyvr1mc", md: "fyvr1md", lg: "fyvr1me", xl: "fyvr1mf" }, defaultClass: "fyvr1mc" }, "1.5": { conditions: { sm: "fyvr1mg", md: "fyvr1mh", lg: "fyvr1mi", xl: "fyvr1mj" }, defaultClass: "fyvr1mg" }, auto: { conditions: { sm: "fyvr1mk", md: "fyvr1ml", lg: "fyvr1mm", xl: "fyvr1mn" }, defaultClass: "fyvr1mk" } } }, bottom: { values: { "0": { conditions: { sm: "fyvr1mo", md: "fyvr1mp", lg: "fyvr1mq", xl: "fyvr1mr" }, defaultClass: "fyvr1mo" }, "1": { conditions: { sm: "fyvr1ms", md: "fyvr1mt", lg: "fyvr1mu", xl: "fyvr1mv" }, defaultClass: "fyvr1ms" }, "2": { conditions: { sm: "fyvr1mw", md: "fyvr1mx", lg: "fyvr1my", xl: "fyvr1mz" }, defaultClass: "fyvr1mw" }, "3": { conditions: { sm: "fyvr1n0", md: "fyvr1n1", lg: "fyvr1n2", xl: "fyvr1n3" }, defaultClass: "fyvr1n0" }, "4": { conditions: { sm: "fyvr1n4", md: "fyvr1n5", lg: "fyvr1n6", xl: "fyvr1n7" }, defaultClass: "fyvr1n4" }, "5": { conditions: { sm: "fyvr1n8", md: "fyvr1n9", lg: "fyvr1na", xl: "fyvr1nb" }, defaultClass: "fyvr1n8" }, "6": { conditions: { sm: "fyvr1nc", md: "fyvr1nd", lg: "fyvr1ne", xl: "fyvr1nf" }, defaultClass: "fyvr1nc" }, "7": { conditions: { sm: "fyvr1ng", md: "fyvr1nh", lg: "fyvr1ni", xl: "fyvr1nj" }, defaultClass: "fyvr1ng" }, "8": { conditions: { sm: "fyvr1nk", md: "fyvr1nl", lg: "fyvr1nm", xl: "fyvr1nn" }, defaultClass: "fyvr1nk" }, "9": { conditions: { sm: "fyvr1no", md: "fyvr1np", lg: "fyvr1nq", xl: "fyvr1nr" }, defaultClass: "fyvr1no" }, "10": { conditions: { sm: "fyvr1ns", md: "fyvr1nt", lg: "fyvr1nu", xl: "fyvr1nv" }, defaultClass: "fyvr1ns" }, "12": { conditions: { sm: "fyvr1nw", md: "fyvr1nx", lg: "fyvr1ny", xl: "fyvr1nz" }, defaultClass: "fyvr1nw" }, "14": { conditions: { sm: "fyvr1o0", md: "fyvr1o1", lg: "fyvr1o2", xl: "fyvr1o3" }, defaultClass: "fyvr1o0" }, "16": { conditions: { sm: "fyvr1o4", md: "fyvr1o5", lg: "fyvr1o6", xl: "fyvr1o7" }, defaultClass: "fyvr1o4" }, "0.25": { conditions: { sm: "fyvr1o8", md: "fyvr1o9", lg: "fyvr1oa", xl: "fyvr1ob" }, defaultClass: "fyvr1o8" }, "0.5": { conditions: { sm: "fyvr1oc", md: "fyvr1od", lg: "fyvr1oe", xl: "fyvr1of" }, defaultClass: "fyvr1oc" }, "1.5": { conditions: { sm: "fyvr1og", md: "fyvr1oh", lg: "fyvr1oi", xl: "fyvr1oj" }, defaultClass: "fyvr1og" }, auto: { conditions: { sm: "fyvr1ok", md: "fyvr1ol", lg: "fyvr1om", xl: "fyvr1on" }, defaultClass: "fyvr1ok" } } }, left: { values: { "0": { conditions: { sm: "fyvr1oo", md: "fyvr1op", lg: "fyvr1oq", xl: "fyvr1or" }, defaultClass: "fyvr1oo" }, "1": { conditions: { sm: "fyvr1os", md: "fyvr1ot", lg: "fyvr1ou", xl: "fyvr1ov" }, defaultClass: "fyvr1os" }, "2": { conditions: { sm: "fyvr1ow", md: "fyvr1ox", lg: "fyvr1oy", xl: "fyvr1oz" }, defaultClass: "fyvr1ow" }, "3": { conditions: { sm: "fyvr1p0", md: "fyvr1p1", lg: "fyvr1p2", xl: "fyvr1p3" }, defaultClass: "fyvr1p0" }, "4": { conditions: { sm: "fyvr1p4", md: "fyvr1p5", lg: "fyvr1p6", xl: "fyvr1p7" }, defaultClass: "fyvr1p4" }, "5": { conditions: { sm: "fyvr1p8", md: "fyvr1p9", lg: "fyvr1pa", xl: "fyvr1pb" }, defaultClass: "fyvr1p8" }, "6": { conditions: { sm: "fyvr1pc", md: "fyvr1pd", lg: "fyvr1pe", xl: "fyvr1pf" }, defaultClass: "fyvr1pc" }, "7": { conditions: { sm: "fyvr1pg", md: "fyvr1ph", lg: "fyvr1pi", xl: "fyvr1pj" }, defaultClass: "fyvr1pg" }, "8": { conditions: { sm: "fyvr1pk", md: "fyvr1pl", lg: "fyvr1pm", xl: "fyvr1pn" }, defaultClass: "fyvr1pk" }, "9": { conditions: { sm: "fyvr1po", md: "fyvr1pp", lg: "fyvr1pq", xl: "fyvr1pr" }, defaultClass: "fyvr1po" }, "10": { conditions: { sm: "fyvr1ps", md: "fyvr1pt", lg: "fyvr1pu", xl: "fyvr1pv" }, defaultClass: "fyvr1ps" }, "12": { conditions: { sm: "fyvr1pw", md: "fyvr1px", lg: "fyvr1py", xl: "fyvr1pz" }, defaultClass: "fyvr1pw" }, "14": { conditions: { sm: "fyvr1q0", md: "fyvr1q1", lg: "fyvr1q2", xl: "fyvr1q3" }, defaultClass: "fyvr1q0" }, "16": { conditions: { sm: "fyvr1q4", md: "fyvr1q5", lg: "fyvr1q6", xl: "fyvr1q7" }, defaultClass: "fyvr1q4" }, "0.25": { conditions: { sm: "fyvr1q8", md: "fyvr1q9", lg: "fyvr1qa", xl: "fyvr1qb" }, defaultClass: "fyvr1q8" }, "0.5": { conditions: { sm: "fyvr1qc", md: "fyvr1qd", lg: "fyvr1qe", xl: "fyvr1qf" }, defaultClass: "fyvr1qc" }, "1.5": { conditions: { sm: "fyvr1qg", md: "fyvr1qh", lg: "fyvr1qi", xl: "fyvr1qj" }, defaultClass: "fyvr1qg" }, auto: { conditions: { sm: "fyvr1qk", md: "fyvr1ql", lg: "fyvr1qm", xl: "fyvr1qn" }, defaultClass: "fyvr1qk" } } }, right: { values: { "0": { conditions: { sm: "fyvr1qo", md: "fyvr1qp", lg: "fyvr1qq", xl: "fyvr1qr" }, defaultClass: "fyvr1qo" }, "1": { conditions: { sm: "fyvr1qs", md: "fyvr1qt", lg: "fyvr1qu", xl: "fyvr1qv" }, defaultClass: "fyvr1qs" }, "2": { conditions: { sm: "fyvr1qw", md: "fyvr1qx", lg: "fyvr1qy", xl: "fyvr1qz" }, defaultClass: "fyvr1qw" }, "3": { conditions: { sm: "fyvr1r0", md: "fyvr1r1", lg: "fyvr1r2", xl: "fyvr1r3" }, defaultClass: "fyvr1r0" }, "4": { conditions: { sm: "fyvr1r4", md: "fyvr1r5", lg: "fyvr1r6", xl: "fyvr1r7" }, defaultClass: "fyvr1r4" }, "5": { conditions: { sm: "fyvr1r8", md: "fyvr1r9", lg: "fyvr1ra", xl: "fyvr1rb" }, defaultClass: "fyvr1r8" }, "6": { conditions: { sm: "fyvr1rc", md: "fyvr1rd", lg: "fyvr1re", xl: "fyvr1rf" }, defaultClass: "fyvr1rc" }, "7": { conditions: { sm: "fyvr1rg", md: "fyvr1rh", lg: "fyvr1ri", xl: "fyvr1rj" }, defaultClass: "fyvr1rg" }, "8": { conditions: { sm: "fyvr1rk", md: "fyvr1rl", lg: "fyvr1rm", xl: "fyvr1rn" }, defaultClass: "fyvr1rk" }, "9": { conditions: { sm: "fyvr1ro", md: "fyvr1rp", lg: "fyvr1rq", xl: "fyvr1rr" }, defaultClass: "fyvr1ro" }, "10": { conditions: { sm: "fyvr1rs", md: "fyvr1rt", lg: "fyvr1ru", xl: "fyvr1rv" }, defaultClass: "fyvr1rs" }, "12": { conditions: { sm: "fyvr1rw", md: "fyvr1rx", lg: "fyvr1ry", xl: "fyvr1rz" }, defaultClass: "fyvr1rw" }, "14": { conditions: { sm: "fyvr1s0", md: "fyvr1s1", lg: "fyvr1s2", xl: "fyvr1s3" }, defaultClass: "fyvr1s0" }, "16": { conditions: { sm: "fyvr1s4", md: "fyvr1s5", lg: "fyvr1s6", xl: "fyvr1s7" }, defaultClass: "fyvr1s4" }, "0.25": { conditions: { sm: "fyvr1s8", md: "fyvr1s9", lg: "fyvr1sa", xl: "fyvr1sb" }, defaultClass: "fyvr1s8" }, "0.5": { conditions: { sm: "fyvr1sc", md: "fyvr1sd", lg: "fyvr1se", xl: "fyvr1sf" }, defaultClass: "fyvr1sc" }, "1.5": { conditions: { sm: "fyvr1sg", md: "fyvr1sh", lg: "fyvr1si", xl: "fyvr1sj" }, defaultClass: "fyvr1sg" }, auto: { conditions: { sm: "fyvr1sk", md: "fyvr1sl", lg: "fyvr1sm", xl: "fyvr1sn" }, defaultClass: "fyvr1sk" } } }, paddingTop: { values: { "0": { conditions: { sm: "fyvr1so", md: "fyvr1sp", lg: "fyvr1sq", xl: "fyvr1sr" }, defaultClass: "fyvr1so" }, "1": { conditions: { sm: "fyvr1ss", md: "fyvr1st", lg: "fyvr1su", xl: "fyvr1sv" }, defaultClass: "fyvr1ss" }, "2": { conditions: { sm: "fyvr1sw", md: "fyvr1sx", lg: "fyvr1sy", xl: "fyvr1sz" }, defaultClass: "fyvr1sw" }, "3": { conditions: { sm: "fyvr1t0", md: "fyvr1t1", lg: "fyvr1t2", xl: "fyvr1t3" }, defaultClass: "fyvr1t0" }, "4": { conditions: { sm: "fyvr1t4", md: "fyvr1t5", lg: "fyvr1t6", xl: "fyvr1t7" }, defaultClass: "fyvr1t4" }, "5": { conditions: { sm: "fyvr1t8", md: "fyvr1t9", lg: "fyvr1ta", xl: "fyvr1tb" }, defaultClass: "fyvr1t8" }, "6": { conditions: { sm: "fyvr1tc", md: "fyvr1td", lg: "fyvr1te", xl: "fyvr1tf" }, defaultClass: "fyvr1tc" }, "7": { conditions: { sm: "fyvr1tg", md: "fyvr1th", lg: "fyvr1ti", xl: "fyvr1tj" }, defaultClass: "fyvr1tg" }, "8": { conditions: { sm: "fyvr1tk", md: "fyvr1tl", lg: "fyvr1tm", xl: "fyvr1tn" }, defaultClass: "fyvr1tk" }, "9": { conditions: { sm: "fyvr1to", md: "fyvr1tp", lg: "fyvr1tq", xl: "fyvr1tr" }, defaultClass: "fyvr1to" }, "10": { conditions: { sm: "fyvr1ts", md: "fyvr1tt", lg: "fyvr1tu", xl: "fyvr1tv" }, defaultClass: "fyvr1ts" }, "12": { conditions: { sm: "fyvr1tw", md: "fyvr1tx", lg: "fyvr1ty", xl: "fyvr1tz" }, defaultClass: "fyvr1tw" }, "14": { conditions: { sm: "fyvr1u0", md: "fyvr1u1", lg: "fyvr1u2", xl: "fyvr1u3" }, defaultClass: "fyvr1u0" }, "16": { conditions: { sm: "fyvr1u4", md: "fyvr1u5", lg: "fyvr1u6", xl: "fyvr1u7" }, defaultClass: "fyvr1u4" }, "0.25": { conditions: { sm: "fyvr1u8", md: "fyvr1u9", lg: "fyvr1ua", xl: "fyvr1ub" }, defaultClass: "fyvr1u8" }, "0.5": { conditions: { sm: "fyvr1uc", md: "fyvr1ud", lg: "fyvr1ue", xl: "fyvr1uf" }, defaultClass: "fyvr1uc" }, "1.5": { conditions: { sm: "fyvr1ug", md: "fyvr1uh", lg: "fyvr1ui", xl: "fyvr1uj" }, defaultClass: "fyvr1ug" } } }, paddingBottom: { values: { "0": { conditions: { sm: "fyvr1uk", md: "fyvr1ul", lg: "fyvr1um", xl: "fyvr1un" }, defaultClass: "fyvr1uk" }, "1": { conditions: { sm: "fyvr1uo", md: "fyvr1up", lg: "fyvr1uq", xl: "fyvr1ur" }, defaultClass: "fyvr1uo" }, "2": { conditions: { sm: "fyvr1us", md: "fyvr1ut", lg: "fyvr1uu", xl: "fyvr1uv" }, defaultClass: "fyvr1us" }, "3": { conditions: { sm: "fyvr1uw", md: "fyvr1ux", lg: "fyvr1uy", xl: "fyvr1uz" }, defaultClass: "fyvr1uw" }, "4": { conditions: { sm: "fyvr1v0", md: "fyvr1v1", lg: "fyvr1v2", xl: "fyvr1v3" }, defaultClass: "fyvr1v0" }, "5": { conditions: { sm: "fyvr1v4", md: "fyvr1v5", lg: "fyvr1v6", xl: "fyvr1v7" }, defaultClass: "fyvr1v4" }, "6": { conditions: { sm: "fyvr1v8", md: "fyvr1v9", lg: "fyvr1va", xl: "fyvr1vb" }, defaultClass: "fyvr1v8" }, "7": { conditions: { sm: "fyvr1vc", md: "fyvr1vd", lg: "fyvr1ve", xl: "fyvr1vf" }, defaultClass: "fyvr1vc" }, "8": { conditions: { sm: "fyvr1vg", md: "fyvr1vh", lg: "fyvr1vi", xl: "fyvr1vj" }, defaultClass: "fyvr1vg" }, "9": { conditions: { sm: "fyvr1vk", md: "fyvr1vl", lg: "fyvr1vm", xl: "fyvr1vn" }, defaultClass: "fyvr1vk" }, "10": { conditions: { sm: "fyvr1vo", md: "fyvr1vp", lg: "fyvr1vq", xl: "fyvr1vr" }, defaultClass: "fyvr1vo" }, "12": { conditions: { sm: "fyvr1vs", md: "fyvr1vt", lg: "fyvr1vu", xl: "fyvr1vv" }, defaultClass: "fyvr1vs" }, "14": { conditions: { sm: "fyvr1vw", md: "fyvr1vx", lg: "fyvr1vy", xl: "fyvr1vz" }, defaultClass: "fyvr1vw" }, "16": { conditions: { sm: "fyvr1w0", md: "fyvr1w1", lg: "fyvr1w2", xl: "fyvr1w3" }, defaultClass: "fyvr1w0" }, "0.25": { conditions: { sm: "fyvr1w4", md: "fyvr1w5", lg: "fyvr1w6", xl: "fyvr1w7" }, defaultClass: "fyvr1w4" }, "0.5": { conditions: { sm: "fyvr1w8", md: "fyvr1w9", lg: "fyvr1wa", xl: "fyvr1wb" }, defaultClass: "fyvr1w8" }, "1.5": { conditions: { sm: "fyvr1wc", md: "fyvr1wd", lg: "fyvr1we", xl: "fyvr1wf" }, defaultClass: "fyvr1wc" } } }, paddingLeft: { values: { "0": { conditions: { sm: "fyvr1wg", md: "fyvr1wh", lg: "fyvr1wi", xl: "fyvr1wj" }, defaultClass: "fyvr1wg" }, "1": { conditions: { sm: "fyvr1wk", md: "fyvr1wl", lg: "fyvr1wm", xl: "fyvr1wn" }, defaultClass: "fyvr1wk" }, "2": { conditions: { sm: "fyvr1wo", md: "fyvr1wp", lg: "fyvr1wq", xl: "fyvr1wr" }, defaultClass: "fyvr1wo" }, "3": { conditions: { sm: "fyvr1ws", md: "fyvr1wt", lg: "fyvr1wu", xl: "fyvr1wv" }, defaultClass: "fyvr1ws" }, "4": { conditions: { sm: "fyvr1ww", md: "fyvr1wx", lg: "fyvr1wy", xl: "fyvr1wz" }, defaultClass: "fyvr1ww" }, "5": { conditions: { sm: "fyvr1x0", md: "fyvr1x1", lg: "fyvr1x2", xl: "fyvr1x3" }, defaultClass: "fyvr1x0" }, "6": { conditions: { sm: "fyvr1x4", md: "fyvr1x5", lg: "fyvr1x6", xl: "fyvr1x7" }, defaultClass: "fyvr1x4" }, "7": { conditions: { sm: "fyvr1x8", md: "fyvr1x9", lg: "fyvr1xa", xl: "fyvr1xb" }, defaultClass: "fyvr1x8" }, "8": { conditions: { sm: "fyvr1xc", md: "fyvr1xd", lg: "fyvr1xe", xl: "fyvr1xf" }, defaultClass: "fyvr1xc" }, "9": { conditions: { sm: "fyvr1xg", md: "fyvr1xh", lg: "fyvr1xi", xl: "fyvr1xj" }, defaultClass: "fyvr1xg" }, "10": { conditions: { sm: "fyvr1xk", md: "fyvr1xl", lg: "fyvr1xm", xl: "fyvr1xn" }, defaultClass: "fyvr1xk" }, "12": { conditions: { sm: "fyvr1xo", md: "fyvr1xp", lg: "fyvr1xq", xl: "fyvr1xr" }, defaultClass: "fyvr1xo" }, "14": { conditions: { sm: "fyvr1xs", md: "fyvr1xt", lg: "fyvr1xu", xl: "fyvr1xv" }, defaultClass: "fyvr1xs" }, "16": { conditions: { sm: "fyvr1xw", md: "fyvr1xx", lg: "fyvr1xy", xl: "fyvr1xz" }, defaultClass: "fyvr1xw" }, "0.25": { conditions: { sm: "fyvr1y0", md: "fyvr1y1", lg: "fyvr1y2", xl: "fyvr1y3" }, defaultClass: "fyvr1y0" }, "0.5": { conditions: { sm: "fyvr1y4", md: "fyvr1y5", lg: "fyvr1y6", xl: "fyvr1y7" }, defaultClass: "fyvr1y4" }, "1.5": { conditions: { sm: "fyvr1y8", md: "fyvr1y9", lg: "fyvr1ya", xl: "fyvr1yb" }, defaultClass: "fyvr1y8" } } }, paddingRight: { values: { "0": { conditions: { sm: "fyvr1yc", md: "fyvr1yd", lg: "fyvr1ye", xl: "fyvr1yf" }, defaultClass: "fyvr1yc" }, "1": { conditions: { sm: "fyvr1yg", md: "fyvr1yh", lg: "fyvr1yi", xl: "fyvr1yj" }, defaultClass: "fyvr1yg" }, "2": { conditions: { sm: "fyvr1yk", md: "fyvr1yl", lg: "fyvr1ym", xl: "fyvr1yn" }, defaultClass: "fyvr1yk" }, "3": { conditions: { sm: "fyvr1yo", md: "fyvr1yp", lg: "fyvr1yq", xl: "fyvr1yr" }, defaultClass: "fyvr1yo" }, "4": { conditions: { sm: "fyvr1ys", md: "fyvr1yt", lg: "fyvr1yu", xl: "fyvr1yv" }, defaultClass: "fyvr1ys" }, "5": { conditions: { sm: "fyvr1yw", md: "fyvr1yx", lg: "fyvr1yy", xl: "fyvr1yz" }, defaultClass: "fyvr1yw" }, "6": { conditions: { sm: "fyvr1z0", md: "fyvr1z1", lg: "fyvr1z2", xl: "fyvr1z3" }, defaultClass: "fyvr1z0" }, "7": { conditions: { sm: "fyvr1z4", md: "fyvr1z5", lg: "fyvr1z6", xl: "fyvr1z7" }, defaultClass: "fyvr1z4" }, "8": { conditions: { sm: "fyvr1z8", md: "fyvr1z9", lg: "fyvr1za", xl: "fyvr1zb" }, defaultClass: "fyvr1z8" }, "9": { conditions: { sm: "fyvr1zc", md: "fyvr1zd", lg: "fyvr1ze", xl: "fyvr1zf" }, defaultClass: "fyvr1zc" }, "10": { conditions: { sm: "fyvr1zg", md: "fyvr1zh", lg: "fyvr1zi", xl: "fyvr1zj" }, defaultClass: "fyvr1zg" }, "12": { conditions: { sm: "fyvr1zk", md: "fyvr1zl", lg: "fyvr1zm", xl: "fyvr1zn" }, defaultClass: "fyvr1zk" }, "14": { conditions: { sm: "fyvr1zo", md: "fyvr1zp", lg: "fyvr1zq", xl: "fyvr1zr" }, defaultClass: "fyvr1zo" }, "16": { conditions: { sm: "fyvr1zs", md: "fyvr1zt", lg: "fyvr1zu", xl: "fyvr1zv" }, defaultClass: "fyvr1zs" }, "0.25": { conditions: { sm: "fyvr1zw", md: "fyvr1zx", lg: "fyvr1zy", xl: "fyvr1zz" }, defaultClass: "fyvr1zw" }, "0.5": { conditions: { sm: "fyvr1100", md: "fyvr1101", lg: "fyvr1102", xl: "fyvr1103" }, defaultClass: "fyvr1100" }, "1.5": { conditions: { sm: "fyvr1104", md: "fyvr1105", lg: "fyvr1106", xl: "fyvr1107" }, defaultClass: "fyvr1104" } } }, marginTop: { values: { "0": { conditions: { sm: "fyvr1108", md: "fyvr1109", lg: "fyvr110a", xl: "fyvr110b" }, defaultClass: "fyvr1108" }, "1": { conditions: { sm: "fyvr110c", md: "fyvr110d", lg: "fyvr110e", xl: "fyvr110f" }, defaultClass: "fyvr110c" }, "2": { conditions: { sm: "fyvr110g", md: "fyvr110h", lg: "fyvr110i", xl: "fyvr110j" }, defaultClass: "fyvr110g" }, "3": { conditions: { sm: "fyvr110k", md: "fyvr110l", lg: "fyvr110m", xl: "fyvr110n" }, defaultClass: "fyvr110k" }, "4": { conditions: { sm: "fyvr110o", md: "fyvr110p", lg: "fyvr110q", xl: "fyvr110r" }, defaultClass: "fyvr110o" }, "5": { conditions: { sm: "fyvr110s", md: "fyvr110t", lg: "fyvr110u", xl: "fyvr110v" }, defaultClass: "fyvr110s" }, "6": { conditions: { sm: "fyvr110w", md: "fyvr110x", lg: "fyvr110y", xl: "fyvr110z" }, defaultClass: "fyvr110w" }, "7": { conditions: { sm: "fyvr1110", md: "fyvr1111", lg: "fyvr1112", xl: "fyvr1113" }, defaultClass: "fyvr1110" }, "8": { conditions: { sm: "fyvr1114", md: "fyvr1115", lg: "fyvr1116", xl: "fyvr1117" }, defaultClass: "fyvr1114" }, "9": { conditions: { sm: "fyvr1118", md: "fyvr1119", lg: "fyvr111a", xl: "fyvr111b" }, defaultClass: "fyvr1118" }, "10": { conditions: { sm: "fyvr111c", md: "fyvr111d", lg: "fyvr111e", xl: "fyvr111f" }, defaultClass: "fyvr111c" }, "12": { conditions: { sm: "fyvr111g", md: "fyvr111h", lg: "fyvr111i", xl: "fyvr111j" }, defaultClass: "fyvr111g" }, "14": { conditions: { sm: "fyvr111k", md: "fyvr111l", lg: "fyvr111m", xl: "fyvr111n" }, defaultClass: "fyvr111k" }, "16": { conditions: { sm: "fyvr111o", md: "fyvr111p", lg: "fyvr111q", xl: "fyvr111r" }, defaultClass: "fyvr111o" }, "0.25": { conditions: { sm: "fyvr111s", md: "fyvr111t", lg: "fyvr111u", xl: "fyvr111v" }, defaultClass: "fyvr111s" }, "0.5": { conditions: { sm: "fyvr111w", md: "fyvr111x", lg: "fyvr111y", xl: "fyvr111z" }, defaultClass: "fyvr111w" }, "1.5": { conditions: { sm: "fyvr1120", md: "fyvr1121", lg: "fyvr1122", xl: "fyvr1123" }, defaultClass: "fyvr1120" }, auto: { conditions: { sm: "fyvr1124", md: "fyvr1125", lg: "fyvr1126", xl: "fyvr1127" }, defaultClass: "fyvr1124" } } }, marginBottom: { values: { "0": { conditions: { sm: "fyvr1128", md: "fyvr1129", lg: "fyvr112a", xl: "fyvr112b" }, defaultClass: "fyvr1128" }, "1": { conditions: { sm: "fyvr112c", md: "fyvr112d", lg: "fyvr112e", xl: "fyvr112f" }, defaultClass: "fyvr112c" }, "2": { conditions: { sm: "fyvr112g", md: "fyvr112h", lg: "fyvr112i", xl: "fyvr112j" }, defaultClass: "fyvr112g" }, "3": { conditions: { sm: "fyvr112k", md: "fyvr112l", lg: "fyvr112m", xl: "fyvr112n" }, defaultClass: "fyvr112k" }, "4": { conditions: { sm: "fyvr112o", md: "fyvr112p", lg: "fyvr112q", xl: "fyvr112r" }, defaultClass: "fyvr112o" }, "5": { conditions: { sm: "fyvr112s", md: "fyvr112t", lg: "fyvr112u", xl: "fyvr112v" }, defaultClass: "fyvr112s" }, "6": { conditions: { sm: "fyvr112w", md: "fyvr112x", lg: "fyvr112y", xl: "fyvr112z" }, defaultClass: "fyvr112w" }, "7": { conditions: { sm: "fyvr1130", md: "fyvr1131", lg: "fyvr1132", xl: "fyvr1133" }, defaultClass: "fyvr1130" }, "8": { conditions: { sm: "fyvr1134", md: "fyvr1135", lg: "fyvr1136", xl: "fyvr1137" }, defaultClass: "fyvr1134" }, "9": { conditions: { sm: "fyvr1138", md: "fyvr1139", lg: "fyvr113a", xl: "fyvr113b" }, defaultClass: "fyvr1138" }, "10": { conditions: { sm: "fyvr113c", md: "fyvr113d", lg: "fyvr113e", xl: "fyvr113f" }, defaultClass: "fyvr113c" }, "12": { conditions: { sm: "fyvr113g", md: "fyvr113h", lg: "fyvr113i", xl: "fyvr113j" }, defaultClass: "fyvr113g" }, "14": { conditions: { sm: "fyvr113k", md: "fyvr113l", lg: "fyvr113m", xl: "fyvr113n" }, defaultClass: "fyvr113k" }, "16": { conditions: { sm: "fyvr113o", md: "fyvr113p", lg: "fyvr113q", xl: "fyvr113r" }, defaultClass: "fyvr113o" }, "0.25": { conditions: { sm: "fyvr113s", md: "fyvr113t", lg: "fyvr113u", xl: "fyvr113v" }, defaultClass: "fyvr113s" }, "0.5": { conditions: { sm: "fyvr113w", md: "fyvr113x", lg: "fyvr113y", xl: "fyvr113z" }, defaultClass: "fyvr113w" }, "1.5": { conditions: { sm: "fyvr1140", md: "fyvr1141", lg: "fyvr1142", xl: "fyvr1143" }, defaultClass: "fyvr1140" }, auto: { conditions: { sm: "fyvr1144", md: "fyvr1145", lg: "fyvr1146", xl: "fyvr1147" }, defaultClass: "fyvr1144" } } }, marginLeft: { values: { "0": { conditions: { sm: "fyvr1148", md: "fyvr1149", lg: "fyvr114a", xl: "fyvr114b" }, defaultClass: "fyvr1148" }, "1": { conditions: { sm: "fyvr114c", md: "fyvr114d", lg: "fyvr114e", xl: "fyvr114f" }, defaultClass: "fyvr114c" }, "2": { conditions: { sm: "fyvr114g", md: "fyvr114h", lg: "fyvr114i", xl: "fyvr114j" }, defaultClass: "fyvr114g" }, "3": { conditions: { sm: "fyvr114k", md: "fyvr114l", lg: "fyvr114m", xl: "fyvr114n" }, defaultClass: "fyvr114k" }, "4": { conditions: { sm: "fyvr114o", md: "fyvr114p", lg: "fyvr114q", xl: "fyvr114r" }, defaultClass: "fyvr114o" }, "5": { conditions: { sm: "fyvr114s", md: "fyvr114t", lg: "fyvr114u", xl: "fyvr114v" }, defaultClass: "fyvr114s" }, "6": { conditions: { sm: "fyvr114w", md: "fyvr114x", lg: "fyvr114y", xl: "fyvr114z" }, defaultClass: "fyvr114w" }, "7": { conditions: { sm: "fyvr1150", md: "fyvr1151", lg: "fyvr1152", xl: "fyvr1153" }, defaultClass: "fyvr1150" }, "8": { conditions: { sm: "fyvr1154", md: "fyvr1155", lg: "fyvr1156", xl: "fyvr1157" }, defaultClass: "fyvr1154" }, "9": { conditions: { sm: "fyvr1158", md: "fyvr1159", lg: "fyvr115a", xl: "fyvr115b" }, defaultClass: "fyvr1158" }, "10": { conditions: { sm: "fyvr115c", md: "fyvr115d", lg: "fyvr115e", xl: "fyvr115f" }, defaultClass: "fyvr115c" }, "12": { conditions: { sm: "fyvr115g", md: "fyvr115h", lg: "fyvr115i", xl: "fyvr115j" }, defaultClass: "fyvr115g" }, "14": { conditions: { sm: "fyvr115k", md: "fyvr115l", lg: "fyvr115m", xl: "fyvr115n" }, defaultClass: "fyvr115k" }, "16": { conditions: { sm: "fyvr115o", md: "fyvr115p", lg: "fyvr115q", xl: "fyvr115r" }, defaultClass: "fyvr115o" }, "0.25": { conditions: { sm: "fyvr115s", md: "fyvr115t", lg: "fyvr115u", xl: "fyvr115v" }, defaultClass: "fyvr115s" }, "0.5": { conditions: { sm: "fyvr115w", md: "fyvr115x", lg: "fyvr115y", xl: "fyvr115z" }, defaultClass: "fyvr115w" }, "1.5": { conditions: { sm: "fyvr1160", md: "fyvr1161", lg: "fyvr1162", xl: "fyvr1163" }, defaultClass: "fyvr1160" }, auto: { conditions: { sm: "fyvr1164", md: "fyvr1165", lg: "fyvr1166", xl: "fyvr1167" }, defaultClass: "fyvr1164" } } }, marginRight: { values: { "0": { conditions: { sm: "fyvr1168", md: "fyvr1169", lg: "fyvr116a", xl: "fyvr116b" }, defaultClass: "fyvr1168" }, "1": { conditions: { sm: "fyvr116c", md: "fyvr116d", lg: "fyvr116e", xl: "fyvr116f" }, defaultClass: "fyvr116c" }, "2": { conditions: { sm: "fyvr116g", md: "fyvr116h", lg: "fyvr116i", xl: "fyvr116j" }, defaultClass: "fyvr116g" }, "3": { conditions: { sm: "fyvr116k", md: "fyvr116l", lg: "fyvr116m", xl: "fyvr116n" }, defaultClass: "fyvr116k" }, "4": { conditions: { sm: "fyvr116o", md: "fyvr116p", lg: "fyvr116q", xl: "fyvr116r" }, defaultClass: "fyvr116o" }, "5": { conditions: { sm: "fyvr116s", md: "fyvr116t", lg: "fyvr116u", xl: "fyvr116v" }, defaultClass: "fyvr116s" }, "6": { conditions: { sm: "fyvr116w", md: "fyvr116x", lg: "fyvr116y", xl: "fyvr116z" }, defaultClass: "fyvr116w" }, "7": { conditions: { sm: "fyvr1170", md: "fyvr1171", lg: "fyvr1172", xl: "fyvr1173" }, defaultClass: "fyvr1170" }, "8": { conditions: { sm: "fyvr1174", md: "fyvr1175", lg: "fyvr1176", xl: "fyvr1177" }, defaultClass: "fyvr1174" }, "9": { conditions: { sm: "fyvr1178", md: "fyvr1179", lg: "fyvr117a", xl: "fyvr117b" }, defaultClass: "fyvr1178" }, "10": { conditions: { sm: "fyvr117c", md: "fyvr117d", lg: "fyvr117e", xl: "fyvr117f" }, defaultClass: "fyvr117c" }, "12": { conditions: { sm: "fyvr117g", md: "fyvr117h", lg: "fyvr117i", xl: "fyvr117j" }, defaultClass: "fyvr117g" }, "14": { conditions: { sm: "fyvr117k", md: "fyvr117l", lg: "fyvr117m", xl: "fyvr117n" }, defaultClass: "fyvr117k" }, "16": { conditions: { sm: "fyvr117o", md: "fyvr117p", lg: "fyvr117q", xl: "fyvr117r" }, defaultClass: "fyvr117o" }, "0.25": { conditions: { sm: "fyvr117s", md: "fyvr117t", lg: "fyvr117u", xl: "fyvr117v" }, defaultClass: "fyvr117s" }, "0.5": { conditions: { sm: "fyvr117w", md: "fyvr117x", lg: "fyvr117y", xl: "fyvr117z" }, defaultClass: "fyvr117w" }, "1.5": { conditions: { sm: "fyvr1180", md: "fyvr1181", lg: "fyvr1182", xl: "fyvr1183" }, defaultClass: "fyvr1180" }, auto: { conditions: { sm: "fyvr1184", md: "fyvr1185", lg: "fyvr1186", xl: "fyvr1187" }, defaultClass: "fyvr1184" } } }, gap: { values: { "0": { conditions: { sm: "fyvr1188", md: "fyvr1189", lg: "fyvr118a", xl: "fyvr118b" }, defaultClass: "fyvr1188" }, "1": { conditions: { sm: "fyvr118c", md: "fyvr118d", lg: "fyvr118e", xl: "fyvr118f" }, defaultClass: "fyvr118c" }, "2": { conditions: { sm: "fyvr118g", md: "fyvr118h", lg: "fyvr118i", xl: "fyvr118j" }, defaultClass: "fyvr118g" }, "3": { conditions: { sm: "fyvr118k", md: "fyvr118l", lg: "fyvr118m", xl: "fyvr118n" }, defaultClass: "fyvr118k" }, "4": { conditions: { sm: "fyvr118o", md: "fyvr118p", lg: "fyvr118q", xl: "fyvr118r" }, defaultClass: "fyvr118o" }, "5": { conditions: { sm: "fyvr118s", md: "fyvr118t", lg: "fyvr118u", xl: "fyvr118v" }, defaultClass: "fyvr118s" }, "6": { conditions: { sm: "fyvr118w", md: "fyvr118x", lg: "fyvr118y", xl: "fyvr118z" }, defaultClass: "fyvr118w" }, "7": { conditions: { sm: "fyvr1190", md: "fyvr1191", lg: "fyvr1192", xl: "fyvr1193" }, defaultClass: "fyvr1190" }, "8": { conditions: { sm: "fyvr1194", md: "fyvr1195", lg: "fyvr1196", xl: "fyvr1197" }, defaultClass: "fyvr1194" }, "9": { conditions: { sm: "fyvr1198", md: "fyvr1199", lg: "fyvr119a", xl: "fyvr119b" }, defaultClass: "fyvr1198" }, "10": { conditions: { sm: "fyvr119c", md: "fyvr119d", lg: "fyvr119e", xl: "fyvr119f" }, defaultClass: "fyvr119c" }, "12": { conditions: { sm: "fyvr119g", md: "fyvr119h", lg: "fyvr119i", xl: "fyvr119j" }, defaultClass: "fyvr119g" }, "14": { conditions: { sm: "fyvr119k", md: "fyvr119l", lg: "fyvr119m", xl: "fyvr119n" }, defaultClass: "fyvr119k" }, "16": { conditions: { sm: "fyvr119o", md: "fyvr119p", lg: "fyvr119q", xl: "fyvr119r" }, defaultClass: "fyvr119o" }, "0.25": { conditions: { sm: "fyvr119s", md: "fyvr119t", lg: "fyvr119u", xl: "fyvr119v" }, defaultClass: "fyvr119s" }, "0.5": { conditions: { sm: "fyvr119w", md: "fyvr119x", lg: "fyvr119y", xl: "fyvr119z" }, defaultClass: "fyvr119w" }, "1.5": { conditions: { sm: "fyvr11a0", md: "fyvr11a1", lg: "fyvr11a2", xl: "fyvr11a3" }, defaultClass: "fyvr11a0" } } }, borderBottomWidth: { values: { none: { conditions: { sm: "fyvr11a4", md: "fyvr11a5", lg: "fyvr11a6", xl: "fyvr11a7" }, defaultClass: "fyvr11a4" }, thin: { conditions: { sm: "fyvr11a8", md: "fyvr11a9", lg: "fyvr11aa", xl: "fyvr11ab" }, defaultClass: "fyvr11a8" }, thick: { conditions: { sm: "fyvr11ac", md: "fyvr11ad", lg: "fyvr11ae", xl: "fyvr11af" }, defaultClass: "fyvr11ac" } } }, borderLeftWidth: { values: { none: { conditions: { sm: "fyvr11ag", md: "fyvr11ah", lg: "fyvr11ai", xl: "fyvr11aj" }, defaultClass: "fyvr11ag" }, thin: { conditions: { sm: "fyvr11ak", md: "fyvr11al", lg: "fyvr11am", xl: "fyvr11an" }, defaultClass: "fyvr11ak" }, thick: { conditions: { sm: "fyvr11ao", md: "fyvr11ap", lg: "fyvr11aq", xl: "fyvr11ar" }, defaultClass: "fyvr11ao" } } }, borderRightWidth: { values: { none: { conditions: { sm: "fyvr11as", md: "fyvr11at", lg: "fyvr11au", xl: "fyvr11av" }, defaultClass: "fyvr11as" }, thin: { conditions: { sm: "fyvr11aw", md: "fyvr11ax", lg: "fyvr11ay", xl: "fyvr11az" }, defaultClass: "fyvr11aw" }, thick: { conditions: { sm: "fyvr11b0", md: "fyvr11b1", lg: "fyvr11b2", xl: "fyvr11b3" }, defaultClass: "fyvr11b0" } } }, borderTopWidth: { values: { none: { conditions: { sm: "fyvr11b4", md: "fyvr11b5", lg: "fyvr11b6", xl: "fyvr11b7" }, defaultClass: "fyvr11b4" }, thin: { conditions: { sm: "fyvr11b8", md: "fyvr11b9", lg: "fyvr11ba", xl: "fyvr11bb" }, defaultClass: "fyvr11b8" }, thick: { conditions: { sm: "fyvr11bc", md: "fyvr11bd", lg: "fyvr11be", xl: "fyvr11bf" }, defaultClass: "fyvr11bc" } } }, borderBottomLeftRadius: { values: { none: { conditions: { sm: "fyvr11bg", md: "fyvr11bh", lg: "fyvr11bi", xl: "fyvr11bj" }, defaultClass: "fyvr11bg" }, xs: { conditions: { sm: "fyvr11bk", md: "fyvr11bl", lg: "fyvr11bm", xl: "fyvr11bn" }, defaultClass: "fyvr11bk" }, sm: { conditions: { sm: "fyvr11bo", md: "fyvr11bp", lg: "fyvr11bq", xl: "fyvr11br" }, defaultClass: "fyvr11bo" }, md: { conditions: { sm: "fyvr11bs", md: "fyvr11bt", lg: "fyvr11bu", xl: "fyvr11bv" }, defaultClass: "fyvr11bs" }, lg: { conditions: { sm: "fyvr11bw", md: "fyvr11bx", lg: "fyvr11by", xl: "fyvr11bz" }, defaultClass: "fyvr11bw" }, circle: { conditions: { sm: "fyvr11c0", md: "fyvr11c1", lg: "fyvr11c2", xl: "fyvr11c3" }, defaultClass: "fyvr11c0" } } }, borderBottomRightRadius: { values: { none: { conditions: { sm: "fyvr11c4", md: "fyvr11c5", lg: "fyvr11c6", xl: "fyvr11c7" }, defaultClass: "fyvr11c4" }, xs: { conditions: { sm: "fyvr11c8", md: "fyvr11c9", lg: "fyvr11ca", xl: "fyvr11cb" }, defaultClass: "fyvr11c8" }, sm: { conditions: { sm: "fyvr11cc", md: "fyvr11cd", lg: "fyvr11ce", xl: "fyvr11cf" }, defaultClass: "fyvr11cc" }, md: { conditions: { sm: "fyvr11cg", md: "fyvr11ch", lg: "fyvr11ci", xl: "fyvr11cj" }, defaultClass: "fyvr11cg" }, lg: { conditions: { sm: "fyvr11ck", md: "fyvr11cl", lg: "fyvr11cm", xl: "fyvr11cn" }, defaultClass: "fyvr11ck" }, circle: { conditions: { sm: "fyvr11co", md: "fyvr11cp", lg: "fyvr11cq", xl: "fyvr11cr" }, defaultClass: "fyvr11co" } } }, borderTopLeftRadius: { values: { none: { conditions: { sm: "fyvr11cs", md: "fyvr11ct", lg: "fyvr11cu", xl: "fyvr11cv" }, defaultClass: "fyvr11cs" }, xs: { conditions: { sm: "fyvr11cw", md: "fyvr11cx", lg: "fyvr11cy", xl: "fyvr11cz" }, defaultClass: "fyvr11cw" }, sm: { conditions: { sm: "fyvr11d0", md: "fyvr11d1", lg: "fyvr11d2", xl: "fyvr11d3" }, defaultClass: "fyvr11d0" }, md: { conditions: { sm: "fyvr11d4", md: "fyvr11d5", lg: "fyvr11d6", xl: "fyvr11d7" }, defaultClass: "fyvr11d4" }, lg: { conditions: { sm: "fyvr11d8", md: "fyvr11d9", lg: "fyvr11da", xl: "fyvr11db" }, defaultClass: "fyvr11d8" }, circle: { conditions: { sm: "fyvr11dc", md: "fyvr11dd", lg: "fyvr11de", xl: "fyvr11df" }, defaultClass: "fyvr11dc" } } }, borderTopRightRadius: { values: { none: { conditions: { sm: "fyvr11dg", md: "fyvr11dh", lg: "fyvr11di", xl: "fyvr11dj" }, defaultClass: "fyvr11dg" }, xs: { conditions: { sm: "fyvr11dk", md: "fyvr11dl", lg: "fyvr11dm", xl: "fyvr11dn" }, defaultClass: "fyvr11dk" }, sm: { conditions: { sm: "fyvr11do", md: "fyvr11dp", lg: "fyvr11dq", xl: "fyvr11dr" }, defaultClass: "fyvr11do" }, md: { conditions: { sm: "fyvr11ds", md: "fyvr11dt", lg: "fyvr11du", xl: "fyvr11dv" }, defaultClass: "fyvr11ds" }, lg: { conditions: { sm: "fyvr11dw", md: "fyvr11dx", lg: "fyvr11dy", xl: "fyvr11dz" }, defaultClass: "fyvr11dw" }, circle: { conditions: { sm: "fyvr11e0", md: "fyvr11e1", lg: "fyvr11e2", xl: "fyvr11e3" }, defaultClass: "fyvr11e0" } } }, fontSize: { values: { inherit: { conditions: { sm: "fyvr11e4", md: "fyvr11e5", lg: "fyvr11e6", xl: "fyvr11e7" }, defaultClass: "fyvr11e4" }, xsmall: { conditions: { sm: "fyvr11e8", md: "fyvr11e9", lg: "fyvr11ea", xl: "fyvr11eb" }, defaultClass: "fyvr11e8" }, small: { conditions: { sm: "fyvr11ec", md: "fyvr11ed", lg: "fyvr11ee", xl: "fyvr11ef" }, defaultClass: "fyvr11ec" }, normal: { conditions: { sm: "fyvr11eg", md: "fyvr11eh", lg: "fyvr11ei", xl: "fyvr11ej" }, defaultClass: "fyvr11eg" }, medium: { conditions: { sm: "fyvr11ek", md: "fyvr11el", lg: "fyvr11em", xl: "fyvr11en" }, defaultClass: "fyvr11ek" }, large: { conditions: { sm: "fyvr11eo", md: "fyvr11ep", lg: "fyvr11eq", xl: "fyvr11er" }, defaultClass: "fyvr11eo" }, xlarge: { conditions: { sm: "fyvr11es", md: "fyvr11et", lg: "fyvr11eu", xl: "fyvr11ev" }, defaultClass: "fyvr11es" } } }, fontWeight: { values: { inherit: { conditions: { sm: "fyvr11ew", md: "fyvr11ex", lg: "fyvr11ey", xl: "fyvr11ez" }, defaultClass: "fyvr11ew" }, normal: { conditions: { sm: "fyvr11f0", md: "fyvr11f1", lg: "fyvr11f2", xl: "fyvr11f3" }, defaultClass: "fyvr11f0" }, medium: { conditions: { sm: "fyvr11f4", md: "fyvr11f5", lg: "fyvr11f6", xl: "fyvr11f7" }, defaultClass: "fyvr11f4" }, semibold: { conditions: { sm: "fyvr11f8", md: "fyvr11f9", lg: "fyvr11fa", xl: "fyvr11fb" }, defaultClass: "fyvr11f8" }, bold: { conditions: { sm: "fyvr11fc", md: "fyvr11fd", lg: "fyvr11fe", xl: "fyvr11ff" }, defaultClass: "fyvr11fc" } } }, letterSpacing: { values: { inherit: { conditions: { sm: "fyvr11fg", md: "fyvr11fh", lg: "fyvr11fi", xl: "fyvr11fj" }, defaultClass: "fyvr11fg" }, none: { conditions: { sm: "fyvr11fk", md: "fyvr11fl", lg: "fyvr11fm", xl: "fyvr11fn" }, defaultClass: "fyvr11fk" }, normal: { conditions: { sm: "fyvr11fo", md: "fyvr11fp", lg: "fyvr11fq", xl: "fyvr11fr" }, defaultClass: "fyvr11fo" }, wide: { conditions: { sm: "fyvr11fs", md: "fyvr11ft", lg: "fyvr11fu", xl: "fyvr11fv" }, defaultClass: "fyvr11fs" } } }, lineHeight: { values: { "4": { conditions: { sm: "fyvr11fw", md: "fyvr11fx", lg: "fyvr11fy", xl: "fyvr11fz" }, defaultClass: "fyvr11fw" }, "5": { conditions: { sm: "fyvr11g0", md: "fyvr11g1", lg: "fyvr11g2", xl: "fyvr11g3" }, defaultClass: "fyvr11g0" }, "6": { conditions: { sm: "fyvr11g4", md: "fyvr11g5", lg: "fyvr11g6", xl: "fyvr11g7" }, defaultClass: "fyvr11g4" }, "7": { conditions: { sm: "fyvr11g8", md: "fyvr11g9", lg: "fyvr11ga", xl: "fyvr11gb" }, defaultClass: "fyvr11g8" }, "9": { conditions: { sm: "fyvr11gc", md: "fyvr11gd", lg: "fyvr11ge", xl: "fyvr11gf" }, defaultClass: "fyvr11gc" }, inherit: { conditions: { sm: "fyvr11gg", md: "fyvr11gh", lg: "fyvr11gi", xl: "fyvr11gj" }, defaultClass: "fyvr11gg" } } }, textAlign: { values: { center: { conditions: { sm: "fyvr11gk", md: "fyvr11gl", lg: "fyvr11gm", xl: "fyvr11gn" }, defaultClass: "fyvr11gk" }, left: { conditions: { sm: "fyvr11go", md: "fyvr11gp", lg: "fyvr11gq", xl: "fyvr11gr" }, defaultClass: "fyvr11go" }, right: { conditions: { sm: "fyvr11gs", md: "fyvr11gt", lg: "fyvr11gu", xl: "fyvr11gv" }, defaultClass: "fyvr11gs" } } }, display: { values: { block: { conditions: { sm: "fyvr11gw", md: "fyvr11gx", lg: "fyvr11gy", xl: "fyvr11gz" }, defaultClass: "fyvr11gw" }, flex: { conditions: { sm: "fyvr11h0", md: "fyvr11h1", lg: "fyvr11h2", xl: "fyvr11h3" }, defaultClass: "fyvr11h0" }, grid: { conditions: { sm: "fyvr11h4", md: "fyvr11h5", lg: "fyvr11h6", xl: "fyvr11h7" }, defaultClass: "fyvr11h4" }, "inline-block": { conditions: { sm: "fyvr11h8", md: "fyvr11h9", lg: "fyvr11ha", xl: "fyvr11hb" }, defaultClass: "fyvr11h8" }, "inline-flex": { conditions: { sm: "fyvr11hc", md: "fyvr11hd", lg: "fyvr11he", xl: "fyvr11hf" }, defaultClass: "fyvr11hc" }, none: { conditions: { sm: "fyvr11hg", md: "fyvr11hh", lg: "fyvr11hi", xl: "fyvr11hj" }, defaultClass: "fyvr11hg" }, contents: { conditions: { sm: "fyvr11hk", md: "fyvr11hl", lg: "fyvr11hm", xl: "fyvr11hn" }, defaultClass: "fyvr11hk" } } }, position: { values: { absolute: { conditions: { sm: "fyvr11ho", md: "fyvr11hp", lg: "fyvr11hq", xl: "fyvr11hr" }, defaultClass: "fyvr11ho" }, fixed: { conditions: { sm: "fyvr11hs", md: "fyvr11ht", lg: "fyvr11hu", xl: "fyvr11hv" }, defaultClass: "fyvr11hs" }, relative: { conditions: { sm: "fyvr11hw", md: "fyvr11hx", lg: "fyvr11hy", xl: "fyvr11hz" }, defaultClass: "fyvr11hw" }, sticky: { conditions: { sm: "fyvr11i0", md: "fyvr11i1", lg: "fyvr11i2", xl: "fyvr11i3" }, defaultClass: "fyvr11i0" } } }, flexDirection: { values: { column: { conditions: { sm: "fyvr11i4", md: "fyvr11i5", lg: "fyvr11i6", xl: "fyvr11i7" }, defaultClass: "fyvr11i4" }, "column-reverse": { conditions: { sm: "fyvr11i8", md: "fyvr11i9", lg: "fyvr11ia", xl: "fyvr11ib" }, defaultClass: "fyvr11i8" }, row: { conditions: { sm: "fyvr11ic", md: "fyvr11id", lg: "fyvr11ie", xl: "fyvr11if" }, defaultClass: "fyvr11ic" }, "row-reverse": { conditions: { sm: "fyvr11ig", md: "fyvr11ih", lg: "fyvr11ii", xl: "fyvr11ij" }, defaultClass: "fyvr11ig" } } }, flexShrink: { values: { "0": { conditions: { sm: "fyvr11ik", md: "fyvr11il", lg: "fyvr11im", xl: "fyvr11in" }, defaultClass: "fyvr11ik" }, "1": { conditions: { sm: "fyvr11io", md: "fyvr11ip", lg: "fyvr11iq", xl: "fyvr11ir" }, defaultClass: "fyvr11io" } } }, flexGrow: { values: { "0": { conditions: { sm: "fyvr11is", md: "fyvr11it", lg: "fyvr11iu", xl: "fyvr11iv" }, defaultClass: "fyvr11is" }, "1": { conditions: { sm: "fyvr11iw", md: "fyvr11ix", lg: "fyvr11iy", xl: "fyvr11iz" }, defaultClass: "fyvr11iw" } } }, flexWrap: { values: { nowrap: { conditions: { sm: "fyvr11j0", md: "fyvr11j1", lg: "fyvr11j2", xl: "fyvr11j3" }, defaultClass: "fyvr11j0" }, wrap: { conditions: { sm: "fyvr11j4", md: "fyvr11j5", lg: "fyvr11j6", xl: "fyvr11j7" }, defaultClass: "fyvr11j4" }, "wrap-reverse": { conditions: { sm: "fyvr11j8", md: "fyvr11j9", lg: "fyvr11ja", xl: "fyvr11jb" }, defaultClass: "fyvr11j8" } } }, justifyContent: { values: { "flex-start": { conditions: { sm: "fyvr11jc", md: "fyvr11jd", lg: "fyvr11je", xl: "fyvr11jf" }, defaultClass: "fyvr11jc" }, center: { conditions: { sm: "fyvr11jg", md: "fyvr11jh", lg: "fyvr11ji", xl: "fyvr11jj" }, defaultClass: "fyvr11jg" }, "flex-end": { conditions: { sm: "fyvr11jk", md: "fyvr11jl", lg: "fyvr11jm", xl: "fyvr11jn" }, defaultClass: "fyvr11jk" }, stretch: { conditions: { sm: "fyvr11jo", md: "fyvr11jp", lg: "fyvr11jq", xl: "fyvr11jr" }, defaultClass: "fyvr11jo" }, "space-around": { conditions: { sm: "fyvr11js", md: "fyvr11jt", lg: "fyvr11ju", xl: "fyvr11jv" }, defaultClass: "fyvr11js" }, "space-between": { conditions: { sm: "fyvr11jw", md: "fyvr11jx", lg: "fyvr11jy", xl: "fyvr11jz" }, defaultClass: "fyvr11jw" }, "space-evenly": { conditions: { sm: "fyvr11k0", md: "fyvr11k1", lg: "fyvr11k2", xl: "fyvr11k3" }, defaultClass: "fyvr11k0" } } }, justifySelf: { values: { "flex-start": { conditions: { sm: "fyvr11k4", md: "fyvr11k5", lg: "fyvr11k6", xl: "fyvr11k7" }, defaultClass: "fyvr11k4" }, center: { conditions: { sm: "fyvr11k8", md: "fyvr11k9", lg: "fyvr11ka", xl: "fyvr11kb" }, defaultClass: "fyvr11k8" }, "flex-end": { conditions: { sm: "fyvr11kc", md: "fyvr11kd", lg: "fyvr11ke", xl: "fyvr11kf" }, defaultClass: "fyvr11kc" }, stretch: { conditions: { sm: "fyvr11kg", md: "fyvr11kh", lg: "fyvr11ki", xl: "fyvr11kj" }, defaultClass: "fyvr11kg" } } }, alignItems: { values: { "flex-start": { conditions: { sm: "fyvr11kk", md: "fyvr11kl", lg: "fyvr11km", xl: "fyvr11kn" }, defaultClass: "fyvr11kk" }, center: { conditions: { sm: "fyvr11ko", md: "fyvr11kp", lg: "fyvr11kq", xl: "fyvr11kr" }, defaultClass: "fyvr11ko" }, "flex-end": { conditions: { sm: "fyvr11ks", md: "fyvr11kt", lg: "fyvr11ku", xl: "fyvr11kv" }, defaultClass: "fyvr11ks" }, stretch: { conditions: { sm: "fyvr11kw", md: "fyvr11kx", lg: "fyvr11ky", xl: "fyvr11kz" }, defaultClass: "fyvr11kw" }, baseline: { conditions: { sm: "fyvr11l0", md: "fyvr11l1", lg: "fyvr11l2", xl: "fyvr11l3" }, defaultClass: "fyvr11l0" } } }, alignSelf: { values: { "flex-start": { conditions: { sm: "fyvr11l4", md: "fyvr11l5", lg: "fyvr11l6", xl: "fyvr11l7" }, defaultClass: "fyvr11l4" }, center: { conditions: { sm: "fyvr11l8", md: "fyvr11l9", lg: "fyvr11la", xl: "fyvr11lb" }, defaultClass: "fyvr11l8" }, "flex-end": { conditions: { sm: "fyvr11lc", md: "fyvr11ld", lg: "fyvr11le", xl: "fyvr11lf" }, defaultClass: "fyvr11lc" }, stretch: { conditions: { sm: "fyvr11lg", md: "fyvr11lh", lg: "fyvr11li", xl: "fyvr11lj" }, defaultClass: "fyvr11lg" }, baseline: { conditions: { sm: "fyvr11lk", md: "fyvr11ll", lg: "fyvr11lm", xl: "fyvr11ln" }, defaultClass: "fyvr11lk" } } }, overflowX: { values: { auto: { conditions: { sm: "fyvr11lo", md: "fyvr11lp", lg: "fyvr11lq", xl: "fyvr11lr" }, defaultClass: "fyvr11lo" }, hidden: { conditions: { sm: "fyvr11ls", md: "fyvr11lt", lg: "fyvr11lu", xl: "fyvr11lv" }, defaultClass: "fyvr11ls" }, scroll: { conditions: { sm: "fyvr11lw", md: "fyvr11lx", lg: "fyvr11ly", xl: "fyvr11lz" }, defaultClass: "fyvr11lw" }, visible: { conditions: { sm: "fyvr11m0", md: "fyvr11m1", lg: "fyvr11m2", xl: "fyvr11m3" }, defaultClass: "fyvr11m0" } } }, overflowY: { values: { auto: { conditions: { sm: "fyvr11m4", md: "fyvr11m5", lg: "fyvr11m6", xl: "fyvr11m7" }, defaultClass: "fyvr11m4" }, hidden: { conditions: { sm: "fyvr11m8", md: "fyvr11m9", lg: "fyvr11ma", xl: "fyvr11mb" }, defaultClass: "fyvr11m8" }, scroll: { conditions: { sm: "fyvr11mc", md: "fyvr11md", lg: "fyvr11me", xl: "fyvr11mf" }, defaultClass: "fyvr11mc" }, visible: { conditions: { sm: "fyvr11mg", md: "fyvr11mh", lg: "fyvr11mi", xl: "fyvr11mj" }, defaultClass: "fyvr11mg" } } }, visibility: { values: { hidden: { conditions: { sm: "fyvr11mk", md: "fyvr11ml", lg: "fyvr11mm", xl: "fyvr11mn" }, defaultClass: "fyvr11mk" }, visible: { conditions: { sm: "fyvr11mo", md: "fyvr11mp", lg: "fyvr11mq", xl: "fyvr11mr" }, defaultClass: "fyvr11mo" } } } } }, { conditions: void 0, styles: { backdropFilter: { values: { blur: { defaultClass: "fyvr11ms" }, none: { defaultClass: "fyvr11mt" } } }, fontFamily: { values: { inherit: { defaultClass: "fyvr11mu" }, body: { defaultClass: "fyvr11mv" }, mono: { defaultClass: "fyvr11mw" } } }, textOverflow: { values: { ellipsis: { defaultClass: "fyvr11mx" }, clip: { defaultClass: "fyvr11my" } } }, textTransform: { values: { capitalize: { defaultClass: "fyvr11mz" }, lowercase: { defaultClass: "fyvr11n0" }, uppercase: { defaultClass: "fyvr11n1" } } }, textDecoration: { values: { none: { defaultClass: "fyvr11n2" }, underline: { defaultClass: "fyvr11n3" } } }, userSelect: { values: { none: { defaultClass: "fyvr11n4" }, text: { defaultClass: "fyvr11n5" }, all: { defaultClass: "fyvr11n6" }, auto: { defaultClass: "fyvr11n7" } } }, whiteSpace: { values: { normal: { defaultClass: "fyvr11n8" }, nowrap: { defaultClass: "fyvr11n9" }, initial: { defaultClass: "fyvr11na" }, inherit: { defaultClass: "fyvr11nb" } } }, wordBreak: { values: { "break-word": { defaultClass: "fyvr11nc" } } }, wordWrap: { values: { normal: { defaultClass: "fyvr11nd" }, "break-word": { defaultClass: "fyvr11ne" }, initial: { defaultClass: "fyvr11nf" }, inherit: { defaultClass: "fyvr11ng" } } }, zIndex: { values: { "0": { defaultClass: "fyvr11nh" }, "1": { defaultClass: "fyvr11ni" }, "10": { defaultClass: "fyvr11nj" }, "20": { defaultClass: "fyvr11nk" }, "30": { defaultClass: "fyvr11nl" }, "40": { defaultClass: "fyvr11nm" }, "50": { defaultClass: "fyvr11nn" }, "-1": { defaultClass: "fyvr11no" }, auto: { defaultClass: "fyvr11np" } } }, aspectRatio: { values: { "1/1": { defaultClass: "fyvr11nq" }, "16/9": { defaultClass: "fyvr11nr" }, "4/3": { defaultClass: "fyvr11ns" }, "3/1": { defaultClass: "fyvr11nt" }, auto: { defaultClass: "fyvr11nu" } } } } }, { conditions: { defaultCondition: "base", conditionNames: ["base", "active", "disabled", "focus", "hover", "checked"], responsiveArray: void 0 }, styles: { borderColor: { mappings: ["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"] }, borderStyle: { mappings: ["borderTopStyle", "borderRightStyle", "borderBottomStyle", "borderLeftStyle"] }, focusRing: { mappings: ["boxShadow", "outline"] }, background: { values: { black: { conditions: { base: "fyvr11nv", active: "fyvr11nw", disabled: "fyvr11nx", focus: "fyvr11ny", hover: "fyvr11nz", checked: "fyvr11o0" }, defaultClass: "fyvr11nv" }, white: { conditions: { base: "fyvr11o1", active: "fyvr11o2", disabled: "fyvr11o3", focus: "fyvr11o4", hover: "fyvr11o5", checked: "fyvr11o6" }, defaultClass: "fyvr11o1" }, inherit: { conditions: { base: "fyvr11o7", active: "fyvr11o8", disabled: "fyvr11o9", focus: "fyvr11oa", hover: "fyvr11ob", checked: "fyvr11oc" }, defaultClass: "fyvr11o7" }, transparent: { conditions: { base: "fyvr11od", active: "fyvr11oe", disabled: "fyvr11of", focus: "fyvr11og", hover: "fyvr11oh", checked: "fyvr11oi" }, defaultClass: "fyvr11od" }, positive: { conditions: { base: "fyvr11oj", active: "fyvr11ok", disabled: "fyvr11ol", focus: "fyvr11om", hover: "fyvr11on", checked: "fyvr11oo" }, defaultClass: "fyvr11oj" }, negative: { conditions: { base: "fyvr11op", active: "fyvr11oq", disabled: "fyvr11or", focus: "fyvr11os", hover: "fyvr11ot", checked: "fyvr11ou" }, defaultClass: "fyvr11op" }, info: { conditions: { base: "fyvr11ov", active: "fyvr11ow", disabled: "fyvr11ox", focus: "fyvr11oy", hover: "fyvr11oz", checked: "fyvr11p0" }, defaultClass: "fyvr11ov" }, warning: { conditions: { base: "fyvr11p1", active: "fyvr11p2", disabled: "fyvr11p3", focus: "fyvr11p4", hover: "fyvr11p5", checked: "fyvr11p6" }, defaultClass: "fyvr11p1" }, gradientBackdrop: { conditions: { base: "fyvr11p7", active: "fyvr11p8", disabled: "fyvr11p9", focus: "fyvr11pa", hover: "fyvr11pb", checked: "fyvr11pc" }, defaultClass: "fyvr11p7" }, gradientPrimary: { conditions: { base: "fyvr11pd", active: "fyvr11pe", disabled: "fyvr11pf", focus: "fyvr11pg", hover: "fyvr11ph", checked: "fyvr11pi" }, defaultClass: "fyvr11pd" }, gradientSecondary: { conditions: { base: "fyvr11pj", active: "fyvr11pk", disabled: "fyvr11pl", focus: "fyvr11pm", hover: "fyvr11pn", checked: "fyvr11po" }, defaultClass: "fyvr11pj" }, arbitrumDark: { conditions: { base: "fyvr11pp", active: "fyvr11pq", disabled: "fyvr11pr", focus: "fyvr11ps", hover: "fyvr11pt", checked: "fyvr11pu" }, defaultClass: "fyvr11pp" }, arbitrumLight: { conditions: { base: "fyvr11pv", active: "fyvr11pw", disabled: "fyvr11px", focus: "fyvr11py", hover: "fyvr11pz", checked: "fyvr11q0" }, defaultClass: "fyvr11pv" }, avalanceDark: { conditions: { base: "fyvr11q1", active: "fyvr11q2", disabled: "fyvr11q3", focus: "fyvr11q4", hover: "fyvr11q5", checked: "fyvr11q6" }, defaultClass: "fyvr11q1" }, avalanceLight: { conditions: { base: "fyvr11q7", active: "fyvr11q8", disabled: "fyvr11q9", focus: "fyvr11qa", hover: "fyvr11qb", checked: "fyvr11qc" }, defaultClass: "fyvr11q7" }, bscDark: { conditions: { base: "fyvr11qd", active: "fyvr11qe", disabled: "fyvr11qf", focus: "fyvr11qg", hover: "fyvr11qh", checked: "fyvr11qi" }, defaultClass: "fyvr11qd" }, bscLight: { conditions: { base: "fyvr11qj", active: "fyvr11qk", disabled: "fyvr11ql", focus: "fyvr11qm", hover: "fyvr11qn", checked: "fyvr11qo" }, defaultClass: "fyvr11qj" }, ethereumDark: { conditions: { base: "fyvr11qp", active: "fyvr11qq", disabled: "fyvr11qr", focus: "fyvr11qs", hover: "fyvr11qt", checked: "fyvr11qu" }, defaultClass: "fyvr11qp" }, ethereumLight: { conditions: { base: "fyvr11qv", active: "fyvr11qw", disabled: "fyvr11qx", focus: "fyvr11qy", hover: "fyvr11qz", checked: "fyvr11r0" }, defaultClass: "fyvr11qv" }, gnosisDark: { conditions: { base: "fyvr11r1", active: "fyvr11r2", disabled: "fyvr11r3", focus: "fyvr11r4", hover: "fyvr11r5", checked: "fyvr11r6" }, defaultClass: "fyvr11r1" }, gnosisLight: { conditions: { base: "fyvr11r7", active: "fyvr11r8", disabled: "fyvr11r9", focus: "fyvr11ra", hover: "fyvr11rb", checked: "fyvr11rc" }, defaultClass: "fyvr11r7" }, polygonDark: { conditions: { base: "fyvr11rd", active: "fyvr11re", disabled: "fyvr11rf", focus: "fyvr11rg", hover: "fyvr11rh", checked: "fyvr11ri" }, defaultClass: "fyvr11rd" }, polygonLight: { conditions: { base: "fyvr11rj", active: "fyvr11rk", disabled: "fyvr11rl", focus: "fyvr11rm", hover: "fyvr11rn", checked: "fyvr11ro" }, defaultClass: "fyvr11rj" }, text100: { conditions: { base: "fyvr11rp", active: "fyvr11rq", disabled: "fyvr11rr", focus: "fyvr11rs", hover: "fyvr11rt", checked: "fyvr11ru" }, defaultClass: "fyvr11rp" }, text80: { conditions: { base: "fyvr11rv", active: "fyvr11rw", disabled: "fyvr11rx", focus: "fyvr11ry", hover: "fyvr11rz", checked: "fyvr11s0" }, defaultClass: "fyvr11rv" }, text50: { conditions: { base: "fyvr11s1", active: "fyvr11s2", disabled: "fyvr11s3", focus: "fyvr11s4", hover: "fyvr11s5", checked: "fyvr11s6" }, defaultClass: "fyvr11s1" }, textInverse100: { conditions: { base: "fyvr11s7", active: "fyvr11s8", disabled: "fyvr11s9", focus: "fyvr11sa", hover: "fyvr11sb", checked: "fyvr11sc" }, defaultClass: "fyvr11s7" }, backgroundPrimary: { conditions: { base: "fyvr11sd", active: "fyvr11se", disabled: "fyvr11sf", focus: "fyvr11sg", hover: "fyvr11sh", checked: "fyvr11si" }, defaultClass: "fyvr11sd" }, backgroundSecondary: { conditions: { base: "fyvr11sj", active: "fyvr11sk", disabled: "fyvr11sl", focus: "fyvr11sm", hover: "fyvr11sn", checked: "fyvr11so" }, defaultClass: "fyvr11sj" }, backgroundContrast: { conditions: { base: "fyvr11sp", active: "fyvr11sq", disabled: "fyvr11sr", focus: "fyvr11ss", hover: "fyvr11st", checked: "fyvr11su" }, defaultClass: "fyvr11sp" }, backgroundMuted: { conditions: { base: "fyvr11sv", active: "fyvr11sw", disabled: "fyvr11sx", focus: "fyvr11sy", hover: "fyvr11sz", checked: "fyvr11t0" }, defaultClass: "fyvr11sv" }, backgroundControl: { conditions: { base: "fyvr11t1", active: "fyvr11t2", disabled: "fyvr11t3", focus: "fyvr11t4", hover: "fyvr11t5", checked: "fyvr11t6" }, defaultClass: "fyvr11t1" }, backgroundInverse: { conditions: { base: "fyvr11t7", active: "fyvr11t8", disabled: "fyvr11t9", focus: "fyvr11ta", hover: "fyvr11tb", checked: "fyvr11tc" }, defaultClass: "fyvr11t7" }, backgroundBackdrop: { conditions: { base: "fyvr11td", active: "fyvr11te", disabled: "fyvr11tf", focus: "fyvr11tg", hover: "fyvr11th", checked: "fyvr11ti" }, defaultClass: "fyvr11td" }, backgroundOverlay: { conditions: { base: "fyvr11tj", active: "fyvr11tk", disabled: "fyvr11tl", focus: "fyvr11tm", hover: "fyvr11tn", checked: "fyvr11to" }, defaultClass: "fyvr11tj" }, backgroundRaised: { conditions: { base: "fyvr11tp", active: "fyvr11tq", disabled: "fyvr11tr", focus: "fyvr11ts", hover: "fyvr11tt", checked: "fyvr11tu" }, defaultClass: "fyvr11tp" }, buttonGlass: { conditions: { base: "fyvr11tv", active: "fyvr11tw", disabled: "fyvr11tx", focus: "fyvr11ty", hover: "fyvr11tz", checked: "fyvr11u0" }, defaultClass: "fyvr11tv" }, buttonEmphasis: { conditions: { base: "fyvr11u1", active: "fyvr11u2", disabled: "fyvr11u3", focus: "fyvr11u4", hover: "fyvr11u5", checked: "fyvr11u6" }, defaultClass: "fyvr11u1" }, buttonInverse: { conditions: { base: "fyvr11u7", active: "fyvr11u8", disabled: "fyvr11u9", focus: "fyvr11ua", hover: "fyvr11ub", checked: "fyvr11uc" }, defaultClass: "fyvr11u7" }, borderNormal: { conditions: { base: "fyvr11ud", active: "fyvr11ue", disabled: "fyvr11uf", focus: "fyvr11ug", hover: "fyvr11uh", checked: "fyvr11ui" }, defaultClass: "fyvr11ud" }, borderFocus: { conditions: { base: "fyvr11uj", active: "fyvr11uk", disabled: "fyvr11ul", focus: "fyvr11um", hover: "fyvr11un", checked: "fyvr11uo" }, defaultClass: "fyvr11uj" } } }, borderBottomColor: { values: { black: { conditions: { base: "fyvr11up", active: "fyvr11uq", disabled: "fyvr11ur", focus: "fyvr11us", hover: "fyvr11ut", checked: "fyvr11uu" }, defaultClass: "fyvr11up" }, white: { conditions: { base: "fyvr11uv", active: "fyvr11uw", disabled: "fyvr11ux", focus: "fyvr11uy", hover: "fyvr11uz", checked: "fyvr11v0" }, defaultClass: "fyvr11uv" }, inherit: { conditions: { base: "fyvr11v1", active: "fyvr11v2", disabled: "fyvr11v3", focus: "fyvr11v4", hover: "fyvr11v5", checked: "fyvr11v6" }, defaultClass: "fyvr11v1" }, transparent: { conditions: { base: "fyvr11v7", active: "fyvr11v8", disabled: "fyvr11v9", focus: "fyvr11va", hover: "fyvr11vb", checked: "fyvr11vc" }, defaultClass: "fyvr11v7" }, positive: { conditions: { base: "fyvr11vd", active: "fyvr11ve", disabled: "fyvr11vf", focus: "fyvr11vg", hover: "fyvr11vh", checked: "fyvr11vi" }, defaultClass: "fyvr11vd" }, negative: { conditions: { base: "fyvr11vj", active: "fyvr11vk", disabled: "fyvr11vl", focus: "fyvr11vm", hover: "fyvr11vn", checked: "fyvr11vo" }, defaultClass: "fyvr11vj" }, info: { conditions: { base: "fyvr11vp", active: "fyvr11vq", disabled: "fyvr11vr", focus: "fyvr11vs", hover: "fyvr11vt", checked: "fyvr11vu" }, defaultClass: "fyvr11vp" }, warning: { conditions: { base: "fyvr11vv", active: "fyvr11vw", disabled: "fyvr11vx", focus: "fyvr11vy", hover: "fyvr11vz", checked: "fyvr11w0" }, defaultClass: "fyvr11vv" }, gradientBackdrop: { conditions: { base: "fyvr11w1", active: "fyvr11w2", disabled: "fyvr11w3", focus: "fyvr11w4", hover: "fyvr11w5", checked: "fyvr11w6" }, defaultClass: "fyvr11w1" }, gradientPrimary: { conditions: { base: "fyvr11w7", active: "fyvr11w8", disabled: "fyvr11w9", focus: "fyvr11wa", hover: "fyvr11wb", checked: "fyvr11wc" }, defaultClass: "fyvr11w7" }, gradientSecondary: { conditions: { base: "fyvr11wd", active: "fyvr11we", disabled: "fyvr11wf", focus: "fyvr11wg", hover: "fyvr11wh", checked: "fyvr11wi" }, defaultClass: "fyvr11wd" }, arbitrumDark: { conditions: { base: "fyvr11wj", active: "fyvr11wk", disabled: "fyvr11wl", focus: "fyvr11wm", hover: "fyvr11wn", checked: "fyvr11wo" }, defaultClass: "fyvr11wj" }, arbitrumLight: { conditions: { base: "fyvr11wp", active: "fyvr11wq", disabled: "fyvr11wr", focus: "fyvr11ws", hover: "fyvr11wt", checked: "fyvr11wu" }, defaultClass: "fyvr11wp" }, avalanceDark: { conditions: { base: "fyvr11wv", active: "fyvr11ww", disabled: "fyvr11wx", focus: "fyvr11wy", hover: "fyvr11wz", checked: "fyvr11x0" }, defaultClass: "fyvr11wv" }, avalanceLight: { conditions: { base: "fyvr11x1", active: "fyvr11x2", disabled: "fyvr11x3", focus: "fyvr11x4", hover: "fyvr11x5", checked: "fyvr11x6" }, defaultClass: "fyvr11x1" }, bscDark: { conditions: { base: "fyvr11x7", active: "fyvr11x8", disabled: "fyvr11x9", focus: "fyvr11xa", hover: "fyvr11xb", checked: "fyvr11xc" }, defaultClass: "fyvr11x7" }, bscLight: { conditions: { base: "fyvr11xd", active: "fyvr11xe", disabled: "fyvr11xf", focus: "fyvr11xg", hover: "fyvr11xh", checked: "fyvr11xi" }, defaultClass: "fyvr11xd" }, ethereumDark: { conditions: { base: "fyvr11xj", active: "fyvr11xk", disabled: "fyvr11xl", focus: "fyvr11xm", hover: "fyvr11xn", checked: "fyvr11xo" }, defaultClass: "fyvr11xj" }, ethereumLight: { conditions: { base: "fyvr11xp", active: "fyvr11xq", disabled: "fyvr11xr", focus: "fyvr11xs", hover: "fyvr11xt", checked: "fyvr11xu" }, defaultClass: "fyvr11xp" }, gnosisDark: { conditions: { base: "fyvr11xv", active: "fyvr11xw", disabled: "fyvr11xx", focus: "fyvr11xy", hover: "fyvr11xz", checked: "fyvr11y0" }, defaultClass: "fyvr11xv" }, gnosisLight: { conditions: { base: "fyvr11y1", active: "fyvr11y2", disabled: "fyvr11y3", focus: "fyvr11y4", hover: "fyvr11y5", checked: "fyvr11y6" }, defaultClass: "fyvr11y1" }, polygonDark: { conditions: { base: "fyvr11y7", active: "fyvr11y8", disabled: "fyvr11y9", focus: "fyvr11ya", hover: "fyvr11yb", checked: "fyvr11yc" }, defaultClass: "fyvr11y7" }, polygonLight: { conditions: { base: "fyvr11yd", active: "fyvr11ye", disabled: "fyvr11yf", focus: "fyvr11yg", hover: "fyvr11yh", checked: "fyvr11yi" }, defaultClass: "fyvr11yd" }, text100: { conditions: { base: "fyvr11yj", active: "fyvr11yk", disabled: "fyvr11yl", focus: "fyvr11ym", hover: "fyvr11yn", checked: "fyvr11yo" }, defaultClass: "fyvr11yj" }, text80: { conditions: { base: "fyvr11yp", active: "fyvr11yq", disabled: "fyvr11yr", focus: "fyvr11ys", hover: "fyvr11yt", checked: "fyvr11yu" }, defaultClass: "fyvr11yp" }, text50: { conditions: { base: "fyvr11yv", active: "fyvr11yw", disabled: "fyvr11yx", focus: "fyvr11yy", hover: "fyvr11yz", checked: "fyvr11z0" }, defaultClass: "fyvr11yv" }, textInverse100: { conditions: { base: "fyvr11z1", active: "fyvr11z2", disabled: "fyvr11z3", focus: "fyvr11z4", hover: "fyvr11z5", checked: "fyvr11z6" }, defaultClass: "fyvr11z1" }, backgroundPrimary: { conditions: { base: "fyvr11z7", active: "fyvr11z8", disabled: "fyvr11z9", focus: "fyvr11za", hover: "fyvr11zb", checked: "fyvr11zc" }, defaultClass: "fyvr11z7" }, backgroundSecondary: { conditions: { base: "fyvr11zd", active: "fyvr11ze", disabled: "fyvr11zf", focus: "fyvr11zg", hover: "fyvr11zh", checked: "fyvr11zi" }, defaultClass: "fyvr11zd" }, backgroundContrast: { conditions: { base: "fyvr11zj", active: "fyvr11zk", disabled: "fyvr11zl", focus: "fyvr11zm", hover: "fyvr11zn", checked: "fyvr11zo" }, defaultClass: "fyvr11zj" }, backgroundMuted: { conditions: { base: "fyvr11zp", active: "fyvr11zq", disabled: "fyvr11zr", focus: "fyvr11zs", hover: "fyvr11zt", checked: "fyvr11zu" }, defaultClass: "fyvr11zp" }, backgroundControl: { conditions: { base: "fyvr11zv", active: "fyvr11zw", disabled: "fyvr11zx", focus: "fyvr11zy", hover: "fyvr11zz", checked: "fyvr1200" }, defaultClass: "fyvr11zv" }, backgroundInverse: { conditions: { base: "fyvr1201", active: "fyvr1202", disabled: "fyvr1203", focus: "fyvr1204", hover: "fyvr1205", checked: "fyvr1206" }, defaultClass: "fyvr1201" }, backgroundBackdrop: { conditions: { base: "fyvr1207", active: "fyvr1208", disabled: "fyvr1209", focus: "fyvr120a", hover: "fyvr120b", checked: "fyvr120c" }, defaultClass: "fyvr1207" }, backgroundOverlay: { conditions: { base: "fyvr120d", active: "fyvr120e", disabled: "fyvr120f", focus: "fyvr120g", hover: "fyvr120h", checked: "fyvr120i" }, defaultClass: "fyvr120d" }, backgroundRaised: { conditions: { base: "fyvr120j", active: "fyvr120k", disabled: "fyvr120l", focus: "fyvr120m", hover: "fyvr120n", checked: "fyvr120o" }, defaultClass: "fyvr120j" }, buttonGlass: { conditions: { base: "fyvr120p", active: "fyvr120q", disabled: "fyvr120r", focus: "fyvr120s", hover: "fyvr120t", checked: "fyvr120u" }, defaultClass: "fyvr120p" }, buttonEmphasis: { conditions: { base: "fyvr120v", active: "fyvr120w", disabled: "fyvr120x", focus: "fyvr120y", hover: "fyvr120z", checked: "fyvr1210" }, defaultClass: "fyvr120v" }, buttonInverse: { conditions: { base: "fyvr1211", active: "fyvr1212", disabled: "fyvr1213", focus: "fyvr1214", hover: "fyvr1215", checked: "fyvr1216" }, defaultClass: "fyvr1211" }, borderNormal: { conditions: { base: "fyvr1217", active: "fyvr1218", disabled: "fyvr1219", focus: "fyvr121a", hover: "fyvr121b", checked: "fyvr121c" }, defaultClass: "fyvr1217" }, borderFocus: { conditions: { base: "fyvr121d", active: "fyvr121e", disabled: "fyvr121f", focus: "fyvr121g", hover: "fyvr121h", checked: "fyvr121i" }, defaultClass: "fyvr121d" } } }, borderBottomStyle: { values: { solid: { conditions: { base: "fyvr121j", active: "fyvr121k", disabled: "fyvr121l", focus: "fyvr121m", hover: "fyvr121n", checked: "fyvr121o" }, defaultClass: "fyvr121j" }, dashed: { conditions: { base: "fyvr121p", active: "fyvr121q", disabled: "fyvr121r", focus: "fyvr121s", hover: "fyvr121t", checked: "fyvr121u" }, defaultClass: "fyvr121p" }, dotted: { conditions: { base: "fyvr121v", active: "fyvr121w", disabled: "fyvr121x", focus: "fyvr121y", hover: "fyvr121z", checked: "fyvr1220" }, defaultClass: "fyvr121v" } } }, borderLeftColor: { values: { black: { conditions: { base: "fyvr1221", active: "fyvr1222", disabled: "fyvr1223", focus: "fyvr1224", hover: "fyvr1225", checked: "fyvr1226" }, defaultClass: "fyvr1221" }, white: { conditions: { base: "fyvr1227", active: "fyvr1228", disabled: "fyvr1229", focus: "fyvr122a", hover: "fyvr122b", checked: "fyvr122c" }, defaultClass: "fyvr1227" }, inherit: { conditions: { base: "fyvr122d", active: "fyvr122e", disabled: "fyvr122f", focus: "fyvr122g", hover: "fyvr122h", checked: "fyvr122i" }, defaultClass: "fyvr122d" }, transparent: { conditions: { base: "fyvr122j", active: "fyvr122k", disabled: "fyvr122l", focus: "fyvr122m", hover: "fyvr122n", checked: "fyvr122o" }, defaultClass: "fyvr122j" }, positive: { conditions: { base: "fyvr122p", active: "fyvr122q", disabled: "fyvr122r", focus: "fyvr122s", hover: "fyvr122t", checked: "fyvr122u" }, defaultClass: "fyvr122p" }, negative: { conditions: { base: "fyvr122v", active: "fyvr122w", disabled: "fyvr122x", focus: "fyvr122y", hover: "fyvr122z", checked: "fyvr1230" }, defaultClass: "fyvr122v" }, info: { conditions: { base: "fyvr1231", active: "fyvr1232", disabled: "fyvr1233", focus: "fyvr1234", hover: "fyvr1235", checked: "fyvr1236" }, defaultClass: "fyvr1231" }, warning: { conditions: { base: "fyvr1237", active: "fyvr1238", disabled: "fyvr1239", focus: "fyvr123a", hover: "fyvr123b", checked: "fyvr123c" }, defaultClass: "fyvr1237" }, gradientBackdrop: { conditions: { base: "fyvr123d", active: "fyvr123e", disabled: "fyvr123f", focus: "fyvr123g", hover: "fyvr123h", checked: "fyvr123i" }, defaultClass: "fyvr123d" }, gradientPrimary: { conditions: { base: "fyvr123j", active: "fyvr123k", disabled: "fyvr123l", focus: "fyvr123m", hover: "fyvr123n", checked: "fyvr123o" }, defaultClass: "fyvr123j" }, gradientSecondary: { conditions: { base: "fyvr123p", active: "fyvr123q", disabled: "fyvr123r", focus: "fyvr123s", hover: "fyvr123t", checked: "fyvr123u" }, defaultClass: "fyvr123p" }, arbitrumDark: { conditions: { base: "fyvr123v", active: "fyvr123w", disabled: "fyvr123x", focus: "fyvr123y", hover: "fyvr123z", checked: "fyvr1240" }, defaultClass: "fyvr123v" }, arbitrumLight: { conditions: { base: "fyvr1241", active: "fyvr1242", disabled: "fyvr1243", focus: "fyvr1244", hover: "fyvr1245", checked: "fyvr1246" }, defaultClass: "fyvr1241" }, avalanceDark: { conditions: { base: "fyvr1247", active: "fyvr1248", disabled: "fyvr1249", focus: "fyvr124a", hover: "fyvr124b", checked: "fyvr124c" }, defaultClass: "fyvr1247" }, avalanceLight: { conditions: { base: "fyvr124d", active: "fyvr124e", disabled: "fyvr124f", focus: "fyvr124g", hover: "fyvr124h", checked: "fyvr124i" }, defaultClass: "fyvr124d" }, bscDark: { conditions: { base: "fyvr124j", active: "fyvr124k", disabled: "fyvr124l", focus: "fyvr124m", hover: "fyvr124n", checked: "fyvr124o" }, defaultClass: "fyvr124j" }, bscLight: { conditions: { base: "fyvr124p", active: "fyvr124q", disabled: "fyvr124r", focus: "fyvr124s", hover: "fyvr124t", checked: "fyvr124u" }, defaultClass: "fyvr124p" }, ethereumDark: { conditions: { base: "fyvr124v", active: "fyvr124w", disabled: "fyvr124x", focus: "fyvr124y", hover: "fyvr124z", checked: "fyvr1250" }, defaultClass: "fyvr124v" }, ethereumLight: { conditions: { base: "fyvr1251", active: "fyvr1252", disabled: "fyvr1253", focus: "fyvr1254", hover: "fyvr1255", checked: "fyvr1256" }, defaultClass: "fyvr1251" }, gnosisDark: { conditions: { base: "fyvr1257", active: "fyvr1258", disabled: "fyvr1259", focus: "fyvr125a", hover: "fyvr125b", checked: "fyvr125c" }, defaultClass: "fyvr1257" }, gnosisLight: { conditions: { base: "fyvr125d", active: "fyvr125e", disabled: "fyvr125f", focus: "fyvr125g", hover: "fyvr125h", checked: "fyvr125i" }, defaultClass: "fyvr125d" }, polygonDark: { conditions: { base: "fyvr125j", active: "fyvr125k", disabled: "fyvr125l", focus: "fyvr125m", hover: "fyvr125n", checked: "fyvr125o" }, defaultClass: "fyvr125j" }, polygonLight: { conditions: { base: "fyvr125p", active: "fyvr125q", disabled: "fyvr125r", focus: "fyvr125s", hover: "fyvr125t", checked: "fyvr125u" }, defaultClass: "fyvr125p" }, text100: { conditions: { base: "fyvr125v", active: "fyvr125w", disabled: "fyvr125x", focus: "fyvr125y", hover: "fyvr125z", checked: "fyvr1260" }, defaultClass: "fyvr125v" }, text80: { conditions: { base: "fyvr1261", active: "fyvr1262", disabled: "fyvr1263", focus: "fyvr1264", hover: "fyvr1265", checked: "fyvr1266" }, defaultClass: "fyvr1261" }, text50: { conditions: { base: "fyvr1267", active: "fyvr1268", disabled: "fyvr1269", focus: "fyvr126a", hover: "fyvr126b", checked: "fyvr126c" }, defaultClass: "fyvr1267" }, textInverse100: { conditions: { base: "fyvr126d", active: "fyvr126e", disabled: "fyvr126f", focus: "fyvr126g", hover: "fyvr126h", checked: "fyvr126i" }, defaultClass: "fyvr126d" }, backgroundPrimary: { conditions: { base: "fyvr126j", active: "fyvr126k", disabled: "fyvr126l", focus: "fyvr126m", hover: "fyvr126n", checked: "fyvr126o" }, defaultClass: "fyvr126j" }, backgroundSecondary: { conditions: { base: "fyvr126p", active: "fyvr126q", disabled: "fyvr126r", focus: "fyvr126s", hover: "fyvr126t", checked: "fyvr126u" }, defaultClass: "fyvr126p" }, backgroundContrast: { conditions: { base: "fyvr126v", active: "fyvr126w", disabled: "fyvr126x", focus: "fyvr126y", hover: "fyvr126z", checked: "fyvr1270" }, defaultClass: "fyvr126v" }, backgroundMuted: { conditions: { base: "fyvr1271", active: "fyvr1272", disabled: "fyvr1273", focus: "fyvr1274", hover: "fyvr1275", checked: "fyvr1276" }, defaultClass: "fyvr1271" }, backgroundControl: { conditions: { base: "fyvr1277", active: "fyvr1278", disabled: "fyvr1279", focus: "fyvr127a", hover: "fyvr127b", checked: "fyvr127c" }, defaultClass: "fyvr1277" }, backgroundInverse: { conditions: { base: "fyvr127d", active: "fyvr127e", disabled: "fyvr127f", focus: "fyvr127g", hover: "fyvr127h", checked: "fyvr127i" }, defaultClass: "fyvr127d" }, backgroundBackdrop: { conditions: { base: "fyvr127j", active: "fyvr127k", disabled: "fyvr127l", focus: "fyvr127m", hover: "fyvr127n", checked: "fyvr127o" }, defaultClass: "fyvr127j" }, backgroundOverlay: { conditions: { base: "fyvr127p", active: "fyvr127q", disabled: "fyvr127r", focus: "fyvr127s", hover: "fyvr127t", checked: "fyvr127u" }, defaultClass: "fyvr127p" }, backgroundRaised: { conditions: { base: "fyvr127v", active: "fyvr127w", disabled: "fyvr127x", focus: "fyvr127y", hover: "fyvr127z", checked: "fyvr1280" }, defaultClass: "fyvr127v" }, buttonGlass: { conditions: { base: "fyvr1281", active: "fyvr1282", disabled: "fyvr1283", focus: "fyvr1284", hover: "fyvr1285", checked: "fyvr1286" }, defaultClass: "fyvr1281" }, buttonEmphasis: { conditions: { base: "fyvr1287", active: "fyvr1288", disabled: "fyvr1289", focus: "fyvr128a", hover: "fyvr128b", checked: "fyvr128c" }, defaultClass: "fyvr1287" }, buttonInverse: { conditions: { base: "fyvr128d", active: "fyvr128e", disabled: "fyvr128f", focus: "fyvr128g", hover: "fyvr128h", checked: "fyvr128i" }, defaultClass: "fyvr128d" }, borderNormal: { conditions: { base: "fyvr128j", active: "fyvr128k", disabled: "fyvr128l", focus: "fyvr128m", hover: "fyvr128n", checked: "fyvr128o" }, defaultClass: "fyvr128j" }, borderFocus: { conditions: { base: "fyvr128p", active: "fyvr128q", disabled: "fyvr128r", focus: "fyvr128s", hover: "fyvr128t", checked: "fyvr128u" }, defaultClass: "fyvr128p" } } }, borderLeftStyle: { values: { solid: { conditions: { base: "fyvr128v", active: "fyvr128w", disabled: "fyvr128x", focus: "fyvr128y", hover: "fyvr128z", checked: "fyvr1290" }, defaultClass: "fyvr128v" }, dashed: { conditions: { base: "fyvr1291", active: "fyvr1292", disabled: "fyvr1293", focus: "fyvr1294", hover: "fyvr1295", checked: "fyvr1296" }, defaultClass: "fyvr1291" }, dotted: { conditions: { base: "fyvr1297", active: "fyvr1298", disabled: "fyvr1299", focus: "fyvr129a", hover: "fyvr129b", checked: "fyvr129c" }, defaultClass: "fyvr1297" } } }, borderRightColor: { values: { black: { conditions: { base: "fyvr129d", active: "fyvr129e", disabled: "fyvr129f", focus: "fyvr129g", hover: "fyvr129h", checked: "fyvr129i" }, defaultClass: "fyvr129d" }, white: { conditions: { base: "fyvr129j", active: "fyvr129k", disabled: "fyvr129l", focus: "fyvr129m", hover: "fyvr129n", checked: "fyvr129o" }, defaultClass: "fyvr129j" }, inherit: { conditions: { base: "fyvr129p", active: "fyvr129q", disabled: "fyvr129r", focus: "fyvr129s", hover: "fyvr129t", checked: "fyvr129u" }, defaultClass: "fyvr129p" }, transparent: { conditions: { base: "fyvr129v", active: "fyvr129w", disabled: "fyvr129x", focus: "fyvr129y", hover: "fyvr129z", checked: "fyvr12a0" }, defaultClass: "fyvr129v" }, positive: { conditions: { base: "fyvr12a1", active: "fyvr12a2", disabled: "fyvr12a3", focus: "fyvr12a4", hover: "fyvr12a5", checked: "fyvr12a6" }, defaultClass: "fyvr12a1" }, negative: { conditions: { base: "fyvr12a7", active: "fyvr12a8", disabled: "fyvr12a9", focus: "fyvr12aa", hover: "fyvr12ab", checked: "fyvr12ac" }, defaultClass: "fyvr12a7" }, info: { conditions: { base: "fyvr12ad", active: "fyvr12ae", disabled: "fyvr12af", focus: "fyvr12ag", hover: "fyvr12ah", checked: "fyvr12ai" }, defaultClass: "fyvr12ad" }, warning: { conditions: { base: "fyvr12aj", active: "fyvr12ak", disabled: "fyvr12al", focus: "fyvr12am", hover: "fyvr12an", checked: "fyvr12ao" }, defaultClass: "fyvr12aj" }, gradientBackdrop: { conditions: { base: "fyvr12ap", active: "fyvr12aq", disabled: "fyvr12ar", focus: "fyvr12as", hover: "fyvr12at", checked: "fyvr12au" }, defaultClass: "fyvr12ap" }, gradientPrimary: { conditions: { base: "fyvr12av", active: "fyvr12aw", disabled: "fyvr12ax", focus: "fyvr12ay", hover: "fyvr12az", checked: "fyvr12b0" }, defaultClass: "fyvr12av" }, gradientSecondary: { conditions: { base: "fyvr12b1", active: "fyvr12b2", disabled: "fyvr12b3", focus: "fyvr12b4", hover: "fyvr12b5", checked: "fyvr12b6" }, defaultClass: "fyvr12b1" }, arbitrumDark: { conditions: { base: "fyvr12b7", active: "fyvr12b8", disabled: "fyvr12b9", focus: "fyvr12ba", hover: "fyvr12bb", checked: "fyvr12bc" }, defaultClass: "fyvr12b7" }, arbitrumLight: { conditions: { base: "fyvr12bd", active: "fyvr12be", disabled: "fyvr12bf", focus: "fyvr12bg", hover: "fyvr12bh", checked: "fyvr12bi" }, defaultClass: "fyvr12bd" }, avalanceDark: { conditions: { base: "fyvr12bj", active: "fyvr12bk", disabled: "fyvr12bl", focus: "fyvr12bm", hover: "fyvr12bn", checked: "fyvr12bo" }, defaultClass: "fyvr12bj" }, avalanceLight: { conditions: { base: "fyvr12bp", active: "fyvr12bq", disabled: "fyvr12br", focus: "fyvr12bs", hover: "fyvr12bt", checked: "fyvr12bu" }, defaultClass: "fyvr12bp" }, bscDark: { conditions: { base: "fyvr12bv", active: "fyvr12bw", disabled: "fyvr12bx", focus: "fyvr12by", hover: "fyvr12bz", checked: "fyvr12c0" }, defaultClass: "fyvr12bv" }, bscLight: { conditions: { base: "fyvr12c1", active: "fyvr12c2", disabled: "fyvr12c3", focus: "fyvr12c4", hover: "fyvr12c5", checked: "fyvr12c6" }, defaultClass: "fyvr12c1" }, ethereumDark: { conditions: { base: "fyvr12c7", active: "fyvr12c8", disabled: "fyvr12c9", focus: "fyvr12ca", hover: "fyvr12cb", checked: "fyvr12cc" }, defaultClass: "fyvr12c7" }, ethereumLight: { conditions: { base: "fyvr12cd", active: "fyvr12ce", disabled: "fyvr12cf", focus: "fyvr12cg", hover: "fyvr12ch", checked: "fyvr12ci" }, defaultClass: "fyvr12cd" }, gnosisDark: { conditions: { base: "fyvr12cj", active: "fyvr12ck", disabled: "fyvr12cl", focus: "fyvr12cm", hover: "fyvr12cn", checked: "fyvr12co" }, defaultClass: "fyvr12cj" }, gnosisLight: { conditions: { base: "fyvr12cp", active: "fyvr12cq", disabled: "fyvr12cr", focus: "fyvr12cs", hover: "fyvr12ct", checked: "fyvr12cu" }, defaultClass: "fyvr12cp" }, polygonDark: { conditions: { base: "fyvr12cv", active: "fyvr12cw", disabled: "fyvr12cx", focus: "fyvr12cy", hover: "fyvr12cz", checked: "fyvr12d0" }, defaultClass: "fyvr12cv" }, polygonLight: { conditions: { base: "fyvr12d1", active: "fyvr12d2", disabled: "fyvr12d3", focus: "fyvr12d4", hover: "fyvr12d5", checked: "fyvr12d6" }, defaultClass: "fyvr12d1" }, text100: { conditions: { base: "fyvr12d7", active: "fyvr12d8", disabled: "fyvr12d9", focus: "fyvr12da", hover: "fyvr12db", checked: "fyvr12dc" }, defaultClass: "fyvr12d7" }, text80: { conditions: { base: "fyvr12dd", active: "fyvr12de", disabled: "fyvr12df", focus: "fyvr12dg", hover: "fyvr12dh", checked: "fyvr12di" }, defaultClass: "fyvr12dd" }, text50: { conditions: { base: "fyvr12dj", active: "fyvr12dk", disabled: "fyvr12dl", focus: "fyvr12dm", hover: "fyvr12dn", checked: "fyvr12do" }, defaultClass: "fyvr12dj" }, textInverse100: { conditions: { base: "fyvr12dp", active: "fyvr12dq", disabled: "fyvr12dr", focus: "fyvr12ds", hover: "fyvr12dt", checked: "fyvr12du" }, defaultClass: "fyvr12dp" }, backgroundPrimary: { conditions: { base: "fyvr12dv", active: "fyvr12dw", disabled: "fyvr12dx", focus: "fyvr12dy", hover: "fyvr12dz", checked: "fyvr12e0" }, defaultClass: "fyvr12dv" }, backgroundSecondary: { conditions: { base: "fyvr12e1", active: "fyvr12e2", disabled: "fyvr12e3", focus: "fyvr12e4", hover: "fyvr12e5", checked: "fyvr12e6" }, defaultClass: "fyvr12e1" }, backgroundContrast: { conditions: { base: "fyvr12e7", active: "fyvr12e8", disabled: "fyvr12e9", focus: "fyvr12ea", hover: "fyvr12eb", checked: "fyvr12ec" }, defaultClass: "fyvr12e7" }, backgroundMuted: { conditions: { base: "fyvr12ed", active: "fyvr12ee", disabled: "fyvr12ef", focus: "fyvr12eg", hover: "fyvr12eh", checked: "fyvr12ei" }, defaultClass: "fyvr12ed" }, backgroundControl: { conditions: { base: "fyvr12ej", active: "fyvr12ek", disabled: "fyvr12el", focus: "fyvr12em", hover: "fyvr12en", checked: "fyvr12eo" }, defaultClass: "fyvr12ej" }, backgroundInverse: { conditions: { base: "fyvr12ep", active: "fyvr12eq", disabled: "fyvr12er", focus: "fyvr12es", hover: "fyvr12et", checked: "fyvr12eu" }, defaultClass: "fyvr12ep" }, backgroundBackdrop: { conditions: { base: "fyvr12ev", active: "fyvr12ew", disabled: "fyvr12ex", focus: "fyvr12ey", hover: "fyvr12ez", checked: "fyvr12f0" }, defaultClass: "fyvr12ev" }, backgroundOverlay: { conditions: { base: "fyvr12f1", active: "fyvr12f2", disabled: "fyvr12f3", focus: "fyvr12f4", hover: "fyvr12f5", checked: "fyvr12f6" }, defaultClass: "fyvr12f1" }, backgroundRaised: { conditions: { base: "fyvr12f7", active: "fyvr12f8", disabled: "fyvr12f9", focus: "fyvr12fa", hover: "fyvr12fb", checked: "fyvr12fc" }, defaultClass: "fyvr12f7" }, buttonGlass: { conditions: { base: "fyvr12fd", active: "fyvr12fe", disabled: "fyvr12ff", focus: "fyvr12fg", hover: "fyvr12fh", checked: "fyvr12fi" }, defaultClass: "fyvr12fd" }, buttonEmphasis: { conditions: { base: "fyvr12fj", active: "fyvr12fk", disabled: "fyvr12fl", focus: "fyvr12fm", hover: "fyvr12fn", checked: "fyvr12fo" }, defaultClass: "fyvr12fj" }, buttonInverse: { conditions: { base: "fyvr12fp", active: "fyvr12fq", disabled: "fyvr12fr", focus: "fyvr12fs", hover: "fyvr12ft", checked: "fyvr12fu" }, defaultClass: "fyvr12fp" }, borderNormal: { conditions: { base: "fyvr12fv", active: "fyvr12fw", disabled: "fyvr12fx", focus: "fyvr12fy", hover: "fyvr12fz", checked: "fyvr12g0" }, defaultClass: "fyvr12fv" }, borderFocus: { conditions: { base: "fyvr12g1", active: "fyvr12g2", disabled: "fyvr12g3", focus: "fyvr12g4", hover: "fyvr12g5", checked: "fyvr12g6" }, defaultClass: "fyvr12g1" } } }, borderRightStyle: { values: { solid: { conditions: { base: "fyvr12g7", active: "fyvr12g8", disabled: "fyvr12g9", focus: "fyvr12ga", hover: "fyvr12gb", checked: "fyvr12gc" }, defaultClass: "fyvr12g7" }, dashed: { conditions: { base: "fyvr12gd", active: "fyvr12ge", disabled: "fyvr12gf", focus: "fyvr12gg", hover: "fyvr12gh", checked: "fyvr12gi" }, defaultClass: "fyvr12gd" }, dotted: { conditions: { base: "fyvr12gj", active: "fyvr12gk", disabled: "fyvr12gl", focus: "fyvr12gm", hover: "fyvr12gn", checked: "fyvr12go" }, defaultClass: "fyvr12gj" } } }, borderTopColor: { values: { black: { conditions: { base: "fyvr12gp", active: "fyvr12gq", disabled: "fyvr12gr", focus: "fyvr12gs", hover: "fyvr12gt", checked: "fyvr12gu" }, defaultClass: "fyvr12gp" }, white: { conditions: { base: "fyvr12gv", active: "fyvr12gw", disabled: "fyvr12gx", focus: "fyvr12gy", hover: "fyvr12gz", checked: "fyvr12h0" }, defaultClass: "fyvr12gv" }, inherit: { conditions: { base: "fyvr12h1", active: "fyvr12h2", disabled: "fyvr12h3", focus: "fyvr12h4", hover: "fyvr12h5", checked: "fyvr12h6" }, defaultClass: "fyvr12h1" }, transparent: { conditions: { base: "fyvr12h7", active: "fyvr12h8", disabled: "fyvr12h9", focus: "fyvr12ha", hover: "fyvr12hb", checked: "fyvr12hc" }, defaultClass: "fyvr12h7" }, positive: { conditions: { base: "fyvr12hd", active: "fyvr12he", disabled: "fyvr12hf", focus: "fyvr12hg", hover: "fyvr12hh", checked: "fyvr12hi" }, defaultClass: "fyvr12hd" }, negative: { conditions: { base: "fyvr12hj", active: "fyvr12hk", disabled: "fyvr12hl", focus: "fyvr12hm", hover: "fyvr12hn", checked: "fyvr12ho" }, defaultClass: "fyvr12hj" }, info: { conditions: { base: "fyvr12hp", active: "fyvr12hq", disabled: "fyvr12hr", focus: "fyvr12hs", hover: "fyvr12ht", checked: "fyvr12hu" }, defaultClass: "fyvr12hp" }, warning: { conditions: { base: "fyvr12hv", active: "fyvr12hw", disabled: "fyvr12hx", focus: "fyvr12hy", hover: "fyvr12hz", checked: "fyvr12i0" }, defaultClass: "fyvr12hv" }, gradientBackdrop: { conditions: { base: "fyvr12i1", active: "fyvr12i2", disabled: "fyvr12i3", focus: "fyvr12i4", hover: "fyvr12i5", checked: "fyvr12i6" }, defaultClass: "fyvr12i1" }, gradientPrimary: { conditions: { base: "fyvr12i7", active: "fyvr12i8", disabled: "fyvr12i9", focus: "fyvr12ia", hover: "fyvr12ib", checked: "fyvr12ic" }, defaultClass: "fyvr12i7" }, gradientSecondary: { conditions: { base: "fyvr12id", active: "fyvr12ie", disabled: "fyvr12if", focus: "fyvr12ig", hover: "fyvr12ih", checked: "fyvr12ii" }, defaultClass: "fyvr12id" }, arbitrumDark: { conditions: { base: "fyvr12ij", active: "fyvr12ik", disabled: "fyvr12il", focus: "fyvr12im", hover: "fyvr12in", checked: "fyvr12io" }, defaultClass: "fyvr12ij" }, arbitrumLight: { conditions: { base: "fyvr12ip", active: "fyvr12iq", disabled: "fyvr12ir", focus: "fyvr12is", hover: "fyvr12it", checked: "fyvr12iu" }, defaultClass: "fyvr12ip" }, avalanceDark: { conditions: { base: "fyvr12iv", active: "fyvr12iw", disabled: "fyvr12ix", focus: "fyvr12iy", hover: "fyvr12iz", checked: "fyvr12j0" }, defaultClass: "fyvr12iv" }, avalanceLight: { conditions: { base: "fyvr12j1", active: "fyvr12j2", disabled: "fyvr12j3", focus: "fyvr12j4", hover: "fyvr12j5", checked: "fyvr12j6" }, defaultClass: "fyvr12j1" }, bscDark: { conditions: { base: "fyvr12j7", active: "fyvr12j8", disabled: "fyvr12j9", focus: "fyvr12ja", hover: "fyvr12jb", checked: "fyvr12jc" }, defaultClass: "fyvr12j7" }, bscLight: { conditions: { base: "fyvr12jd", active: "fyvr12je", disabled: "fyvr12jf", focus: "fyvr12jg", hover: "fyvr12jh", checked: "fyvr12ji" }, defaultClass: "fyvr12jd" }, ethereumDark: { conditions: { base: "fyvr12jj", active: "fyvr12jk", disabled: "fyvr12jl", focus: "fyvr12jm", hover: "fyvr12jn", checked: "fyvr12jo" }, defaultClass: "fyvr12jj" }, ethereumLight: { conditions: { base: "fyvr12jp", active: "fyvr12jq", disabled: "fyvr12jr", focus: "fyvr12js", hover: "fyvr12jt", checked: "fyvr12ju" }, defaultClass: "fyvr12jp" }, gnosisDark: { conditions: { base: "fyvr12jv", active: "fyvr12jw", disabled: "fyvr12jx", focus: "fyvr12jy", hover: "fyvr12jz", checked: "fyvr12k0" }, defaultClass: "fyvr12jv" }, gnosisLight: { conditions: { base: "fyvr12k1", active: "fyvr12k2", disabled: "fyvr12k3", focus: "fyvr12k4", hover: "fyvr12k5", checked: "fyvr12k6" }, defaultClass: "fyvr12k1" }, polygonDark: { conditions: { base: "fyvr12k7", active: "fyvr12k8", disabled: "fyvr12k9", focus: "fyvr12ka", hover: "fyvr12kb", checked: "fyvr12kc" }, defaultClass: "fyvr12k7" }, polygonLight: { conditions: { base: "fyvr12kd", active: "fyvr12ke", disabled: "fyvr12kf", focus: "fyvr12kg", hover: "fyvr12kh", checked: "fyvr12ki" }, defaultClass: "fyvr12kd" }, text100: { conditions: { base: "fyvr12kj", active: "fyvr12kk", disabled: "fyvr12kl", focus: "fyvr12km", hover: "fyvr12kn", checked: "fyvr12ko" }, defaultClass: "fyvr12kj" }, text80: { conditions: { base: "fyvr12kp", active: "fyvr12kq", disabled: "fyvr12kr", focus: "fyvr12ks", hover: "fyvr12kt", checked: "fyvr12ku" }, defaultClass: "fyvr12kp" }, text50: { conditions: { base: "fyvr12kv", active: "fyvr12kw", disabled: "fyvr12kx", focus: "fyvr12ky", hover: "fyvr12kz", checked: "fyvr12l0" }, defaultClass: "fyvr12kv" }, textInverse100: { conditions: { base: "fyvr12l1", active: "fyvr12l2", disabled: "fyvr12l3", focus: "fyvr12l4", hover: "fyvr12l5", checked: "fyvr12l6" }, defaultClass: "fyvr12l1" }, backgroundPrimary: { conditions: { base: "fyvr12l7", active: "fyvr12l8", disabled: "fyvr12l9", focus: "fyvr12la", hover: "fyvr12lb", checked: "fyvr12lc" }, defaultClass: "fyvr12l7" }, backgroundSecondary: { conditions: { base: "fyvr12ld", active: "fyvr12le", disabled: "fyvr12lf", focus: "fyvr12lg", hover: "fyvr12lh", checked: "fyvr12li" }, defaultClass: "fyvr12ld" }, backgroundContrast: { conditions: { base: "fyvr12lj", active: "fyvr12lk", disabled: "fyvr12ll", focus: "fyvr12lm", hover: "fyvr12ln", checked: "fyvr12lo" }, defaultClass: "fyvr12lj" }, backgroundMuted: { conditions: { base: "fyvr12lp", active: "fyvr12lq", disabled: "fyvr12lr", focus: "fyvr12ls", hover: "fyvr12lt", checked: "fyvr12lu" }, defaultClass: "fyvr12lp" }, backgroundControl: { conditions: { base: "fyvr12lv", active: "fyvr12lw", disabled: "fyvr12lx", focus: "fyvr12ly", hover: "fyvr12lz", checked: "fyvr12m0" }, defaultClass: "fyvr12lv" }, backgroundInverse: { conditions: { base: "fyvr12m1", active: "fyvr12m2", disabled: "fyvr12m3", focus: "fyvr12m4", hover: "fyvr12m5", checked: "fyvr12m6" }, defaultClass: "fyvr12m1" }, backgroundBackdrop: { conditions: { base: "fyvr12m7", active: "fyvr12m8", disabled: "fyvr12m9", focus: "fyvr12ma", hover: "fyvr12mb", checked: "fyvr12mc" }, defaultClass: "fyvr12m7" }, backgroundOverlay: { conditions: { base: "fyvr12md", active: "fyvr12me", disabled: "fyvr12mf", focus: "fyvr12mg", hover: "fyvr12mh", checked: "fyvr12mi" }, defaultClass: "fyvr12md" }, backgroundRaised: { conditions: { base: "fyvr12mj", active: "fyvr12mk", disabled: "fyvr12ml", focus: "fyvr12mm", hover: "fyvr12mn", checked: "fyvr12mo" }, defaultClass: "fyvr12mj" }, buttonGlass: { conditions: { base: "fyvr12mp", active: "fyvr12mq", disabled: "fyvr12mr", focus: "fyvr12ms", hover: "fyvr12mt", checked: "fyvr12mu" }, defaultClass: "fyvr12mp" }, buttonEmphasis: { conditions: { base: "fyvr12mv", active: "fyvr12mw", disabled: "fyvr12mx", focus: "fyvr12my", hover: "fyvr12mz", checked: "fyvr12n0" }, defaultClass: "fyvr12mv" }, buttonInverse: { conditions: { base: "fyvr12n1", active: "fyvr12n2", disabled: "fyvr12n3", focus: "fyvr12n4", hover: "fyvr12n5", checked: "fyvr12n6" }, defaultClass: "fyvr12n1" }, borderNormal: { conditions: { base: "fyvr12n7", active: "fyvr12n8", disabled: "fyvr12n9", focus: "fyvr12na", hover: "fyvr12nb", checked: "fyvr12nc" }, defaultClass: "fyvr12n7" }, borderFocus: { conditions: { base: "fyvr12nd", active: "fyvr12ne", disabled: "fyvr12nf", focus: "fyvr12ng", hover: "fyvr12nh", checked: "fyvr12ni" }, defaultClass: "fyvr12nd" } } }, borderTopStyle: { values: { solid: { conditions: { base: "fyvr12nj", active: "fyvr12nk", disabled: "fyvr12nl", focus: "fyvr12nm", hover: "fyvr12nn", checked: "fyvr12no" }, defaultClass: "fyvr12nj" }, dashed: { conditions: { base: "fyvr12np", active: "fyvr12nq", disabled: "fyvr12nr", focus: "fyvr12ns", hover: "fyvr12nt", checked: "fyvr12nu" }, defaultClass: "fyvr12np" }, dotted: { conditions: { base: "fyvr12nv", active: "fyvr12nw", disabled: "fyvr12nx", focus: "fyvr12ny", hover: "fyvr12nz", checked: "fyvr12o0" }, defaultClass: "fyvr12nv" } } }, border: { values: { none: { conditions: { base: "fyvr12o1", active: "fyvr12o2", disabled: "fyvr12o3", focus: "fyvr12o4", hover: "fyvr12o5", checked: "fyvr12o6" }, defaultClass: "fyvr12o1" } } }, color: { values: { black: { conditions: { base: "fyvr12o7", active: "fyvr12o8", disabled: "fyvr12o9", focus: "fyvr12oa", hover: "fyvr12ob", checked: "fyvr12oc" }, defaultClass: "fyvr12o7" }, white: { conditions: { base: "fyvr12od", active: "fyvr12oe", disabled: "fyvr12of", focus: "fyvr12og", hover: "fyvr12oh", checked: "fyvr12oi" }, defaultClass: "fyvr12od" }, inherit: { conditions: { base: "fyvr12oj", active: "fyvr12ok", disabled: "fyvr12ol", focus: "fyvr12om", hover: "fyvr12on", checked: "fyvr12oo" }, defaultClass: "fyvr12oj" }, transparent: { conditions: { base: "fyvr12op", active: "fyvr12oq", disabled: "fyvr12or", focus: "fyvr12os", hover: "fyvr12ot", checked: "fyvr12ou" }, defaultClass: "fyvr12op" }, positive: { conditions: { base: "fyvr12ov", active: "fyvr12ow", disabled: "fyvr12ox", focus: "fyvr12oy", hover: "fyvr12oz", checked: "fyvr12p0" }, defaultClass: "fyvr12ov" }, negative: { conditions: { base: "fyvr12p1", active: "fyvr12p2", disabled: "fyvr12p3", focus: "fyvr12p4", hover: "fyvr12p5", checked: "fyvr12p6" }, defaultClass: "fyvr12p1" }, info: { conditions: { base: "fyvr12p7", active: "fyvr12p8", disabled: "fyvr12p9", focus: "fyvr12pa", hover: "fyvr12pb", checked: "fyvr12pc" }, defaultClass: "fyvr12p7" }, warning: { conditions: { base: "fyvr12pd", active: "fyvr12pe", disabled: "fyvr12pf", focus: "fyvr12pg", hover: "fyvr12ph", checked: "fyvr12pi" }, defaultClass: "fyvr12pd" }, gradientBackdrop: { conditions: { base: "fyvr12pj", active: "fyvr12pk", disabled: "fyvr12pl", focus: "fyvr12pm", hover: "fyvr12pn", checked: "fyvr12po" }, defaultClass: "fyvr12pj" }, gradientPrimary: { conditions: { base: "fyvr12pp", active: "fyvr12pq", disabled: "fyvr12pr", focus: "fyvr12ps", hover: "fyvr12pt", checked: "fyvr12pu" }, defaultClass: "fyvr12pp" }, gradientSecondary: { conditions: { base: "fyvr12pv", active: "fyvr12pw", disabled: "fyvr12px", focus: "fyvr12py", hover: "fyvr12pz", checked: "fyvr12q0" }, defaultClass: "fyvr12pv" }, arbitrumDark: { conditions: { base: "fyvr12q1", active: "fyvr12q2", disabled: "fyvr12q3", focus: "fyvr12q4", hover: "fyvr12q5", checked: "fyvr12q6" }, defaultClass: "fyvr12q1" }, arbitrumLight: { conditions: { base: "fyvr12q7", active: "fyvr12q8", disabled: "fyvr12q9", focus: "fyvr12qa", hover: "fyvr12qb", checked: "fyvr12qc" }, defaultClass: "fyvr12q7" }, avalanceDark: { conditions: { base: "fyvr12qd", active: "fyvr12qe", disabled: "fyvr12qf", focus: "fyvr12qg", hover: "fyvr12qh", checked: "fyvr12qi" }, defaultClass: "fyvr12qd" }, avalanceLight: { conditions: { base: "fyvr12qj", active: "fyvr12qk", disabled: "fyvr12ql", focus: "fyvr12qm", hover: "fyvr12qn", checked: "fyvr12qo" }, defaultClass: "fyvr12qj" }, bscDark: { conditions: { base: "fyvr12qp", active: "fyvr12qq", disabled: "fyvr12qr", focus: "fyvr12qs", hover: "fyvr12qt", checked: "fyvr12qu" }, defaultClass: "fyvr12qp" }, bscLight: { conditions: { base: "fyvr12qv", active: "fyvr12qw", disabled: "fyvr12qx", focus: "fyvr12qy", hover: "fyvr12qz", checked: "fyvr12r0" }, defaultClass: "fyvr12qv" }, ethereumDark: { conditions: { base: "fyvr12r1", active: "fyvr12r2", disabled: "fyvr12r3", focus: "fyvr12r4", hover: "fyvr12r5", checked: "fyvr12r6" }, defaultClass: "fyvr12r1" }, ethereumLight: { conditions: { base: "fyvr12r7", active: "fyvr12r8", disabled: "fyvr12r9", focus: "fyvr12ra", hover: "fyvr12rb", checked: "fyvr12rc" }, defaultClass: "fyvr12r7" }, gnosisDark: { conditions: { base: "fyvr12rd", active: "fyvr12re", disabled: "fyvr12rf", focus: "fyvr12rg", hover: "fyvr12rh", checked: "fyvr12ri" }, defaultClass: "fyvr12rd" }, gnosisLight: { conditions: { base: "fyvr12rj", active: "fyvr12rk", disabled: "fyvr12rl", focus: "fyvr12rm", hover: "fyvr12rn", checked: "fyvr12ro" }, defaultClass: "fyvr12rj" }, polygonDark: { conditions: { base: "fyvr12rp", active: "fyvr12rq", disabled: "fyvr12rr", focus: "fyvr12rs", hover: "fyvr12rt", checked: "fyvr12ru" }, defaultClass: "fyvr12rp" }, polygonLight: { conditions: { base: "fyvr12rv", active: "fyvr12rw", disabled: "fyvr12rx", focus: "fyvr12ry", hover: "fyvr12rz", checked: "fyvr12s0" }, defaultClass: "fyvr12rv" }, text100: { conditions: { base: "fyvr12s1", active: "fyvr12s2", disabled: "fyvr12s3", focus: "fyvr12s4", hover: "fyvr12s5", checked: "fyvr12s6" }, defaultClass: "fyvr12s1" }, text80: { conditions: { base: "fyvr12s7", active: "fyvr12s8", disabled: "fyvr12s9", focus: "fyvr12sa", hover: "fyvr12sb", checked: "fyvr12sc" }, defaultClass: "fyvr12s7" }, text50: { conditions: { base: "fyvr12sd", active: "fyvr12se", disabled: "fyvr12sf", focus: "fyvr12sg", hover: "fyvr12sh", checked: "fyvr12si" }, defaultClass: "fyvr12sd" }, textInverse100: { conditions: { base: "fyvr12sj", active: "fyvr12sk", disabled: "fyvr12sl", focus: "fyvr12sm", hover: "fyvr12sn", checked: "fyvr12so" }, defaultClass: "fyvr12sj" }, backgroundPrimary: { conditions: { base: "fyvr12sp", active: "fyvr12sq", disabled: "fyvr12sr", focus: "fyvr12ss", hover: "fyvr12st", checked: "fyvr12su" }, defaultClass: "fyvr12sp" }, backgroundSecondary: { conditions: { base: "fyvr12sv", active: "fyvr12sw", disabled: "fyvr12sx", focus: "fyvr12sy", hover: "fyvr12sz", checked: "fyvr12t0" }, defaultClass: "fyvr12sv" }, backgroundContrast: { conditions: { base: "fyvr12t1", active: "fyvr12t2", disabled: "fyvr12t3", focus: "fyvr12t4", hover: "fyvr12t5", checked: "fyvr12t6" }, defaultClass: "fyvr12t1" }, backgroundMuted: { conditions: { base: "fyvr12t7", active: "fyvr12t8", disabled: "fyvr12t9", focus: "fyvr12ta", hover: "fyvr12tb", checked: "fyvr12tc" }, defaultClass: "fyvr12t7" }, backgroundControl: { conditions: { base: "fyvr12td", active: "fyvr12te", disabled: "fyvr12tf", focus: "fyvr12tg", hover: "fyvr12th", checked: "fyvr12ti" }, defaultClass: "fyvr12td" }, backgroundInverse: { conditions: { base: "fyvr12tj", active: "fyvr12tk", disabled: "fyvr12tl", focus: "fyvr12tm", hover: "fyvr12tn", checked: "fyvr12to" }, defaultClass: "fyvr12tj" }, backgroundBackdrop: { conditions: { base: "fyvr12tp", active: "fyvr12tq", disabled: "fyvr12tr", focus: "fyvr12ts", hover: "fyvr12tt", checked: "fyvr12tu" }, defaultClass: "fyvr12tp" }, backgroundOverlay: { conditions: { base: "fyvr12tv", active: "fyvr12tw", disabled: "fyvr12tx", focus: "fyvr12ty", hover: "fyvr12tz", checked: "fyvr12u0" }, defaultClass: "fyvr12tv" }, backgroundRaised: { conditions: { base: "fyvr12u1", active: "fyvr12u2", disabled: "fyvr12u3", focus: "fyvr12u4", hover: "fyvr12u5", checked: "fyvr12u6" }, defaultClass: "fyvr12u1" }, buttonGlass: { conditions: { base: "fyvr12u7", active: "fyvr12u8", disabled: "fyvr12u9", focus: "fyvr12ua", hover: "fyvr12ub", checked: "fyvr12uc" }, defaultClass: "fyvr12u7" }, buttonEmphasis: { conditions: { base: "fyvr12ud", active: "fyvr12ue", disabled: "fyvr12uf", focus: "fyvr12ug", hover: "fyvr12uh", checked: "fyvr12ui" }, defaultClass: "fyvr12ud" }, buttonInverse: { conditions: { base: "fyvr12uj", active: "fyvr12uk", disabled: "fyvr12ul", focus: "fyvr12um", hover: "fyvr12un", checked: "fyvr12uo" }, defaultClass: "fyvr12uj" }, borderNormal: { conditions: { base: "fyvr12up", active: "fyvr12uq", disabled: "fyvr12ur", focus: "fyvr12us", hover: "fyvr12ut", checked: "fyvr12uu" }, defaultClass: "fyvr12up" }, borderFocus: { conditions: { base: "fyvr12uv", active: "fyvr12uw", disabled: "fyvr12ux", focus: "fyvr12uy", hover: "fyvr12uz", checked: "fyvr12v0" }, defaultClass: "fyvr12uv" } } }, cursor: { values: { "default": { conditions: { base: "fyvr12v1", active: "fyvr12v2", disabled: "fyvr12v3", focus: "fyvr12v4", hover: "fyvr12v5", checked: "fyvr12v6" }, defaultClass: "fyvr12v1" }, pointer: { conditions: { base: "fyvr12v7", active: "fyvr12v8", disabled: "fyvr12v9", focus: "fyvr12va", hover: "fyvr12vb", checked: "fyvr12vc" }, defaultClass: "fyvr12v7" }, text: { conditions: { base: "fyvr12vd", active: "fyvr12ve", disabled: "fyvr12vf", focus: "fyvr12vg", hover: "fyvr12vh", checked: "fyvr12vi" }, defaultClass: "fyvr12vd" } } }, opacity: { values: { "0": { conditions: { base: "fyvr12vj", active: "fyvr12vk", disabled: "fyvr12vl", focus: "fyvr12vm", hover: "fyvr12vn", checked: "fyvr12vo" }, defaultClass: "fyvr12vj" }, "50": { conditions: { base: "fyvr12vp", active: "fyvr12vq", disabled: "fyvr12vr", focus: "fyvr12vs", hover: "fyvr12vt", checked: "fyvr12vu" }, defaultClass: "fyvr12vp" }, "80": { conditions: { base: "fyvr12vv", active: "fyvr12vw", disabled: "fyvr12vx", focus: "fyvr12vy", hover: "fyvr12vz", checked: "fyvr12w0" }, defaultClass: "fyvr12vv" }, "100": { conditions: { base: "fyvr12w1", active: "fyvr12w2", disabled: "fyvr12w3", focus: "fyvr12w4", hover: "fyvr12w5", checked: "fyvr12w6" }, defaultClass: "fyvr12w1" } } }, pointerEvents: { values: { none: { conditions: { base: "fyvr12w7", active: "fyvr12w8", disabled: "fyvr12w9", focus: "fyvr12wa", hover: "fyvr12wb", checked: "fyvr12wc" }, defaultClass: "fyvr12w7" }, auto: { conditions: { base: "fyvr12wd", active: "fyvr12we", disabled: "fyvr12wf", focus: "fyvr12wg", hover: "fyvr12wh", checked: "fyvr12wi" }, defaultClass: "fyvr12wd" } } }, outline: { values: { none: { conditions: { base: "fyvr12wj", active: "fyvr12wk", disabled: "fyvr12wl", focus: "fyvr12wm", hover: "fyvr12wn", checked: "fyvr12wo" }, defaultClass: "fyvr12wj" } } }, boxShadow: { values: { none: { conditions: { base: "fyvr12wp", active: "fyvr12wq", disabled: "fyvr12wr", focus: "fyvr12ws", hover: "fyvr12wt", checked: "fyvr12wu" }, defaultClass: "fyvr12wp" } } } } });
const FLEX_PROPS = [
  "alignItems",
  "alignSelf",
  "flexDirection",
  "gap",
  "justifyContent",
  "justifySelf",
  "placeItems"
];
const atoms = (props) => {
  props.display || (props.display = Object.keys(props).some((prop) => FLEX_PROPS.includes(prop)) ? "flex" : void 0);
  return sprinkles(props);
};
atoms.properties = sprinkles.properties;
const truncateAddress = (address, minPrefix = 20, minSuffix = 3) => {
  if (minPrefix + minSuffix >= 40) {
    return address;
  } else {
    return `${address.substring(0, 2 + minPrefix)}${address.substring(address.length - minSuffix)}`;
  }
};
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const SEQUENCE_ASSETS_URL_PREFIX = "https://assets.sequence.info/";
const VERSION$3 = 3;
const sizes = {
  xs: "small",
  sm: "small",
  md: "medium",
  lg: "large",
  xl: "large"
};
const getSize = (size2) => size2 ? sizes[size2] || size2 : "medium";
const replaceSize = (url, size2) => {
  return url.replace(/\/(small|medium|large)\//, `/${getSize(size2)}/`);
};
const tokenImageUrl = (chainId, contractAddress, size2) => {
  return SEQUENCE_ASSETS_URL_PREFIX + `images/tokens/${getSize(size2)}/${chainId}/${contractAddress.toLowerCase()}.webp?v${VERSION$3}`;
};
const nativeTokenImageUrl = (chainId, size2) => tokenImageUrl(chainId, ZERO_ADDRESS, size2);
const networkImageUrl = (chainId, size2) => {
  return SEQUENCE_ASSETS_URL_PREFIX + `images/networks/${getSize(size2)}/${chainId}.webp?v${VERSION$3}`;
};
function r$6(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++)
        e2[t2] && (f2 = r$6(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e2)
        e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx$1() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++)
    (e2 = arguments[f2]) && (t2 = r$6(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const Box = reactExports.forwardRef(
  (props, ref) => {
    const { as = "div", sx = {}, className, ...restProps } = props;
    const atomProps = {};
    const nativeProps = {};
    for (const key2 in restProps) {
      if (atoms.properties.has(key2)) {
        atomProps[key2] = restProps[key2];
      } else {
        nativeProps[key2] = restProps[key2];
      }
    }
    const atomicClasses = atoms({
      ...atomProps,
      ...sx
    });
    return reactExports.createElement(as, {
      className: clsx$1(atomicClasses, className),
      ...nativeProps,
      ref
    });
  }
);
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = React, k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q2(c2, a2, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2)
      m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a2 = c2.defaultProps, a2)
        void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
{
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
}
var jsxRuntimeExports = jsxRuntime.exports;
function toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty$2(obj, key2, value) {
  key2 = toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function mapValues(input2, fn) {
  var result = {};
  for (var _key in input2) {
    result[_key] = fn(input2[_key], _key);
  }
  return result;
}
var shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {
  for (var key2 of Object.keys(compoundCheck)) {
    var _selections$key;
    if (compoundCheck[key2] !== ((_selections$key = selections[key2]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key2])) {
      return false;
    }
  }
  return true;
};
var createRuntimeFn = (config2) => {
  var runtimeFn = (options) => {
    var className = config2.defaultClassName;
    var selections = _objectSpread2(_objectSpread2({}, config2.defaultVariants), options);
    for (var variantName in selections) {
      var _selections$variantNa;
      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config2.defaultVariants[variantName];
      if (variantSelection != null) {
        var selection = variantSelection;
        if (typeof selection === "boolean") {
          selection = selection === true ? "true" : "false";
        }
        var selectionClassName = (
          // @ts-expect-error
          config2.variantClassNames[variantName][selection]
        );
        if (selectionClassName) {
          className += " " + selectionClassName;
        }
      }
    }
    for (var [compoundCheck, compoundClassName] of config2.compoundVariants) {
      if (shouldApplyCompound(compoundCheck, selections, config2.defaultVariants)) {
        className += " " + compoundClassName;
      }
    }
    return className;
  };
  runtimeFn.variants = () => Object.keys(config2.variantClassNames);
  runtimeFn.classNames = {
    get base() {
      return config2.defaultClassName.split(" ")[0];
    },
    get variants() {
      return mapValues(config2.variantClassNames, (classNames) => mapValues(classNames, (className) => className.split(" ")[0]));
    }
  };
  return runtimeFn;
};
createRuntimeFn({ defaultClassName: "_2q9vfj7", variantClassNames: { variant: { info: "_2q9vfj8 _2q9vfj0 fyvr11ov", warning: "_2q9vfj9 _2q9vfj1 fyvr11p1", success: "_2q9vfja _2q9vfj2 fyvr11oj", error: "_2q9vfjb _2q9vfj3 fyvr11op" }, size: { sm: "_2q9vfjc _1qxj1ib9 _1qxj1ibf _1qxj1ib5 fyvr11mv fyvr11ec fyvr11fw fyvr11fs fyvr11f4 _2q9vfj4 fyvr1wo fyvr1yk fyvr13w fyvr1e8", md: "_2q9vfjd _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 _2q9vfj5 fyvr1ws fyvr1yo fyvr140 fyvr1ec", lg: "_2q9vfje _1qxj1ib9 _1qxj1ibd _1qxj1ib3 fyvr11mv fyvr11ek fyvr11g4 fyvr11fo fyvr11fc _2q9vfj6 fyvr1ww fyvr1ys fyvr144 fyvr1eg" } }, defaultVariants: {}, compoundVariants: [] });
const Divider = (props) => {
  const { color: color2 = "borderNormal", marginY = "4", ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: "hr",
      marginY,
      background: color2,
      height: "px",
      borderWidth: "none",
      ...rest
    }
  );
};
var textVariants = createRuntimeFn({ defaultClassName: "_1qxj1ib9", variantClassNames: { variant: { inherit: "_1qxj1iba _1qxj1ib0 fyvr11mu fyvr11e4 fyvr11gg fyvr11fg fyvr11ew", xlarge: "_1qxj1ibb _1qxj1ib1 fyvr11mv fyvr11es fyvr11gc fyvr11fk fyvr11fc", large: "_1qxj1ibc _1qxj1ib2 fyvr11mv fyvr11eo fyvr11g8 fyvr11fo fyvr11f8", medium: "_1qxj1ibd _1qxj1ib3 fyvr11mv fyvr11ek fyvr11g4 fyvr11fo fyvr11fc", normal: "_1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0", small: "_1qxj1ibf _1qxj1ib5 fyvr11mv fyvr11ec fyvr11fw fyvr11fs fyvr11f4", xsmall: "_1qxj1ibg _1qxj1ib6 fyvr11mv fyvr11e8 fyvr11fw fyvr11fs fyvr11fc", code: "_1qxj1ibh _1qxj1ib7 fyvr11mw fyvr11eg fyvr11g0 fyvr11fk fyvr11f0" }, ellipsis: { true: "_1qxj1ibi _1qxj1ib8 fyvr11ls fyvr11m8 fyvr11n9 fyvr11mx" }, italic: { true: "_1qxj1ibj" }, underline: { true: "_1qxj1ibk" }, uppercase: { true: "_1qxj1ibl" }, capitalize: { true: "_1qxj1ibm" }, hidden: { true: "_1qxj1ibn" } }, defaultVariants: {}, compoundVariants: [] });
const Text = reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "span",
      variant = "inherit",
      className,
      hidden,
      italic,
      underline,
      children,
      ellipsis,
      uppercase,
      capitalize: capitalize2,
      ...boxProps
    } = props;
    const textVariantProps = text[variant];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as,
        className: clsx$1(
          className,
          textVariants({
            hidden,
            ellipsis,
            italic,
            underline,
            uppercase,
            capitalize: capitalize2
          })
        ),
        ref,
        ...textVariantProps,
        ...boxProps,
        children
      }
    );
  }
);
var buttonVariants = createRuntimeFn({ defaultClassName: "_140wn8ni _140wn8n0 fyvr11ls fyvr11m8 fyvr11n9 fyvr11ko fyvr12o1 fyvr11n2 fyvr11h0 _4efw240", variantClassNames: { variant: { base: "_140wn8nj _140wn8n1 fyvr11od fyvr12s1", ghost: "_140wn8nk _140wn8n2 fyvr11od fyvr12s1", feature: "_140wn8nl _140wn8n3 fyvr11pj fyvr12od", primary: "_140wn8nm _140wn8n4 fyvr11pd fyvr12od", glass: "_140wn8nn _140wn8n5 fyvr11tv fyvr12s1", emphasis: "_140wn8no _140wn8n6 fyvr11u1 fyvr12s1", raised: "_140wn8np _140wn8n7 fyvr11tp fyvr12s1", danger: "_140wn8nq _140wn8n8 fyvr11op fyvr12od", text: "_140wn8nr _1qxj1ib9 _1qxj1ibf _1qxj1ib5 fyvr11mv fyvr11ec fyvr11fw fyvr11fs fyvr11f4 _140wn8n9 fyvr11cw fyvr11dk fyvr11bk fyvr11c8 fyvr11od fyvr12sd" }, shape: { circle: "_140wn8ns _140wn8na fyvr11dc fyvr11e0 fyvr11c0 fyvr11co", square: "_140wn8nt _140wn8nb fyvr11d0 fyvr11do fyvr11bo fyvr11cc" }, disabled: { true: "_140wn8nu _140wn8nc fyvr12v1 fyvr12vp", false: "_140wn8nv _140wn8nd fyvr12v7 fyvr12w1 fyvr12vz" }, size: { xs: "_140wn8nw _1qxj1ib9 _1qxj1ibg _1qxj1ib6 fyvr11mv fyvr11e8 fyvr11fw fyvr11fs fyvr11fc _140wn8ne fyvr1ws fyvr1yo", sm: "_140wn8nx _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 _140wn8nf fyvr1ww fyvr1ys", md: "_140wn8ny _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 _140wn8ng fyvr1x0 fyvr1yw", lg: "_140wn8nz _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 _140wn8nh fyvr1x0 fyvr1yw" }, iconOnly: { true: "_140wn8n10" }, hasLeftIcon: { true: "_140wn8n11" }, hasRightIcon: { true: "_140wn8n12" }, activeOutline: { light: "_140wn8n13", bold: "_140wn8n14" } }, defaultVariants: {}, compoundVariants: [[{ iconOnly: true, size: "xs" }, "_140wn8n15"], [{ iconOnly: true, size: "sm" }, "_140wn8n16"], [{ iconOnly: true, size: "md" }, "_140wn8n17"], [{ iconOnly: true, size: "lg" }, "_140wn8n18"], [{ iconOnly: false, hasLeftIcon: true, size: "xs" }, "_140wn8n19"], [{ iconOnly: false, hasLeftIcon: true, size: "sm" }, "_140wn8n1a"], [{ iconOnly: false, hasLeftIcon: true, size: "md" }, "_140wn8n1b"], [{ iconOnly: false, hasRightIcon: true, size: "xs" }, "_140wn8n1c"], [{ iconOnly: false, hasRightIcon: true, size: "sm" }, "_140wn8n1d"], [{ iconOnly: false, hasRightIcon: true, size: "md" }, "_140wn8n1e"]] });
const Button = reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "button",
      activeOutline,
      className,
      disabled = false,
      display = "inline-flex",
      fontWeight = "bold",
      pending = false,
      label,
      leftIcon: LeftIcon,
      rightIcon: RightIcon,
      size: size2 = "md",
      variant = "glass",
      width = "fit",
      shape = "circle",
      type = "button",
      ...restProps
    } = props;
    const hasLeftIcon = LeftIcon !== void 0 && label !== void 0;
    const hasRightIcon = RightIcon !== void 0 && label !== void 0;
    const iconOnly = LeftIcon !== void 0 && label === void 0;
    const iconSize = size2 === "xs" ? "xs" : "sm";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as,
        className: clsx$1(
          className,
          buttonVariants({
            activeOutline,
            disabled: disabled || pending,
            hasLeftIcon,
            hasRightIcon,
            iconOnly,
            size: variant === "text" ? void 0 : size2,
            shape: variant === "text" ? void 0 : shape,
            variant
          })
        ),
        disabled: disabled || pending,
        display,
        fontWeight,
        ref,
        type,
        width,
        ...restProps,
        children: iconOnly ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: iconSize }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            width: "full",
            height: "full",
            justifyContent: "space-between",
            alignItems: "center",
            gap: size2 === "xs" ? "1" : "2",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box,
                {
                  justifyContent: "flex-start",
                  alignItems: "center",
                  gap: size2 === "xs" ? "1" : "2",
                  children: [
                    LeftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: iconSize }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: label })
                  ]
                }
              ),
              RightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(RightIcon, { size: iconSize })
            ]
          }
        )
      }
    );
  }
);
var cardVariants = createRuntimeFn({ defaultClassName: "rhmai63", variantClassNames: { clickable: { true: "rhmai64 rhmai60 fyvr11a4 fyvr11ag fyvr11as fyvr11b4 fyvr12vz fyvr12v7 _4efw240" }, disabled: { true: "rhmai65" }, outlined: { true: "rhmai66 rhmai61 fyvr11a8 fyvr11ak fyvr11aw fyvr11b8 fyvr12n7 fyvr12fv fyvr1217 fyvr128j fyvr12nj fyvr12g7 fyvr121j fyvr128v" }, blur: { true: "rhmai67 rhmai62 fyvr11ms" } }, defaultVariants: {}, compoundVariants: [] });
const Card = reactExports.forwardRef(
  (props, ref) => {
    const {
      className,
      children,
      clickable,
      outlined,
      disabled,
      blur: blur2,
      width = "full",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: clsx$1(
          className,
          cardVariants({ clickable, outlined, disabled, blur: blur2 })
        ),
        background: outlined ? "transparent" : "backgroundSecondary",
        overflow: "hidden",
        borderRadius: "md",
        padding: "4",
        width,
        ref,
        ...rest,
        children
      }
    );
  }
);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContext2(rootComponentName, defaultContext) {
  const Context = reactExports.createContext(defaultContext);
  function Provider2(props) {
    const { children, ...context2 } = props;
    const value = reactExports.useMemo(() => context2, Object.values(context2));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
  }
  function useContext2(consumerName) {
    const context2 = reactExports.useContext(Context);
    if (context2)
      return context2;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider2.displayName = rootComponentName + "Provider";
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts2 = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts2.length;
    defaultContexts2 = [...defaultContexts2, defaultContext];
    function Provider2(props) {
      const { scope, children, ...context2 } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(() => context2, Object.values(context2));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context2 = reactExports.useContext(Context);
      if (context2)
        return context2;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope2 = () => {
    const scopeContexts = defaultContexts2.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope2.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope2, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope2 = () => {
    const scopeHooks = scopes.map((createScope22) => ({
      useScope: createScope22(),
      scopeName: createScope22.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope2.scopeName = baseScope.scopeName;
  return createScope2;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop)
          handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
function usePrevious(value) {
  const ref = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
function useStateMachine(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef$1(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          reactDomExports.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      if (node2)
        stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef$1(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var Slot = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1)
          return reactExports.Children.only(null);
        return reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (reactExports.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return reactExports.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return reactExports.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    reactDomExports.flushSync(() => target.dispatchEvent(event));
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name: name2,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      ...checkboxProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    const initialCheckedStateRef = reactExports.useRef(checked);
    reactExports.useEffect(() => {
      const form = button == null ? void 0 : button.form;
      if (form) {
        const reset2 = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset2);
        return () => form.removeEventListener("reset", reset2);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate$1(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState$4(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Enter")
              event.preventDefault();
          }),
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate$1(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$2,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME$3 = "CheckboxIndicator";
var CheckboxIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context2 = useCheckboxContext(INDICATOR_NAME$3, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isIndeterminate$1(context2.state) || context2.state === true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$4(context2.state),
        "data-disabled": context2.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef,
        style: { pointerEvents: "none", ...props.style }
      }
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME$3;
var BubbleInput$2 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  reactExports.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input2.indeterminate = isIndeterminate$1(checked);
      setChecked.call(input2, isIndeterminate$1(checked) ? false : checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: isIndeterminate$1(checked) ? false : checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function isIndeterminate$1(checked) {
  return checked === "indeterminate";
}
function getState$4(checked) {
  return isIndeterminate$1(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root$8 = Checkbox$1;
var Indicator$2 = CheckboxIndicator;
var labelVariants = createRuntimeFn({ defaultClassName: "_43lu9r4", variantClassNames: { labelLocation: { top: "_43lu9r5 _43lu9r0 fyvr11kw fyvr11i4 fyvr118k fyvr11h0", left: "_43lu9r6 _43lu9r1 fyvr11ko fyvr11ic fyvr118k fyvr11h0", right: "_43lu9r7 _43lu9r2 fyvr11ko fyvr11ic fyvr118k fyvr11h0", hidden: "_43lu9r8 _43lu9r3 fyvr1188 fyvr11h0" } }, defaultVariants: {}, compoundVariants: [] });
const Field$1 = (props) => {
  const {
    id: id2,
    label,
    description: description2,
    labelLocation = "top",
    children,
    ...rest
  } = props;
  const renderLabel = () => label || description2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flexDirection: "column", gap: "0.5", children: [
    label && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        variant: "small",
        color: "text100",
        hidden: labelLocation === "hidden",
        children: label
      }
    ),
    description2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        variant: "small",
        color: "text50",
        hidden: labelLocation === "hidden",
        children: description2
      }
    )
  ] }) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      as: "label",
      className: labelVariants({ labelLocation }),
      htmlFor: id2,
      ...rest,
      children: [
        ["left", "top", "hidden"].includes(labelLocation) && renderLabel(),
        children,
        labelLocation === "right" && renderLabel()
      ]
    }
  );
};
var iconVariants = createRuntimeFn({ defaultClassName: "_1dizidw0", variantClassNames: { size: { xs: "_1dizidw1", sm: "_1dizidw2", md: "_1dizidw3", lg: "_1dizidw4", xl: "_1dizidw5" } }, defaultVariants: {}, compoundVariants: [] });
const Svg$17 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M11.168 9.25V2.929h-1.5V9.25h-6.32v1.5h6.32v6.321h1.5V10.75h6.321v-1.5h-6.32Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgAddIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$17,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$13 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m10.888 14.47 1.06 1.06L17.48 10l-5.53-5.53-1.06 1.06 3.719 3.72H4.418v1.5h10.19l-3.72 3.72Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgArrowRightIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$13,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$11 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        stroke: "currentColor",
        strokeWidth: 1.5,
        d: "m4.304 10.232 4.263 4.79 7.13-11.238"
      }
    )
  }
);
const SvgCheckmarkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$11,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$10 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m3.888 7.53 1.06-1.06 5.47 5.47 5.47-5.47 1.06 1.06-6.53 6.53-6.53-6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronDownIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$10,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$$ = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m12.888 3.47 1.06 1.06L8.48 10l5.47 5.47-1.061 1.06L6.358 10l6.53-6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronLeftIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$$,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$_ = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m7.949 16.53-1.061-1.06 5.47-5.47-5.47-5.47 1.06-1.06L14.48 10l-6.53 6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronRightIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$_,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$Y = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m10.418 11.06 4.47 4.47 1.06-1.06L11.48 10l4.47-4.47-1.06-1.06-4.47 4.47-4.47-4.47-1.06 1.06L9.357 10l-4.47 4.47 1.06 1.06 4.47-4.47Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCloseIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$Y,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$U = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M14.918 4.5h-6V6h4.5v6.5h1.5v-8Zm-1.5 9.5v3h-9V6h3V3h9v11h-3Zm-7.5 1.5v-8h6v8h-6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCopyIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$U,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$T = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M5 6.714 3.618 3.547H2.5L4.158 7.02H2.98v.69h1.494v.663H2.981v.69h1.494v1.484h1.036V9.063h1.46v-.69h-1.46v-.66l.001-.003h1.46v-.69h-1.13L7.5 3.547H6.383L5 6.714Zm4.747 8.232v-.788a2.887 2.887 0 0 1-1.04-.249 2.04 2.04 0 0 1-.863-.727 2.213 2.213 0 0 1-.344-1.125h1.017c.02.26.098.476.236.65.14.171.319.299.535.383.144.054.297.09.46.109V10.81l-.319-.093c-.538-.157-.964-.388-1.28-.693-.312-.304-.469-.707-.469-1.209 0-.415.105-.777.315-1.086.21-.31.495-.55.853-.72.273-.133.573-.215.9-.246v-.817h.537v.81c.365.023.692.106.981.249.35.17.626.406.827.706.201.298.306.64.315 1.027h-.978a1.04 1.04 0 0 0-.433-.774 1.47 1.47 0 0 0-.712-.264v2.253l.283.079c.214.056.434.132.659.228a2.6 2.6 0 0 1 .627.38c.192.157.347.351.466.583.12.232.18.51.18.834 0 .407-.098.77-.295 1.086a2.006 2.006 0 0 1-.85.749c-.304.15-.66.239-1.07.265v.79h-.538Zm1.024-1.877c-.148.064-.31.106-.486.128v-2.23c.216.064.41.136.584.218.193.089.345.201.457.337.113.136.17.31.17.524 0 .234-.065.44-.194.615-.129.174-.306.31-.531.408ZM9.747 7.706v2.095a4.605 4.605 0 0 1-.246-.086 2.195 2.195 0 0 1-.4-.207 1.038 1.038 0 0 1-.299-.313.847.847 0 0 1-.111-.443.94.94 0 0 1 .164-.545c.112-.162.268-.288.47-.38.126-.059.267-.099.422-.12Zm7.677 10.086h-4.9v-.897h.34a.342.342 0 0 0 .29-.186c.068-.117.114-.254.137-.411.023-.16.032-.304.028-.432l-.027-.779H12.5v-.896h.76l-.043-1.262c-.018-.472.073-.866.273-1.183.203-.317.473-.555.809-.715.335-.16.697-.24 1.084-.24.346 0 .656.056.931.166.278.11.511.26.7.452.191.188.328.404.41.647.081.243.097.498.048.766l-1.01-.156c.023-.22-.014-.403-.11-.55a.891.891 0 0 0-.395-.33 1.31 1.31 0 0 0-1.102.024c-.177.09-.322.227-.434.411-.11.185-.164.42-.164.708l.048 1.261h1.649v.897H14.34l.029.752c.014.29-.025.55-.116.78-.04.1-.096.193-.166.276h3.337v.897Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCurrencyIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$T,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$K = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M15.01 6.1H4.99L10 9.68 15.01 6.1ZM3.5 6.88v7.22h13V6.88L10 11.521 3.5 6.88ZM2 15.6v-11h16v11H2Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgEmailIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$K,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$C = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.918 10a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0Zm1.5 0a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-9 1.469v.133h1.48v-.133c.003-.255.036-.47.098-.645a1.3 1.3 0 0 1 .293-.46c.133-.134.303-.261.508-.384.245-.145.457-.308.637-.488.18-.182.319-.39.418-.625.101-.237.152-.508.152-.812 0-.456-.113-.845-.34-1.168a2.131 2.131 0 0 0-.937-.739c-.399-.171-.857-.257-1.375-.257-.471 0-.902.084-1.293.254-.39.166-.704.42-.941.761-.237.339-.362.768-.375 1.29h1.593c.008-.214.06-.393.157-.536a.917.917 0 0 1 .37-.328 1.06 1.06 0 0 1 .481-.113c.175 0 .333.036.477.11a.858.858 0 0 1 .347.312.863.863 0 0 1 .13.472c0 .17-.039.323-.114.461-.076.136-.177.26-.305.371a3.69 3.69 0 0 1-.433.325 2.69 2.69 0 0 0-.555.453c-.154.166-.27.385-.352.656-.078.27-.118.634-.12 1.09Zm.106 2.36a.917.917 0 0 0 .668.273c.166 0 .32-.042.46-.125.141-.086.255-.2.34-.34a.897.897 0 0 0-.149-1.129.907.907 0 0 0-.651-.274.917.917 0 0 0-.668.274.882.882 0 0 0-.27.656.899.899 0 0 0 .27.664Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgHelpIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$C,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$x = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeWidth: 1.5,
          d: "M10.906 8.966c1.459 1.316 1.459 3.45 0 4.765l-2.53 2.282c-1.459 1.316-3.824 1.316-5.282 0-1.459-1.315-1.459-3.449 0-4.764l1.265-1.142"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeWidth: 1.5,
          d: "M8.094 11c-1.459-1.316-1.459-3.449 0-4.765l2.53-2.282c1.459-1.316 3.823-1.316 5.282 0s1.459 3.449 0 4.765l-1.265 1.14"
        }
      )
    ]
  }
);
const SvgLinkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$x,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$r = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M13.283 6.175a4.643 4.643 0 1 0-6.566 6.567l-.708.707a5.644 5.644 0 1 1 7.982 0l-.708-.707a4.644 4.644 0 0 0 0-6.567Zm-5.097 1.47a2.565 2.565 0 0 1 3.628 3.627l.707.707a3.565 3.565 0 1 0-5.042 0l.707-.707a2.565 2.565 0 0 1 0-3.627ZM10 10.959a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm0 .667-1.5 6h3l-1.5-6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgNetworkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$r,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$p = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.899 5.261a1 1 0 0 1 1 1v.729H2.102v2.055h15.797v4.694a1 1 0 0 1-1 1H3.102a1 1 0 0 1-1-1V6.261a1 1 0 0 1 1-1h13.797Zm-7.13 7.284h7v1h-7v-1Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgPaymentsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$p,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$m = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M6.418 3.6h-2.5v2.5h2.5V3.6Zm0-1.5h1.5v5.5h-5.5V2.1h4Zm0 12h-2.5v2.5h2.5v-2.5Zm0-1.5h1.5v5.5h-5.5v-5.5h4Zm8-9h2.5v2.5h-2.5V3.6Zm4-1.5h-5.5v5.5h5.5V2.1Zm-1.5 12h-2.5v2.5h2.5v-2.5Zm0-1.5h1.5v5.5h-5.5v-5.5h4ZM9.668 2.1v7.25h-7.25v1.5h8.75V2.1h-1.5Zm1.5 10.5v5.5h-1.5v-5.5h1.5Zm1.75-1.75h5.5v-1.5h-5.5v1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgQrCodeIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$m,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$h = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M13.918 9.5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-.677 4.383a5.5 5.5 0 1 1 1.06-1.06l2.648 2.647-1.061 1.06-2.647-2.647Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSearchIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$h,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$g = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M11.529 15.925 9.419 11 4.493 8.89 2.418 8l2.142-.714 11.08-3.693L17.418 3l-.593 1.779-3.693 11.08L12.418 18l-.89-2.075Zm-1.71-6.386L6.635 8.175l6.82-2.273-3.638 3.637Zm1.06 1.061 1.364 3.183 2.273-6.82L10.88 10.6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSendIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$g,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$e = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M12.775 5.204a5.465 5.465 0 0 0-1.341-.537L11 2.5H9l-.443 2.214c-.444.128-.866.31-1.257.54L5.404 3.99 3.99 5.404l1.283 1.925c-.212.38-.38.787-.497 1.216L2.5 9v2l2.276.455c.118.429.285.836.497 1.216L3.99 14.596l1.414 1.414L7.3 14.746c.391.23.813.412 1.257.54L9 17.5h2l.434-2.167c.474-.12.925-.302 1.341-.537l1.821 1.214 1.414-1.414-1.195-1.793c.253-.427.45-.891.581-1.382L17.5 11V9l-2.104-.42a5.467 5.467 0 0 0-.581-1.383l1.195-1.793-1.414-1.414-1.82 1.214Zm-.59 2.692a2.976 2.976 0 1 0-4.208 4.208 2.976 2.976 0 0 0 4.209-4.208Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSettingsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$e,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$d = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M4 6.234a.5.5 0 0 0-.5.5v8a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5V10.5L14 9v5.734a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h5.769l-1.516 1.5H4Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: 1.25, d: "M11 3h5v5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: 1.5, d: "m16 3-8 8" })
    ]
  }
);
const SvgShareIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$d,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$b = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M9.418 3.25h-5.75v13.5h5.75v-1.5h-4.25V4.75h4.25v-1.5Zm4.53 11.28-1.06-1.06 2.72-2.72h-8.19v-1.5h8.19l-2.72-2.72 1.06-1.06L18.48 10l-4.53 4.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSignoutIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$b,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$a = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.539 10.75H4.298v-1.5h12.24v1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSubtractIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$a,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$7 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m12.28 2.856-6.71 8.887h4.134l-1.424 6.2 6.887-8.71h-4.322l1.435-6.377Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgTransactionIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$7,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
var checkboxVariants = createRuntimeFn({ defaultClassName: "_1c9x66f1 _1c9x66f0 fyvr11a8 fyvr11ak fyvr11aw fyvr11b8 fyvr11cw fyvr11dk fyvr11bk fyvr11c8 fyvr12nd fyvr12g1 fyvr121d fyvr128p fyvr12nj fyvr12g7 fyvr121j fyvr128v fyvr11h0 fyvr11ko fyvr11jg fyvr11od fyvr12w1 fyvr12vz fyvr12vr fyvr12v7 fyvr12v3 _4efw240", variantClassNames: { size: { sm: "_1c9x66f2", lg: "_1c9x66f3" } }, defaultVariants: {}, compoundVariants: [] });
var indicator$1 = "_1c9x66f4 fyvr12s1 fyvr11h0 fyvr11ko fyvr11jg fyvr128 fyvr15o";
const Indicator$1 = ({ size: size2 = "sm" }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator$2, { className: indicator$1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckmarkIcon, { size: size2 === "lg" ? "sm" : "xs" }) });
reactExports.forwardRef(
  (props, ref) => {
    const {
      disabled = false,
      id: id2,
      name: name2,
      label = "",
      labelLocation = "left",
      size: size2 = "sm",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$1,
      {
        disabled,
        display: "flex",
        id: id2 ?? name2,
        label,
        labelLocation,
        whiteSpace: "nowrap",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$8,
          {
            className: checkboxVariants({ size: size2 }),
            disabled,
            id: id2 ?? name2,
            name: name2,
            ref,
            ...rest,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator$1, { size: size2 })
          }
        )
      }
    );
  }
);
React.createContext(null);
var useReactId = $2AODx$react["useId".toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId(),
        open,
        onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-state": getState$3(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible$1.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME$5 = "CollapsibleTrigger";
var CollapsibleTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context2 = useCollapsibleContext(TRIGGER_NAME$5, __scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-controls": context2.contentId,
        "aria-expanded": context2.open || false,
        "data-state": getState$3(context2.open),
        "data-disabled": context2.disabled ? "" : void 0,
        disabled: context2.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, context2.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME$5;
var CONTENT_NAME$7 = "CollapsibleContent";
var CollapsibleContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context2 = useCollapsibleContext(CONTENT_NAME$7, props.__scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME$7;
var CollapsibleContentImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context2 = useCollapsibleContext(CONTENT_NAME$7, __scopeCollapsible);
  const [isPresent, setIsPresent] = reactExports.useState(present);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const heightRef = reactExports.useRef(0);
  const height = heightRef.current;
  const widthRef = reactExports.useRef(0);
  const width = widthRef.current;
  const isOpen = context2.open || isPresent;
  const isMountAnimationPreventedRef = reactExports.useRef(isOpen);
  const originalStylesRef = reactExports.useRef();
  reactExports.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect2(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context2.open, present]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-state": getState$3(context2.open),
      "data-disabled": context2.disabled ? "" : void 0,
      id: context2.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState$3(open) {
  return open ? "open" : "closed";
}
var Root$7 = Collapsible$1;
var Trigger$5 = CollapsibleTrigger;
var Content$3 = CollapsibleContent;
var COLLAPSED_HEIGHT = "64px";
var root$4 = "_4j62fl0";
var trigger$1 = "_4j62fl2 _4j62fl1 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg fyvr1t4 fyvr1v0 fyvr1ww fyvr1ys fyvr11h0 fyvr11ko fyvr11od fyvr128 fyvr12v7 fyvr11n4 _4efw240";
var content$3 = "_4j62fl4 _4j62fl3 fyvr1ww fyvr1ys fyvr1so fyvr1v0 fyvr128";
var icon = "_4j62fl5";
const Collapsible = (props) => {
  const {
    className,
    children,
    defaultOpen,
    open,
    onOpenChange,
    label,
    ...rest
  } = props;
  const [expanded, toggleExpanded] = reactExports.useState(defaultOpen);
  const isOpen = open ?? expanded;
  const handleSetExpanded = (isExpanded) => {
    if (open !== void 0) {
      return;
    }
    toggleExpanded(isExpanded);
  };
  const handleOpenChange = (isOpen2) => {
    handleSetExpanded(isOpen2);
    onOpenChange == null ? void 0 : onOpenChange(isOpen2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root$7,
    {
      open: isOpen,
      defaultOpen,
      onOpenChange: handleOpenChange,
      asChild: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          as: motion.div,
          className: clsx$1(className, root$4),
          initial: { height: isOpen ? "auto" : COLLAPSED_HEIGHT },
          animate: { height: isOpen ? "auto" : COLLAPSED_HEIGHT },
          transition: { ease: "easeOut", duration: 0.3 },
          borderRadius: "md",
          background: "backgroundSecondary",
          position: "relative",
          overflow: "hidden",
          width: "full",
          ...rest,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Trigger$5, { className: trigger$1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "div", variant: "normal", fontWeight: "bold", color: "text80", children: label }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  as: motion.div,
                  position: "absolute",
                  right: "0",
                  marginRight: "4",
                  initial: { rotate: isOpen ? 180 : 0 },
                  animate: { rotate: isOpen ? 180 : 0 },
                  transition: { ease: "linear", duration: 0.1 },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgChevronDownIcon, { className: icon, color: "text50" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content$3,
              {
                className: content$3,
                asChild: true,
                forceMount: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.div,
                  {
                    initial: { opacity: isOpen ? 1 : 0 },
                    animate: { opacity: 1 },
                    exit: { opacity: 0 },
                    transition: { ease: "easeOut", duration: 0.3 },
                    children
                  }
                )
              }
            ) })
          ]
        }
      )
    }
  );
};
function createCollection(name2) {
  const PROVIDER_NAME2 = name2 + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name2 + "CollectionSlot";
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context2 = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context2.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name2 + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context2 = useCollectionContext(ITEM_SLOT_NAME, scope);
      React.useEffect(() => {
        context2.itemMap.set(ref, { ref, ...itemData });
        return () => void context2.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context2 = useCollectionContext(name2 + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context2.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context2.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context2.collectionRef, context2.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context2 = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context2.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context2.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context2.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context2.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context2.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch)
        return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context2.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node)
        return;
      if (disableOutsidePointerEvents) {
        if (context2.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context2.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context2.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context2.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context2]);
    reactExports.useEffect(() => {
      return () => {
        if (!node)
          return;
        context2.layers.delete(node);
        context2.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context2]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context2 = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context2.branches.add(node);
      return () => {
        context2.branches.delete(node);
      };
    }
  }, [context2.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name2, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root$6 = DismissableLayer;
var Branch = DismissableLayerBranch;
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$3(removeLinks(getTabbableCandidates$1(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$3(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates$1(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a2;
      stack = arrayRemove(stack, focusScope);
      (_a2 = stack[0]) == null ? void 0 : _a2.resume();
    }
  };
}
function arrayRemove(array, item2) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item2);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item2) => item2.tagName !== "A");
}
const sides$1 = ["top", "right", "bottom", "left"];
const min$1 = Math.min;
const max$1 = Math.max;
const round$1 = Math.round;
const floor$1 = Math.floor;
const createCoords$1 = (v3) => ({
  x: v3,
  y: v3
});
const oppositeSideMap$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap$1 = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max$1(start, min$1(value, end));
}
function evaluate$1(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide$1(placement) {
  return placement.split("-")[0];
}
function getAlignment$1(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis$1(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength$1(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis$1(placement) {
  return ["top", "bottom"].includes(getSide$1(placement)) ? "y" : "x";
}
function getAlignmentAxis$1(placement) {
  return getOppositeAxis$1(getSideAxis$1(placement));
}
function getAlignmentSides$1(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment$1(placement);
  const alignmentAxis = getAlignmentAxis$1(placement);
  const length = getAxisLength$1(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement$1(mainAlignmentSide)];
}
function getExpandedPlacements$1(placement) {
  const oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeAlignmentPlacement$1(placement), oppositePlacement, getOppositeAlignmentPlacement$1(oppositePlacement)];
}
function getOppositeAlignmentPlacement$1(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap$1[alignment]);
}
function getSideList$1(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements$1(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment$1(placement);
  let list2 = getSideList$1(getSide$1(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement$1));
    }
  }
  return list2;
}
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap$1[side]);
}
function expandPaddingObject$1(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getPaddingObject$1(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject$1(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect$1(rect) {
  const {
    x,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x,
    right: x + width,
    bottom: y2 + height,
    x,
    y: y2
  };
}
function computeCoordsFromPlacement$1(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis$1(placement);
  const alignmentAxis = getAlignmentAxis$1(placement);
  const alignLength = getAxisLength$1(alignmentAxis);
  const side = getSide$1(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment$1(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement$1(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement$1(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate$1(options, state);
  const paddingObject = getPaddingObject$1(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect$1(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect$1(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$4 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding: padding2 = 0
    } = evaluate$1(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject$1(padding2);
    const coords = {
      x,
      y: y2
    };
    const axis = getAlignmentAxis$1(placement);
    const length = getAxisLength$1(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);
    const min$1$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment$1(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide$1(placement);
      const initialSideAxis = getSideAxis$1(initialPlacement);
      const isBasePlacement = getSide$1(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements$1(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements$1(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides$1(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis$1(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets$1(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped$1(overflow) {
  return sides$1.some((side) => overflow[side] >= 0);
}
const hide$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets$1(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped$1(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets$1(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped$1(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords$1(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide$1(placement);
  const alignment = getAlignment$1(placement);
  const isVertical = getSideAxis$1(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate$1(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords$1(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y22
            } = _ref;
            return {
              x: x2,
              y: y22
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      const coords = {
        x,
        y: y2
      };
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const crossAxis = getSideAxis$1(getSide$1(placement));
      const mainAxis = getOppositeAxis$1(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
const limitShift$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate$1(options, state);
      const coords = {
        x,
        y: y2
      };
      const crossAxis = getSideAxis$1(placement);
      const mainAxis = getOppositeAxis$1(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate$1(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide$1(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate$1(options, state);
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const side = getSide$1(placement);
      const alignment = getAlignment$1(placement);
      const isYAxis = getSideAxis$1(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min$1(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min$1(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min$1(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max$1(overflow.left, 0);
        const xMax = max$1(overflow.right, 0);
        const yMin = max$1(overflow.top, 0);
        const yMax = max$1(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getNodeName$1(node) {
  if (isNode$3(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement$1(node) {
  var _ref;
  return (_ref = (isNode$3(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode$3(value) {
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement$1(value) {
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement$1(value) {
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot$1(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
function isOverflowElement$1(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].includes(getNodeName$1(element));
}
function isTopLayer$1(element) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element.matches(selector2);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock$1(element) {
  const webkit = isWebKit$1();
  const css = getComputedStyle$1$1(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock$1(element) {
  let currentNode = getParentNode$1(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode$1(currentNode)) {
    if (isTopLayer$1(currentNode)) {
      return null;
    }
    if (isContainingBlock$1(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode$1(currentNode);
  }
  return null;
}
function isWebKit$1() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode$1(node) {
  return ["html", "body", "#document"].includes(getNodeName$1(node));
}
function getComputedStyle$1$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll$1(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode$1(node) {
  if (getNodeName$1(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot$1(node) && node.host || // Fallback.
    getDocumentElement$1(node)
  );
  return isShadowRoot$1(result) ? result.host : result;
}
function getNearestOverflowAncestor$1(node) {
  const parentNode = getParentNode$1(node);
  if (isLastTraversableNode$1(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement$1(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor$1(parentNode);
}
function getOverflowAncestors$1(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor$1(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement$1(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors$1(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors$1(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions$1(element) {
  const css = getComputedStyle$1$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round$1(width) !== offsetWidth || round$1(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement$1(element) {
  return !isElement$1(element) ? element.contextElement : element;
}
function getScale$1(element) {
  const domElement = unwrapElement$1(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords$1(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions$1(domElement);
  let x = ($ ? round$1(rect.width) : rect.width) / width;
  let y2 = ($ ? round$1(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x,
    y: y2
  };
}
const noOffsets$1 = /* @__PURE__ */ createCoords$1(0);
function getVisualOffsets$1(element) {
  const win = getWindow$1(element);
  if (!isWebKit$1() || !win.visualViewport) {
    return noOffsets$1;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets$1(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect$1(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement$1(element);
  let scale2 = createCoords$1(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale2 = getScale$1(offsetParent);
      }
    } else {
      scale2 = getScale$1(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets$1(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets$1(domElement) : createCoords$1(0);
  let x = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale$1(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y2 += top;
      currentWin = getWindow$1(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect$1({
    width,
    height,
    x,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect$1(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement$1(offsetParent);
  const topLayer = elements ? isTopLayer$1(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords$1(1);
  const offsets = createCoords$1(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || isOverflowElement$1(documentElement)) {
      scroll2 = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent);
      scale2 = getScale$1(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll2.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll2.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects$1(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getNodeScroll$1(element).scrollLeft;
}
function getDocumentRect$1(element) {
  const html = getDocumentElement$1(element);
  const scroll2 = getNodeScroll$1(element);
  const body = element.ownerDocument.body;
  const width = max$1(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max$1(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll2.scrollLeft + getWindowScrollBarX$1(element);
  const y2 = -scroll2.scrollTop;
  if (getComputedStyle$1$1(body).direction === "rtl") {
    x += max$1(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getViewportRect$1(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement$1(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit$1();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getInnerBoundingClientRect$1(element, strategy) {
  const clientRect = getBoundingClientRect$1(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement$1(element) ? getScale$1(element) : createCoords$1(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect$1(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect$1(getDocumentElement$1(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect$1(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets$1(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect$1(rect);
}
function hasFixedPositionAncestor$1(element, stopNode) {
  const parentNode = getParentNode$1(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode$1(parentNode)) {
    return false;
  }
  return getComputedStyle$1$1(parentNode).position === "fixed" || hasFixedPositionAncestor$1(parentNode, stopNode);
}
function getClippingElementAncestors$1(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors$1(element, [], false).filter((el2) => isElement$1(el2) && getNodeName$1(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode$1(element) : element;
  while (isElement$1(currentNode) && !isLastTraversableNode$1(currentNode)) {
    const computedStyle = getComputedStyle$1$1(currentNode);
    const currentNodeIsContaining = isContainingBlock$1(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement$1(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor$1(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode$1(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect$1(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer$1(element) ? [] : getClippingElementAncestors$1(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor$1(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions$1(element) {
  const {
    width,
    height
  } = getCssDimensions$1(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent$1(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect$1(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords$1(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || isOverflowElement$1(documentElement)) {
      scroll2 = getNodeScroll$1(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  const x = rect.left + scroll2.scrollLeft - offsets.x;
  const y2 = rect.top + scroll2.scrollTop - offsets.y;
  return {
    x,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned$1(element) {
  return getComputedStyle$1$1(element).position === "static";
}
function getTrueOffsetParent$1(element, polyfill2) {
  if (!isHTMLElement$1(element) || getComputedStyle$1$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  return element.offsetParent;
}
function getOffsetParent$1(element, polyfill2) {
  const win = getWindow$1(element);
  if (isTopLayer$1(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode$1(element);
    while (svgOffsetParent && !isLastTraversableNode$1(svgOffsetParent)) {
      if (isElement$1(svgOffsetParent) && !isStaticPositioned$1(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode$1(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent$1(element, polyfill2);
  while (offsetParent && isTableElement$1(offsetParent) && isStaticPositioned$1(offsetParent)) {
    offsetParent = getTrueOffsetParent$1(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode$1(offsetParent) && isStaticPositioned$1(offsetParent) && !isContainingBlock$1(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock$1(element) || win;
}
const getElementRects$1 = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent$1;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent$1(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL$1(element) {
  return getComputedStyle$1$1(element).direction === "rtl";
}
const platform$1 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect$1,
  getDocumentElement: getDocumentElement$1,
  getClippingRect: getClippingRect$1,
  getOffsetParent: getOffsetParent$1,
  getElementRects: getElementRects$1,
  getClientRects: getClientRects$1,
  getDimensions: getDimensions$1,
  getScale: getScale$1,
  isElement: isElement$1,
  isRTL: isRTL$1
};
function observeMove$1(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement$1(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor$1(top);
    const insetRight = floor$1(root2.clientWidth - (left + width));
    const insetBottom = floor$1(root2.clientHeight - (top + height));
    const insetLeft = floor$1(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate$1(reference, floating, update5, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement$1(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors$1(referenceEl) : [], ...getOverflowAncestors$1(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update5, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update5);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove$1(referenceEl, update5) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update5();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect$1(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect$1(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update5();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update5();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update5);
      ancestorResize && ancestor.removeEventListener("resize", update5);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1$1 = offset$2$1;
const shift$1$1 = shift$2$1;
const flip$1$1 = flip$2$1;
const size$1$1 = size$2$1;
const hide$1$1 = hide$2$1;
const arrow$3$1 = arrow$4;
const limitShift$1$1 = limitShift$2$1;
const computePosition$2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform: platform$1,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$4$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$2(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual$2(a2[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key2 = keys[i];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual$2(a2[key2], b2[key2])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR$1(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR$1(element, value) {
  const dpr = getDPR$1(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = reactExports.useRef(value);
  index$4$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual$2(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const platformRef = useLatestRef$1(platform2);
  const update5 = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition$2(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual$2(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$4$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$4$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$4$1(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update5);
      }
      update5();
    }
  }, [referenceEl, floatingEl, update5, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR$1(elements.floating, data.x);
    const y2 = roundByDPR$1(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y2 + "px)",
        ...getDPR$1(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update: update5,
    refs,
    elements,
    floatingStyles
  }), [data, update5, refs, elements, floatingStyles]);
}
const arrow$1$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding: padding2
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$3$1({
            element: element.current,
            padding: padding2
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$3$1({
          element,
          padding: padding2
        }).fn(state);
      }
      return {};
    }
  };
};
const offset$3 = (options, deps) => ({
  ...offset$1$1(options),
  options: [options, deps]
});
const shift$3 = (options, deps) => ({
  ...shift$1$1(options),
  options: [options, deps]
});
const limitShift$3 = (options, deps) => ({
  ...limitShift$1$1(options),
  options: [options, deps]
});
const flip$3 = (options, deps) => ({
  ...flip$1$1(options),
  options: [options, deps]
});
const size$6 = (options, deps) => ({
  ...size$1$1(options),
  options: [options, deps]
});
const hide$3 = (options, deps) => ({
  ...hide$1$1(options),
  options: [options, deps]
});
const arrow$2$1 = (options, deps) => ({
  ...arrow$1$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root$5 = Arrow$1;
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context2 = usePopperContext(ANCHOR_NAME$1, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context2.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$6 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$6);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context2 = usePopperContext(CONTENT_NAME$6, __scopePopper);
    const [content2, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow2, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow2);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating$1({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate$1(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context2.anchor
      },
      middleware: [
        offset$3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift$3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift$3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip$3({ ...detectOverflowOptions }),
        size$6({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle2 = elements.floating.style;
            contentStyle2.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle2.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle2.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle2.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow2 && arrow$2$1({ element: arrow2, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide$3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
    const arrowY = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content2)
        setContentZIndex(window.getComputedStyle(content2).zIndex);
    }, [content2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d2 = middlewareData.transformOrigin) == null ? void 0 : _d2.x,
            (_e2 = middlewareData.transformOrigin) == null ? void 0 : _e2.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f2 = middlewareData.hide) == null ? void 0 : _f2.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$6;
var ARROW_NAME$4 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$4, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$5,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$4;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a2, _b2, _c2;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$5 = Popper;
var Anchor = PopperAnchor;
var Content$2 = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$4 = "Portal";
var Portal$3 = reactExports.forwardRef((props, forwardedRef) => {
  var _a2;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
  return container ? $7SXl2$reactdom.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$3.displayName = PORTAL_NAME$4;
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$3 = "RovingFocusGroup";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(GROUP_NAME$3);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$3,
  [createCollectionScope$3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
var RovingFocusGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$3(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: reactExports.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item2) => item2.focusable);
                const activeItem = items.find((item2) => item2.active);
                const currentItem = items.find((item2) => item2.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item2) => item2.ref.current);
                focusFirst$2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$4 = "RovingFocusGroupItem";
var RovingFocusGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      ...itemProps
    } = props;
    const autoId = useId();
    const id2 = tabStopId || autoId;
    const context2 = useRovingFocusContext(ITEM_NAME$4, __scopeRovingFocusGroup);
    const isCurrentTabStop = context2.currentTabStopId === id2;
    const getItems = useCollection$3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context2;
    reactExports.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context2.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable)
                event.preventDefault();
              else
                context2.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context2.onItemFocus(id2)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context2.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget)
                return;
              const focusIntent = getFocusIntent(event, context2.orientation, context2.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey)
                  return;
                event.preventDefault();
                const items = getItems().filter((item2) => item2.focusable);
                let candidateNodes = items.map((item2) => item2.ref.current);
                if (focusIntent === "last")
                  candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev")
                    candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context2.loop ? wrapArray$2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$2(candidateNodes));
              }
            })
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$4;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key2, dir) {
  if (dir !== "rtl")
    return key2;
  return key2 === "ArrowLeft" ? "ArrowRight" : key2 === "ArrowRight" ? "ArrowLeft" : key2;
}
function getFocusIntent(event, orientation, dir) {
  const key2 = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key2))
    return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key2))
    return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key2];
}
function focusFirst$2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray$2(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root$4 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
var getDefaultParent$1 = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap$1 = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes$1 = /* @__PURE__ */ new WeakMap();
var markerMap$1 = {};
var lockCount$1 = 0;
var unwrapHost$1 = function(node) {
  return node && (node.host || unwrapHost$1(node.parentNode));
};
var correctTargets$1 = function(parent2, targets) {
  return targets.map(function(target) {
    if (parent2.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost$1(target);
    if (correctedTarget && parent2.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent2, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers$1 = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets$1(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap$1[markerName]) {
    markerMap$1[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap$1[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent2) {
    if (!parent2 || elementsToStop.has(parent2)) {
      return;
    }
    Array.prototype.forEach.call(parent2.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap$1.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap$1.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes$1.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount$1++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap$1.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap$1.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes$1.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes$1.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount$1--;
    if (!lockCount$1) {
      counterMap$1 = /* @__PURE__ */ new WeakMap();
      counterMap$1 = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes$1 = /* @__PURE__ */ new WeakMap();
      markerMap$1 = {};
    }
  };
};
var hideOthers$1 = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent$1(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers$1(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign$2 = function() {
  __assign$2 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
function __rest$1(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __spreadArray(to, from, pack2) {
  for (var i = 0, l2 = from.length, ar; i < l2; i++) {
    if (ar || !(i in from)) {
      if (!ar)
        ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var zeroRightClassName$1 = "right-scroll-bar-position";
var fullWidthClassName$1 = "width-before-scroll-bar";
var noScrollbarsClassName$1 = "with-scroll-bars-hidden";
var removedBarSizeVariable$1 = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef$2(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues$1 = /* @__PURE__ */ new WeakMap();
function useMergeRefs$1(refs, defaultValue) {
  var callbackRef = useCallbackRef$2(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues$1.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef$1(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef$1(ref, current_1);
        }
      });
    }
    currentValues$1.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI$1(a2) {
  return a2;
}
function innerCreateMedium$1(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI$1;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item2 = middleware(data, assigned);
      buffer2.push(item2);
      return function() {
        buffer2 = buffer2.filter(function(x) {
          return x !== item2;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
      }
      buffer2 = {
        push: function(x) {
          return cb2(x);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium$1(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium$1(null);
  medium.options = __assign$2({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest$1(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign$2({}, rest));
};
SideCar$1$1.isSideCarExport = true;
function exportSidecar$1(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1$1;
}
var effectCar$1 = createSidecarMedium$1();
var nothing$1 = function() {
  return;
};
var RemoveScroll$1 = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing$1,
    onWheelCapture: nothing$1,
    onTouchMoveCapture: nothing$1
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest$1(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs$1([ref, parentRef]);
  var containerProps = __assign$2(__assign$2({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar$1, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$2(__assign$2({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign$2({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName$1,
  zeroRight: zeroRightClassName$1
};
var getNonce$1 = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag$1() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce$1();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles$1(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag$1(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton$1 = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag$1()) {
          injectStyles$1(stylesheet, style);
          insertStyleTag$1(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton$1 = function() {
  var sheet = stylesheetSingleton$1();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton$1 = function() {
  var useStyle2 = styleHookSingleton$1();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle2(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap$1 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$3 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset$1 = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$3(left), parse$3(top), parse$3(right)];
};
var getGapWidth$1 = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap$1;
  }
  var offsets = getOffset$1(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style$1 = styleSingleton$1();
var lockAttribute$1 = "data-scroll-locked";
var getStyles$1 = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName$1, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute$1, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName$1, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName$1, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName$1, " .").concat(zeroRightClassName$1, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName$1, " .").concat(fullWidthClassName$1, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute$1, "] {\n    ").concat(removedBarSizeVariable$1, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter$1 = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute$1) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute$1 = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute$1, (getCurrentUseCounter$1() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter$1() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute$1);
      } else {
        document.body.setAttribute(lockAttribute$1, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar$1 = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute$1();
  var gap = reactExports.useMemo(function() {
    return getGapWidth$1(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style$1, { styles: getStyles$1(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported$1 = false;
if (typeof window !== "undefined") {
  try {
    var options$1 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported$1 = true;
        return true;
      }
    });
    window.addEventListener("test", options$1, options$1);
    window.removeEventListener("test", options$1, options$1);
  } catch (err) {
    passiveSupported$1 = false;
  }
}
var nonPassive$1 = passiveSupported$1 ? { passive: false } : false;
var alwaysContainsScroll$1 = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled$1 = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll$1(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled$1 = function(node) {
  return elementCanBeScrolled$1(node, "overflowY");
};
var elementCouldBeHScrolled$1 = function(node) {
  return elementCanBeScrolled$1(node, "overflowX");
};
var locationCouldBeScrolled$1 = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled$1(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables$1(axis, current), s2 = _a2[1], d2 = _a2[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables$1 = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables$1 = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled$1 = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled$1(node) : elementCouldBeHScrolled$1(node);
};
var getScrollVariables$1 = function(axis, node) {
  return axis === "v" ? getVScrollVariables$1(node) : getHScrollVariables$1(node);
};
var getDirectionFactor$1 = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll$1 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor$1(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables$1(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled$1(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY$1 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY$1 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef$1 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare$1 = function(x, y2) {
  return x[0] === y2[0] && x[1] === y2[1];
};
var generateStyle$1 = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter$1 = 0;
var lockStack$1 = [];
function RemoveScrollSideCar$1(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter$1++)[0];
  var Style2 = reactExports.useState(styleSingleton$1)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef$1)).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent2) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY$1(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll$1(cancelingAxis, parent2, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack$1.length || lockStack$1[lockStack$1.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY$1(event) : getTouchXY$1(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare$1(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef$1).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY$1(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack$1.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive$1);
    document.addEventListener("touchmove", shouldPrevent, nonPassive$1);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive$1);
    return function() {
      lockStack$1 = lockStack$1.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive$1);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle$1(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar$1, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar$2 = exportSidecar$1(effectCar$1, RemoveScrollSideCar$1);
var ReactRemoveScroll$1 = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll$1, __assign$2({}, props, { ref, sideCar: SideCar$2 }));
});
ReactRemoveScroll$1.classNames = RemoveScroll$1.classNames;
var SELECTION_KEYS$1 = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS$1, "ArrowRight"],
  rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope$2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$2 = createPopperScope();
var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$2(__scopeMenu);
  const [content2, setContent] = reactExports.useState(null);
  const isUsingKeyboardRef = reactExports.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  reactExports.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content: content2,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: reactExports.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME = "MenuAnchor";
var MenuAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME;
var PORTAL_NAME$3 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context2 = useMenuContext(PORTAL_NAME$3, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$3;
var CONTENT_NAME$5 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$5);
var MenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      const content2 = ref.current;
      if (content2)
        return hideOthers$1(content2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context2.open,
        disableOutsidePointerEvents: context2.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context2.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = reactExports.forwardRef((props, forwardedRef) => {
  const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context2.onOpenChange(false)
    }
  );
});
var MenuContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context2 = useMenuContext(CONTENT_NAME$5, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, __scopeMenu);
    const popperScope = usePopperScope$2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const getItems = useCollection$2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = reactExports.useState(null);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context2.onContentChange);
    const timerRef = reactExports.useRef(0);
    const searchRef = reactExports.useRef("");
    const pointerGraceTimerRef = reactExports.useRef(0);
    const pointerGraceIntentRef = reactExports.useRef(null);
    const pointerDirRef = reactExports.useRef("right");
    const lastPointerXRef = reactExports.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll$1 : reactExports.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key2) => {
      var _a2, _b2;
      const search2 = searchRef.current + key2;
      const items = getItems().filter((item2) => !item2.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a2 = items.find((item2) => item2.ref.current === currentItem)) == null ? void 0 : _a2.textValue;
      const values = items.map((item2) => item2.textValue);
      const nextMatch = getNextMatch(values, search2, currentMatch);
      const newItem = (_b2 = items.find((item2) => item2.textValue === nextMatch)) == null ? void 0 : _b2.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search2);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    reactExports.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
      var _a2, _b2;
      const isMovingTowards = pointerDirRef.current === ((_a2 = pointerGraceIntentRef.current) == null ? void 0 : _a2.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b2 = pointerGraceIntentRef.current) == null ? void 0 : _b2.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event))
              event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: reactExports.useCallback(
          (event) => {
            var _a2;
            if (isPointerMovingToSubmenu(event))
              return;
            (_a2 = contentRef.current) == null ? void 0 : _a2.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event))
              event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: reactExports.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a2;
              event.preventDefault();
              (_a2 = contentRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$4,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current)
                        event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content$2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context2.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab")
                              event.preventDefault();
                            if (!isModifierKey && isCharacterKey)
                              handleTypeaheadSearch(event.key);
                          }
                          const content2 = contentRef.current;
                          if (event.target !== content2)
                            return;
                          if (!FIRST_LAST_KEYS.includes(event.key))
                            return;
                          event.preventDefault();
                          const items = getItems().filter((item2) => !item2.disabled);
                          const candidateNodes = items.map((item2) => item2.ref.current);
                          if (LAST_KEYS.includes(event.key))
                            candidateNodes.reverse();
                          focusFirst$1(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$5;
var GROUP_NAME$2 = "MenuGroup";
var MenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel";
var MenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = reactExports.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$3, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$3, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = reactExports.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a2;
          (_a2 = props.onPointerDown) == null ? void 0 : _a2.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          var _a2;
          if (!isPointerDownRef.current)
            (_a2 = event.currentTarget) == null ? void 0 : _a2.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ")
            return;
          if (SELECTION_KEYS$1.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$3;
var MenuItemImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$3, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const [textContent, setTextContent] = reactExports.useState("");
    reactExports.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item2 = event.currentTarget;
                    item2.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem";
var MenuCheckboxItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$2 = "MenuRadioGroup";
var [RadioGroupProvider$1, useRadioGroupContext$1] = createMenuContext(
  RADIO_GROUP_NAME$2,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider$1, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
var RADIO_ITEM_NAME$1 = "MenuRadioItem";
var MenuRadioItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context2 = useRadioGroupContext$1(RADIO_ITEM_NAME$1, props.__scopeMenu);
    const checked = value === context2.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a2;
            return (_a2 = context2.onValueChange) == null ? void 0 : _a2.call(context2, value);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME$1,
  { checked: false }
);
var MenuItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "MenuSeparator";
var MenuSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$3 = "MenuArrow";
var MenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var SUB_TRIGGER_NAME$1 = "MenuSubTrigger";
var MenuSubTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useMenuContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const openTimerRef = reactExports.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = reactExports.useCallback(() => {
      if (openTimerRef.current)
        window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    reactExports.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    reactExports.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context2.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context2.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a2;
          (_a2 = props.onClick) == null ? void 0 : _a2.call(props, event);
          if (props.disabled || event.defaultPrevented)
            return;
          event.currentTarget.focus();
          if (!context2.open)
            context2.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented)
              return;
            if (!props.disabled && !context2.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context2.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            var _a2, _b2;
            clearOpenTimer();
            const contentRect = (_a2 = context2.content) == null ? void 0 : _a2.getBoundingClientRect();
            if (contentRect) {
              const side = (_b2 = context2.content) == null ? void 0 : _b2.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented)
                return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a2;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ")
            return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context2.onOpenChange(true);
            (_a2 = context2.content) == null ? void 0 : _a2.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent";
var MenuSubContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context2 = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$1, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a2;
          if (rootContext.isUsingKeyboardRef.current)
            (_a2 = ref.current) == null ? void 0 : _a2.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger)
            context2.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a2;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context2.onOpenChange(false);
            (_a2 = subContext.trigger) == null ? void 0 : _a2.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$1(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function wrapArray$1(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search2, currentMatch) {
  const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
  const normalizedSearch = isRepeated ? search2[0] : search2;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray$1(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v3) => v3 !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point3, polygon) {
  const { x, y: y2 } = point3;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi2 = polygon[i].x;
    const yi2 = polygon[i].y;
    const xj2 = polygon[j2].x;
    const yj2 = polygon[j2].y;
    const intersect = yi2 > y2 !== yj2 > y2 && x < (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$1 = Menu;
var Anchor2 = MenuAnchor;
var Portal$2 = MenuPortal;
var Content2$3 = MenuContent;
var Group$1 = MenuGroup;
var Label = MenuLabel;
var Item2$2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup$2 = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow2$2 = MenuArrow;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = reactExports.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$1, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$4 = "DropdownMenuTrigger";
var DropdownMenuTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context2 = useDropdownMenuContext(TRIGGER_NAME$4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        id: context2.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context2.open,
        "aria-controls": context2.open ? context2.contentId : void 0,
        "data-state": context2.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context2.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context2.onOpenToggle();
            if (!context2.open)
              event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled)
            return;
          if (["Enter", " "].includes(event.key))
            context2.onOpenToggle();
          if (event.key === "ArrowDown")
            context2.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key))
            event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger$1.displayName = TRIGGER_NAME$4;
var PORTAL_NAME$2 = "DropdownMenuPortal";
var DropdownMenuPortal$1 = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { ...menuScope, ...portalProps });
};
DropdownMenuPortal$1.displayName = PORTAL_NAME$2;
var CONTENT_NAME$4 = "DropdownMenuContent";
var DropdownMenuContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context2 = useDropdownMenuContext(CONTENT_NAME$4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$3,
      {
        id: context2.contentId,
        "aria-labelledby": context2.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          if (!hasInteractedOutsideRef.current)
            (_a2 = context2.triggerRef.current) == null ? void 0 : _a2.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context2.modal || isRightClick)
            hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent$1.displayName = CONTENT_NAME$4;
var GROUP_NAME$1 = "DropdownMenuGroup";
var DropdownMenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group$1, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "DropdownMenuLabel";
var DropdownMenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$2 = "DropdownMenuItem";
var DropdownMenuItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem$1.displayName = ITEM_NAME$2;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME$1 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup$2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup$1.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME$2 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator$1.displayName = INDICATOR_NAME$2;
var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
var DropdownMenuSeparator$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator$1.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$2 = "DropdownMenuArrow";
var DropdownMenuArrow$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow$1.displayName = ARROW_NAME$2;
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME;
var CheckboxItem2 = DropdownMenuCheckboxItem$1;
var RadioItem2 = DropdownMenuRadioItem$1;
var ItemIndicator2 = DropdownMenuItemIndicator$1;
var item = "_1k2mbvi4 _1k2mbvi3 fyvr11cw fyvr11dk fyvr11bk fyvr11c8 fyvr1x4 fyvr1yk fyvr1ss fyvr1uo fyvr12ws fyvr12wm fyvr11h0 fyvr11ko fyvr11jw fyvr12v7 fyvr11n4 fyvr11hw fyvr12s7";
var indicator = "_1k2mbvi5";
const DropdownMenuItemIndicator = ({
  children
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { className: indicator, children });
reactExports.forwardRef(({ className, children, ...rest }, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CheckboxItem2,
    {
      className: clsx$1(item, className),
      ...rest,
      ref: forwardedRef,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckmarkIcon, { size: "xs" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", children })
      ]
    }
  );
});
reactExports.forwardRef(({ className, children, ...rest }, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    RadioItem2,
    {
      className: clsx$1(item, className),
      ...rest,
      ref: forwardedRef,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { className: indicator, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", children })
      ]
    }
  );
});
const IconButton = reactExports.forwardRef(
  (props, ref) => {
    const { icon: icon2, size: size2 = "md", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        leftIcon: icon2,
        size: size2,
        flexShrink: "0",
        ref,
        ...rest
      }
    );
  }
);
const useCombinedRefs = (...refs) => (element) => refs.forEach((ref) => {
  if (!ref) {
    return;
  }
  if (typeof ref === "function") {
    ref(element);
  } else {
    ref.current = element;
  }
});
var wrap$1 = "_1hq71vk1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 _1hq71vk0 fyvr11a8 fyvr11ak fyvr11aw fyvr11b8 fyvr1t4 fyvr1v0 fyvr1ww fyvr1ys fyvr12n7 fyvr12fv fyvr1217 fyvr128j fyvr12np fyvr12gd fyvr121p fyvr1291 fyvr11ko fyvr11hc fyvr11ic fyvr11jc fyvr1g0 fyvr11hw";
var wrapVariants$1 = createRuntimeFn({ defaultClassName: "_1hq71vk5", variantClassNames: { borderRadius: { xs: "_1hq71vk6 _1hq71vk2 fyvr11cw fyvr11dk fyvr11bk fyvr11c8", sm: "_1hq71vk7 _1hq71vk3 fyvr11d0 fyvr11do fyvr11bo fyvr11cc", md: "_1hq71vk8 _1hq71vk4 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg" } }, defaultVariants: {}, compoundVariants: [] });
var input$1 = "_1hq71vka _1hq71vk9 fyvr12wp fyvr12wj fyvr11ho fyvr12vj fyvr1ko fyvr1oo fyvr1mo fyvr1qo";
const MIME_TYPES = {
  png: ".png,image/png",
  jpeg: ".jpeg,image/jpeg",
  jpg: ".jpg,image/jpg",
  images: "image/*, video/*",
  pdf: ".pdf,application/pdf",
  mp4: ".mp4,video/mp4",
  csv: ".csv,text/csv",
  json: ".json,application/json"
};
reactExports.forwardRef(
  (props, ref) => {
    const {
      borderRadius = "md",
      description: description2,
      disabled = false,
      id: id2,
      label = "",
      labelLocation = "hidden",
      name: name2,
      onValueChange,
      placeholder = "Upload a file",
      validExtensions,
      ...rest
    } = props;
    const inputRef = reactExports.useRef(null);
    const combinedRef = useCombinedRefs(inputRef, ref);
    const [fileData, setFileData] = reactExports.useState(null);
    const handleChange = (e2) => {
      const filelist = e2.currentTarget.files;
      if (!filelist || !filelist[0]) {
        return;
      }
      const file = filelist[0];
      const filename = file.name;
      const filesize = file.size / 1e3;
      setFileData({
        name: filename,
        size: filesize,
        extension: filename.split(".").pop() ?? ""
      });
      onValueChange == null ? void 0 : onValueChange(file);
    };
    const accept = validExtensions.map((ext) => MIME_TYPES[ext]).join(",");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$1,
      {
        description: description2,
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            width: "full",
            minWidth: "0",
            justifyContent: fileData ? "space-between" : "flex-start",
            gap: "2",
            color: fileData ? "text100" : "text50",
            className: clsx$1(wrap$1, wrapVariants$1({ borderRadius })),
            children: [
              fileData ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flexDirection: "row", gap: "2", alignItems: "center", minWidth: "0", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ellipsis: true, children: fileData.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { color: "text50", variant: "xsmall", whiteSpace: "nowrap", children: [
                  fileData.size.toFixed(2),
                  " kb"
                ] })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ellipsis: true, children: placeholder }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  accept,
                  as: "input",
                  className: input$1,
                  cursor: "pointer",
                  disabled,
                  id: id2 ?? name2,
                  name: name2,
                  onChange: handleChange,
                  ref: combinedRef,
                  type: "file",
                  ...rest
                }
              ),
              fileData && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  cursor: "pointer",
                  icon: SvgCloseIcon,
                  size: "xs",
                  onClick: (ev) => {
                    var _a2;
                    ev.preventDefault();
                    ev.stopPropagation();
                    ((_a2 = inputRef.current) == null ? void 0 : _a2.value) && (inputRef.current.value = "");
                    onValueChange == null ? void 0 : onValueChange(null);
                    setFileData(null);
                  },
                  zIndex: "10"
                }
              )
            ]
          }
        )
      }
    );
  }
);
var avatar = createRuntimeFn({ defaultClassName: "_1bhyzin0", variantClassNames: { size: { xs: "_1bhyzin1", sm: "_1bhyzin2", md: "_1bhyzin3", lg: "_1bhyzin4", xl: "_1bhyzin5" } }, defaultVariants: {}, compoundVariants: [] });
const MOD = 1e3;
const SIZE = 64;
const RADIUS = SIZE / 2;
const scaledMod = (value, mod2 = MOD) => {
  return value % mod2 / (MOD / SIZE);
};
const cyrb53 = (str, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch2; i < str.length; i++) {
    ch2 = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch2, 2654435761);
    h2 = Math.imul(h2 ^ ch2, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
const createGradient = (a2, b2, c2) => {
  const hueA = a2 % 360;
  const hueB = (a2 + 120) % 360;
  const hueC = c2 % 360;
  return {
    a: `hsl(${hueA}deg 100% 40%)`,
    b: `hsl(${hueB}deg 100% 50%)`,
    c: `hsl(${hueC}deg 100% 50%)`
  };
};
const createGradients = (address, complexity) => {
  const hashes = [];
  for (let i = 0; i < complexity; i++) {
    const offset2 = i * 6;
    hashes.push({
      a: cyrb53(address + "a", offset2),
      b: cyrb53(address + "b", offset2 + 1),
      c: cyrb53(address + "c", offset2 + 2),
      x: cyrb53(address + "d", offset2 + 3),
      y: cyrb53(address + "e", offset2 + 4),
      r: cyrb53(address + "f", offset2 + 5)
    });
  }
  return hashes.map((hash2, idx) => {
    const r2 = SIZE / 10 + scaledMod(hash2.r, MOD * 1.5 / (idx + 1));
    return {
      ...createGradient(hash2.a, hash2.b, hash2.c),
      x: scaledMod(hash2.x),
      //clampGradientPosition(hash.x % SIZE, -r / 3),
      y: scaledMod(hash2.y),
      //clampGradientPosition(hash.y % SIZE, -r / 3),
      r: r2
    };
  });
};
const GradientAvatar = reactExports.memo((props) => {
  const { className, address, size: size2 = "md", complexity = 1, ...rest } = props;
  const gradients = createGradients(address, complexity);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      as: "svg",
      className: clsx$1(className, avatar({ size: size2 })),
      viewBox: `0 0 ${SIZE} ${SIZE}`,
      version: "1.1",
      flexShrink: "0",
      borderRadius: "circle",
      overflow: "hidden",
      xmlns: "http://www.w3.org/2000/svg",
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "circle-clip", children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: RADIUS, cy: RADIUS, r: RADIUS }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "filter",
            {
              id: "blur",
              x: "-10%",
              y: "-10%",
              width: "120%",
              height: "120%",
              filterUnits: "userSpaceOnUse",
              colorInterpolationFilters: "sRGB",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "feBlend",
                  {
                    mode: "normal",
                    in: "SourceGraphic",
                    in2: "BackgroundImageFix",
                    result: "shape"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "feGaussianBlur",
                  {
                    stdDeviation: SIZE / 10,
                    result: "effect1_foregroundBlur"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "linearGradient",
            {
              id: `gradient-background-${address}`,
              x1: "0",
              y1: "0",
              x2: "1",
              y2: "1",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradients[0].c }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradients[0].a })
              ]
            }
          ),
          gradients.map((gradient, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: `gradient-primary-${address}-${idx}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradient.a }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradient.b })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: `gradient-secondary-${address}-${idx}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradient.c }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradient.b })
            ] })
          ] }, idx))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#circle-clip)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              width: "100%",
              height: "100%",
              fill: `url(#gradient-background-${address})`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { filter: "url(#blur)", children: gradients.map((gradient, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                fill: `url(#gradient-primary-${address}-${idx})`,
                cx: gradient.x,
                cy: gradient.y,
                r: gradient.r
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                fill: `url(#gradient-secondary-${address}-${idx})`,
                cx: gradient.y,
                cy: gradient.x,
                r: gradient.r / 2
              }
            )
          ] }, idx)) })
        ] })
      ]
    }
  );
});
const Image$1 = (props) => {
  const { disableAnimation = false, onLoad, ...rest } = props;
  const [isImageLoaded, setImageLoaded] = reactExports.useState(false);
  const handleLoad = (ev) => {
    setImageLoaded(true);
    onLoad == null ? void 0 : onLoad(ev);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: motion.img,
      initial: disableAnimation ? void 0 : { opacity: 0 },
      animate: disableAnimation ? void 0 : { opacity: isImageLoaded ? 1 : 0 },
      transition: { duration: 0.2 },
      onLoad: disableAnimation ? void 0 : handleLoad,
      ...rest
    }
  );
};
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$3 = "DialogTrigger";
var DialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context2 = useDialogContext(TRIGGER_NAME$3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context2.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context2.open,
        "aria-controls": context2.contentId,
        "data-state": getState$2(context2.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context2.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$1 = "DialogPortal";
var [PortalProvider$1, usePortalContext$1] = createDialogContext(PORTAL_NAME$1, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context2 = useDialogContext(PORTAL_NAME$1, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME$1;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context2 = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context2 = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll$1, { as: Slot, allowPinchZoom: true, shards: [context2.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$2(context2.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$3 = "DialogContent";
var DialogContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context2 = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME$3;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context2.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content2 = contentRef.current;
      if (content2)
        return hideOthers$1(content2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context2.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          (_a2 = context2.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              (_b2 = context2.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context2.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context2 = useDialogContext(CONTENT_NAME$3, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context2.contentId,
              "aria-describedby": context2.descriptionId,
              "aria-labelledby": context2.titleId,
              "data-state": getState$2(context2.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context2.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context2.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context2.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$1 = "DialogTitle";
var DialogTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context2 = useDialogContext(TITLE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context2.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "DialogDescription";
var DialogDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context2 = useDialogContext(DESCRIPTION_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context2.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME$1;
var CLOSE_NAME$1 = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context2 = useDialogContext(CLOSE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context2.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$1;
function getState$2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$3,
  titleName: TITLE_NAME$1,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    var _a2;
    const describedById = (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$3 = Dialog;
var Portal$1 = DialogPortal;
var Overlay = DialogOverlay;
var Content$1 = DialogContent;
var Close$1 = DialogClose;
var scroll = createRuntimeFn({ defaultClassName: "_1vqx0w91 _1vqx0w90 fyvr128 fyvr15o", variantClassNames: { direction: { vertical: "_1vqx0w92", horizontal: "_1vqx0w93" } }, defaultVariants: {}, compoundVariants: [] });
var overlay$1 = createRuntimeFn({ defaultClassName: "_1vqx0w94", variantClassNames: { shadows: { true: "_1vqx0w95", false: "_1vqx0w96" }, direction: { vertical: "_1vqx0w97", horizontal: "_1vqx0w98" } }, defaultVariants: {}, compoundVariants: [] });
const Scroll = (props) => {
  const {
    children,
    shadows = true,
    direction = "vertical",
    contentProps,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: overlay$1({ direction, shadows }),
      position: "relative",
      width: "full",
      height: "full",
      ...rest,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          className: scroll({ direction }),
          background: "backgroundPrimary",
          ...contentProps,
          children
        }
      )
    }
  );
};
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  if (matches) {
    return matches[1];
  }
  return variable;
}
function get$1(obj, path) {
  var result = obj;
  for (var key2 of path) {
    if (!(key2 in result)) {
      throw new Error("Path ".concat(path.join(" -> "), " does not exist in object"));
    }
    result = result[key2];
  }
  return result;
}
function walkObject(obj, fn) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var clone = {};
  for (var key2 in obj) {
    var _value = obj[key2];
    var currentPath = [...path, key2];
    if (typeof _value === "string" || typeof _value === "number" || _value == null) {
      clone[key2] = fn(_value, currentPath);
    } else if (typeof _value === "object" && !Array.isArray(_value)) {
      clone[key2] = walkObject(_value, fn, currentPath);
    } else {
      console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
    }
  }
  return clone;
}
function setVar(element, variable, value) {
  element.style.setProperty(getVarName(variable), value);
}
function setElementVars(element, varsOrContract, tokens2) {
  if (typeof tokens2 === "object") {
    var _contract = varsOrContract;
    walkObject(tokens2, (value2, path) => {
      if (value2 == null) {
        return;
      }
      setVar(element, get$1(_contract, path), String(value2));
    });
  } else {
    var _vars = varsOrContract;
    for (var varName in _vars) {
      var value = _vars[varName];
      if (value == null) {
        continue;
      }
      setVar(element, varName, _vars[varName]);
    }
  }
}
const THEMES = ["dark", "light"];
const DEFAULT_THEME = "dark";
const THEME_ATTR = "data-theme";
const STORAGE_KEY = "@sequence.theme";
const isTheme = (theme) => THEMES.includes(theme);
const isThemeOverrides = (theme) => typeof theme === "object" && theme !== null && !Array.isArray(theme);
const getStorageKey = (scope) => scope ? `${STORAGE_KEY}.${scope}` : STORAGE_KEY;
const getTheme = (scope) => {
  const persistedTheme = localStorage.getItem(
    getStorageKey(scope)
  );
  if (persistedTheme && THEMES.includes(persistedTheme)) {
    return persistedTheme;
  }
  return DEFAULT_THEME;
};
const ThemeContext = reactExports.createContext(null);
const ThemeProvider = (props) => {
  const [theme, setTheme] = reactExports.useState(
    props.theme || DEFAULT_THEME
  );
  reactExports.useEffect(() => {
    /Mac/.test(window.navigator.userAgent) && window.document.documentElement.classList.add("is-apple");
  }, []);
  reactExports.useEffect(() => {
    if (!props.theme) {
      setTheme(getTheme(props.scope));
    }
  }, [props.theme, props.scope]);
  reactExports.useEffect(() => {
    if (props.theme) {
      setTheme(props.theme);
    }
  }, [props.theme]);
  reactExports.useEffect(() => {
    const rootEl = document.querySelector(props.root || ":root");
    if (rootEl) {
      if (isTheme(theme)) {
        rootEl.setAttribute(THEME_ATTR, theme);
        setElementVars(rootEl, colorSchemeVars, {
          colors: colors[theme]
        });
      } else if (isThemeOverrides(theme)) {
        setElementVars(rootEl, colorSchemeVars, {
          colors: theme
        });
      }
    }
  }, [theme, props.root]);
  const value = reactExports.useMemo(() => {
    return {
      theme,
      root: props.root,
      setTheme: (mode) => {
        if (THEMES.includes(mode)) {
          localStorage.setItem(getStorageKey(props.scope), mode);
          setTheme(mode);
        }
      }
    };
  }, [theme, props.root, props.scope]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, { value, children: props.children });
};
const useTheme$1 = () => {
  const context2 = reactExports.useContext(ThemeContext);
  if (!context2) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context2;
};
var root$3 = "_5b32m91 _5b32m90 fyvr11jg fyvr11ko fyvr11h0 fyvr11hs fyvr11nk fyvr1ko fyvr1oo fyvr1qo fyvr1mo";
var overlay = "_5b32m93 _5b32m92 fyvr11hs fyvr1ko fyvr1oo fyvr1qo fyvr1mo";
var contentVariants = createRuntimeFn({ defaultClassName: "_5b32m95 _5b32m94 fyvr11d8 fyvr11dw fyvr11bg fyvr11by fyvr11c4 fyvr11cm fyvr11ls fyvr11m8 fyvr12ws fyvr12wm fyvr11h0 fyvr11i4 fyvr11hs fyvr11sd fyvr1mo fyvr1om", variantClassNames: { size: { sm: "_5b32m96", lg: "_5b32m97" }, autoHeight: { true: "_5b32m98" } }, defaultVariants: {}, compoundVariants: [[{ autoHeight: true, size: "lg" }, "_5b32m99"]] });
var close = "_5b32m9b _5b32m9a fyvr110o fyvr112o fyvr114o fyvr116o fyvr11ho fyvr1qo fyvr1ko fyvr11nk";
const Modal = (props) => {
  const {
    autoHeight = false,
    backdropColor = "backgroundBackdrop",
    // gradientBackdrop for onboarding or special modals
    children,
    disableAnimation = false,
    isDismissible = true,
    onClose,
    scroll: scroll2 = true,
    size: size2 = "lg",
    overlayProps,
    contentProps
  } = props;
  const { root: root2 } = useTheme$1();
  const [container, setContainer] = reactExports.useState(null);
  reactExports.useEffect(() => {
    setContainer(document.querySelector(root2 || "body"));
  }, [root2]);
  return container ? /* @__PURE__ */ jsxRuntimeExports.jsx(Root$3, { modal: true, defaultOpen: true, onOpenChange: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { forceMount: true, container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: root$3, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as: Overlay,
        asChild: true,
        background: backdropColor,
        className: overlay,
        forceMount: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: disableAnimation ? false : { opacity: 0 },
            animate: disableAnimation ? false : { opacity: 1 },
            exit: disableAnimation ? void 0 : { opacity: 0 },
            transition: {
              type: "tween",
              ease: "linear"
            },
            ...overlayProps
          },
          "modal-overlay"
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content$1,
      {
        asChild: true,
        className: contentVariants({ autoHeight, size: size2 }),
        forceMount: true,
        onEscapeKeyDown: (ev) => {
          if (isDismissible) {
            onClose == null ? void 0 : onClose();
          } else {
            ev.preventDefault();
          }
        },
        onInteractOutside: (ev) => {
          if (!isDismissible) {
            ev.preventDefault();
          }
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            initial: disableAnimation ? false : { y: "100%", opacity: size2 === "sm" ? 0 : 1 },
            animate: disableAnimation ? false : { y: 0, opacity: size2 === "sm" ? 1 : 1 },
            exit: disableAnimation ? void 0 : { y: "100%", opacity: size2 === "sm" ? 0 : 1 },
            transition: { type: "tween", ease: "easeOut" },
            ...contentProps,
            children: [
              scroll2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Scroll, { children }) : children,
              isDismissible && /* @__PURE__ */ jsxRuntimeExports.jsx(Close$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  icon: SvgCloseIcon,
                  backdropFilter: "blur",
                  size: "xs",
                  className: close,
                  "aria-label": "Close"
                }
              ) })
            ]
          },
          "modal-content"
        )
      }
    )
  ] }) }) }) : null;
};
var wrap$2 = "_1acm19y1 _1acm19y0 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg fyvr1ww fyvr1ys fyvr11hc fyvr11ko fyvr11od fyvr12s1 fyvr1g0 fyvr118g";
var wrapVariants = createRuntimeFn({ defaultClassName: "_1acm19y5", variantClassNames: { borderRadius: { xs: "_1acm19y6 _1acm19y2 fyvr11cw fyvr11dk fyvr11bk fyvr11c8", sm: "_1acm19y7 _1acm19y3 fyvr11d0 fyvr11do fyvr11bo fyvr11cc", md: "_1acm19y8 _1acm19y4 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg" } }, defaultVariants: {}, compoundVariants: [] });
var input = createRuntimeFn({ defaultClassName: "_1acm19ya _1acm19y9 fyvr1wg fyvr1yc fyvr1t4 fyvr1v0 fyvr12wp fyvr12wj fyvr11gw fyvr11od fyvr12s1 fyvr12o1 fyvr128 fyvr15o", variantClassNames: { numeric: { false: "_1acm19yb _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0", true: "_1acm19yc _1qxj1ib9 _1qxj1ibc _1qxj1ib2 fyvr11mv fyvr11eo fyvr11g8 fyvr11fo fyvr11f8" } }, defaultVariants: {}, compoundVariants: [] });
const TextInput = reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "input",
      autoComplete = "off",
      borderRadius = "md",
      description: description2,
      disabled = false,
      id: id2,
      label = "",
      labelLocation = "hidden",
      leftIcon: LeftIcon,
      rightIcon: RightIcon,
      name: name2,
      controls,
      type = "text",
      numeric = false,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$1,
      {
        description: description2,
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { width: "full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            className: clsx$1(
              wrap$2,
              wrapVariants({ borderRadius })
            ),
            children: [
              LeftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: "sm" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  as,
                  autoComplete,
                  spellCheck: "false",
                  className: input({ numeric }),
                  disabled,
                  id: id2 ?? name2,
                  name: name2,
                  ref,
                  type,
                  ...rest
                }
              ),
              RightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(RightIcon, { size: "sm" }),
              controls
            ]
          }
        ) })
      }
    );
  }
);
const inputRegex = RegExp(`^\\d*(?:\\\\[.])?\\d*$`);
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const NumericInput = reactExports.forwardRef(
  (props, ref) => {
    const { name: name2 = "amount", placeholder, onChange, onBlur, ...rest } = props;
    const handleChange = (ev) => {
      let { value } = ev.target;
      value = value.replace(/,/g, ".");
      if (value.startsWith(".")) {
        value = "0" + value;
      }
      if (value.startsWith("0")) {
        value = value.replace(/^0+(?=\d)/, "");
      }
      if (value === "" || inputRegex.test(escapeRegExp(value))) {
        onChange == null ? void 0 : onChange({ ...ev, target: { ...ev.target, value } });
      }
    };
    const handleBlur = (ev) => {
      const { value } = ev.target;
      let v3 = value;
      if (v3.endsWith(".")) {
        v3 = v3.slice(0, -1);
      }
      if (v3.endsWith(".0")) {
        v3 = v3.slice(0, -2);
      }
      if (v3 === "0") {
        v3 = "";
      }
      onBlur == null ? void 0 : onBlur(ev);
      if (v3 !== value) {
        onChange == null ? void 0 : onChange({ ...ev, target: { ...ev.target, value: v3 } });
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        name: name2,
        onChange: handleChange,
        onBlur: handleBlur,
        inputMode: "decimal",
        autoComplete: "off",
        autoCorrect: "off",
        type: "text",
        pattern: "^[0-9]*[.,]?[0-9]*$",
        placeholder: placeholder || "0",
        minLength: 1,
        maxLength: 79,
        spellCheck: "false",
        numeric: true,
        ref,
        ...rest
      }
    );
  }
);
var digitInput = "y5zf971 _1qxj1ib9 _1qxj1ibc _1qxj1ib2 fyvr11mv fyvr11eo fyvr11g8 fyvr11fo fyvr11f8 _4efw240";
const PINCodeInput = (props) => {
  const {
    value,
    digits = 6,
    group,
    onChange,
    onConfirm,
    disabled = false
  } = props;
  const inputRefs = reactExports.useMemo(() => {
    return range(0, digits).map(() => reactExports.createRef());
  }, [digits]);
  reactExports.useEffect(() => {
    var _a2, _b2;
    (_b2 = (_a2 = inputRefs[0]) == null ? void 0 : _a2.current) == null ? void 0 : _b2.focus();
  }, [inputRefs]);
  const handleChange = (idx, character) => {
    var _a2, _b2;
    if (!/^\d$/.test(character)) {
      character = "";
    }
    const curr = [...value];
    curr[idx] = character;
    if (character !== "") {
      (_b2 = (_a2 = inputRefs[idx + 1]) == null ? void 0 : _a2.current) == null ? void 0 : _b2.focus();
    }
    onChange(curr);
  };
  const isValid2 = () => value.join("").length === digits;
  const handleKeyDown = (idx, ev) => {
    var _a2, _b2;
    const currentRef = inputRefs[idx].current;
    const prevRef = (_a2 = inputRefs[idx - 1]) == null ? void 0 : _a2.current;
    const nextRef = (_b2 = inputRefs[idx + 1]) == null ? void 0 : _b2.current;
    switch (ev.key) {
      case "Backspace":
        ev.preventDefault();
        if (currentRef) {
          currentRef.value = "";
          handleChange(idx, "");
        }
        prevRef == null ? void 0 : prevRef.focus();
        break;
      case "ArrowLeft":
        ev.preventDefault();
        prevRef == null ? void 0 : prevRef.focus();
        break;
      case "ArrowRight":
        ev.preventDefault();
        nextRef == null ? void 0 : nextRef.focus();
        break;
      case "Enter":
        ev.preventDefault();
        if (isValid2()) {
          onConfirm == null ? void 0 : onConfirm();
        }
        break;
      default:
        if ((currentRef == null ? void 0 : currentRef.value) === ev.key) {
          ev.preventDefault();
          handleChange(idx, ev.key);
        }
    }
  };
  const handlePaste = (idx, ev) => {
    var _a2, _b2;
    const pasted = ev.clipboardData.getData("text/plain");
    const filtered = pasted.replace(/\D/g, "");
    const re2 = new RegExp(`^\\d{${digits}}$`);
    if (re2.test(filtered)) {
      (_b2 = (_a2 = inputRefs[0]) == null ? void 0 : _a2.current) == null ? void 0 : _b2.focus();
      onChange(filtered.split(""));
      setTimeout(() => {
        var _a22, _b22;
        (_b22 = (_a22 = inputRefs[inputRefs.length - 1]) == null ? void 0 : _a22.current) == null ? void 0 : _b22.focus();
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { gap: "2", children: range(0, digits).map((idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    !!group && idx > 0 && idx % group === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as: "input",
        className: digitInput,
        value: value[idx] || "",
        ref: inputRefs[idx],
        type: "text",
        inputMode: "numeric",
        maxLength: 1,
        disabled,
        onFocus: (ev) => ev.target.select(),
        onPaste: (ev) => handlePaste(idx, ev),
        onChange: (ev) => handleChange(idx, ev.target.value),
        onKeyDown: (ev) => {
          handleKeyDown(idx, ev);
        }
      }
    )
  ] }, idx)) });
};
const range = (start, end) => Array.from({ length: end - start }, (v3, k2) => k2 + start);
var skeleton = createRuntimeFn({ defaultClassName: "_1jujggt1", variantClassNames: { size: { sm: "_1jujggt2", normal: "_1jujggt3", md: "_1jujggt4", lg: "_1jujggt5", xl: "_1jujggt6" } }, defaultVariants: {}, compoundVariants: [] });
const Skeleton = (props) => {
  const { size: size2, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: motion.div,
      className: skeleton({ size: size2 }),
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      borderRadius: "sm",
      ...rest
    }
  );
};
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeProgress,
      value: valueProp = null,
      max: maxProp,
      getValueLabel = defaultGetValueLabel,
      ...progressProps
    } = props;
    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
      console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
    }
    const max2 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
    if (valueProp !== null && !isValidValueNumber(valueProp, max2)) {
      console.error(getInvalidValueError(`${valueProp}`, "Progress"));
    }
    const value = isValidValueNumber(valueProp, max2) ? valueProp : null;
    const valueLabel = isNumber$1(value) ? getValueLabel(value, max2) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressProvider, { scope: __scopeProgress, value, max: max2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "aria-valuemax": max2,
        "aria-valuemin": 0,
        "aria-valuenow": isNumber$1(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": getProgressState(value, max2),
        "data-value": value ?? void 0,
        "data-max": max2,
        ...progressProps,
        ref: forwardedRef
      }
    ) });
  }
);
Progress$1.displayName = PROGRESS_NAME;
var INDICATOR_NAME$1 = "ProgressIndicator";
var ProgressIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeProgress, ...indicatorProps } = props;
    const context2 = useProgressContext(INDICATOR_NAME$1, __scopeProgress);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": getProgressState(context2.value, context2.max),
        "data-value": context2.value ?? void 0,
        "data-max": context2.max,
        ...indicatorProps,
        ref: forwardedRef
      }
    );
  }
);
ProgressIndicator.displayName = INDICATOR_NAME$1;
function defaultGetValueLabel(value, max2) {
  return `${Math.round(value / max2 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber$1(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max2) {
  return isNumber$1(max2) && !isNaN(max2) && max2 > 0;
}
function isValidValueNumber(value, max2) {
  return isNumber$1(value) && !isNaN(value) && value <= max2 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name: name2,
      checked = false,
      required,
      disabled,
      value = "on",
      onCheck,
      ...radioProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState$1(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            if (!checked)
              onCheck == null ? void 0 : onCheck();
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$1,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME = "RadioIndicator";
var RadioIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context2 = useRadioContext(INDICATOR_NAME, __scopeRadio);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$1(context2.checked),
        "data-disabled": context2.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME;
var BubbleInput$1 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  reactExports.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input2, checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "radio",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState$1(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
var RadioGroup$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name: name2,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioGroupProvider,
      {
        scope: __scopeRadioGroup,
        name: name2,
        required,
        disabled,
        value,
        onValueChange: setValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$4,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup$1.displayName = RADIO_GROUP_NAME;
var ITEM_NAME$1 = "RadioGroupItem";
var RadioGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context2 = useRadioGroupContext(ITEM_NAME$1, __scopeRadioGroup);
    const isDisabled = context2.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const checked = context2.value === itemProps.value;
    const isArrowKeyPressedRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        if (ARROW_KEYS.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Radio,
          {
            disabled: isDisabled,
            required: context2.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context2.name,
            ref: composedRefs,
            onCheck: () => context2.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter")
                event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              var _a2;
              if (isArrowKeyPressedRef.current)
                (_a2 = ref.current) == null ? void 0 : _a2.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem.displayName = ITEM_NAME$1;
var INDICATOR_NAME2 = "RadioGroupIndicator";
var RadioGroupIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME2;
var Root2$3 = RadioGroup$1;
var Item2 = RadioGroupItem;
var Indicator = RadioGroupIndicator;
var radioItemVariants = createRuntimeFn({ defaultClassName: "io59uy3 io59uy0 fyvr11dc fyvr11e0 fyvr11c0 fyvr11co fyvr1so fyvr1uk fyvr1wg fyvr1yc fyvr12nd fyvr12g1 fyvr121d fyvr128p fyvr12nj fyvr12g7 fyvr121j fyvr128v fyvr11od fyvr12v7 fyvr12v3 fyvr12vz fyvr12vr _4efw240", variantClassNames: { size: { sm: "io59uy4 io59uy1 fyvr11a8 fyvr11ak fyvr11aw fyvr11b8", lg: "io59uy5 io59uy2 fyvr11ac fyvr11ao fyvr11b0 fyvr11bc" } }, defaultVariants: {}, compoundVariants: [] });
var indicatorVariants = createRuntimeFn({ defaultClassName: "io59uy8 io59uy7 io59uy6 fyvr11h0 fyvr11ko fyvr11jg fyvr11hw fyvr128 fyvr15o fyvr12s1", variantClassNames: { size: { sm: "io59uy9", lg: "io59uya" } }, defaultVariants: {}, compoundVariants: [] });
const RadioOption = (props) => {
  const { id: id2, label, size: size2 = "sm", value, disabled } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field$1,
    {
      disabled,
      display: "flex",
      id: id2,
      label,
      labelLocation: "right",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Item2,
        {
          className: radioItemVariants({ size: size2 }),
          value,
          id: id2,
          disabled,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, { className: indicatorVariants({ size: size2 }) })
        }
      )
    }
  ) });
};
reactExports.forwardRef(
  (props, ref) => {
    const {
      flexDirection = "column",
      disabled = false,
      gap = "2",
      name: name2,
      options,
      size: size2 = "sm",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$3, { disabled, name: name2, ref, ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { flexDirection, gap, children: options.map(({ label, value, disabled: disabled2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioOption,
      {
        id: `${name2}-${value}`,
        label,
        size: size2,
        value,
        disabled: disabled2
      },
      value
    )) }) });
  }
);
function clamp$2(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
var NAME = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var Root$1 = VisuallyHidden;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope$1,
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name: name2,
    autoComplete,
    disabled,
    required
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const [valueNode, setValueNode] = reactExports.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = reactExports.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = reactExports.useRef(null);
  const isFormControl = trigger2 ? Boolean(trigger2.closest("form")) : true;
  const [nativeOptionsSet, setNativeOptionsSet] = reactExports.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name: name2,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$2 = "SelectTrigger";
var SelectTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context2 = useSelectContext(TRIGGER_NAME$2, __scopeSelect);
    const isDisabled = context2.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context2.onTriggerChange);
    const getItems = useCollection$1(__scopeSelect);
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search2) => {
      const enabledItems = getItems().filter((item2) => !item2.disabled);
      const currentItem = enabledItems.find((item2) => item2.value === context2.value);
      const nextItem = findNextItem(enabledItems, search2, currentItem);
      if (nextItem !== void 0) {
        context2.onValueChange(nextItem.value);
      }
    });
    const handleOpen = () => {
      if (!isDisabled) {
        context2.onOpenChange(true);
        resetTypeahead();
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context2.contentId,
        "aria-expanded": context2.open,
        "aria-required": context2.required,
        "aria-autocomplete": "none",
        dir: context2.dir,
        "data-state": context2.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context2.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false) {
            handleOpen();
            context2.triggerPointerDownPosRef.current = {
              x: Math.round(event.pageX),
              y: Math.round(event.pageY)
            };
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1)
            handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ")
            return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME$2;
var VALUE_NAME = "SelectValue";
var SelectValue = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context2 = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context2;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context2.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context2.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
  }
);
SelectIcon.displayName = ICON_NAME;
var CONTENT_NAME$2 = "SelectContent";
var SelectContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context2 = useSelectContext(CONTENT_NAME$2, props.__scopeSelect);
    const [fragment, setFragment] = reactExports.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context2.open) {
      const frag = fragment;
      return frag ? reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME$2;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$2);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context2 = useSelectContext(CONTENT_NAME$2, __scopeSelect);
    const [content2, setContent] = reactExports.useState(null);
    const [viewport2, setViewport] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = reactExports.useState(null);
    const [selectedItemText, setSelectedItemText] = reactExports.useState(
      null
    );
    const getItems = useCollection$1(__scopeSelect);
    const [isPositioned, setIsPositioned] = reactExports.useState(false);
    const firstValidItemFoundRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (content2)
        return hideOthers$1(content2);
    }, [content2]);
    useFocusGuards();
    const focusFirst2 = reactExports.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item2) => item2.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
            return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport2)
            viewport2.scrollTop = 0;
          if (candidate === lastItem && viewport2)
            viewport2.scrollTop = viewport2.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
            return;
        }
      },
      [getItems, viewport2]
    );
    const focusSelectedItem = reactExports.useCallback(
      () => focusFirst2([selectedItem, content2]),
      [focusFirst2, selectedItem, content2]
    );
    reactExports.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context2;
    reactExports.useEffect(() => {
      if (content2) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a2, _b2;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a2 = triggerPointerDownPosRef.current) == null ? void 0 : _a2.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b2 = triggerPointerDownPosRef.current) == null ? void 0 : _b2.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content2.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content2, onOpenChange, triggerPointerDownPosRef]);
    reactExports.useEffect(() => {
      const close2 = () => onOpenChange(false);
      window.addEventListener("blur", close2);
      window.addEventListener("resize", close2);
      return () => {
        window.removeEventListener("blur", close2);
        window.removeEventListener("resize", close2);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search2) => {
      const enabledItems = getItems().filter((item2) => !item2.disabled);
      const currentItem = enabledItems.find((item2) => item2.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search2, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context2.value !== void 0 && context2.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem)
            firstValidItemFoundRef.current = true;
        }
      },
      [context2.value]
    );
    const handleItemLeave = reactExports.useCallback(() => content2 == null ? void 0 : content2.focus(), [content2]);
    const itemTextRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context2.value !== void 0 && context2.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context2.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content: content2,
        viewport: viewport2,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll$1, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context2.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a2;
              (_a2 = context2.trigger) == null ? void 0 : _a2.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context2.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context2.contentId,
                    "data-state": context2.open ? "open" : "closed",
                    dir: context2.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab")
                        event.preventDefault();
                      if (!isModifierKey && event.key.length === 1)
                        handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item2) => !item2.disabled);
                        let candidateNodes = items.map((item2) => item2.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context2 = useSelectContext(CONTENT_NAME$2, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$2, __scopeSelect);
  const [contentWrapper, setContentWrapper] = reactExports.useState(null);
  const [content2, setContent] = reactExports.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection$1(__scopeSelect);
  const shouldExpandOnScrollRef = reactExports.useRef(false);
  const shouldRepositionRef = reactExports.useRef(true);
  const { viewport: viewport2, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = reactExports.useCallback(() => {
    if (context2.trigger && context2.valueNode && contentWrapper && content2 && viewport2 && selectedItem && selectedItemText) {
      const triggerRect = context2.trigger.getBoundingClientRect();
      const contentRect = content2.getBoundingClientRect();
      const valueNodeRect = context2.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context2.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp$2(left, [CONTENT_MARGIN, rightEdge - contentWidth]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp$2(right, [CONTENT_MARGIN, leftEdge - contentWidth]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport2.scrollHeight;
      const contentStyles = window.getComputedStyle(content2);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport2);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content2.clientHeight - viewport2.offsetTop - viewport2.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport2.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport2.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport2.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context2.trigger,
    context2.valueNode,
    contentWrapper,
    content2,
    viewport2,
    selectedItem,
    selectedItemText,
    context2.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  useLayoutEffect2(() => {
    if (content2)
      setContentZIndex(window.getComputedStyle(content2).zIndex);
  }, [content2]);
  const handleScrollButtonChange = reactExports.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content$2,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$2, {});
var VIEWPORT_NAME$1 = "SelectViewport";
var SelectViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME$1, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME$1, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = reactExports.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport2 = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport2.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport2.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport2.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME$1;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context2 = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context2.value === value;
    const [textValue, setTextValue] = reactExports.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a2;
        return (_a2 = contentContext.itemRefCallback) == null ? void 0 : _a2.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId();
    const handleSelect = () => {
      if (!disabled) {
        context2.onValueChange(value);
        context2.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: reactExports.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection$1.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, handleSelect),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a2;
                  if (disabled) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  } else {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a2;
                  if (event.currentTarget === document.activeElement) {
                    (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a2;
                  const isTypingAhead = ((_a2 = contentContext.searchRef) == null ? void 0 : _a2.current) !== "";
                  if (isTypingAhead && event.key === " ")
                    return;
                  if (SELECTION_KEYS.includes(event.key))
                    handleSelect();
                  if (event.key === " ")
                    event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context2 = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a2;
        return (_a2 = contentContext.itemTextRefCallback) == null ? void 0 : _a2.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = reactExports.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context2.valueNode && !context2.valueNodeHasChildren ? reactDomExports.createPortal(itemTextProps.children, context2.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport2.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport2 = contentContext.viewport;
      handleScroll2();
      viewport2.addEventListener("scroll", handleScroll2);
      return () => viewport2.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport2.scrollHeight - viewport2.clientHeight;
        const canScrollDown2 = Math.ceil(viewport2.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport2 = contentContext.viewport;
      handleScroll2();
      viewport2.addEventListener("scroll", handleScroll2);
      return () => viewport2.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = reactExports.useRef(null);
  const getItems = useCollection$1(__scopeSelect);
  const clearAutoScrollTimer = reactExports.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  reactExports.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    var _a2;
    const activeItem = getItems().find((item2) => item2.ref.current === document.activeElement);
    (_a2 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a2.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a2;
        (_a2 = contentContext.onItemLeave) == null ? void 0 : _a2.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME$1 = "SelectArrow";
var SelectArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context2 = useSelectContext(ARROW_NAME$1, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME$1, __scopeSelect);
    return context2.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME$1;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    reactExports.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = reactExports.useRef("");
  const timerRef = reactExports.useRef(0);
  const handleTypeaheadSearch = reactExports.useCallback(
    (key2) => {
      const search2 = searchRef.current + key2;
      handleSearchChange(search2);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search2);
    },
    [handleSearchChange]
  );
  const resetTypeahead = reactExports.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search2, currentItem) {
  const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
  const normalizedSearch = isRepeated ? search2[0] : search2;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem)
    wrappedItems = wrappedItems.filter((v3) => v3 !== currentItem);
  const nextItem = wrappedItems.find(
    (item2) => item2.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root2$2 = Select$1;
var Trigger$2 = SelectTrigger;
var Value = SelectValue;
var Icon = SelectIcon;
var Content2$1 = SelectContent;
var Viewport$1 = SelectViewport;
var Group = SelectGroup;
var Item$2 = SelectItem$1;
var ItemText = SelectItemText;
var triggerStyle = "gohwum1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 gohwum0 fyvr1t4 fyvr1v0 fyvr1ww fyvr1ys fyvr11ko fyvr11od fyvr11hc fyvr11f4 fyvr12s1 fyvr118c fyvr11jw fyvr11n4 fyvr12v7 fyvr12o1";
var triggerVariants = createRuntimeFn({ defaultClassName: "gohwum5", variantClassNames: { borderRadius: { xs: "gohwum6 gohwum2 fyvr11cw fyvr11dk fyvr11bk fyvr11c8", sm: "gohwum7 gohwum3 fyvr11d0 fyvr11do fyvr11bo fyvr11cc", md: "gohwum8 gohwum4 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg" } }, defaultVariants: {}, compoundVariants: [] });
var contentStyle = "gohwuma gohwum9 fyvr11d0 fyvr11do fyvr11bo fyvr11cc fyvr11ls fyvr11m8 fyvr11ms fyvr11tv fyvr12s1 fyvr11nl";
var optionStyle = "gohwume _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 gohwumd fyvr1ww fyvr1ys fyvr1t0 fyvr1uw fyvr12ws fyvr12wt fyvr12wm fyvr12wn fyvr11h0 fyvr11jw fyvr11ko fyvr12v7 fyvr12v3 fyvr12s1 fyvr12w1 fyvr12vr";
const SelectItem = reactExports.forwardRef(
  ({ children, className, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$2,
      {
        className: clsx$1(optionStyle, className),
        ...props,
        ref,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
      }
    );
  }
);
const Select = reactExports.forwardRef(
  (props, ref) => {
    const {
      borderRadius = "md",
      disabled = false,
      id: id2,
      label = "",
      description: description2,
      labelLocation = "hidden",
      name: name2,
      options,
      placeholder,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$1,
      {
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        description: description2,
        whiteSpace: "nowrap",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$2, { disabled, name: name2, ...rest, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Trigger$2,
            {
              id: id2 ?? name2,
              className: clsx$1(triggerStyle, triggerVariants({ borderRadius })),
              ref,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Value, { placeholder }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: Icon, display: "inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgChevronDownIcon, {}) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Content2$1, { className: contentStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { children: options.map(({ value, label: label2, ...rest2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value, ...rest2, children: label2 }, value)) }) }) })
        ] })
      }
    );
  }
);
reactExports.forwardRef(
  (props, ref) => {
    const {
      controls,
      onChange,
      placeholder = "Search",
      name: name2 = "search",
      value,
      ...rest
    } = props;
    const defaultClearButton = value ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        icon: SvgCloseIcon,
        size: "xs",
        onClick: () => onChange == null ? void 0 : onChange({
          target: { value: "" }
        })
      }
    ) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        ref,
        name: name2,
        leftIcon: SvgSearchIcon,
        controls: controls || defaultClearButton,
        placeholder,
        value,
        onChange: (ev) => onChange == null ? void 0 : onChange(ev),
        ...rest
      }
    );
  }
);
var variants = createRuntimeFn({ defaultClassName: "en4abt1", variantClassNames: { size: { sm: "en4abt2", md: "en4abt3", lg: "en4abt4" } }, defaultVariants: {}, compoundVariants: [] });
const Spinner = reactExports.forwardRef(
  (props, ref) => {
    const { size: size2 = "md", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: variants({ size: size2 }),
        color: "text50",
        ref,
        ...rest,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg",
            stroke: "currentColor",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: "12",
                  cy: "12",
                  fill: "none",
                  r: "10.5",
                  strokeDasharray: "42",
                  strokeLinecap: "round"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: "12",
                  cy: "12",
                  fill: "none",
                  opacity: "0.25",
                  r: "10.5",
                  strokeLinecap: "round"
                }
              )
            ]
          }
        )
      }
    );
  }
);
reactExports.forwardRef(
  ({ children }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ref,
      width: "fit",
      height: "fit",
      onClick: (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      },
      onKeyDown: (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          ev.stopPropagation();
        }
      },
      children
    }
  )
);
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name: name2,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      ...switchProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current)
                event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name: name2,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch$1.displayName = SWITCH_NAME;
var THUMB_NAME = "SwitchThumb";
var SwitchThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context2 = useSwitchContext(THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState(context2.checked),
        "data-disabled": context2.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME;
var BubbleInput = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  reactExports.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input2, checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState(checked) {
  return checked ? "checked" : "unchecked";
}
var Root = Switch$1;
var Thumb = SwitchThumb;
var root$2 = "_1lp2u8e1 _1lp2u8e0 fyvr11dc fyvr11e0 fyvr11c0 fyvr11co fyvr1ss fyvr1uo fyvr1wk fyvr1yg fyvr11t1 fyvr11hw fyvr12v7 fyvr12o1 _4efw240";
var thumb = "_1lp2u8e3 _1lp2u8e2 fyvr11dc fyvr11e0 fyvr11c0 fyvr11co fyvr11ho fyvr1ko fyvr1oo fyvr1k fyvr140 fyvr11o1";
const Switch = (props) => {
  const {
    disabled,
    label,
    labelLocation = "left",
    description: description2,
    id: id2,
    name: name2,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field$1,
    {
      disabled,
      display: "flex",
      id: id2 ?? name2,
      label,
      labelLocation,
      description: description2,
      whiteSpace: "nowrap",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root,
        {
          className: root$2,
          disabled,
          ...rest,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { position: "relative", width: "full", height: "full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: thumb }) })
        }
      )
    }
  );
};
createRuntimeFn({ defaultClassName: "nwwh3z8", variantClassNames: { variant: { pill: "nwwh3z9", line: "nwwh3za nwwh3z1 fyvr11g0" }, active: { true: "nwwh3zb nwwh3z2 fyvr12w5", false: "nwwh3zc" }, disabled: { true: "nwwh3zd nwwh3z3 fyvr12vp" } }, defaultVariants: {}, compoundVariants: [[{ active: true, variant: "pill" }, "nwwh3z4 fyvr11u7 fyvr12sj"], [{ active: false, variant: "pill" }, "nwwh3z5 fyvr11od fyvr12s7"], [{ active: true, variant: "line" }, "nwwh3z6 fyvr12s1"], [{ active: false, variant: "line" }, "nwwh3z7 fyvr12s7"]] });
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context2 = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$4,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context2.orientation,
        dir: context2.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context2.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$1 = "TabsTrigger";
var TabsTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context2 = useTabsContext(TRIGGER_NAME$1, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context2.baseId, value);
    const contentId = makeContentId(context2.baseId, value);
    const isSelected = value === context2.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context2.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key))
                context2.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context2.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context2.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$1;
var CONTENT_NAME$1 = "TabsContent";
var TabsContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context2 = useTabsContext(CONTENT_NAME$1, __scopeTabs);
    const triggerId = makeTriggerId(context2.baseId, value);
    const contentId = makeContentId(context2.baseId, value);
    const isSelected = value === context2.value;
    const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
    reactExports.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context2.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$1;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2$1 = Tabs$1;
var List = TabsList$1;
var Trigger$1 = TabsTrigger$1;
var list = "_10c8o0n1 _10c8o0n0 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg fyvr11h0 fyvr11hw fyvr128 fyvr11sj fyvr14o";
var trigger = "_10c8o0n3 _10c8o0n2 fyvr11d0 fyvr11do fyvr11bo fyvr11cc fyvr12wp fyvr12wj fyvr128 fyvr15o fyvr12v7 fyvr11hw fyvr11od fyvr11n4 fyvr12s7";
var selector = "_10c8o0n5 _10c8o0n4 fyvr11d0 fyvr11do fyvr11bo fyvr11cc fyvr11ho fyvr1ko fyvr1oo fyvr14c fyvr11tv fyvr12w7";
const TabsHeader = (props) => {
  const { tabs, value } = props;
  if (!tabs.length) {
    return null;
  }
  const selectorWidth = 100 / tabs.length;
  const selectedIdx = tabs.findIndex((tab) => tab.value === value);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(List, { className: list, style: { outline: void 0 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { display: "flex", position: "absolute", inset: "2", height: "8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: selector,
        style: {
          width: `${selectorWidth}%`,
          transform: `translateX(${selectedIdx * 100}%)`
        }
      }
    ) }),
    tabs.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trigger$1,
      {
        className: trigger,
        value: tab.value,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "normal", fontWeight: "bold", children: tab.label })
      },
      tab.value
    ))
  ] });
};
const TabsRoot = Root2$1;
const TabsContent = TabsContent$1;
var tagStyle = "_1ppqbnx1 _1qxj1ib9 _1qxj1ibg _1qxj1ib6 fyvr11mv fyvr11e8 fyvr11fw fyvr11fs fyvr11fc _1ppqbnx0 fyvr11cw fyvr11dk fyvr11bk fyvr11c8 fyvr1wo fyvr1yk fyvr1ss fyvr1uo fyvr11hc fyvr118c fyvr11n9";
reactExports.forwardRef(
  (props, ref) => {
    const { icon: Icon2, label, ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        className: tagStyle,
        ref,
        background: "buttonGlass",
        color: "text80",
        ...rest,
        children: [
          Icon2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: "xs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: label })
        ]
      }
    );
  }
);
var PROVIDER_NAME$1 = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME$1);
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context2 = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context2.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context2.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        var _a2;
        const isHotkeyPressed = hotkey.every((key2) => event[key2] || event.code === key2);
        if (isHotkeyPressed)
          (_a2 = ref.current) == null ? void 0 : _a2.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport2 = ref.current;
      if (hasToasts && wrapper && viewport2) {
        const handlePause = () => {
          if (!context2.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport2.dispatchEvent(pauseEvent);
            context2.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context2.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport2.dispatchEvent(resumeEvent);
            context2.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside)
            handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside)
            handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context2.isClosePausedRef]);
    const getSortedTabbableCandidates = reactExports.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    reactExports.useEffect(() => {
      const viewport2 = ref.current;
      if (viewport2) {
        const handleKeyDown = (event) => {
          var _a2, _b2, _c2;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport2;
            if (targetIsViewport && isTabbingBackwards) {
              (_a2 = headFocusProxyRef.current) == null ? void 0 : _a2.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b2 = headFocusProxyRef.current) == null ? void 0 : _b2.focus() : (_c2 = tailFocusProxyRef.current) == null ? void 0 : _c2.focus();
            }
          }
        };
        viewport2.addEventListener("keydown", handleKeyDown);
        return () => viewport2.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport$1.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context2 = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a2;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a2 = context2.viewport) == null ? void 0 : _a2.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport)
            onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open = true, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1(props.onPause),
        onResume: useCallbackRef$1(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast$1.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context2 = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration = durationProp || context2.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context2;
    const handleClose = useCallbackRef$1(() => {
      var _a2;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast)
        (_a2 = context2.viewport) == null ? void 0 : _a2.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity)
          return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    reactExports.useEffect(() => {
      const viewport2 = context2.viewport;
      if (viewport2) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport2.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport2.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport2.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport2.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context2.viewport, duration, onPause, onResume, startTimer]);
    reactExports.useEffect(() => {
      if (open && !context2.isClosePausedRef.current)
        startTimer(duration);
    }, [open, duration, context2.isClosePausedRef, startTimer]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context2.viewport)
      return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$6,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context2.isFocusedToastEscapeKeyDownRef.current)
                handleClose();
              context2.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context2.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape")
                    return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context2.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0)
                    return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current)
                    return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y2 = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context2.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context2.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y2) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context2.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context2.swipeDirection, context2.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context2.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context2 = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
  const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  reactExports.useEffect(() => {
    const timer2 = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer2);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context2.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME;
var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement$2(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name2, { bubbles: true, cancelable: true, detail });
  if (handler)
    currentTarget.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef$1(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement$2(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
createRuntimeFn({ defaultClassName: "_6wut8v3", variantClassNames: { variant: { normal: "_6wut8v4", success: "_6wut8v5", error: "_6wut8v6" } }, defaultVariants: {}, compoundVariants: [] });
reactExports.createContext(null);
var textarea = "_15pztn1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11mv fyvr11eg fyvr11g0 fyvr11fs fyvr11f0 _15pztn0 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg fyvr1t4 fyvr1v0 fyvr1ww fyvr1ys fyvr11ko fyvr11od fyvr12s1 fyvr12o1 fyvr12wj fyvr128 fyvr11h0";
var resize = "_15pztn2";
reactExports.forwardRef(
  (props, ref) => {
    const {
      as = "textarea",
      autoComplete = "off",
      borderRadius = "md",
      description: description2,
      disabled = false,
      id: id2,
      label = "",
      labelLocation = "hidden",
      name: name2,
      rows,
      resize: resize$1 = false,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field$1,
      {
        description: description2,
        disabled,
        display: "grid",
        id: id2 ?? name2,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            as,
            autoComplete,
            spellCheck: "false",
            className: clsx$1(textarea, resize$1 && resize),
            disabled,
            id: id2 ?? name2,
            name: name2,
            ref,
            rows,
            borderRadius,
            ...rest
          }
        )
      }
    );
  }
);
var root$1 = createRuntimeFn({ defaultClassName: "_18h918k5 _18h918k0 fyvr11ls fyvr11m8 fyvr11jg fyvr11ko fyvr11h0", variantClassNames: { size: { xs: "_18h918k6", sm: "_18h918k7", md: "_18h918k8", lg: "_18h918k9", xl: "_18h918ka" }, borderRadius: { circle: "_18h918kb _18h918k1 fyvr11dc fyvr11e0 fyvr11c0 fyvr11co", lg: "_18h918kc _18h918k2 fyvr11d8 fyvr11dw fyvr11bw fyvr11ck", md: "_18h918kd _18h918k3 fyvr11d4 fyvr11ds fyvr11bs fyvr11cg", sm: "_18h918ke _18h918k4 fyvr11d0 fyvr11do fyvr11bo fyvr11cc" } }, defaultVariants: {}, compoundVariants: [] });
var img$1 = "_18h918kf";
const NetworkImage = reactExports.memo((props) => {
  const {
    chainId,
    borderRadius = "circle",
    className,
    disableAnimation = false,
    style,
    src,
    size: size2 = "md",
    ...boxProps
  } = props;
  const logoURI = src || replaceSize(networkImageUrl(chainId), size2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: clsx$1(className, root$1({ borderRadius, size: size2 })),
      style,
      flexShrink: "0",
      ...boxProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Image$1,
        {
          className: img$1,
          disableAnimation,
          src: logoURI
        }
      )
    }
  );
});
var root$5 = createRuntimeFn({ defaultClassName: "bnrreb1 bnrreb0 fyvr11jg fyvr11ko fyvr11hw fyvr11h0", variantClassNames: { size: { xs: "bnrreb2", sm: "bnrreb3", md: "bnrreb4", lg: "bnrreb5", xl: "bnrreb6" } }, defaultVariants: {}, compoundVariants: [] });
var img = "bnrreb7";
var fallback = "bnrreb9 bnrreb8 fyvr11dc fyvr11e0 fyvr11c0 fyvr11co fyvr11ls fyvr11m8 fyvr11jg fyvr11ko fyvr11sj fyvr128 fyvr15o fyvr11h0";
const TokenImage = reactExports.memo((props) => {
  const {
    borderRadius = "circle",
    className,
    disableAnimation = false,
    style,
    src,
    symbol,
    size: size2 = "md",
    withNetwork,
    ...boxProps
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className: clsx$1(className, root$5({ size: size2 })),
      style,
      flexShrink: "0",
      ...boxProps,
      children: [
        src ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Image$1,
          {
            className: img,
            disableAnimation,
            borderRadius,
            overflow: "hidden",
            src
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Text,
          {
            className: fallback,
            variant: "normal",
            fontWeight: "medium",
            color: "text50",
            borderRadius,
            overflow: "hidden",
            uppercase: true,
            children: symbol == null ? void 0 : symbol.replace(/\s/, "").slice(0, 4)
          }
        ),
        withNetwork && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            position: "absolute",
            zIndex: "1",
            borderRadius: "circle",
            borderWidth: "thin",
            borderStyle: "solid",
            borderColor: "backgroundPrimary",
            background: "backgroundPrimary",
            placeItems: "center",
            style: { width: 16 + 2, height: 16 + 2, right: -2, bottom: -2 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              NetworkImage,
              {
                chainId: withNetwork,
                style: { width: 16, height: 16 }
              }
            )
          }
        )
      ]
    }
  );
});
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = reactExports.useState(true);
  const isPointerInTransitRef = reactExports.useRef(false);
  const skipDelayTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: reactExports.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip$1 = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const contentId = useId();
  const openTimerRef = reactExports.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = reactExports.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    }
  });
  const stateAttribute = reactExports.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
    }, delayDuration);
  }, [delayDuration, setOpen]);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(openTimerRef.current);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: reactExports.useCallback(() => {
        if (providerContext.isOpenDelayed)
          handleDelayedOpen();
        else
          handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: reactExports.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context2 = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context2.onTriggerChange);
    const isPointerDownRef = reactExports.useRef(false);
    const hasPointerMoveOpenedRef = reactExports.useRef(false);
    const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
    reactExports.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        "aria-describedby": context2.open ? context2.contentId : void 0,
        "data-state": context2.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch")
            return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context2.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context2.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current)
            context2.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context2.onClose),
        onClick: composeEventHandlers(props.onClick, context2.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context2 = useTooltipContext(PORTAL_NAME, __scopeTooltip);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "TooltipContent";
var TooltipContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context2 = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context2.open, children: context2.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
  const context2 = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger: trigger2, onClose } = context2;
  const content2 = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = reactExports.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (trigger2 && content2) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content2);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content2.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content2.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content2, handleCreateGraceArea, handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger2 == null ? void 0 : trigger2.contains(target)) || (content2 == null ? void 0 : content2.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content2, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context2 = useTooltipContext(CONTENT_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context2;
    reactExports.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    reactExports.useEffect(() => {
      if (context2.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context2.trigger))
            onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context2.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$2,
          {
            "data-state": context2.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, { id: context2.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point3, rect) {
  const top = Math.abs(rect.top - point3.y);
  const bottom = Math.abs(rect.bottom - point3.y);
  const right = Math.abs(rect.right - point3.x);
  const left = Math.abs(rect.left - point3.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding2 = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y + padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y + padding2 }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y - padding2 }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x + padding2, y: exitPoint.y + padding2 }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding2, y: exitPoint.y - padding2 },
        { x: exitPoint.x - padding2, y: exitPoint.y + padding2 }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point3, polygon) {
  const { x, y: y2 } = point3;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi2 = polygon[i].x;
    const yi2 = polygon[i].y;
    const xj2 = polygon[j2].x;
    const yj2 = polygon[j2].y;
    const intersect = yi2 > y2 !== yj2 > y2 && x < (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b2) => {
    if (a2.x < b2.x)
      return -1;
    else if (a2.x > b2.x)
      return 1;
    else if (a2.y < b2.y)
      return -1;
    else if (a2.y > b2.y)
      return 1;
    else
      return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider$1 = TooltipProvider;
var Root3 = Tooltip$1;
var Trigger = TooltipTrigger;
var Content2 = TooltipContent;
var Arrow2 = TooltipArrow;
var content = "q888p21 q888p20 fyvr11d0 fyvr11do fyvr11bo fyvr11cc fyvr1ww fyvr1ys fyvr11ms fyvr11tp fyvr1uw fyvr1sw";
const Tooltip = (props) => {
  const {
    align = "center",
    children,
    delayDuration = 0,
    disabled = false,
    hOffset = 0,
    message,
    side = "top",
    vOffset = 0
  } = props;
  return disabled ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Provider$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root3, { delayDuration, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { asChild: true, children }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Content2,
      {
        className: content,
        side,
        align,
        sideOffset: vOffset,
        alignOffset: hOffset,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", fontWeight: "medium", color: "text80", children: message }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { offset: 12, width: 10, height: 5 })
        ]
      }
    )
  ] }) });
};
const abi$7 = [{
  inputs: [{
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getAlternativeSignature",
  outputs: [{
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var erc5719 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$7
});
const abi$6 = [{
  type: "function",
  name: "isValidSignature",
  constant: true,
  inputs: [{
    type: "bytes32"
  }, {
    type: "bytes"
  }],
  outputs: [{
    type: "bytes4"
  }],
  payable: false,
  stateMutability: "view"
}];
const returns = {
  isValidSignatureBytes32: "0x1626ba7e"
};
var erc1271 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$6,
  returns
});
const abi$5 = [{
  inputs: [{
    internalType: "bytes",
    name: "error",
    type: "bytes"
  }],
  name: "ERC1271Revert",
  type: "error"
}, {
  inputs: [{
    internalType: "bytes",
    name: "error",
    type: "bytes"
  }],
  name: "ERC6492DeployFailed",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSig",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }, {
    internalType: "bool",
    name: "allowSideEffects",
    type: "bool"
  }, {
    internalType: "bool",
    name: "deployAlreadyDeployed",
    type: "bool"
  }],
  name: "isValidSigImpl",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSigNoThrow",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSigWithSideEffects",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_signer",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }],
  name: "isValidSigWithSideEffectsNoThrow",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}];
var erc6492 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$5
});
const abi$4 = [{
  type: "function",
  name: "deploy",
  constant: false,
  inputs: [{
    type: "address"
  }, {
    type: "bytes32"
  }],
  outputs: [],
  payable: true,
  stateMutability: "payable"
}];
var factory = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$4
});
const abi$3 = [{
  type: "function",
  name: "nonce",
  constant: true,
  inputs: [],
  outputs: [{
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view"
}, {
  type: "function",
  name: "readNonce",
  constant: true,
  inputs: [{
    type: "uint256"
  }],
  outputs: [{
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view"
}, {
  type: "function",
  name: "updateImplementation",
  constant: false,
  inputs: [{
    type: "address"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "selfExecute",
  constant: false,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "execute",
  constant: false,
  inputs: [{
    components: [{
      type: "bool",
      name: "delegateCall"
    }, {
      type: "bool",
      name: "revertOnError"
    }, {
      type: "uint256",
      name: "gasLimit"
    }, {
      type: "address",
      name: "target"
    }, {
      type: "uint256",
      name: "value"
    }, {
      type: "bytes",
      name: "data"
    }],
    type: "tuple[]"
  }, {
    type: "uint256"
  }, {
    type: "bytes"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}, {
  type: "function",
  name: "createContract",
  inputs: [{
    type: "bytes"
  }],
  payable: true,
  stateMutability: "payable"
}, {
  type: "function",
  name: "setExtraImageHash",
  constant: false,
  inputs: [{
    type: "bytes32",
    name: "imageHash"
  }, {
    type: "uint256",
    name: "expiration"
  }],
  outputs: [],
  payable: false,
  stateMutability: "nonpayable"
}];
var mainModule = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$3
});
const abi$2 = [{
  type: "function",
  name: "updateImageHash",
  constant: true,
  inputs: [{
    type: "bytes32"
  }],
  outputs: [],
  payable: false,
  stateMutability: "view"
}, {
  type: "function",
  name: "imageHash",
  constant: true,
  inputs: [],
  outputs: [{
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view"
}];
var mainModuleUpgradable = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$2
});
const abi$1$1 = [{
  inputs: [{
    internalType: "address",
    name: "_factory",
    type: "address"
  }, {
    internalType: "address",
    name: "_mainModule",
    type: "address"
  }],
  stateMutability: "nonpayable",
  type: "constructor"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    indexed: true,
    internalType: "bytes32",
    name: "_imageHash",
    type: "bytes32"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "_threshold",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "bytes",
    name: "_signers",
    type: "bytes"
  }],
  name: "RequiredConfig",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "_signer",
    type: "address"
  }],
  name: "RequiredSigner",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callBalanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callBlockNumber",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "_i",
    type: "uint256"
  }],
  name: "callBlockhash",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callChainId",
  outputs: [{
    internalType: "uint256",
    name: "id",
    type: "uint256"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callCode",
  outputs: [{
    internalType: "bytes",
    name: "code",
    type: "bytes"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callCodeHash",
  outputs: [{
    internalType: "bytes32",
    name: "codeHash",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_addr",
    type: "address"
  }],
  name: "callCodeSize",
  outputs: [{
    internalType: "uint256",
    name: "size",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callCoinbase",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callDifficulty",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callGasLeft",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callGasLimit",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callGasPrice",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callOrigin",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "callTimestamp",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "knownImageHashes",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  name: "lastImageHashUpdate",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "lastSignerUpdate",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "lastWalletUpdate",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    components: [{
      internalType: "bool",
      name: "delegateCall",
      type: "bool"
    }, {
      internalType: "bool",
      name: "revertOnError",
      type: "bool"
    }, {
      internalType: "uint256",
      name: "gasLimit",
      type: "uint256"
    }, {
      internalType: "address",
      name: "target",
      type: "address"
    }, {
      internalType: "uint256",
      name: "value",
      type: "uint256"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct IModuleCalls.Transaction[]",
    name: "_txs",
    type: "tuple[]"
  }],
  name: "multiCall",
  outputs: [{
    internalType: "bool[]",
    name: "_successes",
    type: "bool[]"
  }, {
    internalType: "bytes[]",
    name: "_results",
    type: "bytes[]"
  }],
  stateMutability: "payable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_threshold",
    type: "uint256"
  }, {
    components: [{
      internalType: "uint256",
      name: "weight",
      type: "uint256"
    }, {
      internalType: "address",
      name: "signer",
      type: "address"
    }],
    internalType: "struct RequireUtils.Member[]",
    name: "_members",
    type: "tuple[]"
  }, {
    internalType: "bool",
    name: "_index",
    type: "bool"
  }],
  name: "publishConfig",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    internalType: "bytes32",
    name: "_hash",
    type: "bytes32"
  }, {
    internalType: "uint256",
    name: "_sizeMembers",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "_signature",
    type: "bytes"
  }, {
    internalType: "bool",
    name: "_index",
    type: "bool"
  }],
  name: "publishInitialSigners",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_wallet",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_nonce",
    type: "uint256"
  }],
  name: "requireMinNonce",
  outputs: [],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "_expiration",
    type: "uint256"
  }],
  name: "requireNonExpired",
  outputs: [],
  stateMutability: "view",
  type: "function"
}];
var sequenceUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$1$1
});
const abi$8 = [{
  inputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  name: "requireFreshSigner",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var requireFreshSigner = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$8
});
const walletContracts = {
  erc6492,
  erc5719,
  erc1271,
  factory,
  mainModule,
  mainModuleUpgradable,
  sequenceUtils,
  requireFreshSigner
};
const abi$1$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  walletContracts
}, Symbol.toStringTag, { value: "Module" }));
const global$1 = globalThis || void 0 || self;
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
const WebRPCVersion$3 = "v1";
const WebRPCSchemaVersion$3 = "v0.4.0";
const WebRPCSchemaHash$3 = "da72de09959c34a964bb84662ed6bd510f78f5cb";
let SortOrder$2 = /* @__PURE__ */ function(SortOrder2) {
  SortOrder2["DESC"] = "DESC";
  SortOrder2["ASC"] = "ASC";
  return SortOrder2;
}({});
class API {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/API/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            version: _data2.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.clock = (headers, signal) => {
      return this.fetch(this.url("Clock"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            serverTime: _data2.serverTime
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSequenceContext = (headers, signal) => {
      return this.fetch(this.url("GetSequenceContext"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            data: _data2.data
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAuthToken = (args, headers, signal) => {
      return this.fetch(this.url("GetAuthToken"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status,
            jwtToken: _data2.jwtToken,
            address: _data2.address,
            user: _data2.user
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAuthToken2 = (args, headers, signal) => {
      return this.fetch(this.url("GetAuthToken2"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status,
            jwtToken: _data2.jwtToken,
            address: _data2.address,
            user: _data2.user
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sendPasswordlessLink = (args, headers, signal) => {
      return this.fetch(this.url("SendPasswordlessLink"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.friendList = (args, headers, signal) => {
      return this.fetch(this.url("FriendList"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            page: _data2.page,
            friends: _data2.friends
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getFriendByAddress = (args, headers, signal) => {
      return this.fetch(this.url("GetFriendByAddress"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status,
            friend: _data2.friend
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchFriends = (args, headers, signal) => {
      return this.fetch(this.url("SearchFriends"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            friends: _data2.friends
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addFriend = (args, headers, signal) => {
      return this.fetch(this.url("AddFriend"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status,
            friend: _data2.friend
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateFriendNickname = (args, headers, signal) => {
      return this.fetch(this.url("UpdateFriendNickname"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status,
            friend: _data2.friend
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeFriend = (args, headers, signal) => {
      return this.fetch(this.url("RemoveFriend"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.contractCall = (args, headers, signal) => {
      return this.fetch(this.url("ContractCall"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            returns: _data2.returns
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.decodeContractCall = (args, headers, signal) => {
      return this.fetch(this.url("DecodeContractCall"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            call: _data2.call
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.lookupContractCallSelectors = (args, headers, signal) => {
      return this.fetch(this.url("LookupContractCallSelectors"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            signatures: _data2.signatures
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageFetch = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageFetch"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            object: _data2.object
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageSave = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageSave"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageDelete = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageDelete"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.userStorageFetchAll = (args, headers, signal) => {
      return this.fetch(this.url("UserStorageFetchAll"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            objects: _data2.objects
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMoonpayLink = (args, headers, signal) => {
      return this.fetch(this.url("GetMoonpayLink"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            signedUrl: _data2.signedUrl
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSardineClientToken = (headers, signal) => {
      return this.fetch(this.url("GetSardineClientToken"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            token: _data2.token
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSardineNFTCheckoutToken = (args, headers, signal) => {
      return this.fetch(this.url("GetSardineNFTCheckoutToken"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            resp: _data2.resp
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSardineNFTCheckoutOrderStatus = (args, headers, signal) => {
      return this.fetch(this.url("GetSardineNFTCheckoutOrderStatus"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            resp: _data2.resp
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resolveENSAddress = (args, headers, signal) => {
      return this.fetch(this.url("ResolveENSAddress"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            address: _data2.address,
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidSignature = (args, headers, signal) => {
      return this.fetch(this.url("IsValidSignature"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            isValid: _data2.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidMessageSignature = (args, headers, signal) => {
      return this.fetch(this.url("IsValidMessageSignature"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            isValid: _data2.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidTypedDataSignature = (args, headers, signal) => {
      return this.fetch(this.url("IsValidTypedDataSignature"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            isValid: _data2.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidETHAuthProof = (args, headers, signal) => {
      return this.fetch(this.url("IsValidETHAuthProof"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            isValid: _data2.isValid
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getCoinPrices = (args, headers, signal) => {
      return this.fetch(this.url("GetCoinPrices"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            tokenPrices: _data2.tokenPrices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getCollectiblePrices = (args, headers, signal) => {
      return this.fetch(this.url("GetCollectiblePrices"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            tokenPrices: _data2.tokenPrices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getExchangeRate = (args, headers, signal) => {
      return this.fetch(this.url("GetExchangeRate"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            exchangeRate: _data2.exchangeRate
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.memoryStore = (args, headers, signal) => {
      return this.fetch(this.url("MemoryStore"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.memoryLoad = (args, headers, signal) => {
      return this.fetch(this.url("MemoryLoad"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            value: _data2.value
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getInviteInfo = (headers, signal) => {
      return this.fetch(this.url("GetInviteInfo"), createHTTPRequest$7({}, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            inviteInfo: _data2.inviteInfo
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.isValidAccessCode = (args, headers, signal) => {
      return this.fetch(this.url("IsValidAccessCode"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.internalClaimAccessCode = (args, headers, signal) => {
      return this.fetch(this.url("InternalClaimAccessCode"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.blockNumberAtTime = (args, headers, signal) => {
      return this.fetch(this.url("BlockNumberAtTime"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            blocks: _data2.blocks
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.paperSessionSecret = (args, headers, signal) => {
      return this.fetch(this.url("PaperSessionSecret"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            secret: _data2.secret
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.paperSessionSecret2 = (args, headers, signal) => {
      return this.fetch(this.url("PaperSessionSecret2"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            secret: _data2.secret
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.linkWallet = (args, headers, signal) => {
      return this.fetch(this.url("LinkWallet"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            status: _data2.status,
            linkedWalletAddress: _data2.linkedWalletAddress
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getLinkedWallets = (args, headers, signal) => {
      return this.fetch(this.url("GetLinkedWallets"), createHTTPRequest$7(args, headers, signal)).then((res) => {
        return buildResponse$7(res).then((_data2) => {
          return {
            linkedWallets: _data2.linkedWallets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$7 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$h({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$7 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$7.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$7[code2] || WebrpcError$7).new(data);
    }
    return data;
  });
};
let WebrpcError$7 = class WebrpcError extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$7 = class WebrpcEndpointError extends WebrpcError$7 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
};
let WebrpcRequestFailedError$7 = class WebrpcRequestFailedError extends WebrpcError$7 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
};
let WebrpcBadRouteError$7 = class WebrpcBadRouteError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
};
let WebrpcBadMethodError$7 = class WebrpcBadMethodError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
};
let WebrpcBadRequestError$7 = class WebrpcBadRequestError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
};
let WebrpcBadResponseError$7 = class WebrpcBadResponseError extends WebrpcError$7 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
};
let WebrpcServerPanicError$7 = class WebrpcServerPanicError extends WebrpcError$7 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
};
let WebrpcInternalErrorError$7 = class WebrpcInternalErrorError extends WebrpcError$7 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
};
let WebrpcClientDisconnectedError$7 = class WebrpcClientDisconnectedError extends WebrpcError$7 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
};
let WebrpcStreamLostError$7 = class WebrpcStreamLostError extends WebrpcError$7 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
};
let WebrpcStreamFinishedError$7 = class WebrpcStreamFinishedError extends WebrpcError$7 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
};
let UnauthorizedError$6 = class UnauthorizedError extends WebrpcError$7 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
};
let PermissionDeniedError$4 = class PermissionDeniedError extends WebrpcError$7 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError.prototype);
  }
};
let SessionExpiredError$4 = class SessionExpiredError extends WebrpcError$7 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError.prototype);
  }
};
let AbortedError$3 = class AbortedError extends WebrpcError$7 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError.prototype);
  }
};
let InvalidArgumentError$5 = class InvalidArgumentError extends WebrpcError$7 {
  constructor(name2 = "InvalidArgument", code2 = 2e3, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError.prototype);
  }
};
let UnavailableError$3 = class UnavailableError extends WebrpcError$7 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError.prototype);
  }
};
let QueryFailedError$5 = class QueryFailedError extends WebrpcError$7 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError.prototype);
  }
};
let NotFoundError$6 = class NotFoundError extends WebrpcError$7 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
};
let errors$3 = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["SessionExpired"] = "SessionExpired";
  errors2["Aborted"] = "Aborted";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["Unavailable"] = "Unavailable";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["NotFound"] = "NotFound";
  return errors2;
}({});
const webrpcErrorByCode$7 = {
  [0]: WebrpcEndpointError$7,
  [-1]: WebrpcRequestFailedError$7,
  [-2]: WebrpcBadRouteError$7,
  [-3]: WebrpcBadMethodError$7,
  [-4]: WebrpcBadRequestError$7,
  [-5]: WebrpcBadResponseError$7,
  [-6]: WebrpcServerPanicError$7,
  [-7]: WebrpcInternalErrorError$7,
  [-8]: WebrpcClientDisconnectedError$7,
  [-9]: WebrpcStreamLostError$7,
  [-10]: WebrpcStreamFinishedError$7,
  [1e3]: UnauthorizedError$6,
  [1001]: PermissionDeniedError$4,
  [1002]: SessionExpiredError$4,
  [1005]: AbortedError$3,
  [2e3]: InvalidArgumentError$5,
  [2002]: UnavailableError$3,
  [2003]: QueryFailedError$5,
  [3e3]: NotFoundError$6
};
const fetch$5 = typeof global$1 === "object" ? global$1.fetch : window.fetch;
class SequenceAPIClient extends API {
  constructor(hostname, projectAccessKey2, jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$5);
    this.projectAccessKey = projectAccessKey2;
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init3) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      const projectAccessKey3 = this.projectAccessKey;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      if (projectAccessKey3 && projectAccessKey3.length > 0) {
        headers["X-Access-Key"] = projectAccessKey3;
      }
      init3.headers = _extends$h({}, init3.headers, headers);
      return fetch$5(input2, init3);
    };
    this.fetch = this._fetch;
  }
}
const api$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  API,
  AbortedError: AbortedError$3,
  InvalidArgumentError: InvalidArgumentError$5,
  NotFoundError: NotFoundError$6,
  PermissionDeniedError: PermissionDeniedError$4,
  QueryFailedError: QueryFailedError$5,
  SequenceAPIClient,
  SessionExpiredError: SessionExpiredError$4,
  SortOrder: SortOrder$2,
  UnauthorizedError: UnauthorizedError$6,
  UnavailableError: UnavailableError$3,
  WebRPCSchemaHash: WebRPCSchemaHash$3,
  WebRPCSchemaVersion: WebRPCSchemaVersion$3,
  WebRPCVersion: WebRPCVersion$3,
  WebrpcBadMethodError: WebrpcBadMethodError$7,
  WebrpcBadRequestError: WebrpcBadRequestError$7,
  WebrpcBadResponseError: WebrpcBadResponseError$7,
  WebrpcBadRouteError: WebrpcBadRouteError$7,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$7,
  WebrpcEndpointError: WebrpcEndpointError$7,
  WebrpcError: WebrpcError$7,
  WebrpcInternalErrorError: WebrpcInternalErrorError$7,
  WebrpcRequestFailedError: WebrpcRequestFailedError$7,
  WebrpcServerPanicError: WebrpcServerPanicError$7,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$7,
  WebrpcStreamLostError: WebrpcStreamLostError$7,
  errors: errors$3
}, Symbol.toStringTag, { value: "Module" }));
var bn = { exports: {} };
var buffer$2 = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2) {
  lookup[i$2] = code[i$2];
  revLookup[code.charCodeAt(i$2)] = i$2;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE2, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE2 ? nBytes - 1 : 0;
  var d2 = isLE2 ? -1 : 1;
  var s2 = buffer2[offset2 + i];
  i += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE2, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE2 ? 0 : nBytes - 1;
  var d2 = isLE2 ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer3;
  exports.SlowBuffer = SlowBuffer2;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer3, GlobalUint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer3.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize2(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer3.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer3.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer2(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a2, b2) {
    if (isInstance(a2, GlobalUint8Array))
      a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, GlobalUint8Array))
      b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
    if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    let x = a2.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x, y2); i < len; ++i) {
      if (a2[i] !== b2[i]) {
        x = a2[i];
        y2 = b2[i];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat2(list2, length) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list2.length === 0) {
      return Buffer3.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list2.length; ++i) {
        length += list2[i].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list2.length; ++i) {
      let buf = list2[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b2) {
    if (!Buffer3.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer3.compare(this, b2) === 0;
  };
  Buffer3.prototype.inspect = function inspect4() {
    let str = "";
    const max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset2, length) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset2 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset2, length) {
    return blitBuffer(utf8ToBytes2(string, buf.length - offset2), buf, offset2, length);
  }
  function asciiWrite(buf, string, offset2, length) {
    return blitBuffer(asciiToBytes(string), buf, offset2, length);
  }
  function base64Write(buf, string, offset2, length) {
    return blitBuffer(base64ToBytes(string), buf, offset2, length);
  }
  function ucs2Write(buf, string, offset2, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length);
  }
  Buffer3.prototype.write = function write(string, offset2, length, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length = this.length;
      offset2 = 0;
    } else if (length === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset2, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset2, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset2, length);
        case "base64":
          return base64Write(this, string, offset2, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset2, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes3 = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes3.length - 1; i += 2) {
      res += String.fromCharCode(bytes3[i] + bytes3[i + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice2(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length) {
    if (offset2 % 1 !== 0 || offset2 < 0)
      throw new RangeError("offset is not uint");
    if (offset2 + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul3 = 1;
    let i = 0;
    while (++i < byteLength3 && (mul3 *= 256)) {
      val += this[offset2 + i] * mul3;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul3 = 1;
    while (byteLength3 > 0 && (mul3 *= 256)) {
      val += this[offset2 + --byteLength3] * mul3;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi2 = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul3 = 1;
    let i = 0;
    while (++i < byteLength3 && (mul3 *= 256)) {
      val += this[offset2 + i] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let i = byteLength3;
    let mul3 = 1;
    let val = this[offset2 + --i];
    while (i > 0 && (mul3 *= 256)) {
      val += this[offset2 + --i] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128))
      return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last = this[offset2 + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max2, min2) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul3 = 1;
    let i = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul3 *= 256)) {
      this[offset2 + i] = value / mul3 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul3 = 1;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul3 *= 256)) {
      this[offset2 + i] = value / mul3 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2] = hi2;
    return offset2 + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul3 = 1;
    let sub = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul3 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul3 = 1;
    let sub = 0;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul3 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max2, min2) {
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset2 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes3 = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes3.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes3[i % len];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base2) {
    errors2[sym] = class NodeError extends Base2 {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input2) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input2;
      if (Number.isInteger(input2) && Math.abs(input2) > 2 ** 32) {
        received = addNumericalSeparator(String(input2));
      } else if (typeof input2 === "bigint") {
        received = String(input2);
        if (input2 > BigInt(2) ** BigInt(32) || input2 < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset2, byteLength3) {
    if (value > max2 || value < min2) {
      const n2 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes3 = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes3.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes3.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes3.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes3.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes3;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset2, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset2 >= dst.length || i >= src.length)
        break;
      dst[i + offset2] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
const Buffer2 = buffer$2.Buffer;
const Blob$1 = buffer$2.Blob;
const BlobOptions = buffer$2.BlobOptions;
const Buffer$1 = buffer$2.Buffer;
const File = buffer$2.File;
const FileOptions = buffer$2.FileOptions;
const INSPECT_MAX_BYTES = buffer$2.INSPECT_MAX_BYTES;
const SlowBuffer = buffer$2.SlowBuffer;
const TranscodeEncoding = buffer$2.TranscodeEncoding;
const atob$1 = buffer$2.atob;
const btoa$1 = buffer$2.btoa;
const constants$2 = buffer$2.constants;
const isAscii = buffer$2.isAscii;
const isUtf8 = buffer$2.isUtf8;
const kMaxLength = buffer$2.kMaxLength;
const kStringMaxLength = buffer$2.kStringMaxLength;
const resolveObjectURL = buffer$2.resolveObjectURL;
const transcode = buffer$2.transcode;
const dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$2,
  default: Buffer2,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
bn.exports;
(function(module2) {
  (function(module3, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer3;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer3 = window.Buffer;
      } else {
        Buffer3 = require$$2$1.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init3(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i = number2.length - 1, j2 = 0; i >= 0; i -= 3) {
          w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j2 = 0; i < number2.length; i += 3) {
          w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index2) {
      var c2 = string.charCodeAt(index2);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string);
      }
    }
    function parseHexByte(string, lowerBound, index2) {
      var r2 = parseHex4Bits(string, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i = number2.length - 1; i >= start; i -= 2) {
          w2 = parseHexByte(number2, start, i) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
          w2 = parseHexByte(number2, start, i) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul3) {
      var r2 = 0;
      var b2 = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c2 = str.charCodeAt(i) - 48;
        r2 *= mul3;
        if (c2 >= 49) {
          b2 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b2 = c2 - 17 + 10;
        } else {
          b2 = c2;
        }
        assert2(c2 >= 0 && b2 < mul3, "Invalid character");
        r2 += b2;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod2 = total % limbLen;
      var end = Math.min(total, total - mod2) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number2, i, i + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow3 = 1;
        word = parseBase(number2, i, number2.length, base2);
        for (i = 0; i < mod2; i++) {
          pow3 *= base2;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy2(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
      } catch (e2) {
        BN2.prototype.inspect = inspect4;
      }
    } else {
      BN2.prototype.inspect = inspect4;
    }
    function inspect4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = this.words[i];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16, 2);
    };
    if (Buffer3) {
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer3, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size2) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size2);
      }
      return new ArrayType(size2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift2 = 0; i < this.length; i++) {
        var word = this.words[i] << shift2 | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift2 === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift2 = 0;
        } else {
          carry = word >>> 24;
          shift2 += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift2 = 0; i < this.length; i++) {
        var word = this.words[i] << shift2 | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift2 === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift2 = 0;
        } else {
          carry = word >>> 24;
          shift2 += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i = 0; i < this.length; i++) {
        var b2 = this._zeroBits(this.words[i]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i = 0; i < b2.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i = 0; i < b2.length; i++) {
        this.words[i] = a2.words[i] ^ b2.words[i];
      }
      if (this !== a2) {
        for (; i < a2.length; i++) {
          this.words[i] = a2.words[i];
        }
      }
      this.length = a2.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0; i < b2.length; i++) {
        r2 = (a2.words[i] | 0) + (b2.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i < a2.length; i++) {
        r2 = (a2.words[i] | 0) + carry;
        this.words[i] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i < a2.length; i++) {
          this.words[i] = a2.words[i];
        }
      }
      return this;
    };
    BN2.prototype.add = function add3(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0; i < b2.length; i++) {
        r2 = (a2.words[i] | 0) - (b2.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      for (; carry !== 0 && i < a2.length; i++) {
        r2 = (a2.words[i] | 0) + carry;
        carry = r2 >> 26;
        this.words[i] = r2 & 67108863;
      }
      if (carry === 0 && i < a2.length && a2 !== this) {
        for (; i < a2.length; i++) {
          this.words[i] = a2.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i = k2 - j2 | 0;
          a2 = self2.words[i] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i = k2 - j2;
          var a2 = self2.words[i] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul3(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w2 = (this.words[i] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow3(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i = 0; i < w2.length; i++, res = res.sqr()) {
        if (w2[i] !== 0)
          break;
      }
      if (++i < w2.length) {
        for (var q2 = res.sqr(); i < w2.length; i++, q2 = q2.sqr()) {
          if (w2[i] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i;
      if (r2 !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c2 = (this.words[i] | 0) - newCarry << r2;
          this.words[i] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s2] = this.words[i];
        }
        for (i = 0; i < s2; i++) {
          this.words[i] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i = 0; i < s2; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift2) {
      var len = num.length + shift2;
      var i;
      this._expand(len);
      var w2;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w2 = (this.words[i + shift2] | 0) + carry;
        var right = (num.words[i] | 0) * mul3;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i + shift2] = w2 & 67108863;
      }
      for (; i < this.length - shift2; i++) {
        w2 = (this.words[i + shift2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i + shift2] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w2 = -(this.words[i] | 0) + carry;
        carry = w2 >> 26;
        this.words[i] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift2 = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift2 = 26 - bhiBits;
      if (shift2 !== 0) {
        b2 = b2.ushln(shift2);
        a2.iushln(shift2);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i = 0; i < q2.length; i++) {
          q2.words[i] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj2 = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj2, j2);
        while (a2.negative !== 0) {
          qj2--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj2;
        }
      }
      if (q2) {
        q2._strip();
      }
      a2._strip();
      if (mode !== "div" && shift2 !== 0) {
        a2.iushrn(shift2);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p2 * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w2 = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x = this;
      var y2 = p2.clone();
      if (x.negative !== 0) {
        x = x.umod(p2);
      } else {
        x = x.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x.isEven() && y2.isEven()) {
        x.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x.cmp(y2) >= 0) {
          x.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a2.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a2.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift2 = 0; a2.isEven() && b2.isEven(); shift2++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift2);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i = s2; carry !== 0 && i < this.length; i++) {
        var w2 = this.words[i] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i] = w2;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero2() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a2 = this.words[i] | 0;
        var b2 = num.words[i] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq4(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split2(input2, out) {
      input2.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input2, output2) {
      var mask = 4194303;
      var outLen = Math.min(input2.length, 9);
      for (var i = 0; i < outLen; i++) {
        output2.words[i] = input2.words[i];
      }
      output2.length = outLen;
      if (input2.length <= 9) {
        input2.words[0] = 0;
        input2.length = 1;
        return;
      }
      var prev = input2.words[9];
      output2.words[output2.length++] = prev & mask;
      for (i = 10; i < input2.length; i++) {
        var next = input2.words[i] | 0;
        input2.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input2.words[i - 10] = prev;
      if (prev === 0 && input2.length > 10) {
        input2.length -= 10;
      } else {
        input2.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w2 = num.words[i] | 0;
        lo += w2 * 977;
        num.words[i] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi2 = (num.words[i] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b2.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      move(a2, a2.umod(this.m)._forceRed(this));
      return a2;
    };
    Red.prototype.neg = function neg3(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add3(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul3(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow3 = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow3);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c2 = this.pow(z, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow3(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul3(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module2, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(bnExports);
const version$w = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
let Logger$1 = class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel2, args) {
    const level = logLevel2.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel2);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex2 = "";
          for (let i = 0; i < value.length; i++) {
            hex2 += HEX[value[i] >> 4];
            hex2 += HEX[value[i] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex2 + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$w);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel2) {
    const level = LogLevels[logLevel2.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel2);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
};
Logger$1.errors = ErrorCode;
Logger$1.levels = LogLevel;
const lib_esm$k = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ErrorCode() {
    return ErrorCode;
  },
  get LogLevel() {
    return LogLevel;
  },
  Logger: Logger$1
}, Symbol.toStringTag, { value: "Module" }));
const version$v = "bytes/5.7.0";
const logger$A = new Logger$1(version$v);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes$1(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes$1(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v3 = value[i];
    if (!isInteger(v3) || v3 < 0 || v3 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$A.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex2 = value.substring(2);
    if (hex2.length % 2) {
      if (options.hexPad === "left") {
        hex2 = "0" + hex2;
      } else if (options.hexPad === "right") {
        hex2 += "0";
      } else {
        logger$A.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex2.length; i += 2) {
      result.push(parseInt(hex2.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes$1(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$A.throwArgumentError("invalid arrayify value", "value", value);
}
function concat$1(items) {
  const objects = items.map((item2) => arrayify(item2));
  const length = objects.reduce((accum, item2) => accum + item2.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset2, object) => {
    result.set(object, offset2);
    return offset2 + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger$A.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger$A.checkSafeUint53(value, "invalid hexlify value");
    let hex2 = "";
    while (value) {
      hex2 = HexCharacters[value & 15] + hex2;
      value = Math.floor(value / 16);
    }
    if (hex2.length) {
      if (hex2.length % 2) {
        hex2 = "0" + hex2;
      }
      return "0x" + hex2;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger$A.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes$1(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v3 = value[i];
      result += HexCharacters[(v3 & 240) >> 4] + HexCharacters[v3 & 15];
    }
    return result;
  }
  return logger$A.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset2, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger$A.throwArgumentError("invalid hexData", "value", data);
  }
  offset2 = 2 + 2 * offset2;
  if (endOffset != null) {
    return "0x" + data.substring(offset2, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset2);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item2) => {
    result += hexlify(item2).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger$A.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset2 = 0;
  while (offset2 < value.length && value[offset2] === "0") {
    offset2++;
  }
  return "0x" + value.substring(offset2);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger$A.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger$A.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes3 = arrayify(signature2);
    if (bytes3.length === 64) {
      result.v = 27 + (bytes3[32] >> 7);
      bytes3[32] &= 127;
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
    } else if (bytes3.length === 65) {
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
      result.v = bytes3[64];
    } else {
      logger$A.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$A.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes3[32] |= 128;
    }
    result._vs = hexlify(bytes3.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$A.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$A.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$A.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$A.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger$A.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger$A.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$A.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger$A.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$A.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat$1([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
const lib_esm$j = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayify,
  concat: concat$1,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  isBytes: isBytes$1,
  isBytesLike,
  isHexString,
  joinSignature,
  splitSignature,
  stripZeros,
  zeroPad
}, Symbol.toStringTag, { value: "Module" }));
const version$u = "bignumber/5.7.0";
var BN = BN$1.BN;
const logger$z = new Logger$1(version$u);
const _constructorGuard$4 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish$1(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes$1(value));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex2) {
    if (constructorGuard !== _constructorGuard$4) {
      logger$z.throwError("cannot call constructor directly; use BigNumber.from", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex2;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o2 = BigNumber.from(other);
    if (o2.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$z.throwError("this platform does not support BigInt", Logger$1.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$z.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$z.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger$1.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$z.throwError("BigNumber.toString does not accept parameters", Logger$1.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$4, toHex$3(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$4, toHex$3(new BN(value)));
      }
      return logger$z.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes$1(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex2 = anyValue.toHexString();
        if (typeof hex2 === "string") {
          return BigNumber.from(hex2);
        }
      } else {
        let hex2 = anyValue._hex;
        if (hex2 == null && anyValue.type === "BigNumber") {
          hex2 = anyValue.hex;
        }
        if (typeof hex2 === "string") {
          if (isHexString(hex2) || hex2[0] === "-" && isHexString(hex2.substring(1))) {
            return BigNumber.from(hex2);
          }
        }
      }
    }
    return logger$z.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$3(value) {
  if (typeof value !== "string") {
    return toHex$3(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$z.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$3(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$3(value));
}
function toBN(value) {
  const hex2 = BigNumber.from(value).toHexString();
  if (hex2[0] === "-") {
    return new BN("-" + hex2.substring(3), 16);
  }
  return new BN(hex2.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$z.throwError(fault, Logger$1.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
const logger$y = new Logger$1(version$u);
const _constructorGuard$3 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger$y.throwError(message, Logger$1.errors.NUMERIC_FAULT, params);
}
let zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger$y.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$y.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$y.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$y.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$y.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed")
        ;
      else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger$y.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key2, type, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type) {
          logger$y.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$y.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$y.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$3, signed2, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex2, value, format2) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$y.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format2;
    this._hex = hex2;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$y.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$y.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$y.throwArgumentError("invalid byte width", "width", width);
    }
    const hex2 = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex2, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format2) {
    return FixedNumber.fromString(this._value, format2);
  }
  static fromValue(value, decimals, format2) {
    if (format2 == null && decimals != null && !isBigNumberish$1(decimals)) {
      format2 = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format2 == null) {
      format2 = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format2));
  }
  static fromString(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex2 = null;
    if (fixedFormat.signed) {
      hex2 = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex2 = numeric.toHexString();
      hex2 = hexZeroPad(hex2, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex2, decimal, fixedFormat);
  }
  static fromBytes(value, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex2 = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex2, decimal, fixedFormat);
  }
  static from(value, format2) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format2);
    }
    if (isBytes$1(value)) {
      return FixedNumber.fromBytes(value, format2);
    }
    try {
      return FixedNumber.fromValue(value, 0, format2);
    } catch (error) {
      if (error.code !== Logger$1.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger$y.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
const version$t = "properties/5.7.0";
var __awaiter$e = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$x = new Logger$1(version$t);
function defineReadOnly$1(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic$1(ctor, key2) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties$1(object) {
  return __awaiter$e(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v3) => ({ key: key2, value: v3 }));
    });
    const results2 = yield Promise.all(promises);
    return results2.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties$1(object, properties) {
  if (!object || typeof object !== "object") {
    logger$x.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger$x.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy$1(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$x.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item2) => deepCopy$1(item2)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly$1(result, key2, deepCopy$1(value));
    }
    return result;
  }
  return logger$x.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy$1(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy$1(info[key2]);
    }
  }
}
const lib_esm$i = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Description,
  checkProperties: checkProperties$1,
  deepCopy: deepCopy$1,
  defineReadOnly: defineReadOnly$1,
  getStatic: getStatic$1,
  resolveProperties: resolveProperties$1,
  shallowCopy: shallowCopy$1
}, Symbol.toStringTag, { value: "Module" }));
const version$s = "abi/5.7.0";
const logger$w = new Logger$1(version$s);
const _constructorGuard$2 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$w.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger$w.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent3) {
    let node2 = { type: "", name: "", parent: parent3, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent2 = { type: "", name: "", state: { allowType: true } };
  let node = parent2;
  for (let i = 0; i < param.length; i++) {
    let c2 = param[i];
    switch (c2) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c2;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c2;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c2;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c2;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c2;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger$w.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent2.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent2.type = verifyType(parent2.type);
  return parent2;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly$1(object, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$w.throwError("use fromString", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$w.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format2);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format2 !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$2, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$w.throwError("use a static from method", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$w.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$w.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$w.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input2) => JSON.parse(input2.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input2) => input2.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$w.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger$w.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$w.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$w.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$w.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$w.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$w.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$w.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$w.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$w.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$w.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input2) => JSON.parse(input2.format(format2)))
      });
    }
    if (format2 === FormatTypes.sighash) {
      logger$w.throwError("cannot format a constructor for sighash", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input2) => input2.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$w.throwArgumentError("invalid constructor object", "value", value);
    }
    let state = verifyState(value);
    if (state.constant) {
      logger$w.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$w.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$w.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input2) => JSON.parse(input2.format(format2))),
        outputs: this.outputs.map((output2) => JSON.parse(output2.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input2) => input2.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output2) => output2.format(format2)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$w.throwArgumentError("invalid function object", "value", value);
    }
    let state = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$w.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$w.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns2 = comps[1].match(regexParen);
      if (returns2[1].trim() != "" || returns2[3].trim() != "") {
        logger$w.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns2[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$w.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$w.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input2) => JSON.parse(input2.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input2) => input2.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$w.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$2, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$w.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$w.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset2 = 0; offset2 < value.length; offset2++) {
    let c2 = value[offset2];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger$w.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$v = new Logger$1(version$s);
function checkResultErrors(result) {
  const errors2 = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors2.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors2;
}
class Coder {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger$v.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly$1(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat$1(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes3 = arrayify(value);
    const paddingOffset = bytes3.length % this.wordSize;
    if (paddingOffset) {
      bytes3 = concat$1([bytes3, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes3);
  }
  _getValue(value) {
    let bytes3 = arrayify(BigNumber.from(value));
    if (bytes3.length > this.wordSize) {
      logger$v.throwError("value out-of-bounds", Logger$1.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes3.length
      });
    }
    if (bytes3.length % this.wordSize) {
      bytes3 = concat$1([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
    }
    return bytes3;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset2 = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset2] = this._getValue(value);
    };
  }
}
class Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly$1(this, "_data", arrayify(data));
    defineReadOnly$1(this, "wordSize", wordSize || 32);
    defineReadOnly$1(this, "_coerceFunc", coerceFunc);
    defineReadOnly$1(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset2, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger$v.throwError("data out-of-bounds", Logger$1.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset2) {
    return new Reader(this._data.slice(this._offset + offset2), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes3 = this._peekBytes(0, length, !!loose);
    this._offset += bytes3.length;
    return bytes3.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser$1 = { exports: {} };
var process = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e2) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e2) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e22) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e22) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$2() {
}
process.on = noop$2;
process.addListener = noop$2;
process.once = noop$2;
process.off = noop$2;
process.removeListener = noop$2;
process.removeAllListeners = noop$2;
process.emit = noop$2;
process.prependListener = noop$2;
process.prependOnceListener = noop$2;
process.listeners = function(name2) {
  return [];
};
process.binding = function(name2) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var sha3$1 = { exports: {} };
(function(module2) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root2 = WINDOW ? window : {};
    if (root2.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root2.JS_SHA3_NO_NODE_JS && typeof process$1 === "object" && process$1.versions && process$1.versions.node;
    if (NODE_JS) {
      root2 = commonjsGlobal;
    } else if (WEB_WORKER) {
      root2 = self;
    }
    var COMMON_JS = !root2.JS_SHA3_NO_COMMON_JS && true && module2.exports;
    var ARRAY_BUFFER = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method[type] = createMethod2(bits2, padding2, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak2(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak2(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n2, s2) {
        if (!n2 && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak2(bits2, padding2, outputBits).bytepad([n2, s2], w2);
        }
      };
      method.update = function(message, outputBits, n2, s2) {
        return method.create(outputBits, n2, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w2).bytepad([key2], w2);
      };
      method.update = function(key2, message, outputBits, s2) {
        return method.create(key2, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak2(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i2 = 0; i2 < 50; ++i2) {
        this.s[i2] = 0;
      }
    }
    Keccak2.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i2, code2;
      while (index2 < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        if (notString) {
          for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
            blocks[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
            } else if (code2 < 2048) {
              blocks[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        if (i2 >= byteCount) {
          this.start = i2 - byteCount;
          this.block = blocks[blockCount];
          for (i2 = 0; i2 < blockCount; ++i2) {
            s2[i2] ^= blocks[i2];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i2;
        }
      }
      return this;
    };
    Keccak2.prototype.encode = function(x, right) {
      var o2 = x & 255, n2 = 1;
      var bytes3 = [o2];
      x = x >> 8;
      o2 = x & 255;
      while (o2 > 0) {
        bytes3.unshift(o2);
        x = x >> 8;
        o2 = x & 255;
        ++n2;
      }
      if (right) {
        bytes3.push(n2);
      } else {
        bytes3.unshift(n2);
      }
      this.update(bytes3);
      return bytes3.length;
    };
    Keccak2.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes3 = 0, length = str.length;
      if (notString) {
        bytes3 = length;
      } else {
        for (var i2 = 0; i2 < str.length; ++i2) {
          var code2 = str.charCodeAt(i2);
          if (code2 < 128) {
            bytes3 += 1;
          } else if (code2 < 2048) {
            bytes3 += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes3 += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i2) & 1023);
            bytes3 += 4;
          }
        }
      }
      bytes3 += this.encode(bytes3 * 8);
      this.update(str);
      return bytes3;
    };
    Keccak2.prototype.bytepad = function(strs, w2) {
      var bytes3 = this.encode(w2);
      for (var i2 = 0; i2 < strs.length; ++i2) {
        bytes3 += this.encodeString(strs[i2]);
      }
      var paddingBytes = w2 - bytes3 % w2;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak2.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i2 >> 2] |= this.padding[i2 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i2 = 1; i2 < blockCount + 1; ++i2) {
          blocks[i2] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i2 = 0; i2 < blockCount; ++i2) {
        s2[i2] ^= blocks[i2];
      }
      f2(s2);
    };
    Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j3 = 0;
      var hex2 = "", block;
      while (j3 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j3 < outputBlocks; ++i2, ++j3) {
          block = s2[i2];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
          i2 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i2];
        hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex2;
    };
    Keccak2.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j3 = 0;
      var bytes3 = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes3);
      }
      var array = new Uint32Array(buffer2);
      while (j3 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j3 < outputBlocks; ++i2, ++j3) {
          array[j3] = s2[i2];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array[i2] = s2[i2];
        buffer2 = buffer2.slice(0, bytes3);
      }
      return buffer2;
    };
    Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
    Keccak2.prototype.digest = Keccak2.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j3 = 0;
      var array = [], offset2, block;
      while (j3 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j3 < outputBlocks; ++i2, ++j3) {
          offset2 = j3 << 2;
          block = s2[i2];
          array[offset2] = block & 255;
          array[offset2 + 1] = block >> 8 & 255;
          array[offset2 + 2] = block >> 16 & 255;
          array[offset2 + 3] = block >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset2 = j3 << 2;
        block = s2[i2];
        array[offset2] = block & 255;
        if (extraBytes > 1) {
          array[offset2 + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset2 + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak2.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak2();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak2.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS) {
      module2.exports = methods;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root2[methodNames[i]] = methods[methodNames[i]];
      }
    }
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs$1(sha3Exports);
function keccak256$2(data) {
  return "0x" + sha3.keccak_256(arrayify(data));
}
const lib_esm$h = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: keccak256$2
}, Symbol.toStringTag, { value: "Module" }));
const version$r = "rlp/5.7.0";
const logger$u = new Logger$1(version$r);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset2, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset2 + i];
  }
  return result;
}
function _encode$1(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode$1(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$u.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode$3(object) {
  return hexlify(_encode$1(object));
}
function _decodeChildren(data, offset2, childOffset, length) {
  const result = [];
  while (childOffset < offset2 + 1 + length) {
    const decoded = _decode$1(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset2 + 1 + length) {
      logger$u.throwError("child data too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode$1(data, offset2) {
  if (data.length === 0) {
    logger$u.throwError("data too short", Logger$1.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset2] >= 248) {
    const lengthLength = data[offset2] - 247;
    if (offset2 + 1 + lengthLength > data.length) {
      logger$u.throwError("data short segment too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length > data.length) {
      logger$u.throwError("data long segment too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset2, offset2 + 1 + lengthLength, lengthLength + length);
  } else if (data[offset2] >= 192) {
    const length = data[offset2] - 192;
    if (offset2 + 1 + length > data.length) {
      logger$u.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset2, offset2 + 1, length);
  } else if (data[offset2] >= 184) {
    const lengthLength = data[offset2] - 183;
    if (offset2 + 1 + lengthLength > data.length) {
      logger$u.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length > data.length) {
      logger$u.throwError("data array too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset2 + 1 + lengthLength, offset2 + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset2] >= 128) {
    const length = data[offset2] - 128;
    if (offset2 + 1 + length > data.length) {
      logger$u.throwError("data too short", Logger$1.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset2 + 1, offset2 + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset2]) };
}
function decode$3(data) {
  const bytes3 = arrayify(data);
  const decoded = _decode$1(bytes3, 0);
  if (decoded.consumed !== bytes3.length) {
    logger$u.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
const lib_esm$g = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$3,
  encode: encode$3
}, Symbol.toStringTag, { value: "Module" }));
const version$q = "address/5.7.0";
const logger$t = new Logger$1(version$q);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger$t.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256$2(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress$1(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$t.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$t.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$t.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$t.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress$1(address) {
  try {
    getAddress$1(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress$1(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress$1(transaction2) {
  let from = null;
  try {
    from = getAddress$1(transaction2.from);
  } catch (error) {
    logger$t.throwArgumentError("missing from address", "transaction", transaction2);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction2.nonce).toHexString()));
  return getAddress$1(hexDataSlice(keccak256$2(encode$3([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger$t.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger$t.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress$1(hexDataSlice(keccak256$2(concat$1(["0xff", getAddress$1(from), salt, initCodeHash])), 12));
}
const lib_esm$f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAddress: getAddress$1,
  getContractAddress: getContractAddress$1,
  getCreate2Address,
  getIcapAddress,
  isAddress: isAddress$1
}, Symbol.toStringTag, { value: "Module" }));
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress$1(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader2) {
    return getAddress$1(hexZeroPad(reader2.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader2) {
    return this.coder.decode(reader2);
  }
}
const logger$s = new Logger$1(version$s);
function pack$1(writer, coders2, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders2.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$s.throwError("cannot encode object for signature with missing names", Logger$1.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger$s.throwError("cannot encode object for signature with duplicate names", Logger$1.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger$s.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders2.length !== arrayValues.length) {
    logger$s.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders2.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader2, coders2) {
  let values = [];
  let baseReader = reader2.subReader(0);
  coders2.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset2 = reader2.readValue();
      let offsetReader = baseReader.subReader(offset2.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger$1.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader2);
      } catch (error) {
        if (error.code === Logger$1.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders2.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders2.forEach((coder, index2) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index2];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value.length;
      writer.writeValue(value.length);
    }
    logger$s.checkArgumentCount(value.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders2 = [];
    for (let i = 0; i < value.length; i++) {
      coders2.push(this.coder);
    }
    return pack$1(writer, coders2, value);
  }
  decode(reader2) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader2.readValue().toNumber();
      if (count2 * 32 > reader2._data.length) {
        logger$s.throwError("insufficient data length", Logger$1.errors.BUFFER_OVERRUN, {
          length: reader2._data.length,
          count: count2
        });
      }
    }
    let coders2 = [];
    for (let i = 0; i < count2; i++) {
      coders2.push(new AnonymousCoder(this.coder));
    }
    return reader2.coerce(this.name, unpack(reader2, coders2));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader2) {
    return reader2.coerce(this.type, !reader2.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader2) {
    return reader2.readBytes(reader2.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader2) {
    return reader2.coerce(this.name, hexlify(super.decode(reader2)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    this.size = size2;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader2) {
    return reader2.coerce(this.name, hexlify(reader2.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader2) {
    reader2.readBytes(0);
    return reader2.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const Two = /* @__PURE__ */ BigNumber.from(2);
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(size2, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    this.size = size2;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v3 = BigNumber.from(value);
    let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v3.gt(bounds) || v3.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v3.lt(Zero$1) || v3.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v3 = v3.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v3 = v3.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v3);
  }
  decode(reader2) {
    let value = reader2.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader2.coerce(this.name, value);
  }
}
const version$p = "strings/5.7.0";
const logger$r = new Logger$1(version$p);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset2, bytes3, output2, badCodepoint) {
  return logger$r.throwArgumentError(`invalid codepoint at offset ${offset2}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset2, bytes3, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o2 = offset2 + 1; o2 < bytes3.length; o2++) {
      if (bytes3[o2] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes3.length - offset2 - 1;
  }
  return 0;
}
function replaceFunc(reason, offset2, bytes3, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset2, bytes3);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes3, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes3 = arrayify(bytes3);
  const result = [];
  let i = 0;
  while (i < bytes3.length) {
    const c2 = bytes3[i++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes3, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes3, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes3.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes3, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes3[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes3, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$r.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      if (i >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex2 = "0000" + value.toString(16);
  return "\\u" + hex2.substring(hex2.length - 4);
}
function _toEscapedUtf8String(bytes3, onError) {
  return '"' + getUtf8CodePoints(bytes3, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function formatBytes32String(text2) {
  const bytes3 = toUtf8Bytes(text2);
  if (bytes3.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat$1([bytes3, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes3) {
  const data = arrayify(bytes3);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi2 = 0;
  return data.split(",").map((v3) => {
    let comps = v3.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi2 + parseInt(comps[0], 16);
    hi2 = parseInt(comps[1], 16);
    return { l: lo, h: hi2 };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range2 = ranges[i];
    lo += range2.l;
    if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v3) => parseInt(v3, 16));
const Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range2 = matchMap(codepoint, Table_B_2_ranges);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift2 = Table_B_2_lut_rel[codepoint];
  if (shift2) {
    return [codepoint + shift2[0]];
  }
  let complex2 = Table_B_2_complex[codepoint];
  if (complex2) {
    return complex2;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code2) => {
    if (Table_B_1_flags.indexOf(code2) >= 0) {
      return [];
    }
    if (code2 >= 65024 && code2 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code2);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code2];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code2) => {
    if (_nameprepTableC(code2)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code2) => {
    if (_nameprepTableA1(code2)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name2;
}
const lib_esm$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  _toEscapedUtf8String,
  formatBytes32String,
  nameprep,
  parseBytes32String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String
}, Symbol.toStringTag, { value: "Module" }));
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader2) {
    return toUtf8String(super.decode(reader2));
  }
}
class TupleCoder extends Coder {
  constructor(coders2, localName) {
    let dynamic = false;
    const types2 = [];
    coders2.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders2;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack$1(writer, this.coders, value);
  }
  decode(reader2) {
    return reader2.coerce(this.name, unpack(reader2, this.coders));
  }
}
const logger$q = new Logger$1(version$s);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly$1(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size2 = parseInt(match[2] || "256");
      if (size2 === 0 || size2 > 256 || size2 % 8 !== 0) {
        logger$q.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size2 / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size2 = parseInt(match[1]);
      if (size2 === 0 || size2 > 32) {
        logger$q.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size2, param.name);
    }
    return logger$q.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types2) {
    const coders2 = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders2, "_");
    return coder.defaultValue();
  }
  encode(types2, values) {
    if (types2.length !== values.length) {
      logger$q.throwError("types/values length mismatch", Logger$1.errors.INVALID_ARGUMENT, {
        count: { types: types2.length, values: values.length },
        value: { types: types2, values }
      });
    }
    const coders2 = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders2, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types2, data, loose) {
    const coders2 = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders2, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(text2) {
  return keccak256$2(toUtf8Bytes(text2));
}
const version$o = "hash/5.7.0";
function decode$2(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify(data);
}
function encode$2(data) {
  data = arrayify(data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
const lib_esm$d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$2,
  encode: encode$2
}, Symbol.toStringTag, { value: "Module" }));
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes3) {
  let pos = 0;
  function u16() {
    return bytes3[pos++] << 8 | bytes3[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes3[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = Math.pow(2, N2);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register2 = 0;
  for (let i = 0; i < N2; i++)
    register2 = register2 << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register2 - low + 1) * total - 1) / range2);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a2 = low + Math.floor(range2 * acc[start] / total);
    let b2 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register2 = register2 << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register2 = register2 & HALF | register2 << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range2 = 1 + b2 - a2;
  }
  let offset2 = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset2) {
      case 3:
        return offset2 + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 2:
        return offset2 + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 1:
        return offset2 + bytes3[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v3) {
  let pos = 0;
  return () => v3[pos++];
}
function read_compressed_payload(bytes3) {
  return read_payload(decode_arithmetic(bytes3));
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n2, next) {
  let v3 = Array(n2);
  for (let i = 0; i < n2; i++)
    v3[i] = 1 + next();
  return v3;
}
function read_ascending(n2, next) {
  let v3 = Array(n2);
  for (let i = 0, x = -1; i < n2; i++)
    v3[i] = x += 1 + next();
  return v3;
}
function read_deltas(n2, next) {
  let v3 = Array(n2);
  for (let i = 0, x = 0; i < n2; i++)
    v3[i] = x += signed(next());
  return v3;
}
function read_member_array(next, lookup2) {
  let v3 = read_ascending(next(), next);
  let n2 = next();
  let vX = read_ascending(n2, next);
  let vN = read_counts(n2, next);
  for (let i = 0; i < n2; i++) {
    for (let j2 = 0; j2 < vN[i]; j2++) {
      v3.push(vX[i] + j2);
    }
  }
  return lookup2 ? v3.map((x) => lookup2[x]) : v3;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v3 = [];
  while (true) {
    let i = next();
    if (i == 0)
      break;
    v3.push(i);
  }
  return v3;
}
function read_transposed(n2, w2, next) {
  let m2 = Array(n2).fill(void 0).map(() => []);
  for (let i = 0; i < w2; i++) {
    read_deltas(n2, next).forEach((x, j2) => m2[j2].push(x));
  }
  return m2;
}
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m2 = read_transposed(vN.length, 1 + w2, next);
  return flat(m2.map((v3, i) => {
    const x = v3[0], ys = v3.slice(1);
    return Array(vN[i]).fill(void 0).map((_, j2) => {
      let j_dy = j2 * dy;
      return [x + j2 * dx, ys.map((y2) => y2 + j_dy)];
    });
  }));
}
function read_replacement_table(w2, next) {
  let n2 = 1 + next();
  let m2 = read_transposed(n2, 1 + w2, next);
  return m2.map((v3) => [v3[0], v3.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a2, b2) => a2 - b2);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read() });
    }
    branches.sort((a2, b2) => b2.set.size - a2.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}
function getData() {
  return read_compressed_payload(decode$2("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$5 = getData();
const VALID = new Set(read_member_array(r$5));
const IGNORED = new Set(read_member_array(r$5));
const MAPPED = read_mapped_map(r$5);
const EMOJI_ROOT = read_emoji_trie(r$5);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
        if (cps[i] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize(name2, filter_fe0f));
}
function normalize(name2, emoji_filter) {
  let input2 = explode_cp(name2).reverse();
  let output2 = [];
  while (input2.length) {
    let emoji = consume_emoji_reversed(input2);
    if (emoji) {
      output2.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input2.pop();
    if (VALID.has(cp)) {
      output2.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output2.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output2)));
}
function nfc(s2) {
  return s2.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a2;
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  while (pos) {
    let cp = cps[--pos];
    node = (_a2 = node.branches.find((x) => x.set.has(cp))) === null || _a2 === void 0 ? void 0 : _a2.node;
    if (!node)
      break;
    if (node.save) {
      saved = cp;
    } else if (node.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node.valid) {
      emoji = stack.slice();
      if (node.valid == 2)
        emoji.splice(1, 1);
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$p = new Logger$1(version$o);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes3 = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes3.length; i++) {
    const d2 = bytes3[i];
    if (d2 === 46) {
      comps.push(checkComponent(bytes3.slice(last, i)));
      last = i + 1;
    }
  }
  if (last >= bytes3.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes3.slice(last)));
  return comps;
}
function ensNormalize(name2) {
  return ensNameSplit(name2).map((comp) => toUtf8String(comp)).join(".");
}
function isValidName(name2) {
  try {
    return ensNameSplit(name2).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash$1(name2) {
  if (typeof name2 !== "string") {
    logger$p.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros$1;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256$2(concat$1([result, keccak256$2(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat$1(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes3 = new Uint8Array(comp.length + 1);
    bytes3.set(comp, 1);
    bytes3[0] = bytes3.length - 1;
    return bytes3;
  }))) + "00";
}
const messagePrefix = "Ethereum Signed Message:\n";
function hashMessage$1(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256$2(concat$1([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var __awaiter$d = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$o = new Logger$1(version$o);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes3 = arrayify(value);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return hexConcat([bytes3, padding.slice(padOffset)]);
  }
  return hexlify(bytes3);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$o.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$o.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress$1(value).toLowerCase();
    } catch (error) {
    }
    return logger$o.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes3 = arrayify(value);
      if (bytes3.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes3);
    } catch (error) {
    }
    return logger$o.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$o.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v3 = BigNumber.from(value);
        if (v3.lt(boundsLower) || v3.gt(boundsUpper)) {
          logger$o.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v3.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$o.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes3 = arrayify(value);
        if (bytes3.length !== width) {
          logger$o.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress$1(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256$2(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType$1(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types2) {
    defineReadOnly$1(this, "types", Object.freeze(deepCopy$1(types2)));
    defineReadOnly$1(this, "_encoderCache", {});
    defineReadOnly$1(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types2).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types2) {
      const uniqueNames = {};
      types2[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$o.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types2);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$o.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types2);
        }
        const encoder2 = getBaseEncoder(baseType);
        if (encoder2) {
          return;
        }
        if (!parents[baseType]) {
          logger$o.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types2);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
    if (primaryTypes.length === 0) {
      logger$o.throwArgumentError("missing primary type", "types", types2);
    } else if (primaryTypes.length > 1) {
      logger$o.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types2);
    }
    defineReadOnly$1(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$o.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types2);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType$1(name2, types2[name2]) + st.map((t2) => encodeType$1(t2, types2[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder2 = this._encoderCache[type];
    if (!encoder2) {
      encoder2 = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder2;
  }
  _getEncoder(type) {
    {
      const encoder2 = getBaseEncoder(type);
      if (encoder2) {
        return encoder2;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger$o.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256$2);
        }
        return keccak256$2(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak256$2(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$o.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$o.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak256$2(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder2 = getBaseEncoder(type);
      if (encoder2) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger$o.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v3) => this._visit(subtype, v3, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger$o.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name2, types2, value) {
    return TypedDataEncoder.from(types2).hashStruct(name2, value);
  }
  static hashDomain(domain2) {
    const domainFields = [];
    for (const name2 in domain2) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger$o.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
  }
  static encode(domain2, types2, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain2),
      TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  static hash(domain2, types2, value) {
    return keccak256$2(TypedDataEncoder.encode(domain2, types2, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain2, types2, value, resolveName2) {
    return __awaiter$d(this, void 0, void 0, function* () {
      domain2 = shallowCopy$1(domain2);
      const ensCache = {};
      if (domain2.verifyingContract && !isHexString(domain2.verifyingContract, 20)) {
        ensCache[domain2.verifyingContract] = "0x";
      }
      const encoder2 = TypedDataEncoder.from(types2);
      encoder2.visit(value, (type, value2) => {
        if (type === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
        domain2.verifyingContract = ensCache[domain2.verifyingContract];
      }
      value = encoder2.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain: domain2, value };
    });
  }
  static getPayload(domain2, types2, value) {
    TypedDataEncoder.hashDomain(domain2);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain2[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder2 = TypedDataEncoder.from(types2);
    const typesWithDomain = shallowCopy$1(types2);
    if (typesWithDomain.EIP712Domain) {
      logger$o.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder2.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder2.primaryType,
      message: encoder2.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$o.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$o.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
const lib_esm$c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _TypedDataEncoder: TypedDataEncoder,
  dnsEncode,
  ensNormalize,
  hashMessage: hashMessage$1,
  id,
  isValidName,
  messagePrefix,
  namehash: namehash$1
}, Symbol.toStringTag, { value: "Module" }));
const logger$n = new Logger$1(version$s);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap2 = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap2.error = error;
  return wrap2;
}
class Interface {
  constructor(fragments) {
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    defineReadOnly$1(this, "fragments", abi2.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly$1(this, "_abiCoder", getStatic$1(new.target, "getAbiCoder")());
    defineReadOnly$1(this, "functions", {});
    defineReadOnly$1(this, "errors", {});
    defineReadOnly$1(this, "events", {});
    defineReadOnly$1(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$n.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly$1(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger$n.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly$1(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly$1(this, "_isInterface", true);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.full;
    }
    if (format2 === FormatTypes.sighash) {
      logger$n.throwArgumentError("interface does not support formatting sighash", "format", format2);
    }
    const abi2 = this.fragments.map((fragment) => fragment.format(format2));
    if (format2 === FormatTypes.json) {
      return JSON.stringify(abi2.map((j2) => JSON.parse(j2)));
    }
    return abi2;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress$1(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$n.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$n.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$n.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$n.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$n.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$n.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$n.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$n.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic$1(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger$n.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$n.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$n.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$n.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }
    return getStatic$1(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic$1(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$n.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(fragment.inputs, bytes3.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat$1([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$n.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(functionFragment.inputs, bytes3.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat$1([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes3 = arrayify(data);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes3.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes3);
        } catch (error) {
        }
        break;
      case 4: {
        const selector2 = hexlify(bytes3.slice(0, 4));
        const builtin = BuiltinErrors[selector2];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes3.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector2);
            errorArgs = this._abiCoder.decode(error.inputs, bytes3.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger$n.throwError("call revert exception" + message, Logger$1.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$n.throwError("too many arguments for " + eventFragment.format(), Logger$1.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256$2(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value != null) {
          logger$n.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$n.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$n.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256$2(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$n.throwError("fragment/topic mismatch", Logger$1.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat$1(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index2]) {
          result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index2] = error;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index2] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index2];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i = 0; i < result.length; i++) {
      const value = result[i];
      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const lib_esm$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  TransactionDescription,
  checkResultErrors,
  defaultAbiCoder
}, Symbol.toStringTag, { value: "Module" }));
const version$n = "abstract-provider/5.7.0";
var __awaiter$c = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$m = new Logger$1(version$n);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$m.checkAbstract(new.target, Provider);
    defineReadOnly$1(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$c(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties$1({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}
const version$m = "abstract-signer/5.7.0";
var __awaiter$b = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$l = new Logger$1(version$m);
const allowedTransactionKeys$2 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger$1.errors.INSUFFICIENT_FUNDS,
  Logger$1.errors.NONCE_EXPIRED,
  Logger$1.errors.REPLACEMENT_UNDERPRICED
];
let Signer$1 = class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$l.checkAbstract(new.target, Signer);
    defineReadOnly$1(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction2) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties$1(this.checkTransaction(transaction2));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction2, blockTag) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties$1(this.checkTransaction(transaction2));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction2) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction2);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network2 = yield this.provider.getNetwork();
      return network2.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction2) {
    for (const key2 in transaction2) {
      if (allowedTransactionKeys$2.indexOf(key2) === -1) {
        logger$l.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction2);
      }
    }
    const tx = shallowCopy$1(transaction2);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$l.throwArgumentError("from address mismatch", "transaction", transaction2);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction2) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const tx = yield resolveProperties$1(this.checkTransaction(transaction2));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$b(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$l.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$l.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction2);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$l.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction2);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$l.throwError("network does not support EIP-1559", Logger$1.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$l.throwError("failed to get consistent fee data", Logger$1.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$l.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger$1.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results2) => {
          if (results2[1] !== 0 && results2[0] !== results2[1]) {
            logger$l.throwArgumentError("chainId address mismatch", "transaction", transaction2);
          }
          return results2[0];
        });
      }
      return yield resolveProperties$1(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger$l.throwError("missing provider", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};
class VoidSigner extends Signer$1 {
  constructor(address, provider2) {
    super();
    defineReadOnly$1(this, "address", address);
    defineReadOnly$1(this, "provider", provider2 || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$l.throwError(message, Logger$1.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction2) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain2, types2, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider2) {
    return new VoidSigner(this.address, provider2);
  }
}
var hash$3 = {};
var utils$c = {};
var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$b.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser$1.exports;
var assert$a = minimalisticAssert$1;
var inherits = inherits_browserExports;
utils$c.inherits = inherits;
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 64512) !== 55296) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i = 0; i < msg.length; i++) {
        var c2 = msg.charCodeAt(i);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$c.toArray = toArray;
function toHex$2(msg) {
  var res = "";
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$c.toHex = toHex$2;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$c.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i = 0; i < msg.length; i++) {
    var w2 = msg[i];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$c.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$c.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$c.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$a(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k2 = start; i < res.length; i++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i] = w2 >>> 0;
  }
  return res;
}
utils$c.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k2 = 0; i < msg.length; i++, k2 += 4) {
    var m2 = msg[i];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$c.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$c.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$c.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$c.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$c.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$c.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e2) {
  return a2 + b2 + c2 + d2 + e2 >>> 0;
}
utils$c.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah2, al2) {
  var bh2 = buf[pos];
  var bl2 = buf[pos + 1];
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  buf[pos] = hi2 >>> 0;
  buf[pos + 1] = lo;
}
utils$c.sum64 = sum64$1;
function sum64_hi$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  return hi2 >>> 0;
}
utils$c.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2;
  return lo >>> 0;
}
utils$c.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
  return hi2 >>> 0;
}
utils$c.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var lo = al2 + bl2 + cl2 + dl2;
  return lo >>> 0;
}
utils$c.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  lo = lo + el2 >>> 0;
  carry += lo < el2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
utils$c.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var lo = al2 + bl2 + cl2 + dl2 + el2;
  return lo >>> 0;
}
utils$c.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al2, num) {
  var r2 = al2 << 32 - num | ah2 >>> num;
  return r2 >>> 0;
}
utils$c.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$c.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al2, num) {
  return ah2 >>> num;
}
utils$c.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$c.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$b = utils$c;
var assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$b.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$b.join32(msg, 0, msg.length - r2, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes3 = this._delta8;
  var k2 = bytes3 - (len + this.padLength) % bytes3;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i = 1; i < k2; i++)
    res[i] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len & 255;
  } else {
    res[i++] = len & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 24 & 255;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$a = utils$c;
var rotr32 = utils$a.rotr32;
function ft_1$1(s2, x, y2, z) {
  if (s2 === 0)
    return ch32$1(x, y2, z);
  if (s2 === 1 || s2 === 3)
    return p32(x, y2, z);
  if (s2 === 2)
    return maj32$1(x, y2, z);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x, y2, z) {
  return x & y2 ^ ~x & z;
}
common$4.ch32 = ch32$1;
function maj32$1(x, y2, z) {
  return x & y2 ^ x & z ^ y2 & z;
}
common$4.maj32 = maj32$1;
function p32(x, y2, z) {
  return x ^ y2 ^ z;
}
common$4.p32 = p32;
function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$9 = utils$c;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$9.rotl32;
var sum32$2 = utils$9.sum32;
var sum32_5$1 = utils$9.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$9.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = rotl32$1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i = 0; i < W2.length; i++) {
    var s2 = ~~(i / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$9.toHex32(this.h, "big");
  else
    return utils$9.split32(this.h, "big");
};
var utils$8 = utils$c;
var common$2 = common$5;
var shaCommon = common$4;
var assert$8 = minimalisticAssert$1;
var sum32$1 = utils$8.sum32;
var sum32_4$1 = utils$8.sum32_4;
var sum32_5 = utils$8.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$3() {
  if (!(this instanceof SHA256$3))
    return new SHA256$3();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$8.inherits(SHA256$3, BlockHash$2);
var _256 = SHA256$3;
SHA256$3.blockSize = 512;
SHA256$3.outSize = 256;
SHA256$3.hmacStrength = 192;
SHA256$3.padLength = 64;
SHA256$3.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = sum32_4$1(g1_256(W2[i - 2]), W2[i - 7], g0_256(W2[i - 15]), W2[i - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$8(this.k.length === W2.length);
  for (i = 0; i < W2.length; i++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i], W2[i]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$3.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$8.toHex32(this.h, "big");
  else
    return utils$8.split32(this.h, "big");
};
var utils$7 = utils$c;
var SHA256$2 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256$2.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$7.inherits(SHA224, SHA256$2);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$7.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$7.split32(this.h.slice(0, 7), "big");
};
var utils$6 = utils$c;
var common$1 = common$5;
var assert$7 = minimalisticAssert$1;
var rotr64_hi = utils$6.rotr64_hi;
var rotr64_lo = utils$6.rotr64_lo;
var shr64_hi = utils$6.shr64_hi;
var shr64_lo = utils$6.shr64_lo;
var sum64 = utils$6.sum64;
var sum64_hi = utils$6.sum64_hi;
var sum64_lo = utils$6.sum64_lo;
var sum64_4_hi = utils$6.sum64_4_hi;
var sum64_4_lo = utils$6.sum64_4_lo;
var sum64_5_hi = utils$6.sum64_5_hi;
var sum64_5_lo = utils$6.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$6.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 32; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i += 2) {
    var c0_hi = g1_512_hi(W2[i - 4], W2[i - 3]);
    var c0_lo = g1_512_lo(W2[i - 4], W2[i - 3]);
    var c1_hi = W2[i - 14];
    var c1_lo = W2[i - 13];
    var c2_hi = g0_512_hi(W2[i - 30], W2[i - 29]);
    var c2_lo = g0_512_lo(W2[i - 30], W2[i - 29]);
    var c3_hi = W2[i - 32];
    var c3_lo = W2[i - 31];
    W2[i] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al2 = this.h[1];
  var bh2 = this.h[2];
  var bl2 = this.h[3];
  var ch2 = this.h[4];
  var cl2 = this.h[5];
  var dh2 = this.h[6];
  var dl2 = this.h[7];
  var eh2 = this.h[8];
  var el2 = this.h[9];
  var fh2 = this.h[10];
  var fl2 = this.h[11];
  var gh2 = this.h[12];
  var gl2 = this.h[13];
  var hh2 = this.h[14];
  var hl2 = this.h[15];
  assert$7(this.k.length === W2.length);
  for (var i = 0; i < W2.length; i += 2) {
    var c0_hi = hh2;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh2, el2);
    var c1_lo = s1_512_lo(eh2, el2);
    var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
    var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W2[i];
    var c4_lo = W2[i + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al2);
    c0_lo = s0_512_lo(ah2, al2);
    c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
    c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
    el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al2);
  sum64(this.h, 2, bh2, bl2);
  sum64(this.h, 4, ch2, cl2);
  sum64(this.h, 6, dh2, dl2);
  sum64(this.h, 8, eh2, el2);
  sum64(this.h, 10, fh2, fl2);
  sum64(this.h, 12, gh2, gl2);
  sum64(this.h, 14, hh2, hl2);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h, "big");
  else
    return utils$6.split32(this.h, "big");
};
function ch64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ ~xh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 28);
  var c1_hi = rotr64_hi(xl, xh2, 2);
  var c2_hi = rotr64_hi(xl, xh2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 28);
  var c1_lo = rotr64_lo(xl, xh2, 2);
  var c2_lo = rotr64_lo(xl, xh2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 14);
  var c1_hi = rotr64_hi(xh2, xl, 18);
  var c2_hi = rotr64_hi(xl, xh2, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 14);
  var c1_lo = rotr64_lo(xh2, xl, 18);
  var c2_lo = rotr64_lo(xl, xh2, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 1);
  var c1_hi = rotr64_hi(xh2, xl, 8);
  var c2_hi = shr64_hi(xh2, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 1);
  var c1_lo = rotr64_lo(xh2, xl, 8);
  var c2_lo = shr64_lo(xh2, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 19);
  var c1_hi = rotr64_hi(xl, xh2, 29);
  var c2_hi = shr64_hi(xh2, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 19);
  var c1_lo = rotr64_lo(xl, xh2, 29);
  var c2_lo = shr64_lo(xh2, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$5 = utils$c;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$5.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$5.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$4 = utils$c;
var common = common$5;
var rotl32 = utils$4.rotl32;
var sum32 = utils$4.sum32;
var sum32_3 = utils$4.sum32_3;
var sum32_4 = utils$4.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$4.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah2 = A2;
  var Bh2 = B2;
  var Ch2 = C2;
  var Dh2 = D2;
  var Eh2 = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f$1(j2, B2, C2, D2), msg[r$4[j2] + start], K(j2)),
        s$1[j2]
      ),
      E2
    );
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah2, f$1(79 - j2, Bh2, Ch2, Dh2), msg[rh[j2] + start], Kh(j2)),
        sh[j2]
      ),
      Eh2
    );
    Ah2 = Eh2;
    Eh2 = Dh2;
    Dh2 = rotl32(Ch2, 10);
    Ch2 = Bh2;
    Bh2 = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh2);
  this.h[1] = sum32_3(this.h[2], D2, Eh2);
  this.h[2] = sum32_3(this.h[3], E2, Ah2);
  this.h[3] = sum32_3(this.h[4], A2, Bh2);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$4.toHex32(this.h, "little");
  else
    return utils$4.split32(this.h, "little");
};
function f$1(j2, x, y2, z) {
  if (j2 <= 15)
    return x ^ y2 ^ z;
  else if (j2 <= 31)
    return x & y2 | ~x & z;
  else if (j2 <= 47)
    return (x | ~y2) ^ z;
  else if (j2 <= 63)
    return x & z | y2 & ~z;
  else
    return x ^ (y2 | ~z);
}
function K(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r$4 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$3 = utils$c;
var assert$6 = minimalisticAssert$1;
function Hmac(hash2, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key2, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$3.toArray(key2, enc));
}
var hmac$2 = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$6(key2.length <= this.blockSize);
  for (var i = key2.length; i < this.blockSize; i++)
    key2.push(0);
  for (i = 0; i < key2.length; i++)
    key2[i] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i = 0; i < key2.length; i++)
    key2[i] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash2 = exports;
  hash2.utils = utils$c;
  hash2.common = common$5;
  hash2.sha = sha;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac$2;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$3);
const hash$2 = /* @__PURE__ */ getDefaultExportFromCjs$1(hash$3);
function createCommonjsModule(fn, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module2.path : base2);
    }
  }, fn(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1 = createCommonjsModule(function(module2, exports) {
  var utils2 = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c2 = msg.charCodeAt(i);
        var hi2 = c2 >> 8;
        var lo = c2 & 255;
        if (hi2)
          res.push(hi2, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero22(msg[i].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode3(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module2, exports) {
  var utils2 = exports;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1.toArray;
  utils2.zero2 = utils_1.zero2;
  utils2.toHex = utils_1.toHex;
  utils2.encode = utils_1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod2 = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod2 > (ws >> 1) - 1)
          z = (ws >> 1) - mod2;
        else
          z = mod2;
        k2.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k2.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes3) {
    return typeof bytes3 === "string" ? utils2.toArray(bytes3, "hex") : bytes3;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes3) {
    return new BN$1(bytes3, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$1(conf.p, 16);
  this.red = conf.prime ? BN$1.red(conf.prime) : BN$1.mont(this.p);
  this.zero = new BN$1(0).toRed(this.red);
  this.one = new BN$1(1).toRed(this.red);
  this.two = new BN$1(2).toRed(this.red);
  this.n = conf.n && new BN$1(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
  assert$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i = I2; i > 0; i--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l2 = 0; i >= 0 && naf[i] === 0; i--)
      l2++;
    if (i >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i < 0)
      break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i;
  var j2;
  var p2;
  for (i = 0; i < len; i++) {
    p2 = points[i];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a2 = i - 1;
    var b2 = i;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b2]
      /* 7 */
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index2 = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja2 = jsf[0][j2] | 0;
      var jb2 = jsf[1][j2] | 0;
      naf[a2][j2] = index2[(ja2 + 1) * 3 + (jb2 + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max2; i >= 0; i--) {
    var k2 = 0;
    while (i >= 0) {
      var zero3 = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i] | 0;
        if (tmp[j2] !== 0)
          zero3 = false;
      }
      if (!zero3)
        break;
      k2++;
      i--;
    }
    if (i >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z = tmp[j2];
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j2][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j2][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
  bytes3 = utils_1$1.toArray(bytes3, enc);
  var len = this.p.byteLength();
  if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
    if (bytes3[0] === 6)
      assert$1(bytes3[bytes3.length - 1] % 2 === 0);
    else if (bytes3[0] === 7)
      assert$1(bytes3[bytes3.length - 1] % 2 === 1);
    var res = this.point(
      bytes3.slice(1, 1 + len),
      bytes3.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
    return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl3 = max2 === 1 ? null : this.dbl();
  for (var i = 1; i < max2; i++)
    res[i] = res[i - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k2) {
  var r2 = this;
  for (var i = 0; i < k2; i++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module2) {
  if (typeof Object.create === "function") {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new BN$1(conf.a, 16).toRed(this.red);
  this.b = new BN$1(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$1(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$1(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$1(vec.a, 16),
        b: new BN$1(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$1.mont(num);
  var tinv = new BN$1(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$1(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v3 = this.n.clone();
  var x1 = new BN$1(1);
  var y1 = new BN$1(0);
  var x2 = new BN$1(0);
  var y2 = new BN$1(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r2;
  var x;
  while (u2.cmpn(0) !== 0) {
    var q2 = v3.div(u2);
    r2 = v3.sub(q2.mul(u2));
    x = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r2;
    v3 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v12 = basis[0];
  var v22 = basis[1];
  var c1 = v22.b.mul(k2).divRound(this.n);
  var c2 = v12.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v12.a);
  var p2 = c2.mul(v22.a);
  var q1 = c1.mul(v12.b);
  var q2 = c2.mul(v22.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$1(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x, y3);
};
ShortCurve.prototype.validate = function validate3(point3) {
  if (point3.inf)
    return true;
  var x = point3.x;
  var y2 = point3.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split2 = this._endoSplit(coeffs[i]);
    var p2 = points[i];
    var beta = p2._getBeta();
    if (split2.k1.negative) {
      split2.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split2.k2.negative) {
      split2.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p2;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split2.k1;
    ncoeffs[i * 2 + 1] = split2.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j2 = 0; j2 < i * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point(curve, x, y2, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$1(x, 16);
    this.y = new BN$1(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x, y2, isRed) {
  return new Point(this, x, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k2) {
  k2 = new BN$1(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate2 = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate2)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate2)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x, y2, z) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x === null && y2 === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$1(0);
  } else {
    this.x = new BN$1(x, 16);
    this.y = new BN$1(y2, 16);
    this.z = new BN$1(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y2, z) {
  return new JPoint(this, x, y2, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v3 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v3).redISub(v3);
  var ny = r2.redMul(v3.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v3 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v3).redISub(v3);
  var ny = r2.redMul(v3.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow3) {
  if (pow3 === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow3)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i = 0; i < pow3; i++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow3; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow3)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f2 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha2 = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha2 = alpha2.redAdd(alpha2).redIAdd(alpha2);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha2.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha2.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee2 = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k2, kbase) {
  k2 = new BN$1(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc2 = x.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc2.iadd(this.curve.n);
    if (xc2.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module2, exports) {
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function(module2, exports) {
  var curves = exports;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$2.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$2.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$2.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$2.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add3 = utils_1.toArray(add3, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add3);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$1(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN$1(options.r, 16);
  this.s = new BN$1(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$3 = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p2.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p2 = new Position();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$1(r2);
  this.s = new BN$1(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
);
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes3 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$1(2));
  for (; ; ) {
    var priv = new BN$1(drbg.generate(bytes3));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$1(msg, 16));
  var bytes3 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes3);
  var nonce = msg.toArray("be", bytes3);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$1(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new BN$1(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature$3({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$12, key2, enc) {
  msg = this._truncateToN(new BN$1(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$12 = new signature$3(signature$12, "hex");
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$12, j2, enc) {
  assert$5((3 & j2) === j2, "The recovery param is more than two bits");
  signature$12 = new signature$3(signature$12, enc);
  var n2 = this.n;
  var e2 = new BN$1(msg);
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$12.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$12, Q2, enc) {
  signature$12 = new signature$3(signature$12, enc);
  if (signature$12.recoveryParam !== null)
    return signature$12.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$12, i);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module2, exports) {
  var elliptic = exports;
  elliptic.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;
const version$l = "signing-key/5.7.0";
const logger$k = new Logger$1(version$l);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly$1(this, "curve", "secp256k1");
    defineReadOnly$1(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$k.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly$1(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly$1(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly$1(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest9);
    if (digestBytes.length !== 32) {
      logger$k.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes3 = arrayify(key2);
  if (bytes3.length === 32) {
    const signingKey = new SigningKey(bytes3);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes3).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes3.length === 33) {
    if (compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(false, "hex");
  } else if (bytes3.length === 65) {
    if (!compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(true, "hex");
  }
  return logger$k.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const lib_esm$a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SigningKey,
  computePublicKey,
  recoverPublicKey
}, Symbol.toStringTag, { value: "Module" }));
const version$k = "transactions/5.7.0";
const logger$j = new Logger$1(version$k);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress$1(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
const transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
const allowedTransactionKeys$1 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress$1(hexDataSlice(keccak256$2(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest9), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$j.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress$1(addr),
    storageKeys: (storageKeys || []).map((storageKey2, index2) => {
      if (hexDataLength(storageKey2) !== 32) {
        logger$j.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey2);
      }
      return storageKey2.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index2) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger$j.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey2) => {
      accum[storageKey2] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction2, signature2) {
  if (transaction2.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction2.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction2.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$j.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction2.chainId || 0, "chainId"),
    formatNumber(transaction2.nonce || 0, "nonce"),
    formatNumber(transaction2.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction2.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction2.gasLimit || 0, "gasLimit"),
    transaction2.to != null ? getAddress$1(transaction2.to) : "0x",
    formatNumber(transaction2.value || 0, "value"),
    transaction2.data || "0x",
    formatAccessList(transaction2.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$3(fields)]);
}
function _serializeEip2930(transaction2, signature2) {
  const fields = [
    formatNumber(transaction2.chainId || 0, "chainId"),
    formatNumber(transaction2.nonce || 0, "nonce"),
    formatNumber(transaction2.gasPrice || 0, "gasPrice"),
    formatNumber(transaction2.gasLimit || 0, "gasLimit"),
    transaction2.to != null ? getAddress$1(transaction2.to) : "0x",
    formatNumber(transaction2.value || 0, "value"),
    transaction2.data || "0x",
    formatAccessList(transaction2.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$3(fields)]);
}
function _serialize(transaction2, signature2) {
  checkProperties$1(transaction2, allowedTransactionKeys$1);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction2[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger$j.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger$j.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction2.chainId != null) {
    chainId = transaction2.chainId;
    if (typeof chainId !== "number") {
      logger$j.throwArgumentError("invalid transaction.chainId", "transaction", transaction2);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode$3(raw);
  }
  const sig = splitSignature(signature2);
  let v3 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v3 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v3) {
      logger$j.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v3) {
    logger$j.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v3));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode$3(raw);
}
function serialize$2(transaction2, signature2) {
  if (transaction2.type == null || transaction2.type === 0) {
    if (transaction2.accessList != null) {
      logger$j.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction2);
    }
    return _serialize(transaction2, signature2);
  }
  switch (transaction2.type) {
    case 1:
      return _serializeEip2930(transaction2, signature2);
    case 2:
      return _serializeEip1559(transaction2, signature2);
  }
  return logger$j.throwError(`unsupported transaction type: ${transaction2.type}`, Logger$1.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction2.type
  });
}
function _parseEipSignature(tx, fields, serialize2) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$j.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256$2(serialize2(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction2 = decode$3(payload.slice(1));
  if (transaction2.length !== 9 && transaction2.length !== 12) {
    logger$j.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction2[2]);
  const maxFeePerGas = handleNumber(transaction2[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction2[0]).toNumber(),
    nonce: handleNumber(transaction2[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction2[4]),
    to: handleAddress(transaction2[5]),
    value: handleNumber(transaction2[6]),
    data: transaction2[7],
    accessList: accessListify(transaction2[8])
  };
  if (transaction2.length === 9) {
    return tx;
  }
  tx.hash = keccak256$2(payload);
  _parseEipSignature(tx, transaction2.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction2 = decode$3(payload.slice(1));
  if (transaction2.length !== 8 && transaction2.length !== 11) {
    logger$j.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction2[0]).toNumber(),
    nonce: handleNumber(transaction2[1]).toNumber(),
    gasPrice: handleNumber(transaction2[2]),
    gasLimit: handleNumber(transaction2[3]),
    to: handleAddress(transaction2[4]),
    value: handleNumber(transaction2[5]),
    data: transaction2[6],
    accessList: accessListify(transaction2[7])
  };
  if (transaction2.length === 8) {
    return tx;
  }
  tx.hash = keccak256$2(payload);
  _parseEipSignature(tx, transaction2.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction2 = decode$3(rawTransaction);
  if (transaction2.length !== 9 && transaction2.length !== 6) {
    logger$j.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction2[0]).toNumber(),
    gasPrice: handleNumber(transaction2[1]),
    gasLimit: handleNumber(transaction2[2]),
    to: handleAddress(transaction2[3]),
    value: handleNumber(transaction2[4]),
    data: transaction2[5],
    chainId: 0
  };
  if (transaction2.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction2[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction2[7], 32);
  tx.s = hexZeroPad(transaction2[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction2.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256$2(encode$3(raw));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256$2(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse$2(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$j.throwError(`unsupported transaction type: ${payload[0]}`, Logger$1.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const lib_esm$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TransactionTypes() {
    return TransactionTypes;
  },
  accessListify,
  computeAddress,
  parse: parse$2,
  recoverAddress,
  serialize: serialize$2
}, Symbol.toStringTag, { value: "Module" }));
const version$j = "contracts/5.7.0";
var __awaiter$a = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$i = new Logger$1(version$j);
function resolveName(resolver, nameOrPromise) {
  return __awaiter$a(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger$i.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress$1(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger$i.throwError("a provider or signer is needed to resolve ENS names", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger$i.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter$a(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index2) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger$i.makeError("invalid value for array", Logger$1.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v3) => resolveAddresses(resolver, v3, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$a(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy$1(args.pop());
    }
    logger$i.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties$1({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter$a(this, void 0, void 0, function* () {
          if (getAddress$1(check.signer) !== check.override) {
            logger$i.throwError("Contract with a Signer cannot override from", Logger$1.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties$1({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties$1(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes3 = arrayify(data);
      for (let i = 0; i < bytes3.length; i++) {
        intrinsic += 4;
        if (bytes3[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger$i.throwError("non-payable method cannot override value", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy$1(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger$i.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$a(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger$i.throwError("estimate require a provider or signer", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait2 = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait2(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy$1(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e2) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$a(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy$1(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger$1.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter$a(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger$i.throwError("sending a transaction requires a signer", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag$1(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter2) {
    defineReadOnly$1(this, "tag", tag);
    defineReadOnly$1(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item2) => {
      if (done || item2.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i) => i.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item2) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item2.listener.apply(this, argsCopy);
      }, 0);
      return !item2.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger$i.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag$1(filter2), filter2);
    defineReadOnly$1(this, "address", address);
    defineReadOnly$1(this, "interface", contractInterface);
    defineReadOnly$1(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors2 = checkResultErrors(event.args);
    if (errors2.length) {
      throw errors2[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly$1(this, "address", address);
    defineReadOnly$1(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly$1(this, "interface", getStatic$1(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly$1(this, "provider", null);
      defineReadOnly$1(this, "signer", null);
    } else if (Signer$1.isSigner(signerOrProvider)) {
      defineReadOnly$1(this, "provider", signerOrProvider.provider || null);
      defineReadOnly$1(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly$1(this, "provider", signerOrProvider);
      defineReadOnly$1(this, "signer", null);
    } else {
      logger$i.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly$1(this, "callStatic", {});
    defineReadOnly$1(this, "estimateGas", {});
    defineReadOnly$1(this, "functions", {});
    defineReadOnly$1(this, "populateTransaction", {});
    defineReadOnly$1(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly$1(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly$1(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger$i.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly$1(this, "_runningEvents", {});
    defineReadOnly$1(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger$i.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly$1(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly$1(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly$1(this, "resolvedAddress", Promise.resolve(getAddress$1(addressOrName)));
      } catch (error) {
        logger$i.throwError("provider is required to use ENS name as contract address", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e2) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger$i.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly$1(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly$1(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly$1(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly$1(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly$1(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly$1(this, name2, this[signature2]);
        }
      } catch (e2) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly$1(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly$1(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly$1(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly$1(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction2) {
    return getContractAddress$1(transaction2);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger$i.throwError("contract not deployed", Logger$1.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger$i.throwError("sending a transactions require a signer", Logger$1.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy$1(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger$i.throwError("cannot override " + key2, Logger$1.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly$1(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy$1(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger$i.throwError("events require a provider or a signer with a provider", Logger$1.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy$1(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger$i.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
class Contract extends BaseContract {
}
class BaseX {
  constructor(alphabet) {
    defineReadOnly$1(this, "alphabet", alphabet);
    defineReadOnly$1(this, "base", alphabet.length);
    defineReadOnly$1(this, "_alphabetMap", {});
    defineReadOnly$1(this, "_leader", alphabet.charAt(0));
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string += this.alphabet[digits[q2]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes3 = [];
    if (value.length === 0) {
      return new Uint8Array(bytes3);
    }
    bytes3.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j2 = 0; j2 < bytes3.length; ++j2) {
        carry += bytes3[j2] * this.base;
        bytes3[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes3.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes3.push(0);
    }
    return arrayify(new Uint8Array(bytes3.reverse()));
  }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const lib_esm$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Base32,
  Base58,
  BaseX
}, Symbol.toStringTag, { value: "Module" }));
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$i = "sha2/5.7.0";
const logger$h = new Logger$1(version$i);
function ripemd160(data) {
  return "0x" + hash$2.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256$4(data) {
  return "0x" + hash$2.sha256().update(arrayify(data)).digest("hex");
}
function sha512(data) {
  return "0x" + hash$2.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key2, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger$h.throwError("unsupported algorithm " + algorithm, Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + hash$2.hmac(hash$2[algorithm], arrayify(key2)).update(arrayify(data)).digest("hex");
}
const lib_esm$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  },
  computeHmac,
  ripemd160,
  sha256: sha256$4,
  sha512
}, Symbol.toStringTag, { value: "Module" }));
function pbkdf2$1(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l2 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T2;
  for (let i = 1; i <= l2; i++) {
    block1[salt.length] = i >> 24 & 255;
    block1[salt.length + 1] = i >> 16 & 255;
    block1[salt.length + 2] = i >> 8 & 255;
    block1[salt.length + 3] = i & 255;
    let U2 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U2.length;
      T2 = new Uint8Array(hLen);
      l2 = Math.ceil(keylen / hLen);
      r2 = keylen - (l2 - 1) * hLen;
    }
    T2.set(U2);
    for (let j2 = 1; j2 < iterations; j2++) {
      U2 = arrayify(computeHmac(hashAlgorithm, password, U2));
      for (let k2 = 0; k2 < hLen; k2++)
        T2[k2] ^= U2[k2];
    }
    const destPos = (i - 1) * hLen;
    const len = i === l2 ? r2 : hLen;
    DK.set(arrayify(T2).slice(0, len), destPos);
  }
  return hexlify(DK);
}
const version$h = "wordlists/5.7.0";
const logger$g = new Logger$1(version$h);
class Wordlist {
  constructor(locale) {
    logger$g.checkAbstract(new.target, Wordlist);
    defineReadOnly$1(this, "locale", locale);
  }
  // Subclasses may override this
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i = 0; i < 2048; i++) {
      const word = wordlist2.getWord(i);
      if (i !== wordlist2.getWordIndex(word)) {
        return "0x";
      }
      words2.push(word);
    }
    return id(words2.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index2) {
    loadWords(this);
    return wordlist[index2];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
};
const version$g = "hdnode/5.7.0";
const logger$f = new Logger$1(version$g);
const N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const MasterSecret = toUtf8Bytes("Bitcoin seed");
const HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
  return Base58.encode(concat$1([data, hexDataSlice(sha256$4(sha256$4(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger$f.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
const _constructorGuard$1 = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
    if (constructorGuard !== _constructorGuard$1) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly$1(this, "privateKey", signingKey.privateKey);
      defineReadOnly$1(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly$1(this, "privateKey", null);
      defineReadOnly$1(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly$1(this, "parentFingerprint", parentFingerprint);
    defineReadOnly$1(this, "fingerprint", hexDataSlice(ripemd160(sha256$4(this.publicKey)), 0, 4));
    defineReadOnly$1(this, "address", computeAddress(this.publicKey));
    defineReadOnly$1(this, "chainCode", chainCode);
    defineReadOnly$1(this, "index", index2);
    defineReadOnly$1(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly$1(this, "mnemonic", null);
      defineReadOnly$1(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly$1(this, "mnemonic", null);
      defineReadOnly$1(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly$1(this, "mnemonic", mnemonicOrPath);
      defineReadOnly$1(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat$1([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat$1(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index2) {
    if (index2 > 4294967295) {
      throw new Error("invalid index - " + String(index2));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index2 & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify(this.publicKey));
    }
    for (let i = 24; i >= 0; i -= 8) {
      data[33 + (i >> 3)] = index2 >> 24 - i & 255;
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    let ki2 = null;
    let Ki2 = null;
    if (this.privateKey) {
      ki2 = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek2 = new SigningKey(hexlify(IL));
      Ki2 = ek2._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard$1, ki2, Ki2, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      if (component.match(/^[0-9]+'$/)) {
        const index2 = parseInt(component.substring(0, component.length - 1));
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index2);
      } else if (component.match(/^[0-9]+$/)) {
        const index2 = parseInt(component);
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index2);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard$1, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes3 = Base58.decode(extendedKey);
    if (bytes3.length !== 82 || base58check(bytes3.slice(0, 78)) !== extendedKey) {
      logger$f.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes3[4];
    const parentFingerprint = hexlify(bytes3.slice(5, 9));
    const index2 = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes3.slice(13, 45));
    const key2 = bytes3.slice(45, 78);
    switch (hexlify(bytes3.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard$1, null, hexlify(key2), parentFingerprint, chainCode, index2, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key2[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard$1, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
    }
    return logger$f.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2$1(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger$f.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset2 = 0;
  for (let i = 0; i < words2.length; i++) {
    let index2 = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    if (index2 === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset2 >> 3] |= 1 << 7 - offset2 % 8;
      }
      offset2++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256$4(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256$4(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index2) {
  if (typeof index2 !== "number" || index2 < 0 || index2 >= HardenedBit || index2 % 1) {
    logger$f.throwArgumentError("invalid account index", "index", index2);
  }
  return `m/44'/60'/${index2}'/0/0`;
}
const lib_esm$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HDNode,
  defaultPath,
  entropyToMnemonic,
  getAccountPath,
  isValidMnemonic,
  mnemonicToEntropy,
  mnemonicToSeed
}, Symbol.toStringTag, { value: "Module" }));
const version$f = "random/5.7.0";
const logger$e = new Logger$1(version$f);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global$1 !== "undefined") {
    return global$1;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto$2 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto$2 || !crypto$2.getRandomValues) {
  logger$e.warn("WARNING: Missing strong random number source");
  crypto$2 = {
    getRandomValues: function(buffer2) {
      return logger$e.throwError("no secure random source avaialble", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes$1(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger$e.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto$2.getRandomValues(result);
  return arrayify(result);
}
function shuffled(array) {
  array = array.slice();
  for (let i = array.length - 1; i > 0; i--) {
    const j2 = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j2];
    array[j2] = tmp;
  }
  return array;
}
const lib_esm$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomBytes: randomBytes$1,
  shuffled
}, Symbol.toStringTag, { value: "Module" }));
var aesJs = { exports: {} };
(function(module2, exports) {
  (function(root2) {
    function checkInt(value) {
      return parseInt(value) === value;
    }
    function checkInts(arrayish) {
      if (!checkInt(arrayish.length)) {
        return false;
      }
      for (var i = 0; i < arrayish.length; i++) {
        if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
          return false;
        }
      }
      return true;
    }
    function coerceArray(arg, copy2) {
      if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
        if (copy2) {
          if (arg.slice) {
            arg = arg.slice();
          } else {
            arg = Array.prototype.slice.call(arg);
          }
        }
        return arg;
      }
      if (Array.isArray(arg)) {
        if (!checkInts(arg)) {
          throw new Error("Array contains invalid value: " + arg);
        }
        return new Uint8Array(arg);
      }
      if (checkInt(arg.length) && checkInts(arg)) {
        return new Uint8Array(arg);
      }
      throw new Error("unsupported array-like object");
    }
    function createArray(length) {
      return new Uint8Array(length);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
      if (sourceStart != null || sourceEnd != null) {
        if (sourceArray.slice) {
          sourceArray = sourceArray.slice(sourceStart, sourceEnd);
        } else {
          sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
      }
      targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = /* @__PURE__ */ function() {
      function toBytes2(text2) {
        var result = [], i = 0;
        text2 = encodeURI(text2);
        while (i < text2.length) {
          var c2 = text2.charCodeAt(i++);
          if (c2 === 37) {
            result.push(parseInt(text2.substr(i, 2), 16));
            i += 2;
          } else {
            result.push(c2);
          }
        }
        return coerceArray(result);
      }
      function fromBytes(bytes3) {
        var result = [], i = 0;
        while (i < bytes3.length) {
          var c2 = bytes3[i];
          if (c2 < 128) {
            result.push(String.fromCharCode(c2));
            i++;
          } else if (c2 > 191 && c2 < 224) {
            result.push(String.fromCharCode((c2 & 31) << 6 | bytes3[i + 1] & 63));
            i += 2;
          } else {
            result.push(String.fromCharCode((c2 & 15) << 12 | (bytes3[i + 1] & 63) << 6 | bytes3[i + 2] & 63));
            i += 3;
          }
        }
        return result.join("");
      }
      return {
        toBytes: toBytes2,
        fromBytes
      };
    }();
    var convertHex = /* @__PURE__ */ function() {
      function toBytes2(text2) {
        var result = [];
        for (var i = 0; i < text2.length; i += 2) {
          result.push(parseInt(text2.substr(i, 2), 16));
        }
        return result;
      }
      var Hex = "0123456789abcdef";
      function fromBytes(bytes3) {
        var result = [];
        for (var i = 0; i < bytes3.length; i++) {
          var v3 = bytes3[i];
          result.push(Hex[(v3 & 240) >> 4] + Hex[v3 & 15]);
        }
        return result.join("");
      }
      return {
        toBytes: toBytes2,
        fromBytes
      };
    }();
    var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    var Si2 = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function convertToInt32(bytes3) {
      var result = [];
      for (var i = 0; i < bytes3.length; i += 4) {
        result.push(
          bytes3[i] << 24 | bytes3[i + 1] << 16 | bytes3[i + 2] << 8 | bytes3[i + 3]
        );
      }
      return result;
    }
    var AES = function(key2) {
      if (!(this instanceof AES)) {
        throw Error("AES must be instanitated with `new`");
      }
      Object.defineProperty(this, "key", {
        value: coerceArray(key2, true)
      });
      this._prepare();
    };
    AES.prototype._prepare = function() {
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      }
      this._Ke = [];
      this._Kd = [];
      for (var i = 0; i <= rounds; i++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;
      var tk2 = convertToInt32(this.key);
      var index2;
      for (var i = 0; i < KC; i++) {
        index2 = i >> 2;
        this._Ke[index2][i % 4] = tk2[i];
        this._Kd[rounds - index2][i % 4] = tk2[i];
      }
      var rconpointer = 0;
      var t2 = KC, tt;
      while (t2 < roundKeyCount) {
        tt = tk2[KC - 1];
        tk2[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
        rconpointer += 1;
        if (KC != 8) {
          for (var i = 1; i < KC; i++) {
            tk2[i] ^= tk2[i - 1];
          }
        } else {
          for (var i = 1; i < KC / 2; i++) {
            tk2[i] ^= tk2[i - 1];
          }
          tt = tk2[KC / 2 - 1];
          tk2[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
          for (var i = KC / 2 + 1; i < KC; i++) {
            tk2[i] ^= tk2[i - 1];
          }
        }
        var i = 0, r2, c2;
        while (i < KC && t2 < roundKeyCount) {
          r2 = t2 >> 2;
          c2 = t2 % 4;
          this._Ke[r2][c2] = tk2[i];
          this._Kd[rounds - r2][c2] = tk2[i++];
          t2++;
        }
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var c2 = 0; c2 < 4; c2++) {
          tt = this._Kd[r2][c2];
          this._Kd[r2][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
        }
      }
    };
    AES.prototype.encrypt = function(plaintext) {
      if (plaintext.length != 16) {
        throw new Error("invalid plaintext size (must be 16 bytes)");
      }
      var rounds = this._Ke.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(plaintext);
      for (var i = 0; i < 4; i++) {
        t2[i] ^= this._Ke[0][i];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i = 0; i < 4; i++) {
          a2[i] = T1[t2[i] >> 24 & 255] ^ T2[t2[(i + 1) % 4] >> 16 & 255] ^ T3[t2[(i + 2) % 4] >> 8 & 255] ^ T4[t2[(i + 3) % 4] & 255] ^ this._Ke[r2][i];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Ke[rounds][i];
        result[4 * i] = (S2[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (S2[t2[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (S2[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (S2[t2[(i + 3) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    AES.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length != 16) {
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      }
      var rounds = this._Kd.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(ciphertext);
      for (var i = 0; i < 4; i++) {
        t2[i] ^= this._Kd[0][i];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i = 0; i < 4; i++) {
          a2[i] = T5[t2[i] >> 24 & 255] ^ T6[t2[(i + 3) % 4] >> 16 & 255] ^ T7[t2[(i + 2) % 4] >> 8 & 255] ^ T8[t2[(i + 1) % 4] & 255] ^ this._Kd[r2][i];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0; i < 4; i++) {
        tt = this._Kd[rounds][i];
        result[4 * i] = (Si2[t2[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (Si2[t2[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (Si2[t2[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (Si2[t2[(i + 1) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    var ModeOfOperationECB = function(key2) {
      if (!(this instanceof ModeOfOperationECB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Electronic Code Block";
      this.name = "ecb";
      this._aes = new AES(key2);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        block = this._aes.encrypt(block);
        copyArray(block, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        copyArray(block, plaintext, i);
      }
      return plaintext;
    };
    var ModeOfOperationCBC = function(key2, iv) {
      if (!(this instanceof ModeOfOperationCBC)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Block Chaining";
      this.name = "cbc";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastCipherblock = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0; i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        for (var j2 = 0; j2 < 16; j2++) {
          block[j2] ^= this._lastCipherblock[j2];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyArray(this._lastCipherblock, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0; i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        for (var j2 = 0; j2 < 16; j2++) {
          plaintext[i + j2] = block[j2] ^ this._lastCipherblock[j2];
        }
        copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
      }
      return plaintext;
    };
    var ModeOfOperationCFB = function(key2, iv, segmentSize) {
      if (!(this instanceof ModeOfOperationCFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Feedback";
      this.name = "cfb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 size)");
      }
      if (!segmentSize) {
        segmentSize = 1;
      }
      this.segmentSize = segmentSize;
      this._shiftRegister = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
      if (plaintext.length % this.segmentSize != 0) {
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      }
      var encrypted = coerceArray(plaintext, true);
      var xorSegment;
      for (var i = 0; i < encrypted.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j2 = 0; j2 < this.segmentSize; j2++) {
          encrypted[i + j2] ^= xorSegment[j2];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length % this.segmentSize != 0) {
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      }
      var plaintext = coerceArray(ciphertext, true);
      var xorSegment;
      for (var i = 0; i < plaintext.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j2 = 0; j2 < this.segmentSize; j2++) {
          plaintext[i + j2] ^= xorSegment[j2];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return plaintext;
    };
    var ModeOfOperationOFB = function(key2, iv) {
      if (!(this instanceof ModeOfOperationOFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Output Feedback";
      this.name = "ofb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastPrecipher = coerceArray(iv, true);
      this._lastPrecipherIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._lastPrecipherIndex === 16) {
          this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
          this._lastPrecipherIndex = 0;
        }
        encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      }
      return encrypted;
    };
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    var Counter = function(initialValue) {
      if (!(this instanceof Counter)) {
        throw Error("Counter must be instanitated with `new`");
      }
      if (initialValue !== 0 && !initialValue) {
        initialValue = 1;
      }
      if (typeof initialValue === "number") {
        this._counter = createArray(16);
        this.setValue(initialValue);
      } else {
        this.setBytes(initialValue);
      }
    };
    Counter.prototype.setValue = function(value) {
      if (typeof value !== "number" || parseInt(value) != value) {
        throw new Error("invalid counter value (must be an integer)");
      }
      for (var index2 = 15; index2 >= 0; --index2) {
        this._counter[index2] = value % 256;
        value = value >> 8;
      }
    };
    Counter.prototype.setBytes = function(bytes3) {
      bytes3 = coerceArray(bytes3, true);
      if (bytes3.length != 16) {
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      }
      this._counter = bytes3;
    };
    Counter.prototype.increment = function() {
      for (var i = 15; i >= 0; i--) {
        if (this._counter[i] === 255) {
          this._counter[i] = 0;
        } else {
          this._counter[i]++;
          break;
        }
      }
    };
    var ModeOfOperationCTR = function(key2, counter) {
      if (!(this instanceof ModeOfOperationCTR)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Counter";
      this.name = "ctr";
      if (!(counter instanceof Counter)) {
        counter = new Counter(counter);
      }
      this._counter = counter;
      this._remainingCounter = null;
      this._remainingCounterIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0; i < encrypted.length; i++) {
        if (this._remainingCounterIndex === 16) {
          this._remainingCounter = this._aes.encrypt(this._counter._counter);
          this._remainingCounterIndex = 0;
          this._counter.increment();
        }
        encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
      }
      return encrypted;
    };
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    function pkcs7pad(data) {
      data = coerceArray(data, true);
      var padder = 16 - data.length % 16;
      var result = createArray(data.length + padder);
      copyArray(data, result);
      for (var i = data.length; i < result.length; i++) {
        result[i] = padder;
      }
      return result;
    }
    function pkcs7strip(data) {
      data = coerceArray(data, true);
      if (data.length < 16) {
        throw new Error("PKCS#7 invalid length");
      }
      var padder = data[data.length - 1];
      if (padder > 16) {
        throw new Error("PKCS#7 padding byte out of range");
      }
      var length = data.length - padder;
      for (var i = 0; i < padder; i++) {
        if (data[length + i] !== padder) {
          throw new Error("PKCS#7 invalid padding byte");
        }
      }
      var result = createArray(length);
      copyArray(data, result, 0, 0, length);
      return result;
    }
    var aesjs = {
      AES,
      Counter,
      ModeOfOperation: {
        ecb: ModeOfOperationECB,
        cbc: ModeOfOperationCBC,
        cfb: ModeOfOperationCFB,
        ofb: ModeOfOperationOFB,
        ctr: ModeOfOperationCTR
      },
      utils: {
        hex: convertHex,
        utf8: convertUtf8
      },
      padding: {
        pkcs7: {
          pad: pkcs7pad,
          strip: pkcs7strip
        }
      },
      _arrayTest: {
        coerceArray,
        createArray,
        copyArray
      }
    };
    {
      module2.exports = aesjs;
    }
  })();
})(aesJs);
var aesJsExports = aesJs.exports;
const aes = /* @__PURE__ */ getDefaultExportFromCjs$1(aesJsExports);
const version$e = "json-wallets/5.7.0";
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i = 0; i < comps.length; i++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes2) {
  const bytes3 = arrayify(randomBytes2);
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value = hexlify(bytes3);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const logger$d = new Logger$1(version$e);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
}
function decrypt$1(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress$1(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger$d.throwArgumentError("invalid encseed", "json", json);
  }
  const key2 = arrayify(pbkdf2$1(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new aes.ModeOfOperation.cbc(key2, iv);
  const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256$2(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress$1(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress$1(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
var scrypt$1 = { exports: {} };
(function(module2, exports) {
  (function(root2) {
    const MAX_VALUE = 2147483647;
    function SHA2563(m2) {
      const K2 = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
      let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
      const w2 = new Uint32Array(64);
      function blocks(p3) {
        let off = 0, len = p3.length;
        while (len >= 64) {
          let a2 = h0, b2 = h1, c2 = h2, d2 = h3, e2 = h4, f2 = h5, g2 = h6, h8 = h7, u2, i2, j2, t1, t2;
          for (i2 = 0; i2 < 16; i2++) {
            j2 = off + i2 * 4;
            w2[i2] = (p3[j2] & 255) << 24 | (p3[j2 + 1] & 255) << 16 | (p3[j2 + 2] & 255) << 8 | p3[j2 + 3] & 255;
          }
          for (i2 = 16; i2 < 64; i2++) {
            u2 = w2[i2 - 2];
            t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
            u2 = w2[i2 - 15];
            t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
            w2[i2] = (t1 + w2[i2 - 7] | 0) + (t2 + w2[i2 - 16] | 0) | 0;
          }
          for (i2 = 0; i2 < 64; i2++) {
            t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h8 + (K2[i2] + w2[i2] | 0) | 0) | 0;
            t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
            h8 = g2;
            g2 = f2;
            f2 = e2;
            e2 = d2 + t1 | 0;
            d2 = c2;
            c2 = b2;
            b2 = a2;
            a2 = t1 + t2 | 0;
          }
          h0 = h0 + a2 | 0;
          h1 = h1 + b2 | 0;
          h2 = h2 + c2 | 0;
          h3 = h3 + d2 | 0;
          h4 = h4 + e2 | 0;
          h5 = h5 + f2 | 0;
          h6 = h6 + g2 | 0;
          h7 = h7 + h8 | 0;
          off += 64;
          len -= 64;
        }
      }
      blocks(m2);
      let i, bytesLeft = m2.length % 64, bitLenHi = m2.length / 536870912 | 0, bitLenLo = m2.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m2.slice(m2.length - bytesLeft, m2.length);
      p2.push(128);
      for (i = bytesLeft + 1; i < numZeros; i++) {
        p2.push(0);
      }
      p2.push(bitLenHi >>> 24 & 255);
      p2.push(bitLenHi >>> 16 & 255);
      p2.push(bitLenHi >>> 8 & 255);
      p2.push(bitLenHi >>> 0 & 255);
      p2.push(bitLenLo >>> 24 & 255);
      p2.push(bitLenLo >>> 16 & 255);
      p2.push(bitLenLo >>> 8 & 255);
      p2.push(bitLenLo >>> 0 & 255);
      blocks(p2);
      return [
        h0 >>> 24 & 255,
        h0 >>> 16 & 255,
        h0 >>> 8 & 255,
        h0 >>> 0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 >>> 0 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 >>> 0 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 >>> 0 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 >>> 0 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 >>> 0 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 >>> 0 & 255,
        h7 >>> 24 & 255,
        h7 >>> 16 & 255,
        h7 >>> 8 & 255,
        h7 >>> 0 & 255
      ];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
      password = password.length <= 64 ? password : SHA2563(password);
      const innerLen = 64 + salt.length + 4;
      const inner = new Array(innerLen);
      const outerKey = new Array(64);
      let i;
      let dk2 = [];
      for (i = 0; i < 64; i++) {
        inner[i] = 54;
      }
      for (i = 0; i < password.length; i++) {
        inner[i] ^= password[i];
      }
      for (i = 0; i < salt.length; i++) {
        inner[64 + i] = salt[i];
      }
      for (i = innerLen - 4; i < innerLen; i++) {
        inner[i] = 0;
      }
      for (i = 0; i < 64; i++)
        outerKey[i] = 92;
      for (i = 0; i < password.length; i++)
        outerKey[i] ^= password[i];
      function incrementCounter() {
        for (let i2 = innerLen - 1; i2 >= innerLen - 4; i2--) {
          inner[i2]++;
          if (inner[i2] <= 255)
            return;
          inner[i2] = 0;
        }
      }
      while (dkLen >= 32) {
        incrementCounter();
        dk2 = dk2.concat(SHA2563(outerKey.concat(SHA2563(inner))));
        dkLen -= 32;
      }
      if (dkLen > 0) {
        incrementCounter();
        dk2 = dk2.concat(SHA2563(outerKey.concat(SHA2563(inner))).slice(0, dkLen));
      }
      return dk2;
    }
    function blockmix_salsa8(BY, Yi2, r2, x, _X) {
      let i;
      arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
      for (i = 0; i < 2 * r2; i++) {
        blockxor(BY, i * 16, _X, 16);
        salsa20_8(_X, x);
        arraycopy(_X, 0, BY, Yi2 + i * 16, 16);
      }
      for (i = 0; i < r2; i++) {
        arraycopy(BY, Yi2 + i * 2 * 16, BY, i * 16, 16);
      }
      for (i = 0; i < r2; i++) {
        arraycopy(BY, Yi2 + (i * 2 + 1) * 16, BY, (i + r2) * 16, 16);
      }
    }
    function R2(a2, b2) {
      return a2 << b2 | a2 >>> 32 - b2;
    }
    function salsa20_8(B2, x) {
      arraycopy(B2, 0, x, 0, 16);
      for (let i = 8; i > 0; i -= 2) {
        x[4] ^= R2(x[0] + x[12], 7);
        x[8] ^= R2(x[4] + x[0], 9);
        x[12] ^= R2(x[8] + x[4], 13);
        x[0] ^= R2(x[12] + x[8], 18);
        x[9] ^= R2(x[5] + x[1], 7);
        x[13] ^= R2(x[9] + x[5], 9);
        x[1] ^= R2(x[13] + x[9], 13);
        x[5] ^= R2(x[1] + x[13], 18);
        x[14] ^= R2(x[10] + x[6], 7);
        x[2] ^= R2(x[14] + x[10], 9);
        x[6] ^= R2(x[2] + x[14], 13);
        x[10] ^= R2(x[6] + x[2], 18);
        x[3] ^= R2(x[15] + x[11], 7);
        x[7] ^= R2(x[3] + x[15], 9);
        x[11] ^= R2(x[7] + x[3], 13);
        x[15] ^= R2(x[11] + x[7], 18);
        x[1] ^= R2(x[0] + x[3], 7);
        x[2] ^= R2(x[1] + x[0], 9);
        x[3] ^= R2(x[2] + x[1], 13);
        x[0] ^= R2(x[3] + x[2], 18);
        x[6] ^= R2(x[5] + x[4], 7);
        x[7] ^= R2(x[6] + x[5], 9);
        x[4] ^= R2(x[7] + x[6], 13);
        x[5] ^= R2(x[4] + x[7], 18);
        x[11] ^= R2(x[10] + x[9], 7);
        x[8] ^= R2(x[11] + x[10], 9);
        x[9] ^= R2(x[8] + x[11], 13);
        x[10] ^= R2(x[9] + x[8], 18);
        x[12] ^= R2(x[15] + x[14], 7);
        x[13] ^= R2(x[12] + x[15], 9);
        x[14] ^= R2(x[13] + x[12], 13);
        x[15] ^= R2(x[14] + x[13], 18);
      }
      for (let i = 0; i < 16; ++i) {
        B2[i] += x[i];
      }
    }
    function blockxor(S2, Si2, D2, len) {
      for (let i = 0; i < len; i++) {
        D2[i] ^= S2[Si2 + i];
      }
    }
    function arraycopy(src, srcPos, dest, destPos, length) {
      while (length--) {
        dest[destPos++] = src[srcPos++];
      }
    }
    function checkBufferish(o2) {
      if (!o2 || typeof o2.length !== "number") {
        return false;
      }
      for (let i = 0; i < o2.length; i++) {
        const v3 = o2[i];
        if (typeof v3 !== "number" || v3 % 1 || v3 < 0 || v3 >= 256) {
          return false;
        }
      }
      return true;
    }
    function ensureInteger(value, name2) {
      if (typeof value !== "number" || value % 1) {
        throw new Error("invalid " + name2);
      }
      return value;
    }
    function _scrypt(password, salt, N2, r2, p2, dkLen, callback) {
      N2 = ensureInteger(N2, "N");
      r2 = ensureInteger(r2, "r");
      p2 = ensureInteger(p2, "p");
      dkLen = ensureInteger(dkLen, "dkLen");
      if (N2 === 0 || (N2 & N2 - 1) !== 0) {
        throw new Error("N must be power of 2");
      }
      if (N2 > MAX_VALUE / 128 / r2) {
        throw new Error("N too large");
      }
      if (r2 > MAX_VALUE / 128 / p2) {
        throw new Error("r too large");
      }
      if (!checkBufferish(password)) {
        throw new Error("password must be an array or buffer");
      }
      password = Array.prototype.slice.call(password);
      if (!checkBufferish(salt)) {
        throw new Error("salt must be an array or buffer");
      }
      salt = Array.prototype.slice.call(salt);
      let b2 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p2 * 128 * r2);
      const B2 = new Uint32Array(p2 * 32 * r2);
      for (let i = 0; i < B2.length; i++) {
        const j2 = i * 4;
        B2[i] = (b2[j2 + 3] & 255) << 24 | (b2[j2 + 2] & 255) << 16 | (b2[j2 + 1] & 255) << 8 | (b2[j2 + 0] & 255) << 0;
      }
      const XY = new Uint32Array(64 * r2);
      const V2 = new Uint32Array(32 * r2 * N2);
      const Yi2 = 32 * r2;
      const x = new Uint32Array(16);
      const _X = new Uint32Array(16);
      const totalOps = p2 * N2 * 2;
      let currentOp = 0;
      let lastPercent10 = null;
      let stop = false;
      let state = 0;
      let i0 = 0, i1;
      let Bi2;
      const limit = callback ? parseInt(1e3 / r2) : 4294967295;
      const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      const incrementalSMix = function() {
        if (stop) {
          return callback(new Error("cancelled"), currentOp / totalOps);
        }
        let steps2;
        switch (state) {
          case 0:
            Bi2 = i0 * 32 * r2;
            arraycopy(B2, Bi2, XY, 0, Yi2);
            state = 1;
            i1 = 0;
          case 1:
            steps2 = N2 - i1;
            if (steps2 > limit) {
              steps2 = limit;
            }
            for (let i = 0; i < steps2; i++) {
              arraycopy(XY, 0, V2, (i1 + i) * Yi2, Yi2);
              blockmix_salsa8(XY, Yi2, r2, x, _X);
            }
            i1 += steps2;
            currentOp += steps2;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N2) {
              break;
            }
            i1 = 0;
            state = 2;
          case 2:
            steps2 = N2 - i1;
            if (steps2 > limit) {
              steps2 = limit;
            }
            for (let i = 0; i < steps2; i++) {
              const offset2 = (2 * r2 - 1) * 16;
              const j2 = XY[offset2] & N2 - 1;
              blockxor(V2, j2 * Yi2, XY, Yi2);
              blockmix_salsa8(XY, Yi2, r2, x, _X);
            }
            i1 += steps2;
            currentOp += steps2;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N2) {
              break;
            }
            arraycopy(XY, 0, B2, Bi2, Yi2);
            i0++;
            if (i0 < p2) {
              state = 0;
              break;
            }
            b2 = [];
            for (let i = 0; i < B2.length; i++) {
              b2.push(B2[i] >> 0 & 255);
              b2.push(B2[i] >> 8 & 255);
              b2.push(B2[i] >> 16 & 255);
              b2.push(B2[i] >> 24 & 255);
            }
            const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b2, dkLen);
            if (callback) {
              callback(null, 1, derivedKey);
            }
            return derivedKey;
        }
        if (callback) {
          nextTick(incrementalSMix);
        }
      };
      if (!callback) {
        while (true) {
          const derivedKey = incrementalSMix();
          if (derivedKey != void 0) {
            return derivedKey;
          }
        }
      }
      incrementalSMix();
    }
    const lib2 = {
      scrypt: function(password, salt, N2, r2, p2, dkLen, progressCallback) {
        return new Promise(function(resolve, reject) {
          let lastProgress = 0;
          if (progressCallback) {
            progressCallback(0);
          }
          _scrypt(password, salt, N2, r2, p2, dkLen, function(error, progress2, key2) {
            if (error) {
              reject(error);
            } else if (key2) {
              if (progressCallback && lastProgress !== 1) {
                progressCallback(1);
              }
              resolve(new Uint8Array(key2));
            } else if (progressCallback && progress2 !== lastProgress) {
              lastProgress = progress2;
              return progressCallback(progress2);
            }
          });
        });
      },
      syncScrypt: function(password, salt, N2, r2, p2, dkLen) {
        return new Uint8Array(_scrypt(password, salt, N2, r2, p2, dkLen));
      }
    };
    {
      module2.exports = lib2;
    }
  })();
})(scrypt$1);
var scryptExports = scrypt$1.exports;
const scrypt = /* @__PURE__ */ getDefaultExportFromCjs$1(scryptExports);
var __awaiter$9 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$c = new Logger$1(version$e);
function hasMnemonic$1(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
}
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(key2, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256$2(concat$1([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger$c.throwError("unsupported cipher", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress$1(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account2 = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new aes.Counter(mnemonicIv);
    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account2.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account2.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger$1.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account2);
}
function pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc) {
  return arrayify(pbkdf2$1(passwordBytes, salt, count2, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count2, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError = function(name2, value) {
      return logger$c.throwArgumentError("invalid key-derivation function parameters", name2, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N2 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p2 = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N2 || !r2 || !p2) {
        throwError("kdf", kdf);
      }
      if ((N2 & N2 - 1) !== 0) {
        throwError("N", N2);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N2, r2, p2, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }
      const count2 = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count2, dkLen, prfFunc);
    }
  }
  return logger$c.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt(json, password, progressCallback) {
  return __awaiter$9(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key2 = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt(account2, password, options, progressCallback) {
  try {
    if (getAddress$1(account2.address) !== computeAddress(account2.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic$1(account2)) {
      const mnemonic = account2.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account2.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e2) {
    return Promise.reject(e2);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account2.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic$1(account2)) {
    const srcMnemonic = account2.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client2 = options.client;
  if (!client2) {
    client2 = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes$1(32);
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes$1(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes$1(16);
  }
  let N2 = 1 << 17, r2 = 8, p2 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p2 = options.scrypt.p;
    }
  }
  return scrypt.scrypt(passwordBytes, salt, N2, r2, p2, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256$2(concat$1([macPrefix, ciphertext]));
    const data = {
      address: account2.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N2,
          dklen: 32,
          p: p2,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes$1(16);
      const mnemonicCounter = new aes.Counter(mnemonicIv);
      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = /* @__PURE__ */ new Date();
      const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client: client2,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account2 = decrypt$1(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account2);
  }
  if (isKeystoreWallet(json)) {
    return decrypt(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt$1(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
const lib_esm$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decryptCrowdsale: decrypt$1,
  decryptJsonWallet,
  decryptJsonWalletSync,
  decryptKeystore: decrypt,
  decryptKeystoreSync: decryptSync,
  encryptKeystore: encrypt,
  getJsonWalletAddress,
  isCrowdsaleWallet,
  isKeystoreWallet
}, Symbol.toStringTag, { value: "Module" }));
const version$d = "wallet/5.7.0";
var __awaiter$8 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$b = new Logger$1(version$d);
function isAccount$1(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
let Wallet$1 = class Wallet extends Signer$1 {
  constructor(privateKey, provider2) {
    super();
    if (isAccount$1(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly$1(this, "_signingKey", () => signingKey);
      defineReadOnly$1(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress$1(privateKey.address)) {
        logger$b.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly$1(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger$b.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly$1(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger$b.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly$1(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly$1(this, "_signingKey", () => signingKey);
      }
      defineReadOnly$1(this, "_mnemonic", () => null);
      defineReadOnly$1(this, "address", computeAddress(this.publicKey));
    }
    if (provider2 && !Provider.isProvider(provider2)) {
      logger$b.throwArgumentError("invalid provider", "provider", provider2);
    }
    defineReadOnly$1(this, "provider", provider2 || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider2) {
    return new Wallet(this, provider2);
  }
  signTransaction(transaction2) {
    return resolveProperties$1(transaction2).then((tx) => {
      if (tx.from != null) {
        if (getAddress$1(tx.from) !== this.address) {
          logger$b.throwArgumentError("transaction from address mismatch", "transaction.from", transaction2.from);
        }
        delete tx.from;
      }
      const signature2 = this._signingKey().signDigest(keccak256$2(serialize$2(tx)));
      return serialize$2(tx, signature2);
    });
  }
  signMessage(message) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage$1(message)));
    });
  }
  _signTypedData(domain2, types2, value) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types2, value, (name2) => {
        if (this.provider == null) {
          logger$b.throwError("cannot resolve ENS names without a provider", Logger$1.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types2, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt(this, password, options, progressCallback);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(options) {
    let entropy = randomBytes$1(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256$2(concat$1([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json, password, progressCallback) {
    return decryptJsonWallet(json, password, progressCallback).then((account2) => {
      return new Wallet(account2);
    });
  }
  static fromEncryptedJsonSync(json, password) {
    return new Wallet(decryptJsonWalletSync(json, password));
  }
  static fromMnemonic(mnemonic, path, wordlist2) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
  }
};
function verifyMessage$1(message, signature2) {
  return recoverAddress(hashMessage$1(message), signature2);
}
function verifyTypedData$1(domain2, types2, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain2, types2, value), signature2);
}
const lib_esm$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Wallet: Wallet$1,
  verifyMessage: verifyMessage$1,
  verifyTypedData: verifyTypedData$1
}, Symbol.toStringTag, { value: "Module" }));
const version$c = "networks/5.7.1";
const logger$a = new Logger$1(version$c);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network2) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network2, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network2, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network2, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider2 = new providers.PocketProvider(network2, options.pocket);
        if (provider2.network && skip.indexOf(provider2.network.name) === -1) {
          providerList.push(provider2);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network2));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider2 = new providers.AnkrProvider(network2, options.ankr);
        if (provider2.network && skip.indexOf(provider2.network.name) === -1) {
          providerList.push(provider2);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network2 === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network3) {
    return ethDefaultProvider(network3);
  };
  return func;
}
function etcDefaultProvider(url, network2) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network2);
    }
    return null;
  };
  func.renetwork = function(network3) {
    return etcDefaultProvider(url, network3);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks$1 = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork$1(network2) {
  if (network2 == null) {
    return null;
  }
  if (typeof network2 === "number") {
    for (const name2 in networks$1) {
      const standard2 = networks$1[name2];
      if (standard2.chainId === network2) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network2,
      name: "unknown"
    };
  }
  if (typeof network2 === "string") {
    const standard2 = networks$1[network2];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks$1[network2.name];
  if (!standard) {
    if (typeof network2.chainId !== "number") {
      logger$a.throwArgumentError("invalid network chainId", "network", network2);
    }
    return network2;
  }
  if (network2.chainId !== 0 && network2.chainId !== standard.chainId) {
    logger$a.throwArgumentError("network chainId mismatch", "network", network2);
  }
  let defaultProvider = network2._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network2);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network2.name,
    chainId: standard.chainId,
    ensAddress: network2.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
const version$b = "web/5.7.1";
var __awaiter$7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl$1(href, options) {
  return __awaiter$7(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter$6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger$1(version$b);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$9.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$9.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$9.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$9.throwError("basic authentication requires a secure https url", Logger$1.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$2(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy$1(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode$2(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$9.throwError("processing response error", Logger$1.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$9.makeError("timeout", Logger$1.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$6(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl$1(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$9.throwError("missing response", Logger$1.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$9.throwError("bad response", Logger$1.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$9.throwError("processing response error", Logger$1.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$9.throwError("failed response", Logger$1.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$9.throwError("invalid JSON", Logger$1.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy$1(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy$1(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll$1(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy$1(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
const lib_esm$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _fetchData,
  fetchJson,
  poll: poll$1
}, Symbol.toStringTag, { value: "Module" }));
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  if (ALPHABET_MAP[x] !== void 0)
    throw new TypeError(x + " is ambiguous");
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  var b2 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i = 0; i < prefix.length; ++i) {
    var c2 = prefix.charCodeAt(i);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (i = 0; i < prefix.length; ++i) {
    var v3 = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v3 & 31;
  }
  return chk;
}
function encode$1(prefix, words2, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words2.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix = prefix.toLowerCase();
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix + "1";
  for (var i = 0; i < words2.length; ++i) {
    var x = words2[i];
    if (x >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x;
    result += ALPHABET.charAt(x);
  }
  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i = 0; i < 6; ++i) {
    var v3 = chk >> (5 - i) * 5 & 31;
    result += ALPHABET.charAt(v3);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split2 = str.lastIndexOf("1");
  if (split2 === -1)
    return "No separator character for " + str;
  if (split2 === 0)
    return "Missing prefix for " + str;
  var prefix = str.slice(0, split2);
  var wordChars = str.slice(split2 + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    return chk;
  var words2 = [];
  for (var i = 0; i < wordChars.length; ++i) {
    var c2 = wordChars.charAt(i);
    var v3 = ALPHABET_MAP[c2];
    if (v3 === void 0)
      return "Unknown character " + c2;
    chk = polymodStep(chk) ^ v3;
    if (i + 6 >= wordChars.length)
      continue;
    words2.push(v3);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix, words: words2 };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$1(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert(data, inBits, outBits, pad3) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad3) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes3) {
  var res = convert(bytes3, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes3) {
  var res = convert(bytes3, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words2) {
  var res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words2) {
  var res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$1,
  encode: encode$1,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const bech32$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(bech32);
const version$a = "providers/5.7.2";
const logger$8 = new Logger$1(version$a);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash2 = this.hash.bind(this);
    const hex2 = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v3) => {
      return this.data(v3, true);
    };
    formats.transaction = {
      hash: hash2,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash2, null),
      blockNumber: Formatter.allowNull(number2, null),
      transactionIndex: Formatter.allowNull(number2, null),
      confirmations: Formatter.allowNull(number2, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number2),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number2),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number2),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash2,
      address,
      topics: Formatter.arrayOf(hash2),
      data,
      logIndex: number2,
      blockHash: hash2
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number2,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex2),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash2,
      transactionHash: hash2,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number2),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash2),
      parentHash: hash2,
      number: number2,
      timestamp: number2,
      nonce: Formatter.allowNull(hex2),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash2)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy$1(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash2, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number2),
      blockHash: Formatter.allowNull(hash2),
      transactionIndex: number2,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash2),
      transactionHash: hash2,
      logIndex: number2
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger$8.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress$1(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress$1(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress$1(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$8.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v3 = BigNumber.from(value);
    try {
      return v3.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format2) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format2, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction2) {
    if (transaction2.gas != null && transaction2.gasLimit == null) {
      transaction2.gasLimit = transaction2.gas;
    }
    if (transaction2.to && BigNumber.from(transaction2.to).isZero()) {
      transaction2.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction2.input != null && transaction2.data == null) {
      transaction2.data = transaction2.input;
    }
    if (transaction2.to == null && transaction2.creates == null) {
      transaction2.creates = this.contractAddress(transaction2);
    }
    if ((transaction2.type === 1 || transaction2.type === 2) && transaction2.accessList == null) {
      transaction2.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction2);
    if (transaction2.chainId != null) {
      let chainId = transaction2.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction2.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction2.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse$2(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$8.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$8.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$8.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v3) => this.topics(v3));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format2, object) {
    const result = {};
    for (const key2 in format2) {
      try {
        const value = format2[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format2, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format2(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format2, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format2(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format2) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format2(value));
      });
      return result;
    };
  }
}
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var __awaiter$5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$7 = new Logger$1(version$a);
const MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$7.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$7.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
let Event$1 = class Event2 {
  constructor(tag, listener, once) {
    defineReadOnly$1(this, "tag", tag);
    defineReadOnly$1(this, "listener", listener);
    defineReadOnly$1(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat$1([data, hexDataSlice(sha256$4(sha256$4(data)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset2 = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset2, offset2 + 32)).toNumber();
  return hexDataSlice(result, offset2 + 32, offset2 + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$7.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes$1(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data = arrayify(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider2, address, name2, resolvedAddress) {
    defineReadOnly$1(this, "provider", provider2);
    defineReadOnly$1(this, "name", name2);
    defineReadOnly$1(this, "address", provider2.formatter.address(address));
    defineReadOnly$1(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger$1.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector2, parameters) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector2, namehash$1(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes$1([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger$7.throwError("resolver threw error", Logger$1.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger$1.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector2, parameters) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector2, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$7.throwError(`unsupported coin type: ${coinType}`, Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes3 = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat$1([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat$1([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes3[1];
      let version2 = bytes3[0];
      if (version2 === 0) {
        if (length !== 20 && length !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes3.length === 2 + length && length >= 1 && length <= 75) {
        const words2 = bech32$1.toWords(bytes3.slice(2));
        words2.unshift(version2);
        return bech32$1.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger$1.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$7.throwError(`invalid or unsupported coin data`, Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar2 = yield this.getText("avatar");
        if (avatar2 == null) {
          return null;
        }
        for (let i = 0; i < matchers.length; i++) {
          const match = avatar2.match(matchers[i]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar2 });
              return { linkage, url: avatar2 };
            case "data":
              linkage.push({ type: "data", content: avatar2 });
              return { linkage, url: avatar2 };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar2 });
              return { linkage, url: getIpfsLink(avatar2) };
            case "erc721":
            case "erc1155": {
              const selector2 = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar2 });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector2, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata2 = yield fetchJson(metadataUrl);
              if (!metadata2) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata2) });
              let imageUrl = metadata2.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length = parseInt(ipns[3], 16);
        if (ipns[4].length === length * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash2 = encode$2("0x" + skynet[1]).replace(/[=+\/]/g, (a2) => urlSafe[a2]);
          return "sia://" + hash2;
        }
      }
      return logger$7.throwError(`invalid or unsupported content hash data`, Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat$1([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat$1([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network2) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly$1(this, "anyNetwork", network2 === "any");
    if (this.anyNetwork) {
      network2 = this.detectNetwork();
    }
    if (network2 instanceof Promise) {
      this._networkPromise = network2;
      network2.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic$1(new.target, "getNetwork")(network2);
      if (knownNetwork) {
        defineReadOnly$1(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$7.throwArgumentError("invalid network", "network", network2);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network2 = null;
        if (this._networkPromise) {
          try {
            network2 = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network2 == null) {
          network2 = yield this.detectNetwork();
        }
        if (!network2) {
          logger$7.throwError("no network detected", Logger$1.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network2;
          } else {
            defineReadOnly$1(this, "_network", network2);
          }
          this.emit("network", network2, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll$1(() => {
      return this._ready().then((network2) => {
        return network2;
      }, (error) => {
        if (error.code === Logger$1.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network2) {
    return getNetwork$1(network2 == null ? "homestead" : network2);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const href = url.replace("{sender}", sender).replace("{data}", data);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger$7.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger$1.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger$7.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, Logger$1.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties$1({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network2) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$7.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$7.makeError("network block skew detected", Logger$1.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
          this.emit("block", i);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter2 = event.filter;
              filter2.fromBlock = event._lastBlockNumber + 1;
              filter2.toBlock = blockNumber;
              const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter2.fromBlock) {
                filter2.fromBlock = minFromBlock;
              }
              if (filter2.fromBlock < 0) {
                filter2.fromBlock = 0;
              }
              const runner = this.getLogs(filter2).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter2, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$5(this, void 0, void 0, function* () {
      return logger$7.throwError("provider does not support network detection", Logger$1.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const network2 = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network2.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network2);
          yield stall$1(0);
          return this._network;
        }
        const error = logger$7.makeError("underlying network changed", Logger$1.errors.NETWORK_ERROR, {
          event: "changed",
          network: network2,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network2;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$5(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall$1(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$5(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti2 = 0; ti2 < block.transactions.length; ti2++) {
                    const tx = block.transactions[ti2];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$7.makeError("transaction was replaced", Logger$1.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$7.makeError("timeout exceeded", Logger$1.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$7.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties$1({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$7.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties$1({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$7.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties$1({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$7.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties$1({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$7.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger$7.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger$1.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout) => __awaiter$5(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$7.throwError("transaction failed", Logger$1.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const values = yield transaction2;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 ? this._getAddress(v3) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 ? BigNumber.from(v3) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 != null ? v3 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v3) => v3 ? hexlify(v3) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties$1(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties$1(result));
    });
  }
  _call(transaction2, blockTag, attempt) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$7.throwError("CCIP read exceeded maximum redirections", Logger$1.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction: transaction2
        });
      }
      const txSender = transaction2.to;
      const result = yield this.perform("call", { transaction: transaction2, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$7.throwError("CCIP Read sender did not match", Logger$1.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: transaction2,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u2 = 0; u2 < urlsLength; u2++) {
            const url = _parseString(urlsData, u2 * 32);
            if (url == null) {
              logger$7.throwError("CCIP Read contained corrupt URL string", Logger$1.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: transaction2,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data, 64);
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger$7.throwError("CCIP Read callback selector included junk", Logger$1.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: transaction2,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction2, calldata, urls);
          if (ccipResult == null) {
            logger$7.throwError("CCIP Read disabled or provided no URLs", Logger$1.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: transaction2,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes$1([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger$1.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger$7.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: transaction2, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction2, blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties$1({
        transaction: this._getTransactionRequest(transaction2),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction2.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties$1({
        transaction: this._getTransactionRequest(transaction2)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$7.throwError("bad result from backend", Logger$1.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$5(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$7.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$7.throwError("ENS name not configured", Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$7.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll$1(() => __awaiter$5(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i = 0; i < block.transactions.length; i++) {
            const tx = block.transactions[i];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll$1(() => __awaiter$5(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll$1(() => __awaiter$5(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties$1({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$5(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$7.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network2 = yield this.getNetwork();
      if (!network2.ensAddress) {
        logger$7.throwError("network does not support ENS", Logger$1.errors.UNSUPPORTED_OPERATION, { operation, network: network2.name });
      }
      try {
        const addrData = yield this.call({
          to: network2.ensAddress,
          data: "0x0178b8bf" + namehash$1(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger$7.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$5(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash$1(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$5(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar3 = yield resolver.getAvatar();
          if (avatar3) {
            return avatar3.url;
          }
        } catch (error) {
          if (error.code !== Logger$1.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash$1(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== Logger$1.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar2 = yield resolver.getAvatar();
      if (avatar2 == null) {
        return null;
      }
      return avatar2.url;
    });
  }
  perform(method, params) {
    return logger$7.throwError(method + " not implemented", Logger$1.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event$1(getEventTag(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter$4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$6 = new Logger$1(version$a);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data = isHexString(value.data) ? value.data : null;
    if (!requireData || data) {
      return { message: value.message, data };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction2 = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger$6.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger$1.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: transaction2,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger$6.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger$1.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction: transaction2,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger$1.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger$6.throwError("insufficient funds for intrinsic transaction cost", Logger$1.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger$6.throwError("nonce has already been used", Logger$1.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$6.throwError("replacement fee too low", Logger$1.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction: transaction2
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger$6.throwError("legacy pre-eip-155 transactions not supported", Logger$1.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction: transaction2
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger$6.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger$1.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction: transaction2
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult$1(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer$1 {
  constructor(constructorGuard, provider2, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly$1(this, "provider", provider2);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly$1(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly$1(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly$1(this, "_index", addressOrIndex);
      defineReadOnly$1(this, "_address", null);
    } else {
      logger$6.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider2) {
    return logger$6.throwError("cannot alter JSON-RPC Signer connection", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$6.throwError("unknown account #" + this._index, Logger$1.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction2) {
    transaction2 = shallowCopy$1(transaction2);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction2.gasLimit == null) {
      const estimate = shallowCopy$1(transaction2);
      estimate.from = fromAddress;
      transaction2.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction2.to != null) {
      transaction2.to = Promise.resolve(transaction2.to).then((to) => __awaiter$4(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$6.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties$1({
      tx: resolveProperties$1(transaction2),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$6.throwArgumentError("from address mismatch", "transaction", transaction2);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash2) => {
        return hash2;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$6.throwError("user rejected transaction", Logger$1.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction2) {
    return logger$6.throwError("signing transactions is unsupported", Logger$1.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction2) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash2 = yield this.sendUncheckedTransaction(transaction2);
      try {
        return yield poll$1(() => __awaiter$4(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash2);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash2, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash2;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$6.throwError("user rejected signing", Logger$1.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$6.throwError("user rejected signing", Logger$1.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain2, types2, value) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types2, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$6.throwError("user rejected signing", Logger$1.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types: types2, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const provider2 = this.provider;
      const address = yield this.getAddress();
      return provider2.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction2) {
    return this.sendUncheckedTransaction(transaction2).then((hash2) => {
      return {
        hash: hash2,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash2, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
let JsonRpcProvider$1 = class JsonRpcProvider extends BaseProvider {
  constructor(url, network2) {
    let networkOrReady = network2;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network3) => {
            resolve(network3);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic$1(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly$1(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly$1(this, "connection", Object.freeze(shallowCopy$1(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic$1(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger$6.throwError("could not detect network", Logger$1.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$6.throwError("could not detect network", Logger$1.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy$1(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult$1).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic$1(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic$1(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy$1(params);
              params.transaction = shallowCopy$1(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$6.throwError(method + " not implemented", Logger$1.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash2) {
            self2._emitted["t:" + hash2.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash2).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction2, allowExtra) {
    const allowed = shallowCopy$1(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties$1(transaction2, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction2[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction2[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction2[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction2[key2]);
    });
    if (transaction2.accessList) {
      result["accessList"] = accessListify(transaction2.accessList);
    }
    return result;
  }
};
var __awaiter$3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$5 = new Logger$1(version$a);
class StaticJsonRpcProvider extends JsonRpcProvider$1 {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      let network2 = this.network;
      if (network2 == null) {
        network2 = yield _super.detectNetwork.call(this);
        if (!network2) {
          logger$5.throwError("no network detected", Logger$1.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly$1(this, "_network", network2);
          this.emit("network", network2, null);
        }
      }
      return network2;
    });
  }
}
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$4 = new Logger$1(version$a);
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i = 0; i < networks2.length; i++) {
    const network2 = networks2[i];
    if (network2 == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network2.name && result.chainId === network2.chainId && (result.ensAddress === network2.ensAddress || result.ensAddress == null && network2.ensAddress == null))) {
        logger$4.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network2;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a2 = values[middle - 1], b2 = values[middle];
  if (maxDelta != null && Math.abs(a2 - b2) > maxDelta) {
    return null;
  }
  return (a2 + b2) / 2;
}
function serialize$1(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i) => serialize$1(i)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key2) => {
      let v3 = value[key2];
      if (typeof v3 === "function") {
        v3 = "[function]";
      } else {
        v3 = serialize$1(v3);
      }
      return JSON.stringify(key2) + ":" + v3;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
let nextRid = 1;
function stall(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait2 = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait: wait2 };
}
const ForwardErrors = [
  Logger$1.errors.CALL_EXCEPTION,
  Logger$1.errors.INSUFFICIENT_FUNDS,
  Logger$1.errors.NONCE_EXPIRED,
  Logger$1.errors.REPLACEMENT_UNDERPRICED,
  Logger$1.errors.UNPREDICTABLE_GAS_LIMIT
];
const ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now2) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now2) {
    result.duration = now2 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize2, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c2) => {
      const value = normalize2(c2.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c2.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i = 0; i < keys.length; i++) {
      const check = tally[keys[i]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider2, method, params) {
  let normalize2 = serialize$1;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        let blockNumber = median(configs.map((c2) => c2.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider2._highestBlockNumber) {
          provider2._highestBlockNumber = blockNumber;
        }
        return provider2._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c2) => c2.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize2 = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy$1(tx);
        tx.confirmations = -1;
        return serialize$1(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize2 = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy$1(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy$1(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize$1(block);
        };
      } else {
        normalize2 = function(block) {
          if (block == null) {
            return null;
          }
          return serialize$1(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize2, provider2.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter$2(this, void 0, void 0, function* () {
    const provider2 = config2.provider;
    if (provider2.blockNumber != null && provider2.blockNumber >= blockNumber || blockNumber === -1) {
      return provider2;
    }
    return poll$1(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider2.blockNumber >= blockNumber) {
            return resolve(provider2);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider2 });
  });
}
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter$2(this, void 0, void 0, function* () {
    let provider2 = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider2[method]();
      case "getEtherPrice":
        if (provider2.getEtherPrice) {
          return provider2.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider2[method](params.transaction, params.blockTag);
        }
        return provider2[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider2[method](params.transactionHash);
      case "getLogs": {
        let filter2 = params.filter;
        if (filter2.fromBlock && isHexString(filter2.fromBlock) || filter2.toBlock && isHexString(filter2.toBlock)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2.getLogs(filter2);
      }
    }
    return logger$4.throwError("unknown method error", Logger$1.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
class FallbackProvider extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger$4.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index2) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy$1(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger$4.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index2}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c2) => accum + c2.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger$4.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c2) => c2.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly$1(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly$1(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c2) => c2.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results2 = yield Promise.all(this.providerConfigs.map((c2) => {
          return c2.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i2 = 0; i2 < results2.length; i2++) {
          const result = results2[i2];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results2[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy$1));
      configs.sort((a2, b2) => a2.priority - b2.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i = 0;
      let first = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c2) => c2.runner && t0 - c2.start < c2.stallTimeout).reduce((accum, c2) => accum + c2.weight, 0);
        while (inflightWeight < this.quorum && i < configs.length) {
          const config2 = configs[i++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy$1(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy$1(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy$1(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c2) => {
          if (c2.done || !c2.runner) {
            return;
          }
          waiting.push(c2.runner);
          if (c2.staller) {
            waiting.push(c2.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results2 = configs.filter((c2) => c2.done && c2.error == null);
        if (results2.length >= this.quorum) {
          const result = processFunc(results2);
          if (result !== void 0) {
            configs.forEach((c2) => {
              if (c2.staller) {
                c2.staller.cancel();
              }
              c2.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall(100).getPromise();
          }
          first = false;
        }
        const errors2 = configs.reduce((accum, c2) => {
          if (!c2.done || c2.error == null) {
            return accum;
          }
          const code2 = c2.error.code;
          if (ForwardErrors.indexOf(code2) >= 0) {
            if (!accum[code2]) {
              accum[code2] = { error: c2.error, weight: 0 };
            }
            accum[code2].weight += c2.weight;
          }
          return accum;
        }, {});
        Object.keys(errors2).forEach((errorCode) => {
          const tally = errors2[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c2) => {
            if (c2.staller) {
              c2.staller.cancel();
            }
            c2.cancelled = true;
          });
          const e2 = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e2[name2] == null) {
              return;
            }
            props[name2] = e2[name2];
          });
          logger$4.throwError(e2.reason || e2.message, errorCode, props);
        });
        if (configs.filter((c2) => !c2.done).length === 0) {
          break;
        }
      }
      configs.forEach((c2) => {
        if (c2.staller) {
          c2.staller.cancel();
        }
        c2.cancelled = true;
      });
      return logger$4.throwError("failed to meet quorum", Logger$1.errors.SERVER_ERROR, {
        method,
        params,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: configs.map((c2) => exposeDebugConfig(c2)),
        provider: this
      });
    });
  }
}
const logger$3 = new Logger$1(version$a);
let _nextId$1 = 1;
function buildWeb3LegacyFetcher(provider2, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId$1++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy$1(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider2) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy$1(request),
      provider: this
    });
    return provider2.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
class Web3Provider extends JsonRpcProvider$1 {
  constructor(provider2, network2) {
    if (provider2 == null) {
      logger$3.throwArgumentError("missing provider", "provider", provider2);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider2 === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider2;
    } else {
      path = provider2.host || provider2.path || "";
      if (!path && provider2.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider2;
      if (provider2.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider2);
      } else if (provider2.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider2, provider2.sendAsync.bind(provider2));
      } else if (provider2.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider2, provider2.send.bind(provider2));
      } else {
        logger$3.throwArgumentError("unsupported provider", "provider", provider2);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network2);
    defineReadOnly$1(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly$1(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}
const version$9 = "solidity/5.7.0";
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$2 = new Logger$1(version$9);
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size2 = parseInt(match[2] || "256");
    if (match[2] && String(size2) !== match[2] || size2 % 8 !== 0 || size2 === 0 || size2 > 256) {
      logger$2.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray2) {
      size2 = 256;
    }
    value = BigNumber.from(value).toTwos(size2);
    return zeroPad(value, size2 / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size2 = parseInt(match[1]);
    if (String(size2) !== match[1] || size2 === 0 || size2 > 32) {
      logger$2.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size2) {
      logger$2.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray2) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count2 = parseInt(match[2] || String(value.length));
    if (count2 != value.length) {
      logger$2.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat$1(result);
  }
  return logger$2.throwArgumentError("invalid type", "type", type);
}
function pack(types2, values) {
  if (types2.length != values.length) {
    logger$2.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types2.forEach(function(type, index2) {
    tight.push(_pack(type, values[index2]));
  });
  return hexlify(concat$1(tight));
}
function keccak256$1(types2, values) {
  return keccak256$2(pack(types2, values));
}
function sha256$3(types2, values) {
  return sha256$4(pack(types2, values));
}
const lib_esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: keccak256$1,
  pack,
  sha256: sha256$3
}, Symbol.toStringTag, { value: "Module" }));
const version$8 = "units/5.7.0";
const logger$1 = new Logger$1(version$8);
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger$1.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index2 = whole.length - 3;
      formatted.unshift(whole.substring(index2));
      whole = whole.substring(0, index2);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits$1(value, unitName) {
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits$1(value, unitName) {
  if (typeof value !== "string") {
    logger$1.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther$1(wei) {
  return formatUnits$1(wei, 18);
}
function parseEther(ether) {
  return parseUnits$1(ether, 18);
}
const lib_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commify,
  formatEther: formatEther$1,
  formatUnits: formatUnits$1,
  parseEther,
  parseUnits: parseUnits$1
}, Symbol.toStringTag, { value: "Module" }));
const utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  HDNode,
  Indexed,
  Interface,
  LogDescription,
  Logger: Logger$1,
  ParamType,
  RLP: lib_esm$g,
  SigningKey,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  },
  TransactionDescription,
  get TransactionTypes() {
    return TransactionTypes;
  },
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  _TypedDataEncoder: TypedDataEncoder,
  _fetchData,
  _toEscapedUtf8String,
  accessListify,
  arrayify,
  base58: Base58,
  base64: lib_esm$d,
  checkProperties: checkProperties$1,
  checkResultErrors,
  commify,
  computeAddress,
  computeHmac,
  computePublicKey,
  concat: concat$1,
  deepCopy: deepCopy$1,
  defaultAbiCoder,
  defaultPath,
  defineReadOnly: defineReadOnly$1,
  dnsEncode,
  entropyToMnemonic,
  fetchJson,
  formatBytes32String,
  formatEther: formatEther$1,
  formatUnits: formatUnits$1,
  getAccountPath,
  getAddress: getAddress$1,
  getContractAddress: getContractAddress$1,
  getCreate2Address,
  getIcapAddress,
  getJsonWalletAddress,
  getStatic: getStatic$1,
  hashMessage: hashMessage$1,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  id,
  isAddress: isAddress$1,
  isBytes: isBytes$1,
  isBytesLike,
  isHexString,
  isValidMnemonic,
  isValidName,
  joinSignature,
  keccak256: keccak256$2,
  mnemonicToEntropy,
  mnemonicToSeed,
  namehash: namehash$1,
  nameprep,
  parseBytes32String,
  parseEther,
  parseTransaction: parse$2,
  parseUnits: parseUnits$1,
  poll: poll$1,
  randomBytes: randomBytes$1,
  recoverAddress,
  recoverPublicKey,
  resolveProperties: resolveProperties$1,
  ripemd160,
  serializeTransaction: serialize$2,
  sha256: sha256$4,
  sha512,
  shallowCopy: shallowCopy$1,
  shuffled,
  solidityKeccak256: keccak256$1,
  solidityPack: pack,
  soliditySha256: sha256$3,
  splitSignature,
  stripZeros,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  verifyMessage: verifyMessage$1,
  verifyTypedData: verifyTypedData$1,
  zeroPad
}, Symbol.toStringTag, { value: "Module" }));
const version$7 = "3.7.7";
const VERSION$2 = version$7;
const _hasBuffer = typeof Buffer2 === "function";
const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a2) => {
  let tab = {};
  a2.forEach((c2, i) => tab[c2] = i);
  return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
const _tidyB64 = (s2) => s2.replace(/[^A-Za-z0-9\+\/]/g, "");
const btoaPolyfill = (bin) => {
  let u322, c0, c1, c2, asc = "";
  const pad3 = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u322 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u322 >> 18 & 63] + b64chs[u322 >> 12 & 63] + b64chs[u322 >> 6 & 63] + b64chs[u322 & 63];
  }
  return pad3 ? asc.slice(0, pad3 - 3) + "===".substring(pad3) : asc;
};
const _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer2.from(bin, "binary").toString("base64") : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a2) => Buffer2.from(u8a2).toString("base64") : (u8a2) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l2 = u8a2.length; i < l2; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a2.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
const fromUint8Array = (u8a2, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a2)) : _fromUint8Array(u8a2);
const cb_utob = (c2) => {
  if (c2.length < 2) {
    var cc2 = c2.charCodeAt(0);
    return cc2 < 128 ? c2 : cc2 < 2048 ? _fromCC(192 | cc2 >>> 6) + _fromCC(128 | cc2 & 63) : _fromCC(224 | cc2 >>> 12 & 15) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
  } else {
    var cc2 = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
    return _fromCC(240 | cc2 >>> 18 & 7) + _fromCC(128 | cc2 >>> 12 & 63) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);
  }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
const utob = (u2) => u2.replace(re_utob, cb_utob);
const _encode2 = _hasBuffer ? (s2) => Buffer2.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
const encode2 = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode2(src)) : _encode2(src);
const encodeURI$1 = (src) => encode2(src, true);
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset2 = cp - 65536;
      return _fromCC((offset2 >>> 10) + 55296) + _fromCC((offset2 & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
const btou = (b2) => b2.replace(re_btou, cb_btou);
const atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
const _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer2.from(asc, "base64").toString("binary") : atobPolyfill;
const _toUint8Array = _hasBuffer ? (a2) => _U8Afrom(Buffer2.from(a2, "base64")) : (a2) => _U8Afrom(_atob(a2).split("").map((c2) => c2.charCodeAt(0)));
const toUint8Array$1 = (a2) => _toUint8Array(_unURI(a2));
const _decode = _hasBuffer ? (a2) => Buffer2.from(a2, "base64").toString("utf8") : _TD ? (a2) => _TD.decode(_toUint8Array(a2)) : (a2) => btou(_atob(a2));
const _unURI = (a2) => _tidyB64(a2.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
const decode = (src) => _decode(_unURI(src));
const isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
};
const _noEnum = (v3) => {
  return {
    value: v3,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
const extendString = function() {
  const _add = (name2, body) => Object.defineProperty(String.prototype, name2, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode2(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode2(this, true);
  });
  _add("toBase64URL", function() {
    return encode2(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array$1(this);
  });
};
const extendUint8Array = function() {
  const _add = (name2, body) => Object.defineProperty(Uint8Array.prototype, name2, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
const extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
const gBase64 = {
  version: version$7,
  VERSION: VERSION$2,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode2,
  encode: encode2,
  encodeURI: encodeURI$1,
  encodeURL: encodeURI$1,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array: toUint8Array$1,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __awaiter$1(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v3) {
      return step([n2, v3]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var encodeTypedDataHash$1 = function(typedData) {
  return TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message);
};
var Proof = (
  /** @class */
  function() {
    function Proof2(args) {
      this.prefix = ETHAuthPrefix;
      this.address = (args === null || args === void 0 ? void 0 : args.address) ? args.address.toLowerCase() : "";
      this.claims = (args === null || args === void 0 ? void 0 : args.claims) ? args.claims : { app: "", iat: 0, exp: 0, v: ETHAuthVersion };
      this.signature = (args === null || args === void 0 ? void 0 : args.signature) ? args.signature : "";
      this.extra = (args === null || args === void 0 ? void 0 : args.extra) ? args.extra : "";
    }
    Proof2.prototype.setIssuedAtNow = function() {
      this.claims.iat = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    };
    Proof2.prototype.setExpiryIn = function(seconds) {
      this.claims.exp = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + seconds;
    };
    Proof2.prototype.validateClaims = function() {
      return validateClaims(this.claims);
    };
    Proof2.prototype.messageDigest = function() {
      var isValid2 = this.validateClaims();
      if (isValid2.err) {
        throw isValid2.err;
      }
      return arrayify(encodeTypedDataHash$1(this.messageTypedData()));
    };
    Proof2.prototype.messageTypedData = function() {
      var domain2 = __assign$1({}, ETHAuthEIP712Domain);
      var types2 = {
        "Claims": []
      };
      var message = {};
      var typedData = { domain: domain2, types: types2, message };
      if (this.claims.app && this.claims.app.length > 0) {
        typedData.types.Claims.push({ name: "app", type: "string" });
        typedData.message["app"] = this.claims.app;
      }
      if (this.claims.iat && this.claims.iat > 0) {
        typedData.types.Claims.push({ name: "iat", type: "int64" });
        typedData.message["iat"] = this.claims.iat;
      }
      if (this.claims.exp && this.claims.exp > 0) {
        typedData.types.Claims.push({ name: "exp", type: "int64" });
        typedData.message["exp"] = this.claims.exp;
      }
      if (this.claims.n && this.claims.n > 0) {
        typedData.types.Claims.push({ name: "n", type: "uint64" });
        typedData.message["n"] = this.claims.n;
      }
      if (this.claims.typ && this.claims.typ.length > 0) {
        typedData.types.Claims.push({ name: "typ", type: "string" });
        typedData.message["typ"] = this.claims.typ;
      }
      if (this.claims.ogn && this.claims.ogn.length > 0) {
        typedData.types.Claims.push({ name: "ogn", type: "string" });
        typedData.message["ogn"] = this.claims.ogn;
      }
      if (this.claims.v && this.claims.v.length > 0) {
        typedData.types.Claims.push({ name: "v", type: "string" });
        typedData.message["v"] = this.claims.v;
      }
      return typedData;
    };
    return Proof2;
  }()
);
var validateClaims = function(claims) {
  if (claims.app === "") {
    return { ok: false, err: new Error("claims: app is empty") };
  }
  var now2 = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  var drift = 5 * 60;
  var max2 = 60 * 60 * 24 * 365 + drift;
  if (claims.v === "") {
    return { ok: false, err: new Error("claims: ethauth version is empty") };
  }
  if (claims.iat && claims.iat !== 0 && (claims.iat > now2 + drift || claims.iat < now2 - max2)) {
    return { ok: false, err: new Error("claims: iat is invalid") };
  }
  if (claims.exp < now2 - drift || claims.exp > now2 + max2) {
    return { ok: false, err: new Error("claims: token has expired") };
  }
  return { ok: true };
};
var ValidateEOAProof = function(provider2, chainId, proof) {
  return __awaiter$1(void 0, void 0, void 0, function() {
    var messageDigest, address;
    return __generator$1(this, function(_a2) {
      messageDigest = proof.messageDigest();
      address = verifyMessage$1(messageDigest, proof.signature);
      if (address.slice(0, 2) === "0x" && address.length === 42 && address.toLowerCase() === proof.address.toLowerCase()) {
        return [2, { isValid: true, address: proof.address }];
      } else {
        return [2, { isValid: false }];
      }
    });
  });
};
var ValidateContractAccountProof = function(provider2, chainId, proof) {
  return __awaiter$1(void 0, void 0, void 0, function() {
    var messageDigest, walletCode, abi2, contract, isValidSignature2;
    return __generator$1(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (!provider2 || provider2 === void 0) {
            return [2, { isValid: false }];
          }
          messageDigest = proof.messageDigest();
          return [4, provider2.getCode(proof.address)];
        case 1:
          walletCode = _a2.sent();
          if (walletCode === "0x" || walletCode.length <= 2) {
            throw new Error("ValidateContractAccountProof failed. unable to fetch wallet contract code");
          }
          abi2 = ["function isValidSignature(bytes32, bytes) public view returns (bytes4)"];
          contract = new Contract(proof.address, abi2, provider2);
          return [4, contract.isValidSignature(messageDigest, arrayify(proof.signature))];
        case 2:
          isValidSignature2 = _a2.sent();
          if (isValidSignature2 === IsValidSignatureBytes32MagicValue) {
            return [2, { isValid: true, address: proof.address }];
          } else {
            return [2, { isValid: false }];
          }
      }
    });
  });
};
var IsValidSignatureBytes32MagicValue = "0x1626ba7e";
var ETHAuthVersion = "1";
var ETHAuthPrefix = "eth";
var ETHAuthEIP712Domain = {
  name: "ETHAuth",
  version: ETHAuthVersion
};
var ETHAuth = (
  /** @class */
  /* @__PURE__ */ function() {
    function ETHAuth2() {
      var validators = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        validators[_i2] = arguments[_i2];
      }
      var _this = this;
      this.configJsonRpcProvider = function(ethereumJsonRpcURL) {
        return __awaiter$1(_this, void 0, void 0, function() {
          var netVersion;
          return __generator$1(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.provider = new JsonRpcProvider$1(ethereumJsonRpcURL);
                return [4, this.provider.send("net_version", [])];
              case 1:
                netVersion = _a2.sent();
                this.chainId = parseInt(netVersion);
                if (!this.chainId || this.chainId === 0 || this.chainId === NaN) {
                  throw new Error("ethauth: unable to get chainId");
                }
                this.ethereumJsonRpcURL = ethereumJsonRpcURL;
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      this.configValidators = function() {
        var validators2 = [];
        for (var _i3 = 0; _i3 < arguments.length; _i3++) {
          validators2[_i3] = arguments[_i3];
        }
        if (validators2.length == 0) {
          throw new Error("validators list is empty");
        }
        _this.validators = validators2;
      };
      this.encodeProof = function(proof, skipSignatureValidation) {
        if (skipSignatureValidation === void 0) {
          skipSignatureValidation = false;
        }
        return __awaiter$1(_this, void 0, void 0, function() {
          var isValid2, claimsJSON, proofString;
          return __generator$1(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (proof.address.length !== 42 || proof.address.slice(0, 2) !== "0x") {
                  throw new Error("ethauth: invalid address");
                }
                if (proof.signature === "" || proof.signature.slice(0, 2) !== "0x") {
                  throw new Error("ethauth: invalid signature");
                }
                if (proof.extra && proof.extra.slice(0, 2) !== "0x") {
                  throw new Error("ethauth: invalid extra encoding, expecting hex data");
                }
                return [4, this.validateProof(proof, skipSignatureValidation)];
              case 1:
                isValid2 = _a2.sent();
                if (!isValid2) {
                  throw new Error("ethauth: proof is invalid");
                }
                claimsJSON = JSON.stringify(proof.claims);
                proofString = ETHAuthPrefix + "." + proof.address.toLowerCase() + "." + gBase64.encode(claimsJSON, true) + "." + proof.signature;
                if (proof.extra && proof.extra.length > 0) {
                  proofString += "." + proof.extra;
                }
                return [2, proofString];
            }
          });
        });
      };
      this.decodeProof = function(proofString, skipSignatureValidation) {
        if (skipSignatureValidation === void 0) {
          skipSignatureValidation = false;
        }
        return __awaiter$1(_this, void 0, void 0, function() {
          var parts, prefix, address, messageBase64, signature2, extra, message, claims, proof, isValid2;
          return __generator$1(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                parts = proofString.split(".");
                if (parts.length < 4 || parts.length > 5) {
                  throw new Error("ethauth: invalid proof string");
                }
                prefix = parts[0], address = parts[1], messageBase64 = parts[2], signature2 = parts[3], extra = parts[4];
                if (prefix !== ETHAuthPrefix) {
                  throw new Error("ethauth: not an ethauth proof");
                }
                message = gBase64.decode(messageBase64);
                claims = JSON.parse(message);
                proof = new Proof({ address, claims, signature: signature2, extra });
                return [4, this.validateProof(proof, skipSignatureValidation)];
              case 1:
                isValid2 = _a2.sent();
                if (!isValid2) {
                  throw new Error("ethauth: proof is invalid");
                }
                return [2, proof];
            }
          });
        });
      };
      this.validateProof = function(proof, skipSignatureValidation) {
        if (skipSignatureValidation === void 0) {
          skipSignatureValidation = false;
        }
        return __awaiter$1(_this, void 0, void 0, function() {
          var isValidClaims, isValidSig;
          return __generator$1(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isValidClaims = this.validateProofClaims(proof);
                if (isValidClaims.err) {
                  throw new Error("ethauth: proof claims are invalid ".concat(isValidClaims.err));
                }
                if (!(skipSignatureValidation !== true))
                  return [3, 2];
                return [4, this.validateProofSignature(proof)];
              case 1:
                isValidSig = _a2.sent();
                if (isValidSig !== true) {
                  throw new Error("ethauth: proof signature is invalid");
                }
                _a2.label = 2;
              case 2:
                return [2, true];
            }
          });
        });
      };
      this.validateProofSignature = function(proof) {
        return __awaiter$1(_this, void 0, void 0, function() {
          var retIsValid, i, validator, isValid2, i;
          return __generator$1(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                retIsValid = [];
                i = 0;
                _a2.label = 1;
              case 1:
                if (!(i < this.validators.length))
                  return [3, 6];
                _a2.label = 2;
              case 2:
                _a2.trys.push([2, 4, , 5]);
                validator = this.validators[i];
                return [4, validator(this.provider, this.chainId, proof)];
              case 3:
                isValid2 = _a2.sent().isValid;
                if (isValid2 === true) {
                  return [2, true];
                }
                retIsValid.push(isValid2);
                return [3, 5];
              case 4:
                _a2.sent();
                retIsValid.push(false);
                return [3, 5];
              case 5:
                i++;
                return [3, 1];
              case 6:
                for (i = 0; i < retIsValid.length; i++) {
                  if (retIsValid[i]) {
                    return [2, true];
                  }
                }
                return [2, false];
            }
          });
        });
      };
      this.validateProofClaims = function(proof) {
        return proof.validateClaims();
      };
      if (validators.length == 0) {
        this.validators = [ValidateEOAProof, ValidateContractAccountProof];
      } else {
        this.validators = validators;
      }
    }
    return ETHAuth2;
  }()
);
let ChainId = /* @__PURE__ */ function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["ROPSTEN"] = 3] = "ROPSTEN";
  ChainId2[ChainId2["RINKEBY"] = 4] = "RINKEBY";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["KOVAN"] = 42] = "KOVAN";
  ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["POLYGON_ZKEVM"] = 1101] = "POLYGON_ZKEVM";
  ChainId2[ChainId2["POLYGON_AMOY"] = 80002] = "POLYGON_AMOY";
  ChainId2[ChainId2["BSC"] = 56] = "BSC";
  ChainId2[ChainId2["BSC_TESTNET"] = 97] = "BSC_TESTNET";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISM_KOVAN"] = 69] = "OPTIMISM_KOVAN";
  ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM"] = 42161] = "ARBITRUM";
  ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId2[ChainId2["ARBITRUM_SEPOLIA"] = 421614] = "ARBITRUM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM_NOVA"] = 42170] = "ARBITRUM_NOVA";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["AVALANCHE_TESTNET"] = 43113] = "AVALANCHE_TESTNET";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["BASE"] = 8453] = "BASE";
  ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId2[ChainId2["BASE_SEPOLIA"] = 84532] = "BASE_SEPOLIA";
  ChainId2[ChainId2["HOMEVERSE_TESTNET"] = 40875] = "HOMEVERSE_TESTNET";
  ChainId2[ChainId2["HOMEVERSE"] = 19011] = "HOMEVERSE";
  ChainId2[ChainId2["XAI"] = 660279] = "XAI";
  ChainId2[ChainId2["XAI_SEPOLIA"] = 37714555429] = "XAI_SEPOLIA";
  ChainId2[ChainId2["ASTAR_ZKEVM"] = 3776] = "ASTAR_ZKEVM";
  ChainId2[ChainId2["ASTAR_ZKYOTO"] = 6038361] = "ASTAR_ZKYOTO";
  ChainId2[ChainId2["XR_SEPOLIA"] = 2730] = "XR_SEPOLIA";
  ChainId2[ChainId2["TELOS"] = 40] = "TELOS";
  ChainId2[ChainId2["B3_SEPOLIA"] = 1993] = "B3_SEPOLIA";
  ChainId2[ChainId2["APECHAIN_TESTNET"] = 33111] = "APECHAIN_TESTNET";
  ChainId2[ChainId2["BLAST"] = 81457] = "BLAST";
  ChainId2[ChainId2["BLAST_SEPOLIA"] = 168587773] = "BLAST_SEPOLIA";
  ChainId2[ChainId2["HARDHAT"] = 31337] = "HARDHAT";
  ChainId2[ChainId2["HARDHAT_2"] = 31338] = "HARDHAT_2";
  return ChainId2;
}({});
let NetworkType = /* @__PURE__ */ function(NetworkType2) {
  NetworkType2["MAINNET"] = "mainnet";
  NetworkType2["TESTNET"] = "testnet";
  return NetworkType2;
}({});
const networks = {
  [ChainId.MAINNET]: {
    chainId: ChainId.MAINNET,
    type: NetworkType.MAINNET,
    name: "mainnet",
    title: "Ethereum",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.MAINNET}.webp`,
    blockExplorer: {
      name: "Etherscan",
      rootUrl: "https://etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  [ChainId.ROPSTEN]: {
    chainId: ChainId.ROPSTEN,
    type: NetworkType.TESTNET,
    name: "ropsten",
    title: "Ropsten",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ROPSTEN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Ropsten)",
      rootUrl: "https://ropsten.etherscan.io/"
    },
    nativeToken: {
      symbol: "roETH",
      name: "Ropsten Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId.RINKEBY]: {
    chainId: ChainId.RINKEBY,
    type: NetworkType.TESTNET,
    name: "rinkeby",
    title: "Rinkeby",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.RINKEBY}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Rinkeby)",
      rootUrl: "https://rinkeby.etherscan.io/"
    },
    nativeToken: {
      symbol: "rETH",
      name: "Rinkeby Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId.GOERLI]: {
    chainId: ChainId.GOERLI,
    type: NetworkType.TESTNET,
    name: "goerli",
    title: "Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Goerli)",
      rootUrl: "https://goerli.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    deprecated: true
  },
  [ChainId.KOVAN]: {
    chainId: ChainId.KOVAN,
    type: NetworkType.TESTNET,
    name: "kovan",
    title: "Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.KOVAN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Kovan)",
      rootUrl: "https://kovan.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.SEPOLIA]: {
    chainId: ChainId.SEPOLIA,
    type: NetworkType.TESTNET,
    name: "sepolia",
    title: "Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Sepolia)",
      rootUrl: "https://sepolia.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.POLYGON]: {
    chainId: ChainId.POLYGON,
    type: NetworkType.MAINNET,
    name: "polygon",
    title: "Polygon",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON}.webp`,
    blockExplorer: {
      name: "Polygonscan",
      rootUrl: "https://polygonscan.com/"
    },
    nativeToken: {
      symbol: "MATIC",
      name: "Polygon",
      decimals: 18
    }
  },
  [ChainId.POLYGON_MUMBAI]: {
    chainId: ChainId.POLYGON_MUMBAI,
    type: NetworkType.TESTNET,
    name: "mumbai",
    title: "Polygon Mumbai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_MUMBAI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Polygonscan (Mumbai)",
      rootUrl: "https://mumbai.polygonscan.com/"
    },
    nativeToken: {
      symbol: "mMATIC",
      name: "Mumbai Polygon",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.POLYGON_AMOY]: {
    chainId: ChainId.POLYGON_AMOY,
    type: NetworkType.TESTNET,
    name: "amoy",
    title: "Polygon Amoy",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_AMOY}.webp`,
    testnet: true,
    blockExplorer: {
      name: "OKLink (Amoy)",
      rootUrl: "https://www.oklink.com/amoy/"
    },
    nativeToken: {
      symbol: "aMATIC",
      name: "Amoy Polygon",
      decimals: 18
    }
  },
  [ChainId.POLYGON_ZKEVM]: {
    chainId: ChainId.POLYGON_ZKEVM,
    type: NetworkType.MAINNET,
    name: "polygon-zkevm",
    title: "Polygon zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_ZKEVM}.webp`,
    blockExplorer: {
      name: "Polygonscan (zkEVM)",
      rootUrl: "https://zkevm.polygonscan.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.BSC]: {
    chainId: ChainId.BSC,
    type: NetworkType.MAINNET,
    name: "bsc",
    title: "BNB Smart Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BSC}.webp`,
    blockExplorer: {
      name: "BSCScan",
      rootUrl: "https://bscscan.com/"
    },
    nativeToken: {
      symbol: "BNB",
      name: "BNB",
      decimals: 18
    }
  },
  [ChainId.BSC_TESTNET]: {
    chainId: ChainId.BSC_TESTNET,
    type: NetworkType.TESTNET,
    name: "bsc-testnet",
    title: "BNB Smart Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BSC_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "BSCScan (Testnet)",
      rootUrl: "https://testnet.bscscan.com/"
    },
    nativeToken: {
      symbol: "tBNB",
      name: "Testnet BNB",
      decimals: 18
    }
  },
  [ChainId.OPTIMISM]: {
    chainId: ChainId.OPTIMISM,
    type: NetworkType.MAINNET,
    name: "optimism",
    title: "Optimism",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM}.webp`,
    blockExplorer: {
      name: "Etherscan (Optimism)",
      rootUrl: "https://optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.OPTIMISM_KOVAN]: {
    chainId: ChainId.OPTIMISM_KOVAN,
    type: NetworkType.TESTNET,
    name: "optimism-kovan",
    title: "Optimism Kovan",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_KOVAN}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Kovan)",
      rootUrl: "https://kovan-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "kETH",
      name: "Kovan Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.OPTIMISM_GOERLI]: {
    chainId: ChainId.OPTIMISM_GOERLI,
    type: NetworkType.TESTNET,
    name: "optimism-goerli",
    title: "Optimism Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Goerli)",
      rootUrl: "https://goerli-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.OPTIMISM_SEPOLIA]: {
    chainId: ChainId.OPTIMISM_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "optimism-sepolia",
    title: "Optimism Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Etherscan (Optimism Sepolia)",
      rootUrl: "https://sepolia-optimistic.etherscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.ARBITRUM]: {
    chainId: ChainId.ARBITRUM,
    type: NetworkType.MAINNET,
    name: "arbitrum",
    title: "Arbitrum One",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM}.webp`,
    blockExplorer: {
      name: "Arbiscan",
      rootUrl: "https://arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.ARBITRUM_GOERLI]: {
    chainId: ChainId.ARBITRUM_GOERLI,
    type: NetworkType.TESTNET,
    name: "arbitrum-goerli",
    title: "Arbitrum Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Arbiscan (Goerli Testnet)",
      rootUrl: "https://testnet.arbiscan.io/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.ARBITRUM_SEPOLIA]: {
    chainId: ChainId.ARBITRUM_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "arbitrum-sepolia",
    title: "Arbitrum Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Arbiscan (Sepolia Testnet)",
      rootUrl: "https://sepolia.arbiscan.io/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.ARBITRUM_NOVA]: {
    chainId: ChainId.ARBITRUM_NOVA,
    type: NetworkType.MAINNET,
    name: "arbitrum-nova",
    title: "Arbitrum Nova",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_NOVA}.webp`,
    blockExplorer: {
      name: "Arbiscan Nova",
      rootUrl: "https://nova.arbiscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.AVALANCHE]: {
    chainId: ChainId.AVALANCHE,
    type: NetworkType.MAINNET,
    name: "avalanche",
    title: "Avalanche",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.AVALANCHE}.webp`,
    blockExplorer: {
      name: "Snowtrace",
      rootUrl: "https://subnets.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "AVAX",
      name: "AVAX",
      decimals: 18
    }
  },
  [ChainId.AVALANCHE_TESTNET]: {
    chainId: ChainId.AVALANCHE_TESTNET,
    type: NetworkType.TESTNET,
    name: "avalanche-testnet",
    title: "Avalanche Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.AVALANCHE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Snowtrace (Testnet)",
      rootUrl: "https://subnets-test.avax.network/c-chain/"
    },
    nativeToken: {
      symbol: "tAVAX",
      name: "Testnet AVAX",
      decimals: 18
    }
  },
  [ChainId.GNOSIS]: {
    chainId: ChainId.GNOSIS,
    type: NetworkType.MAINNET,
    name: "gnosis",
    title: "Gnosis Chain",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.GNOSIS}.webp`,
    blockExplorer: {
      name: "Gnosis Chain Explorer",
      rootUrl: "https://blockscout.com/xdai/mainnet/"
    },
    nativeToken: {
      symbol: "XDAI",
      name: "XDAI",
      decimals: 18
    }
  },
  [ChainId.BASE]: {
    chainId: ChainId.BASE,
    type: NetworkType.MAINNET,
    name: "base",
    title: "Base (Coinbase)",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE}.webp`,
    blockExplorer: {
      name: "Base Explorer",
      rootUrl: "https://basescan.org/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.BASE_GOERLI]: {
    chainId: ChainId.BASE_GOERLI,
    type: NetworkType.TESTNET,
    name: "base-goerli",
    title: "Base Goerli",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE_GOERLI}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Base Goerli Explorer",
      rootUrl: "https://goerli.basescan.org/"
    },
    nativeToken: {
      symbol: "gETH",
      name: "Goerli Ether",
      decimals: 18
    },
    deprecated: true
  },
  [ChainId.BASE_SEPOLIA]: {
    chainId: ChainId.BASE_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "base-sepolia",
    title: "Base Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Base Sepolia Explorer",
      rootUrl: "https://base-sepolia.blockscout.com/"
    },
    nativeToken: {
      symbol: "sETH",
      name: "Sepolia Ether",
      decimals: 18
    }
  },
  [ChainId.HOMEVERSE]: {
    chainId: ChainId.HOMEVERSE,
    type: NetworkType.MAINNET,
    name: "homeverse",
    title: "Oasys Homeverse",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.HOMEVERSE}.webp`,
    blockExplorer: {
      name: "Oasys Homeverse Explorer",
      rootUrl: "https://explorer.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "OAS",
      name: "OAS",
      decimals: 18
    }
  },
  [ChainId.HOMEVERSE_TESTNET]: {
    chainId: ChainId.HOMEVERSE_TESTNET,
    type: NetworkType.TESTNET,
    name: "homeverse-testnet",
    title: "Oasys Homeverse Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.HOMEVERSE_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Oasys Homeverse Explorer (Testnet)",
      rootUrl: "https://explorer.testnet.oasys.homeverse.games/"
    },
    nativeToken: {
      symbol: "tOAS",
      name: "Testnet OAS",
      decimals: 18
    }
  },
  [ChainId.XAI]: {
    chainId: ChainId.XAI,
    type: NetworkType.MAINNET,
    name: "xai",
    title: "Xai",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XAI}.webp`,
    blockExplorer: {
      name: "Xai Explorer",
      rootUrl: "https://explorer.xai-chain.net/"
    },
    nativeToken: {
      symbol: "XAI",
      name: "XAI",
      decimals: 18
    }
  },
  [ChainId.XAI_SEPOLIA]: {
    chainId: ChainId.XAI_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "xai-sepolia",
    title: "Xai Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XAI_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Xai Sepolia Explorer",
      rootUrl: "https://testnet-explorer-v2.xai-chain.net/"
    },
    nativeToken: {
      symbol: "sXAI",
      name: "Sepolia XAI",
      decimals: 18
    }
  },
  [ChainId.ASTAR_ZKEVM]: {
    chainId: ChainId.ASTAR_ZKEVM,
    type: NetworkType.MAINNET,
    name: "astar-zkevm",
    title: "Astar zkEVM",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ASTAR_ZKEVM}.webp`,
    blockExplorer: {
      name: "Astar zkEVM Explorer",
      rootUrl: "https://astar-zkevm.explorer.startale.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.ASTAR_ZKYOTO]: {
    chainId: ChainId.ASTAR_ZKYOTO,
    type: NetworkType.TESTNET,
    name: "astar-zkyoto",
    title: "Astar zKyoto Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ASTAR_ZKYOTO}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Astar zKyoto Explorer",
      rootUrl: "https://astar-zkyoto.blockscout.com/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.XR_SEPOLIA]: {
    chainId: ChainId.XR_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "xr-sepolia",
    title: "XR Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XR_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "XR Sepolia Explorer",
      rootUrl: "https://xr-sepolia-testnet.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "tXR",
      name: "Sepolia XR",
      decimals: 18
    }
  },
  [ChainId.B3_SEPOLIA]: {
    chainId: ChainId.B3_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "b3-sepolia",
    title: "B3 Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.B3_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "B3 Sepolia Explorer",
      rootUrl: "https://sepolia.explorer.b3.fun/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.APECHAIN_TESTNET]: {
    chainId: ChainId.APECHAIN_TESTNET,
    type: NetworkType.TESTNET,
    name: "apechain-testnet",
    title: "APE Chain Testnet",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.APECHAIN_TESTNET}.webp`,
    testnet: true,
    blockExplorer: {
      name: "APE Chain Explorer",
      rootUrl: "https://curtis.explorer.caldera.xyz/"
    },
    nativeToken: {
      symbol: "APE",
      name: "ApeCoin",
      decimals: 18
    }
  },
  [ChainId.BLAST]: {
    chainId: ChainId.BLAST,
    type: NetworkType.MAINNET,
    name: "blast",
    title: "Blast",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BLAST}.webp`,
    blockExplorer: {
      name: "Blast Explorer",
      rootUrl: "https://blastscan.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.BLAST_SEPOLIA]: {
    chainId: ChainId.BLAST_SEPOLIA,
    type: NetworkType.TESTNET,
    name: "blast-sepolia",
    title: "Blast Sepolia",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BLAST_SEPOLIA}.webp`,
    testnet: true,
    blockExplorer: {
      name: "Blast Sepolia Explorer",
      rootUrl: "https://sepolia.blastexplorer.io/"
    },
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.TELOS]: {
    chainId: ChainId.TELOS,
    type: NetworkType.MAINNET,
    name: "telos",
    title: "Telos",
    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.TELOS}.webp`,
    blockExplorer: {
      name: "Telos Explorer",
      rootUrl: "https://explorer.telos.net/network/"
    },
    nativeToken: {
      symbol: "TLOS",
      name: "TLOS",
      decimals: 18
    }
  },
  [ChainId.HARDHAT]: {
    chainId: ChainId.HARDHAT,
    name: "hardhat",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  },
  [ChainId.HARDHAT_2]: {
    chainId: ChainId.HARDHAT_2,
    name: "hardhat2",
    title: "Hardhat (local testnet)",
    nativeToken: {
      symbol: "ETH",
      name: "Ether",
      decimals: 18
    }
  }
};
const base64Encode = (val) => {
  return gBase64.encode(val, true);
};
const base64EncodeObject = (obj) => {
  return gBase64.encode(JSON.stringify(obj), true);
};
const base64Decode = (encodedString) => {
  if (encodedString === null || encodedString === void 0) {
    return void 0;
  }
  return gBase64.decode(encodedString);
};
const base64DecodeObject = (encodedObject) => {
  if (encodedObject === null || encodedObject === void 0) {
    return void 0;
  }
  return JSON.parse(gBase64.decode(encodedObject));
};
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes$1(value));
}
const encodeMessageDigest = (message) => {
  if (typeof message === "string") {
    return arrayify(keccak256$2(toUtf8Bytes(message)));
  } else {
    return arrayify(keccak256$2(message));
  }
};
const packMessageData = (walletAddress, chainId, digest9) => {
  return pack(["string", "uint256", "address", "bytes32"], ["", chainId, walletAddress, digest9]);
};
const subDigestOf = (address, chainId, digest9) => {
  return keccak256$2(packMessageData(address, chainId, digest9));
};
const isNode$2 = () => {
  if (typeof window === "undefined" && typeof process$1 === "object") {
    return true;
  } else {
    return false;
  }
};
const isBrowser$1 = () => !isNode$2();
const jwtDecodeClaims = (jwt) => {
  const parts = jwt.split(".");
  if (parts.length !== 3) {
    throw new Error("invalid jwt");
  }
  const claims = JSON.parse(gBase64.decode(parts[1]));
  return claims;
};
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
var logLevel = /* @__PURE__ */ function(logLevel2) {
  logLevel2[logLevel2["DEBUG"] = 1] = "DEBUG";
  logLevel2[logLevel2["INFO"] = 2] = "INFO";
  logLevel2[logLevel2["WARN"] = 3] = "WARN";
  logLevel2[logLevel2["ERROR"] = 4] = "ERROR";
  logLevel2[logLevel2["DISABLED"] = 5] = "DISABLED";
  return logLevel2;
}(logLevel || {});
class Logger2 {
  constructor(config2) {
    this.config = config2;
    this.logLevel = void 0;
    this.configure(config2);
  }
  configure(config2) {
    this.config = _extends$g({}, this.config, config2);
    switch (this.config.logLevel) {
      case "DEBUG":
        this.logLevel = logLevel.DEBUG;
        break;
      case "INFO":
        this.logLevel = logLevel.INFO;
        break;
      case "WARN":
        this.logLevel = logLevel.WARN;
        break;
      case "ERROR":
        this.logLevel = logLevel.ERROR;
        break;
      case "DISABLED":
        this.logLevel = logLevel.DISABLED;
        break;
      default:
        this.logLevel = logLevel.INFO;
        break;
    }
    if (this.config.silence === void 0) {
      this.config.silence = false;
    }
  }
  debug(message, ...optionalParams) {
    if (this.config.silence === true)
      return;
    if (this.logLevel === logLevel.DEBUG) {
      console.log(message, ...optionalParams);
    }
  }
  info(message, ...optionalParams) {
    if (this.config.silence === true)
      return;
    if (this.logLevel <= logLevel.INFO) {
      console.log(message, ...optionalParams);
    }
  }
  warn(message, ...optionalParams) {
    if (this.config.silence === true)
      return;
    if (this.logLevel <= logLevel.WARN) {
      console.warn(message, ...optionalParams);
      if (this.config.onwarn) {
        this.config.onwarn(message, optionalParams);
      }
    }
  }
  error(message, ...optionalParams) {
    if (this.config.silence === true)
      return;
    if (this.logLevel <= logLevel.ERROR) {
      console.error(message, ...optionalParams);
      if (this.config.onerror) {
        this.config.onerror(message, optionalParams);
      }
    }
  }
}
const logger = new Logger2({
  logLevel: "INFO",
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: true
});
const configureLogger = (config2) => logger.configure(config2);
class Base {
  static bufferIndexOf(array, element, isSorted = false) {
    if (isSorted) {
      return Base.binarySearch(array, element, Base.compare);
    }
    const eqChecker = (buffer1, buffer2) => {
      if (buffer1 === buffer2) {
        return true;
      }
      if (buffer1.length !== buffer2.length) {
        return false;
      }
      for (let i = 0; i < buffer1.length; i++) {
        if (buffer1[i] !== buffer2[i]) {
          return false;
        }
      }
      return true;
    };
    return Base.linearSearch(array, element, eqChecker);
  }
  static binarySearch(array, element, compareFunction) {
    let start = 0;
    let end = array.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const ordering = compareFunction(array[mid], element);
      if (ordering === 0) {
        for (let i = mid - 1; i >= 0; i--) {
          if (compareFunction(array[i], element) === 0)
            continue;
          return i + 1;
        }
        return 0;
      } else if (ordering < 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    }
    return -1;
  }
  static compare(a2, b2) {
    const len = Math.min(a2.length, b2.length);
    for (let i = 0; i < len; i++) {
      if (a2[i] !== b2[i]) {
        return a2[i] - b2[i];
      }
    }
    return a2.length - b2.length;
  }
  static linearSearch(array, element, eqChecker) {
    for (let i = 0; i < array.length; i++) {
      if (eqChecker(array[i], element)) {
        return i;
      }
    }
    return -1;
  }
  static bufferify(value) {
    if (typeof value === "string") {
      return arrayify(value);
    }
    return value;
  }
  static isHexString(v3) {
    return typeof v3 === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v3);
  }
  static bufferToHex(value, withPrefix = true) {
    const prefixed = hexlify(value, {
      allowMissingPrefix: true
    });
    return withPrefix ? prefixed : prefixed.substring(2);
  }
  static bufferifyFn(f2) {
    return (value) => {
      return Base.bufferify(f2(value));
    };
  }
}
class MerkleTree extends Base {
  constructor(leaves, options = {}) {
    super();
    this.hashFn = void 0;
    this.leaves = [];
    this.layers = [];
    this.sortLeaves = false;
    this.sortPairs = false;
    this.sortLeaves = !!options.sortLeaves;
    this.sortPairs = !!options.sortPairs;
    this.hashFn = Base.bufferifyFn(keccak256$2);
    this.processLeaves(leaves);
  }
  getOptions() {
    return {
      sortLeaves: this.sortLeaves,
      sortPairs: this.sortPairs
    };
  }
  processLeaves(leaves) {
    this.leaves = leaves.map(Base.bufferify);
    if (this.sortLeaves) {
      this.leaves = this.leaves.sort(Base.compare);
    }
    this.createHashes(this.leaves);
  }
  createHashes(nodes) {
    this.layers = [nodes];
    while (nodes.length > 1) {
      const layerIndex = this.layers.length;
      this.layers.push([]);
      const layerLimit = nodes.length;
      for (let i = 0; i < nodes.length; i += 2) {
        if (i >= layerLimit) {
          this.layers[layerIndex].push(...nodes.slice(layerLimit));
          break;
        } else if (i + 1 === nodes.length) {
          if (nodes.length % 2 === 1) {
            this.layers[layerIndex].push(nodes[i]);
            continue;
          }
        }
        const left = nodes[i];
        const right = i + 1 === nodes.length ? left : nodes[i + 1];
        const combined = [left, right];
        if (this.sortPairs) {
          combined.sort(Base.compare);
        }
        const hash2 = this.hashFn(concat$1(combined));
        this.layers[layerIndex].push(hash2);
      }
      nodes = this.layers[layerIndex];
    }
  }
  getRoot() {
    if (this.layers.length === 0) {
      return Uint8Array.from([]);
    }
    return this.layers[this.layers.length - 1][0] || Uint8Array.from([]);
  }
  getHexRoot() {
    return Base.bufferToHex(this.getRoot());
  }
  getProof(leaf, index2) {
    if (typeof leaf === "undefined") {
      throw new Error("leaf is required");
    }
    leaf = Base.bufferify(leaf);
    const proof = [];
    if (!Number.isInteger(index2)) {
      index2 = -1;
      for (let i = 0; i < this.leaves.length; i++) {
        if (Base.compare(leaf, this.leaves[i]) === 0) {
          index2 = i;
        }
      }
    }
    index2 = index2;
    if (index2 <= -1) {
      return [];
    }
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.layers[i];
      const isRightNode = index2 % 2;
      const pairIndex = isRightNode ? index2 - 1 : index2 + 1;
      if (pairIndex < layer.length) {
        proof.push({
          position: isRightNode ? "left" : "right",
          data: layer[pairIndex]
        });
      }
      index2 = index2 / 2 | 0;
    }
    return proof;
  }
  getHexProof(leaf, index2) {
    return this.getProof(leaf, index2).map((item2) => Base.bufferToHex(item2.data));
  }
  verify(proof, targetNode, root2) {
    let hash2 = Base.bufferify(targetNode);
    root2 = Base.bufferify(root2);
    if (!Array.isArray(proof) || !targetNode || !root2) {
      return false;
    }
    for (let i = 0; i < proof.length; i++) {
      const node = proof[i];
      let data;
      let isLeftNode;
      if (typeof node === "string") {
        data = Base.bufferify(node);
        isLeftNode = true;
      } else if (node instanceof Object) {
        data = node.data;
        isLeftNode = node.position === "left";
      } else {
        throw new Error("Expected node to be of type string or object");
      }
      const buffers = [];
      if (this.sortPairs) {
        if (Base.compare(hash2, data) < 0) {
          buffers.push(hash2, data);
        } else {
          buffers.push(data, hash2);
        }
        hash2 = this.hashFn(concat$1(buffers));
      } else {
        buffers.push(hash2);
        buffers[isLeftNode ? "unshift" : "push"](data);
        hash2 = this.hashFn(concat$1(buffers));
      }
    }
    return Base.compare(hash2, root2) === 0;
  }
}
class MerkleTreeGenerator {
  constructor(elements, toLeaf) {
    this.elements = void 0;
    this.toLeaf = void 0;
    this.tree = void 0;
    this.elements = elements;
    this.toLeaf = toLeaf;
  }
  generateTree() {
    const hashed = this.elements.map((e2) => this.toLeaf(e2));
    return new MerkleTree(hashed, {
      sortPairs: true,
      sortLeaves: true
    });
  }
  generateRoot() {
    if (!this.tree)
      this.tree = this.generateTree();
    return this.tree.getHexRoot();
  }
  generateProof(element) {
    if (!this.elements.includes(element))
      throw new Error("Element not found");
    if (!this.tree)
      this.tree = this.generateTree();
    return this.tree.getHexProof(this.toLeaf(element));
  }
  verifyProof(element, proof) {
    if (!this.elements.includes(element))
      throw new Error("Element not found");
    if (!this.tree)
      this.tree = this.generateTree();
    return this.tree.verify(proof, this.toLeaf(element), this.generateRoot());
  }
}
const getSaleItemsLeaf = (element) => keccak256$1(["address", "uint256"], [element.address.toLowerCase(), element.tokenId]);
const getEthersConnectionInfo = (url, projectAccessKey2, jwt) => {
  const headers = {};
  if (jwt && jwt.length > 0) {
    headers["Authorization"] = `BEARER ${jwt}`;
  }
  if (projectAccessKey2 && projectAccessKey2.length > 0) {
    headers["X-Access-Key"] = projectAccessKey2;
  }
  return {
    url,
    headers,
    skipFetchSetup: true,
    fetchOptions: {
      mode: "cors",
      cache: "force-cache",
      credentials: "same-origin",
      redirect: "follow",
      referrer: "client"
    }
  };
};
let PromiseCache$1 = class PromiseCache {
  constructor() {
    this.cache = void 0;
    this.cache = /* @__PURE__ */ new Map();
  }
  do(key2, validMilliseconds, task, ...args) {
    key2 = `${key2}:${keccak256$2(toUtf8Bytes(JSON.stringify(args, deterministically$1)))}`;
    let entry = this.cache.get(key2);
    if (entry) {
      if (entry.expiration) {
        if (/* @__PURE__ */ new Date() >= entry.expiration) {
          entry = void 0;
          this.cache.delete(key2);
        }
      }
    }
    if (!entry) {
      const entry_ = {
        promise: task(...args)
      };
      if (validMilliseconds !== void 0) {
        entry_.promise = entry_.promise.then((result) => {
          entry_.expiration = new Date(Date.now() + validMilliseconds);
          return result;
        });
      }
      entry = entry_;
      this.cache.set(key2, entry);
    }
    return entry.promise;
  }
};
function deterministically$1(_key, value) {
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    return Object.fromEntries(Object.entries(value).sort());
  }
  return value;
}
function promisify(f2, thisContext) {
  return function(...a2) {
    const args = Array.prototype.slice.call(a2);
    return new Promise(async (resolve, reject) => {
      try {
        args.push((err, result) => err ? reject(err) : resolve(result));
        await f2.apply(thisContext, args);
      } catch (e2) {
        reject(e2);
      }
    });
  };
}
function queryStringFromObject(name2, obj) {
  const k2 = encodeURIComponent(name2);
  const v3 = encodeURIComponent(JSON.stringify(obj));
  return `${k2}=${v3}`;
}
function queryStringToObject(qs) {
  const p2 = qs.split("&");
  const o2 = {};
  for (const v3 of p2) {
    const z = v3.split("=");
    o2[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]));
  }
  return o2;
}
const getRandomInt = (min2 = 0, max2 = Number.MAX_SAFE_INTEGER) => {
  min2 = Math.ceil(min2);
  max2 = Math.floor(max2);
  return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
};
const sanitizeNumberString = (numString) => {
  if (!numString || typeof numString !== "string") {
    return "";
  }
  const v3 = numString.match(/[\d.]+/);
  return v3 && v3.length > 0 ? v3[0].trim() : "";
};
const sanitizeAlphanumeric = (alphanum) => {
  if (!alphanum || typeof alphanum !== "string") {
    return "";
  }
  const v3 = alphanum.match(/[\w\s\d]+/);
  return v3 && v3.length > 0 ? v3[0].trim() : "";
};
const sanitizeHost = (host) => {
  if (!host || typeof host !== "string") {
    return "";
  }
  const v3 = host.match(/[\w\d.\-:\/]+/);
  return v3 && v3.length > 0 ? v3[0].trim() : "";
};
const sleep$1 = (t2) => {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      clearTimeout(timeout);
      resolve();
    }, t2);
  });
};
const encodeTypedDataHash = (typedData) => {
  const types2 = _extends$g({}, typedData.types);
  delete types2["EIP712Domain"];
  return TypedDataEncoder.hash(typedData.domain, types2, typedData.message);
};
const encodeTypedDataDigest = (typedData) => {
  return arrayify(encodeTypedDataHash(typedData));
};
const {
  defineReadOnly,
  getStatic,
  resolveProperties,
  checkProperties,
  shallowCopy,
  deepCopy
} = utils$2;
const urlClean = (url) => url.replace(/([^:]\/)\/+/g, "$1");
const utils$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Logger: Logger2,
  MerkleTreeGenerator,
  PromiseCache: PromiseCache$1,
  base64Decode,
  base64DecodeObject,
  base64Encode,
  base64EncodeObject,
  checkProperties,
  configureLogger,
  deepCopy,
  defineReadOnly,
  encodeMessageDigest,
  encodeTypedDataDigest,
  encodeTypedDataHash,
  getEthersConnectionInfo,
  getRandomInt,
  getSaleItemsLeaf,
  getStatic,
  isBigNumberish,
  isBrowser: isBrowser$1,
  isNode: isNode$2,
  jwtDecodeClaims,
  logger,
  packMessageData,
  promisify,
  queryStringFromObject,
  queryStringToObject,
  resolveProperties,
  sanitizeAlphanumeric,
  sanitizeHost,
  sanitizeNumberString,
  shallowCopy,
  sleep: sleep$1,
  subDigestOf,
  urlClean
}, Symbol.toStringTag, { value: "Module" }));
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
function isNetworkConfig(cand) {
  return cand && cand.chainId !== void 0 && cand.name !== void 0 && cand.rpcUrl !== void 0 && cand.relayer !== void 0;
}
const getChainId$2 = (chainId) => {
  if (typeof chainId === "number") {
    return chainId;
  }
  if (chainId.chainId) {
    return chainId.chainId;
  }
  return BigNumber.from(chainId).toNumber();
};
const maybeChainId = (chainId) => {
  if (!chainId)
    return void 0;
  return getChainId$2(chainId);
};
const isValidNetworkConfig = (networkConfig, raise = false, skipRelayerCheck = false) => {
  if (!networkConfig)
    throw new Error(`invalid network config: empty config`);
  const configs = [];
  if (Array.isArray(networkConfig)) {
    configs.push(...networkConfig);
  } else {
    configs.push(networkConfig);
  }
  if (configs.length === 0) {
    if (raise)
      throw new Error(`invalid network config: empty config`);
    return false;
  }
  const chainIds = configs.map((c2) => c2.chainId).sort();
  const dupes = chainIds.filter((c2, i) => chainIds.indexOf(c2) !== i);
  if (dupes.length > 0) {
    if (raise)
      throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }
  configs.forEach((c2) => c2.name = c2.name.toLowerCase());
  const names2 = configs.map((c2) => c2.name).sort();
  const nameDupes = names2.filter((c2, i) => names2.indexOf(c2) !== i);
  if (nameDupes.length > 0) {
    if (raise)
      throw new Error(`invalid network config: duplicate network names ${nameDupes}`);
    return false;
  }
  let defaultChain = false;
  for (let i = 0; i < configs.length; i++) {
    const c2 = configs[i];
    if ((!c2.rpcUrl || c2.rpcUrl === "") && !c2.provider) {
      if (raise)
        throw new Error(`invalid network config for chainId ${c2.chainId}: rpcUrl or provider must be provided`);
      return false;
    }
    if (!skipRelayerCheck) {
      if (!c2.relayer) {
        if (raise)
          throw new Error(`invalid network config for chainId ${c2.chainId}: relayer must be provided`);
        return false;
      }
    }
    if (c2.isDefaultChain) {
      if (defaultChain) {
        if (raise)
          throw new Error(`invalid network config for chainId ${c2.chainId}: DefaultChain is already set by another config`);
        return false;
      }
      defaultChain = true;
    }
  }
  if (!defaultChain) {
    if (raise)
      throw new Error(`invalid network config: DefaultChain must be set`);
    return false;
  }
  return true;
};
const ensureValidNetworks = (networks2, skipRelayerCheck = false) => {
  isValidNetworkConfig(networks2, true, skipRelayerCheck);
  return networks2;
};
const ensureUniqueNetworks = (networks2, raise = true) => {
  const chainIds = networks2.map((c2) => c2.chainId).sort();
  const dupes = chainIds.filter((c2, i) => chainIds.indexOf(c2) !== i);
  if (dupes.length > 0) {
    if (raise)
      throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }
  return true;
};
const updateNetworkConfig = (src, dest) => {
  if (!src || !dest)
    return;
  if (!src.chainId && !src.name) {
    throw new Error("failed to update network config: source config is missing chainId or name");
  }
  if (src.chainId !== dest.chainId && src.name !== dest.name) {
    throw new Error("failed to update network config: one of chainId or name must match");
  }
  if (src.rpcUrl) {
    dest.rpcUrl = src.rpcUrl;
    dest.provider = void 0;
  }
  if (src.provider) {
    dest.provider = src.provider;
  }
  if (src.relayer) {
    dest.relayer = src.relayer;
  }
};
const validateAndSortNetworks = (networks2) => {
  return ensureValidNetworks(sortNetworks(networks2));
};
const findNetworkConfig = (networks2, chainId) => {
  if (typeof chainId === "string") {
    if (chainId.startsWith("0x")) {
      const id2 = BigNumber.from(chainId).toNumber();
      return networks2.find((n2) => n2.chainId === id2);
    } else {
      return networks2.find((n2) => n2.name === chainId || `${n2.chainId}` === chainId);
    }
  } else if (typeof chainId === "number") {
    return networks2.find((n2) => n2.chainId === chainId);
  } else if (chainId.chainId) {
    return networks2.find((n2) => n2.chainId === chainId.chainId);
  } else if (BigNumber.isBigNumber(chainId)) {
    const id2 = chainId.toNumber();
    return networks2.find((n2) => n2.chainId === id2);
  } else {
    return void 0;
  }
};
const checkNetworkConfig = (network2, chainId) => {
  if (!network2)
    return false;
  if (network2.name === chainId)
    return true;
  if (network2.chainId === chainId)
    return true;
  return false;
};
const networksIndex = (networks2) => {
  const index2 = {};
  for (let i = 0; i < networks2.length; i++) {
    index2[networks2[i].name] = networks2[i];
  }
  return index2;
};
const sortNetworks = (networks2) => {
  if (!networks2) {
    return [];
  }
  const config2 = networks2.sort((a2, b2) => {
    if (a2.chainId === b2.chainId)
      return 0;
    return a2.chainId < b2.chainId ? -1 : 1;
  });
  const defaultConfigIdx = config2.findIndex((c2) => c2.isDefaultChain);
  if (defaultConfigIdx > 0)
    config2.splice(0, 0, config2.splice(defaultConfigIdx, 1)[0]);
  return config2;
};
const stringTemplate = (sTemplate, mData) => {
  if (typeof sTemplate === "string") {
    mData = mData ? mData : {};
    return sTemplate.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function(fullMath, grp) {
      let val = mData[grp];
      if (typeof val === "function") {
        val = val();
      } else if (val === null || val === void 0) {
        val = "";
      } else if (typeof val === "object" || typeof val === "symbol") {
        val = val.toString();
      } else {
        val = val.valueOf();
      }
      return val;
    });
  }
  return "";
};
const indexerURL = (network2) => stringTemplate("https://${network}-indexer.sequence.app", {
  network: network2
});
const relayerURL = (network2) => stringTemplate("https://${network}-relayer.sequence.app", {
  network: network2
});
const nodesURL = (network2) => stringTemplate("https://nodes.sequence.app/${network}", {
  network: network2
});
function findSupportedNetwork(chainIdOrName) {
  return findNetworkConfig(allNetworks, chainIdOrName);
}
function toChainIdNumber(chainIdLike) {
  if (BigNumber.isBigNumber(chainIdLike)) {
    return chainIdLike;
  }
  if (isBigNumberish(chainIdLike)) {
    return BigNumber.from(chainIdLike);
  }
  return BigNumber.from(chainIdLike.chainId);
}
const createNetworkConfig = (chainId, options) => {
  const network2 = networks[chainId];
  if (!network2) {
    throw new Error(`Network with chainId ${chainId} not found`);
  }
  const rpcUrl = nodesURL(network2.name);
  return _extends$f({}, network2, {
    rpcUrl,
    indexerUrl: indexerURL(network2.name),
    relayer: {
      url: relayerURL(network2.name),
      provider: {
        url: rpcUrl
      }
    }
  }, options);
};
const hardhatNetworks = [_extends$f({}, networks[ChainId.HARDHAT], {
  rpcUrl: "http://localhost:8545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:8545"
    }
  }
}), _extends$f({}, networks[ChainId.HARDHAT_2], {
  rpcUrl: "http://localhost:9545",
  relayer: {
    url: "http://localhost:3000",
    provider: {
      url: "http://localhost:9545"
    }
  }
})];
const allNetworks = validateAndSortNetworks([_extends$f({}, createNetworkConfig(ChainId.POLYGON), {
  isDefaultChain: true,
  isAuthChain: true
}), createNetworkConfig(ChainId.MAINNET), createNetworkConfig(ChainId.BSC), createNetworkConfig(ChainId.AVALANCHE), createNetworkConfig(ChainId.ARBITRUM), createNetworkConfig(ChainId.ARBITRUM_NOVA), createNetworkConfig(ChainId.OPTIMISM), createNetworkConfig(ChainId.OPTIMISM_SEPOLIA), createNetworkConfig(ChainId.POLYGON_ZKEVM), createNetworkConfig(ChainId.GNOSIS), createNetworkConfig(ChainId.RINKEBY, {
  disabled: true
}), createNetworkConfig(ChainId.GOERLI, {
  disabled: true
}), createNetworkConfig(ChainId.SEPOLIA), createNetworkConfig(ChainId.POLYGON_MUMBAI, {
  disabled: true
}), createNetworkConfig(ChainId.POLYGON_AMOY), createNetworkConfig(ChainId.BSC_TESTNET), createNetworkConfig(ChainId.ARBITRUM_SEPOLIA), createNetworkConfig(ChainId.BASE), createNetworkConfig(ChainId.BASE_SEPOLIA), createNetworkConfig(ChainId.HOMEVERSE), createNetworkConfig(ChainId.HOMEVERSE_TESTNET), createNetworkConfig(ChainId.XAI), createNetworkConfig(ChainId.XAI_SEPOLIA), createNetworkConfig(ChainId.AVALANCHE_TESTNET), createNetworkConfig(ChainId.ASTAR_ZKEVM), createNetworkConfig(ChainId.ASTAR_ZKYOTO), createNetworkConfig(ChainId.XR_SEPOLIA), createNetworkConfig(ChainId.B3_SEPOLIA), createNetworkConfig(ChainId.APECHAIN_TESTNET), createNetworkConfig(ChainId.BLAST), createNetworkConfig(ChainId.BLAST_SEPOLIA), createNetworkConfig(ChainId.TELOS), ...hardhatNetworks]);
const JsonRpcVersion = "2.0";
class JsonRpcRouter {
  constructor(middlewares, sender) {
    this.sender = void 0;
    this.handler = void 0;
    this.sender = sender;
    if (middlewares) {
      this.setMiddleware(middlewares);
    }
  }
  setMiddleware(middlewares) {
    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender.sendAsync);
  }
  sendAsync(request, callback, chainId) {
    try {
      this.handler(request, callback, chainId);
    } catch (err) {
      callback(err, void 0);
    }
  }
}
const createJsonRpcMiddlewareStack = (middlewares, handler) => {
  if (middlewares.length === 0)
    return handler;
  const toMiddleware = (v3) => {
    if (v3.sendAsyncMiddleware) {
      return v3.sendAsyncMiddleware;
    } else {
      return v3;
    }
  };
  let chain;
  chain = toMiddleware(middlewares[middlewares.length - 1])(handler);
  for (let i = middlewares.length - 2; i >= 0; i--) {
    chain = toMiddleware(middlewares[i])(chain);
  }
  return chain;
};
function isJsonRpcProvider(cand) {
  return cand !== void 0 && cand.send !== void 0 && cand.constructor.defaultUrl !== void 0 && cand.detectNetwork !== void 0 && cand.getSigner !== void 0 && cand.perform !== void 0;
}
function isJsonRpcHandler(cand) {
  return cand !== void 0 && cand.sendAsync !== void 0;
}
let _nextId = 0;
class JsonRpcSender {
  constructor(provider2, defaultChainId) {
    this.send = void 0;
    this.request = void 0;
    this.defaultChainId = void 0;
    this.sendAsync = (request, callback, chainId) => {
      this.send(request.method, request.params, chainId || this.defaultChainId).then((r2) => {
        callback(void 0, {
          jsonrpc: "2.0",
          id: request.id,
          result: r2
        });
      }).catch((e2) => {
        callback(e2, void 0);
      });
    };
    this.defaultChainId = defaultChainId;
    if (isJsonRpcProvider(provider2)) {
      this.send = provider2.send.bind(provider2);
    } else if (isJsonRpcHandler(provider2)) {
      this.send = (method, params, chainId) => {
        return new Promise((resolve, reject) => {
          provider2.sendAsync({
            // TODO: really shouldn't have to set these here?
            jsonrpc: JsonRpcVersion,
            id: ++_nextId,
            method,
            params
          }, (error, response) => {
            if (error) {
              reject(error);
            } else if (response) {
              resolve(response.result);
            } else {
              resolve(void 0);
            }
          }, chainId || this.defaultChainId);
        });
      };
    } else {
      this.send = provider2;
    }
    this.request = (request, chainId) => {
      return this.send(request.method, request.params, chainId);
    };
  }
}
class JsonRpcExternalProvider {
  constructor(provider2) {
    this.provider = provider2;
    this.sendAsync = (request, callback) => {
      this.provider.send(request.method, request.params).then((r2) => {
        callback(void 0, {
          jsonrpc: "2.0",
          id: request.id,
          result: r2
        });
      }).catch((e2) => {
        callback(e2, void 0);
      });
    };
    this.send = this.sendAsync;
  }
}
class AllowProvider {
  constructor(isAllowedFunc) {
    this.sendAsyncMiddleware = void 0;
    this.isAllowedFunc = void 0;
    if (isAllowedFunc) {
      this.isAllowedFunc = isAllowedFunc;
    } else {
      this.isAllowedFunc = (request) => true;
    }
    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
  }
  setIsAllowedFunc(fn) {
    this.isAllowedFunc = fn;
    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
  }
}
const allowProviderMiddleware = (isAllowed) => (next) => {
  return (request, callback, chainId) => {
    if (!isAllowed(request)) {
      throw new Error("allowProvider middleware precondition is unmet.");
    }
    next(request, callback, chainId);
  };
};
class CachedProvider {
  constructor(options) {
    this.cachableJsonRpcMethods = ["net_version", "eth_chainId", "eth_accounts", "sequence_getWalletContext", "sequence_getNetworks"];
    this.cachableJsonRpcMethodsByBlock = ["eth_call", "eth_getCode"];
    this.cache = void 0;
    this.cacheByBlock = void 0;
    this.cacheByBlockResetLock = false;
    this.onUpdateCallback = void 0;
    this.defaultChainId = void 0;
    this.sendAsyncMiddleware = (next) => {
      return (request, callback, chainId) => {
        if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
          const key2 = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);
          const result = this.getCacheValue(key2);
          if (result && result !== "") {
            callback(void 0, {
              jsonrpc: "2.0",
              id: request.id,
              result
            });
            return;
          }
        }
        next(request, (error, response, chainId2) => {
          if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
            if (response && response.result && this.shouldCacheResponse(request, response)) {
              const key2 = this.cacheKey(request.method, request.params, chainId2 || this.defaultChainId);
              if (this.cachableJsonRpcMethods.includes(request.method)) {
                this.setCacheValue(key2, response.result);
              } else {
                this.setCacheByBlockValue(key2, response.result);
              }
            }
          }
          callback(error, response);
        }, chainId || this.defaultChainId);
      };
    };
    this.cacheKey = (method, params, chainId) => {
      let key2 = "";
      if (chainId) {
        key2 = `${chainId}:${method}:`;
      } else {
        key2 = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key2 + "[]";
      }
      return key2 + JSON.stringify(params);
    };
    this.getCache = () => this.cache;
    this.setCache = (cache) => {
      this.cache = cache;
      if (this.onUpdateCallback) {
        this.onUpdateCallback();
      }
    };
    this.getCacheValue = (key2) => {
      if (this.cache[key2]) {
        return this.cache[key2];
      }
      if (this.cacheByBlock[key2]) {
        return this.cacheByBlock[key2];
      }
      return void 0;
    };
    this.setCacheValue = (key2, value) => {
      this.cache[key2] = value;
      if (this.onUpdateCallback) {
        this.onUpdateCallback(key2, value);
      }
    };
    this.setCacheByBlockValue = (key2, value) => {
      this.cacheByBlock[key2] = value;
      if (!this.cacheByBlockResetLock) {
        this.cacheByBlockResetLock = true;
        setTimeout(() => {
          this.cacheByBlockResetLock = false;
          this.cacheByBlock = {};
        }, 1500);
      }
    };
    this.shouldCacheResponse = (request, response) => {
      if (!response || !response.result) {
        return false;
      }
      if (request.method === "eth_getCode" && response.result.length <= 2) {
        return false;
      }
      return true;
    };
    this.clearCache = () => {
      this.cache = {};
      this.cacheByBlock = {};
    };
    this.cache = {};
    this.cacheByBlock = {};
    this.defaultChainId = options == null ? void 0 : options.defaultChainId;
    if (!(options != null && options.blockCache)) {
      this.cachableJsonRpcMethodsByBlock = [];
    } else if ((options == null ? void 0 : options.blockCache) !== true) {
      this.cachableJsonRpcMethodsByBlock = options == null ? void 0 : options.blockCache;
    }
  }
  onUpdate(callback) {
    this.onUpdateCallback = callback;
  }
}
class EagerProvider {
  constructor(options) {
    this.options = void 0;
    this.sendAsyncMiddleware = (next) => {
      return (request, callback, chainId) => {
        const {
          id: id2,
          method
        } = request;
        switch (method) {
          case "net_version":
            if (this.options.chainId) {
              callback(void 0, {
                jsonrpc: "2.0",
                id: id2,
                result: `${this.options.chainId}`
              });
              return;
            }
            break;
          case "eth_chainId":
            if (this.options.chainId) {
              callback(void 0, {
                jsonrpc: "2.0",
                id: id2,
                result: hexlify(this.options.chainId)
              });
              return;
            }
            break;
          case "eth_accounts":
            if (this.options.accountAddress) {
              callback(void 0, {
                jsonrpc: "2.0",
                id: id2,
                result: [getAddress$1(this.options.accountAddress)]
              });
              return;
            }
            break;
          case "sequence_getWalletContext":
            if (this.options.walletContext) {
              callback(void 0, {
                jsonrpc: "2.0",
                id: id2,
                result: this.options.walletContext
              });
              return;
            }
            break;
        }
        next(request, callback, chainId);
      };
    };
    this.options = options;
  }
}
const exceptionProviderMiddleware = (next) => {
  return (request, callback, chainId) => {
    next(request, (error, response) => {
      if (!error && response && response.error) {
        if (typeof response.error === "string") {
          throw new Error(response.error);
        } else {
          throw new Error(response.error.message);
        }
      }
      callback(error, response);
    }, chainId);
  };
};
const loggingProviderMiddleware = (next) => {
  return (request, callback, chainId) => {
    const chainIdLabel = chainId ? ` chainId:${chainId}` : "";
    logger.info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params);
    next(request, (error, response) => {
      if (error) {
        logger.warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error);
      } else {
        logger.info(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `response:`, response);
      }
      callback(error, response);
    }, chainId);
  };
};
const networkProviderMiddleware = (getChainId2) => (next) => {
  return (request, callback, chainId) => {
    const networkChainId = getChainId2(request);
    const {
      id: id2,
      method
    } = request;
    switch (method) {
      case "net_version":
        callback(void 0, {
          jsonrpc: "2.0",
          id: id2,
          result: `${networkChainId}`
        });
        return;
      case "eth_chainId":
        callback(void 0, {
          jsonrpc: "2.0",
          id: id2,
          result: hexlify(networkChainId)
        });
        return;
    }
    next(request, callback, chainId);
  };
};
const SignerJsonRpcMethods = [
  "personal_sign",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "eth_sendRawTransaction",
  "sequence_sign",
  // sequence-aware personal_sign
  "sequence_signTypedData_v4",
  // sequence-aware eth_signTypedData_v4
  "sequence_getWalletContext",
  "sequence_getWalletConfig",
  "sequence_getWalletState",
  "sequence_getNetworks",
  "sequence_updateConfig",
  "sequence_publishConfig",
  "sequence_gasRefundOptions",
  "sequence_getNonce",
  "sequence_relay",
  "eth_decrypt",
  "eth_getEncryptionPublicKey",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
class SigningProvider {
  constructor(provider2) {
    this.provider = void 0;
    this.sendAsyncMiddleware = (next) => {
      return (request, callback, chainId) => {
        if (SignerJsonRpcMethods.includes(request.method)) {
          this.provider.sendAsync(request, callback, chainId);
          return;
        }
        next(request, callback, chainId);
      };
    };
    this.provider = provider2;
  }
}
class PublicProvider {
  constructor(rpcUrl) {
    this.privateJsonRpcMethods = ["net_version", "eth_chainId", "eth_accounts", ...SignerJsonRpcMethods];
    this.provider = void 0;
    this.rpcUrl = void 0;
    this.sendAsyncMiddleware = (next) => {
      return (request, callback) => {
        if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {
          this.provider.send(request.method, request.params).then((r2) => {
            callback(void 0, {
              jsonrpc: "2.0",
              id: request.id,
              result: r2
            });
          }).catch((e2) => callback(e2));
          return;
        }
        logger.debug("[public-provider] sending request to signer window", request.method);
        next(request, callback);
      };
    };
    if (rpcUrl) {
      this.setRpcUrl(rpcUrl);
    }
  }
  getRpcUrl() {
    return this.rpcUrl;
  }
  setRpcUrl(rpcUrl) {
    if (!rpcUrl || rpcUrl === "") {
      this.rpcUrl = void 0;
      this.provider = void 0;
    } else {
      this.rpcUrl = rpcUrl;
      this.provider = new JsonRpcProvider$1(rpcUrl);
    }
  }
}
class SingleflightMiddleware {
  constructor() {
    this.singleflightJsonRpcMethods = ["eth_chainId", "net_version", "eth_call", "eth_getCode", "eth_blockNumber", "eth_getBalance", "eth_getStorageAt", "eth_getTransactionCount", "eth_getBlockTransactionCountByHash", "eth_getBlockTransactionCountByNumber", "eth_getUncleCountByBlockHash", "eth_getUncleCountByBlockNumber", "eth_getBlockByHash", "eth_getBlockByNumber", "eth_getTransactionByHash", "eth_getTransactionByBlockHashAndIndex", "eth_getTransactionByBlockNumberAndIndex", "eth_getTransactionReceipt", "eth_getUncleByBlockHashAndIndex", "eth_getUncleByBlockNumberAndIndex", "eth_getLogs"];
    this.inflight = void 0;
    this.sendAsyncMiddleware = (next) => {
      return (request, callback, chainId) => {
        if (!this.singleflightJsonRpcMethods.includes(request.method)) {
          next(request, callback, chainId);
          return;
        }
        const key2 = this.requestKey(request.method, request.params || [], chainId);
        if (!this.inflight[key2]) {
          this.inflight[key2] = [];
        } else {
          this.inflight[key2].push({
            id: request.id,
            callback
          });
          return;
        }
        next(request, (error, response, chainId2) => {
          callback(error, response);
          for (let i = 0; i < this.inflight[key2].length; i++) {
            const sub = this.inflight[key2][i];
            if (error) {
              sub.callback(error, response);
            } else if (response) {
              sub.callback(void 0, {
                jsonrpc: "2.0",
                id: sub.id,
                result: response.result
              });
            }
          }
          delete this.inflight[key2];
        }, chainId);
      };
    };
    this.requestKey = (method, params, chainId) => {
      let key2 = "";
      if (chainId) {
        key2 = `${chainId}:${method}:`;
      } else {
        key2 = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key2 + "[]";
      }
      return key2 + JSON.stringify(params);
    };
    this.inflight = {};
  }
}
class JsonRpcProvider2 extends JsonRpcProvider$1 {
  constructor(url, options) {
    super(url, options == null ? void 0 : options.chainId);
    this._chainId = void 0;
    this._sender = void 0;
    this.send = (method, params) => {
      return this._sender.send(method, params);
    };
    this.fetch = (method, params) => {
      const request = {
        method,
        params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
        return result2;
      }, (error) => {
        throw error;
      });
      return result;
    };
    const chainId = options == null ? void 0 : options.chainId;
    const middlewares = options == null ? void 0 : options.middlewares;
    const blockCache = options == null ? void 0 : options.blockCache;
    this._chainId = chainId;
    const router = new JsonRpcRouter(middlewares != null ? middlewares : [
      // loggingProviderMiddleware,
      new EagerProvider({
        chainId
      }),
      new SingleflightMiddleware(),
      new CachedProvider({
        defaultChainId: chainId,
        blockCache
      })
    ], new JsonRpcSender(this.fetch, chainId));
    this._sender = new JsonRpcSender(router, chainId);
  }
  async getNetwork() {
    const chainId = this._chainId;
    if (chainId) {
      const network2 = networks[chainId];
      const name2 = (network2 == null ? void 0 : network2.name) || "";
      const ensAddress = network2 == null ? void 0 : network2.ensAddress;
      return {
        name: name2,
        chainId,
        ensAddress
      };
    } else {
      const chainIdHex = await this.send("eth_chainId", []);
      this._chainId = BigNumber.from(chainIdHex).toNumber();
      return this.getNetwork();
    }
  }
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
const network$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AllowProvider,
  CachedProvider,
  ChainId,
  EagerProvider,
  JsonRpcExternalProvider,
  JsonRpcProvider: JsonRpcProvider2,
  JsonRpcRouter,
  JsonRpcSender,
  JsonRpcVersion,
  NetworkType,
  PublicProvider,
  SigningProvider,
  SingleflightMiddleware,
  allNetworks,
  allowProviderMiddleware,
  checkNetworkConfig,
  createJsonRpcMiddlewareStack,
  ensureUniqueNetworks,
  ensureValidNetworks,
  exceptionProviderMiddleware,
  findNetworkConfig,
  findSupportedNetwork,
  getChainId: getChainId$2,
  hardhatNetworks,
  indexerURL,
  isJsonRpcHandler,
  isJsonRpcProvider,
  isNetworkConfig,
  isValidNetworkConfig,
  loggingProviderMiddleware,
  maybeChainId,
  networkProviderMiddleware,
  networks,
  networksIndex,
  nodesURL,
  relayerURL,
  sortNetworks,
  stringTemplate,
  toChainIdNumber,
  updateNetworkConfig,
  validateAndSortNetworks
}, Symbol.toStringTag, { value: "Module" }));
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
var config$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
function subdigestOf(payload) {
  return keccak256$1(["bytes", "uint256", "address", "bytes32"], ["0x1901", payload.chainId, payload.address, payload.digest]);
}
function isSignedPayload(payload) {
  return payload.digest !== void 0 && payload.chainId !== void 0 && payload.address !== void 0;
}
var signature$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  subdigestOf,
  isSignedPayload
});
const EIP1271_MAGIC_VALUE = "0x1626ba7e";
const EIP1271_ABI = [{
  inputs: [{
    internalType: "bytes32",
    type: "bytes32"
  }, {
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSignature",
  outputs: [{
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view",
  type: "function"
}];
async function isValidEIP1271Signature(address, digest9, signature2, provider2) {
  const contract = new Contract(address, EIP1271_ABI, provider2);
  const result = await contract.isValidSignature(digest9, signature2);
  return result === EIP1271_MAGIC_VALUE;
}
var validateEIP1271 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isValidEIP1271Signature
});
let SigType = /* @__PURE__ */ function(SigType2) {
  SigType2[SigType2["EIP712"] = 1] = "EIP712";
  SigType2[SigType2["ETH_SIGN"] = 2] = "ETH_SIGN";
  SigType2[SigType2["WALLET_BYTES32"] = 3] = "WALLET_BYTES32";
  return SigType2;
}({});
function canRecover(signature2) {
  const bytes3 = arrayify(signature2);
  const type = bytes3[bytes3.length - 1];
  return type === SigType.EIP712 || type === SigType.ETH_SIGN;
}
function recoverSigner(digest9, signature2) {
  const bytes3 = arrayify(signature2);
  const digestBytes = arrayify(digest9);
  const type = bytes3[bytes3.length - 1];
  const r2 = hexlify(bytes3.slice(0, 32));
  const s2 = hexlify(bytes3.slice(32, 64));
  const v3 = BigNumber.from(bytes3.slice(64, 65)).toNumber();
  const splitSignature2 = {
    r: r2,
    s: s2,
    v: v3
  };
  if (type === SigType.EIP712) {
    return recoverAddress(digestBytes, splitSignature2);
  }
  if (type === SigType.ETH_SIGN) {
    return recoverAddress(hashMessage$1(digestBytes), splitSignature2);
  }
  throw new Error(`Unsupported signature type: ${type}`);
}
function isValidSignature$1(address, digest9, signature2, provider2) {
  const bytes3 = arrayify(signature2);
  const type = bytes3[bytes3.length - 1];
  if (type === SigType.EIP712 || type === SigType.ETH_SIGN) {
    return address === recoverSigner(digest9, signature2);
  }
  if (type === SigType.WALLET_BYTES32) {
    return isValidEIP1271Signature(address, hexlify(digest9), bytes3.slice(0, -1), provider2);
  }
  throw new Error(`Unsupported signature type: ${type}`);
}
function tryRecoverSigner(digest9, signature2) {
  const bytes3 = arrayify(signature2);
  if (bytes3.length !== 66)
    return void 0;
  try {
    return recoverSigner(digest9, bytes3);
  } catch (_unused) {
  }
  return void 0;
}
var signer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SigType,
  canRecover,
  recoverSigner,
  isValidSignature: isValidSignature$1,
  tryRecoverSigner
});
let SignaturePartType$1 = /* @__PURE__ */ function(SignaturePartType2) {
  SignaturePartType2[SignaturePartType2["EOASignature"] = 0] = "EOASignature";
  SignaturePartType2[SignaturePartType2["Address"] = 1] = "Address";
  SignaturePartType2[SignaturePartType2["DynamicSignature"] = 2] = "DynamicSignature";
  return SignaturePartType2;
}({});
function isAddressMember(member) {
  return member.address !== void 0 && !isUnrecoveredSignatureMember(member);
}
function isUnrecoveredSignatureMember(member) {
  return member.signature !== void 0 && member.weight !== void 0 && member.isDynamic !== void 0;
}
function isUnrecoveredSignature$1(signature2) {
  return signature2.threshold !== void 0 && signature2.signers !== void 0;
}
function decodeSignature$1(signature2) {
  const bytes3 = arrayify(signature2);
  const threshold = bytes3[0] << 8 | bytes3[1];
  const signers = [];
  for (let i = 2; i < bytes3.length; ) {
    const type = bytes3[i++];
    const weight = bytes3[i++];
    switch (type) {
      case SignaturePartType$1.EOASignature:
        signers.push({
          unrecovered: true,
          weight,
          signature: hexlify(bytes3.slice(i, i + 66)),
          isDynamic: false
        });
        i += 66;
        break;
      case SignaturePartType$1.Address:
        signers.push({
          weight,
          address: getAddress$1(hexlify(bytes3.slice(i, i + 20)))
        });
        i += 20;
        break;
      case SignaturePartType$1.DynamicSignature:
        const address = getAddress$1(hexlify(bytes3.slice(i, i + 20)));
        i += 20;
        const size2 = bytes3[i] << 8 | bytes3[i + 1];
        i += 2;
        signers.push({
          unrecovered: true,
          weight,
          signature: hexlify(bytes3.slice(i, i + size2)),
          address,
          isDynamic: true
        });
        i += size2;
        break;
      default:
        throw new Error(`Unknown signature part type: ${type}`);
    }
  }
  return {
    version: 1,
    threshold,
    signers
  };
}
function encodeSignature$1(signature2) {
  if (isBytesLike(signature2))
    return hexlify(signature2);
  const {
    signers,
    threshold
  } = isUnrecoveredSignature$1(signature2) ? signature2 : signature2.config;
  const encodedSigners = signers.map((s2) => {
    if (isAddressMember(s2)) {
      return pack(["uint8", "uint8", "address"], [SignaturePartType$1.Address, s2.weight, s2.address]);
    }
    if (s2.isDynamic) {
      const bytes3 = arrayify(s2.signature);
      return pack(["uint8", "uint8", "address", "uint16", "bytes"], [SignaturePartType$1.DynamicSignature, s2.weight, s2.address, bytes3.length, bytes3]);
    }
    return pack(["uint8", "uint8", "bytes"], [SignaturePartType$1.EOASignature, s2.weight, s2.signature]);
  });
  return pack(["uint16", ...new Array(encodedSigners.length).fill("bytes")], [threshold, ...encodedSigners]);
}
async function recoverSignature$1(data, payload, provider2) {
  const subdigest = subdigestOf(payload);
  const signers = await Promise.all(data.signers.map(async (s2) => {
    if (isAddressMember(s2)) {
      return s2;
    }
    if (s2.isDynamic) {
      if (!s2.address)
        throw new Error("Dynamic signature part must have address");
      if (!isValidSignature$1(s2.address, subdigest, s2.signature, provider2)) {
        throw new Error(`Invalid dynamic signature part ${s2.address}`);
      }
      return {
        address: s2.address,
        weight: s2.weight,
        signature: s2.signature
      };
    } else {
      const address = recoverSigner(subdigest, s2.signature);
      return {
        address,
        weight: s2.weight,
        signature: s2.signature
      };
    }
  }));
  return {
    version: 1,
    payload,
    subdigest,
    config: {
      version: 1,
      threshold: data.threshold,
      signers
    }
  };
}
function encodeSigners$1(config2, signatures, subdigests, _) {
  if (subdigests.length !== 0) {
    throw new Error("Explicit subdigests not supported on v1");
  }
  let weight = BigNumber.from(0);
  const parts = config2.signers.map((s2) => {
    if (!signatures.has(s2.address)) {
      return s2;
    }
    const signature2 = signatures.get(s2.address);
    const bytes3 = arrayify(signature2.signature);
    weight = weight.add(s2.weight);
    if (signature2.isDynamic || bytes3.length !== 66) {
      return _extends$e({}, s2, {
        isDynamic: true,
        signature: signature2.signature,
        address: s2.address
      });
    }
    return _extends$e({}, s2, {
      isDynamic: false,
      signature: signature2.signature
    });
  });
  const encoded = encodeSignature$1({
    version: 1,
    threshold: config2.threshold,
    signers: parts
  });
  return {
    encoded,
    weight
  };
}
const SignatureCoder$1 = {
  decode: (data) => {
    return decodeSignature$1(data);
  },
  encode: (data) => {
    return encodeSignature$1(data);
  },
  trim: async (data) => {
    return data;
  },
  supportsNoChainId: true,
  recover: (data, payload, provider2) => {
    return recoverSignature$1(data, payload, provider2);
  },
  encodeSigners: (config2, signatures, subdigests, chainId) => {
    return encodeSigners$1(config2, signatures, subdigests);
  },
  hasEnoughSigningPower: (config2, signatures) => {
    const {
      weight
    } = SignatureCoder$1.encodeSigners(config2, signatures, [], 0);
    return weight.gte(config2.threshold);
  },
  chainSignatures: (_main, _suffix) => {
    throw new Error("Signature chaining not supported on v1");
  },
  hashSetImageHash: function(_imageHash) {
    throw new Error("Image hash not supported on v1");
  },
  signaturesOf(config2) {
    return config2.signers.filter((s2) => s2.signature !== void 0).map((s2) => ({
      address: s2.address,
      signature: s2.signature
    }));
  },
  signaturesOfDecoded: function(data) {
    return data.signers.map((s2) => s2.signature).filter((s2) => s2 !== void 0);
  }
};
var signature$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignaturePartType: SignaturePartType$1,
  isAddressMember,
  isUnrecoveredSignatureMember,
  isUnrecoveredSignature: isUnrecoveredSignature$1,
  decodeSignature: decodeSignature$1,
  encodeSignature: encodeSignature$1,
  recoverSignature: recoverSignature$1,
  encodeSigners: encodeSigners$1,
  SignatureCoder: SignatureCoder$1
});
const ConfigCoder$1 = {
  isWalletConfig: (config2) => {
    return config2.version === 1 && config2.threshold !== void 0 && config2.signers !== void 0;
  },
  imageHashOf: (config2) => {
    return config2.signers.reduce((imageHash2, signer2) => keccak256$2(defaultAbiCoder.encode(["bytes32", "uint8", "address"], [imageHash2, signer2.weight, signer2.address])), pack(["uint256"], [config2.threshold]));
  },
  hasSubdigest: (_walletConfig, _subdigest) => {
    return false;
  },
  isComplete: (_config) => {
    return true;
  },
  checkpointOf: (_config) => {
    return BigNumber.from(0);
  },
  signersOf: (config2) => {
    return config2.signers.map((s2) => ({
      address: s2.address,
      weight: BigNumber.from(s2.weight).toNumber()
    }));
  },
  fromSimple: (config2) => {
    if (!Zero$1.eq(config2.checkpoint)) {
      throw new Error("v1 wallet config does not support checkpoint");
    }
    if (config2.subdigests && config2.subdigests.length > 0) {
      throw new Error("v1 wallet config does not support subdigests");
    }
    return {
      version: 1,
      threshold: config2.threshold,
      signers: config2.signers
    };
  },
  update: {
    isKindUsed: true,
    buildTransaction: (wallet, config2, context2, kind) => {
      const module2 = new Interface([...walletContracts.mainModule.abi, ...walletContracts.mainModuleUpgradable.abi]);
      const transactions2 = [];
      if (!kind || kind === "first") {
        transactions2.push({
          to: wallet,
          data: module2.encodeFunctionData(module2.getFunction("updateImplementation"), [context2.mainModuleUpgradable]),
          gasLimit: 0,
          delegateCall: false,
          revertOnError: true,
          value: 0
        });
      }
      transactions2.push({
        to: wallet,
        data: module2.encodeFunctionData(module2.getFunction("updateImageHash"), [ConfigCoder$1.imageHashOf(config2)]),
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true,
        value: 0
      });
      return {
        entrypoint: wallet,
        transactions: transactions2
      };
    },
    decodeTransaction: function(tx) {
      throw new Error("Function not implemented.");
    }
  },
  toJSON: function(config2) {
    const plainMembers = config2.signers.map((signer2) => {
      return {
        weight: BigNumber.from(signer2.weight).toString(),
        address: signer2.address
      };
    });
    return JSON.stringify({
      version: config2.version,
      threshold: BigNumber.from(config2.threshold).toString(),
      signers: plainMembers
    });
  },
  fromJSON: function(json) {
    const parsed = JSON.parse(json);
    const signers = parsed.signers.map((signer2) => {
      return {
        weight: BigNumber.from(signer2.weight),
        address: signer2.address
      };
    });
    return {
      version: parsed.version,
      threshold: BigNumber.from(parsed.threshold),
      signers
    };
  },
  editConfig: function(config2, action) {
    var _action$threshold;
    const newSigners = config2.signers.slice();
    if (action.checkpoint && !Zero$1.eq(action.checkpoint)) {
      throw new Error("v1 wallet config does not support checkpoint");
    }
    if (action.add) {
      for (const signer2 of action.add) {
        if (newSigners.find((s2) => s2.address === signer2.address)) {
          continue;
        }
        newSigners.push({
          weight: signer2.weight,
          address: signer2.address
        });
      }
    }
    if (action.remove) {
      for (const address of action.remove) {
        const index2 = newSigners.findIndex((signer2) => signer2.address === address);
        if (index2 >= 0) {
          newSigners.splice(index2, 1);
        }
      }
    }
    return {
      version: config2.version,
      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config2.threshold,
      signers: newSigners
    };
  },
  buildStubSignature: function(config2, overrides) {
    const parts = /* @__PURE__ */ new Map();
    for (const [signer2, signature2] of overrides.entries()) {
      parts.set(signer2, {
        signature: signature2,
        isDynamic: true
      });
      const {
        encoded,
        weight
      } = encodeSigners$1(config2, parts, []);
      if (weight.gte(config2.threshold)) {
        return encoded;
      }
    }
    const signers = config2.signers;
    for (const {
      address
    } of signers.sort(({
      weight: a2
    }, {
      weight: b2
    }) => BigNumber.from(a2).sub(b2).toNumber())) {
      const signature2 = "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02";
      parts.set(address, {
        signature: signature2,
        isDynamic: false
      });
      const {
        encoded,
        weight
      } = encodeSigners$1(config2, parts, []);
      if (weight.gte(config2.threshold)) {
        return encoded;
      }
    }
    return encodeSigners$1(config2, parts, []).encoded;
  }
};
var config$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ConfigCoder: ConfigCoder$1
});
const version$1$1 = 1;
const DeployedWalletContext$1 = {
  version: version$1$1,
  factory: "0xf9D09D634Fb818b05149329C1dcCFAeA53639d96",
  guestModule: "0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7",
  mainModule: "0xd01F11855bCcb95f88D7A48492F66410d4637313",
  mainModuleUpgradable: "0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var v1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: config$1,
  signature: signature$1,
  version: version$1$1,
  DeployedWalletContext: DeployedWalletContext$1
});
const SetImageHashPrefix = "0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1";
function hashSetImageHash(imageHash2) {
  return keccak256$2(messageSetImageHash(imageHash2));
}
function messageSetImageHash(imageHash2) {
  return pack(["bytes32", "bytes32"], [SetImageHashPrefix, imageHash2]);
}
function decodeMessageSetImageHash(message) {
  const arr = arrayify(message);
  if (arr.length !== 64)
    return void 0;
  if (hexlify(arr.slice(0, 32)) !== SetImageHashPrefix)
    return void 0;
  return hexlify(arr.slice(32, 64));
}
function isMessageSetImageHash(message) {
  return decodeMessageSetImageHash(message) !== void 0;
}
var chained = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SetImageHashPrefix,
  hashSetImageHash,
  messageSetImageHash,
  decodeMessageSetImageHash,
  isMessageSetImageHash
});
let SignatureType$1 = /* @__PURE__ */ function(SignatureType2) {
  SignatureType2[SignatureType2["Legacy"] = 0] = "Legacy";
  SignatureType2[SignatureType2["Dynamic"] = 1] = "Dynamic";
  SignatureType2[SignatureType2["NoChainIdDynamic"] = 2] = "NoChainIdDynamic";
  SignatureType2[SignatureType2["Chained"] = 3] = "Chained";
  return SignatureType2;
}({});
let SignaturePartType = /* @__PURE__ */ function(SignaturePartType2) {
  SignaturePartType2[SignaturePartType2["Signature"] = 0] = "Signature";
  SignaturePartType2[SignaturePartType2["Address"] = 1] = "Address";
  SignaturePartType2[SignaturePartType2["DynamicSignature"] = 2] = "DynamicSignature";
  SignaturePartType2[SignaturePartType2["Node"] = 3] = "Node";
  SignaturePartType2[SignaturePartType2["Branch"] = 4] = "Branch";
  SignaturePartType2[SignaturePartType2["Subdigest"] = 5] = "Subdigest";
  SignaturePartType2[SignaturePartType2["Nested"] = 6] = "Nested";
  return SignaturePartType2;
}({});
const SignaturePartTypeLength = 66;
function isUnrecoveredNode(node) {
  return node.left !== void 0 && node.right !== void 0;
}
function isUnrecoveredNestedLeaf(leaf) {
  return leaf.tree !== void 0;
}
function isUnrecoveredSignatureLeaf(leaf) {
  return leaf.unrecovered && leaf.signature !== void 0 && leaf.isDynamic !== void 0;
}
function decodeSignatureTree(body) {
  let arr = arrayify(body);
  let pointer;
  const append = (prevPointer, node) => {
    if (!prevPointer) {
      return {
        left: node
      };
    }
    if (!prevPointer.right) {
      return {
        left: prevPointer.left,
        right: node
      };
    }
    return {
      left: prevPointer,
      right: node
    };
  };
  while (arr.length > 0) {
    const type = arr[0];
    arr = arr.slice(1);
    switch (type) {
      case SignaturePartType.Signature:
        {
          const weight = arr[0];
          const signature2 = hexlify(arr.slice(1, SignaturePartTypeLength + 1));
          pointer = append(pointer, {
            signature: signature2,
            weight,
            unrecovered: true,
            isDynamic: false
          });
          arr = arr.slice(SignaturePartTypeLength + 1);
        }
        break;
      case SignaturePartType.Address:
        {
          const weight = arr[0];
          const address = getAddress$1(hexlify(arr.slice(1, 21)));
          pointer = append(pointer, {
            address,
            weight
          });
          arr = arr.slice(21);
        }
        break;
      case SignaturePartType.DynamicSignature:
        {
          const weight = arr[0];
          const address = getAddress$1(hexlify(arr.slice(1, 21)));
          const size2 = arr[21] << 16 | arr[22] << 8 | arr[23];
          const signature2 = hexlify(arr.slice(24, 24 + size2));
          pointer = append(pointer, {
            address,
            signature: signature2,
            weight,
            unrecovered: true,
            isDynamic: true
          });
          arr = arr.slice(24 + size2);
        }
        break;
      case SignaturePartType.Node:
        {
          const nodeHash = hexlify(arr.slice(0, 32));
          pointer = append(pointer, {
            nodeHash
          });
          arr = arr.slice(32);
        }
        break;
      case SignaturePartType.Branch:
        {
          const size2 = arr[0] << 16 | arr[1] << 8 | arr[2];
          const branch = decodeSignatureTree(arr.slice(3, 3 + size2));
          pointer = append(pointer, branch);
          arr = arr.slice(3 + size2);
        }
        break;
      case SignaturePartType.Subdigest:
        {
          const subdigest = hexlify(arr.slice(0, 32));
          pointer = append(pointer, {
            subdigest
          });
          arr = arr.slice(32);
        }
        break;
      case SignaturePartType.Nested:
        {
          const weight = arr[0];
          const threshold = arr[1] << 8 | arr[2];
          const size2 = arr[3] << 16 | arr[4] << 8 | arr[5];
          const tree = decodeSignatureTree(arr.slice(6, 6 + size2));
          pointer = append(pointer, {
            weight,
            threshold,
            tree
          });
          arr = arr.slice(6 + size2);
        }
        break;
      default:
        throw new Error(`Unknown signature part type: ${type}: ${hexlify(arr)}`);
    }
  }
  if (!pointer) {
    throw new Error("Empty signature tree");
  }
  if (pointer.right) {
    return pointer;
  }
  return pointer.left;
}
class InvalidSignatureLeafError extends Error {
  constructor(leaf) {
    super(`Invalid signature leaf: ${JSON.stringify(leaf)}`);
    this.leaf = leaf;
  }
}
async function recoverTopology(unrecovered, subdigest, provider2) {
  if (isUnrecoveredNode(unrecovered)) {
    const [left, right] = await Promise.all([recoverTopology(unrecovered.left, subdigest, provider2), recoverTopology(unrecovered.right, subdigest, provider2)]);
    return {
      left,
      right
    };
  }
  if (isUnrecoveredNestedLeaf(unrecovered)) {
    return {
      weight: unrecovered.weight,
      threshold: unrecovered.threshold,
      tree: await recoverTopology(unrecovered.tree, subdigest, provider2)
    };
  }
  if (isUnrecoveredSignatureLeaf(unrecovered)) {
    if (unrecovered.isDynamic) {
      if (!unrecovered.address) {
        throw new Error("Dynamic signature leaf without address");
      }
      const isValid2 = await isValidSignature$1(unrecovered.address, subdigest, unrecovered.signature, provider2);
      if (!isValid2) {
        throw new InvalidSignatureLeafError(unrecovered);
      }
      return {
        weight: unrecovered.weight,
        address: unrecovered.address,
        signature: unrecovered.signature,
        subdigest
      };
    } else {
      return {
        weight: unrecovered.weight,
        address: recoverSigner(subdigest, unrecovered.signature),
        signature: unrecovered.signature,
        subdigest
      };
    }
  }
  return unrecovered;
}
const partEncoder = {
  concat: (a2, b2) => {
    return pack(["bytes", "bytes"], [a2, b2]);
  },
  node: (nodeHash) => {
    return pack(["uint8", "bytes32"], [SignaturePartType.Node, nodeHash]);
  },
  branch: (tree) => {
    const arr = arrayify(tree);
    return pack(["uint8", "uint24", "bytes"], [SignaturePartType.Branch, arr.length, arr]);
  },
  nested: (weight, threshold, tree) => {
    const arr = arrayify(tree);
    return pack(["uint8", "uint8", "uint16", "uint24", "bytes"], [SignaturePartType.Nested, weight, threshold, arr.length, arr]);
  },
  subdigest: (subdigest) => {
    return pack(["uint8", "bytes32"], [SignaturePartType.Subdigest, subdigest]);
  },
  signature: (weight, signature2) => {
    return pack(["uint8", "uint8", "bytes"], [SignaturePartType.Signature, weight, signature2]);
  },
  dynamicSignature: (weight, address, signature2) => {
    const arrSignature = arrayify(signature2);
    return pack(["uint8", "uint8", "address", "uint24", "bytes"], [SignaturePartType.DynamicSignature, weight, address, arrSignature.length, arrSignature]);
  },
  address: (weight, address) => {
    return pack(["uint8", "uint8", "address"], [SignaturePartType.Address, weight, address]);
  }
};
function encodeSigners(config2, parts, subdigests, chainId, options = {}) {
  const tree = encodeTree(config2.tree, parts, subdigests, options);
  if (BigNumber.from(chainId).isZero()) {
    return {
      encoded: pack(["uint8", "uint16", "uint32", "bytes"], [SignatureType$1.NoChainIdDynamic, config2.threshold, config2.checkpoint, tree.encoded]),
      weight: tree.weight
    };
  }
  if (BigNumber.from(config2.threshold).gt(255)) {
    return {
      encoded: pack(["uint8", "uint16", "uint32", "bytes"], [SignatureType$1.Dynamic, config2.threshold, config2.checkpoint, tree.encoded]),
      weight: tree.weight
    };
  }
  return {
    encoded: pack(["uint8", "uint8", "uint32", "bytes"], [SignatureType$1.Legacy, config2.threshold, config2.checkpoint, tree.encoded]),
    weight: tree.weight
  };
}
function encodeTree(topology, parts, subdigests, options = {}) {
  const trim2 = !options.disableTrim;
  if (isNode$1(topology)) {
    const left = encodeTree(topology.left, parts, subdigests);
    const right = encodeTree(topology.right, parts, subdigests);
    const isLeftSigner = isSignerLeaf(topology.left);
    const isRightSigner = isSignerLeaf(topology.right);
    if (trim2 && left.weight.eq(0) && right.weight.eq(0) && !isLeftSigner && !isRightSigner) {
      return {
        // We don't need to include anything for this node
        // just the hash will be enough
        encoded: partEncoder.node(hashNode(topology)),
        weight: Zero$1
      };
    }
    if (trim2 && right.weight.eq(0) && !isRightSigner) {
      return {
        // The right node doesn't have any weight
        // but we still need to include the left node encoded
        encoded: partEncoder.concat(left.encoded, partEncoder.node(hashNode(topology.right))),
        weight: left.weight
      };
    }
    if (trim2 && left.weight.eq(0) && !isLeftSigner) {
      return {
        // The left node doesn't have any weight
        // we can just append its hash, but for the right node
        // we need to create a new "branch"
        encoded: partEncoder.concat(partEncoder.node(hashNode(topology.left)), partEncoder.branch(right.encoded)),
        weight: right.weight
      };
    }
    return {
      // Both nodes have weight, we need to include both
      // the right one must be a branch
      encoded: partEncoder.concat(left.encoded, partEncoder.branch(right.encoded)),
      weight: left.weight.add(right.weight)
    };
  }
  if (isNestedLeaf(topology)) {
    const tree = encodeTree(topology.tree, parts, subdigests);
    if (trim2 && tree.weight.eq(0)) {
      return {
        encoded: partEncoder.node(hashNode(topology)),
        weight: Zero$1
      };
    }
    return {
      encoded: partEncoder.nested(topology.weight, topology.threshold, tree.encoded),
      weight: tree.weight
    };
  }
  if (isNodeLeaf(topology)) {
    return {
      encoded: partEncoder.node(hashNode(topology)),
      weight: Zero$1
    };
  }
  if (isSubdigestLeaf(topology)) {
    const include = subdigests.includes(topology.subdigest);
    return {
      encoded: partEncoder.subdigest(topology.subdigest),
      weight: include ? MaxUint256$1 : Zero$1
    };
  }
  if (isSignerLeaf(topology)) {
    const include = parts.has(topology.address);
    if (include) {
      const part = parts.get(topology.address);
      const signature2 = part.signature;
      if (options.forceDynamicEncoding || part.isDynamic) {
        return {
          encoded: partEncoder.dynamicSignature(topology.weight, topology.address, signature2),
          weight: BigNumber.from(topology.weight)
        };
      } else {
        return {
          encoded: partEncoder.signature(topology.weight, signature2),
          weight: BigNumber.from(topology.weight)
        };
      }
    } else {
      return {
        encoded: partEncoder.address(topology.weight, topology.address),
        weight: Zero$1
      };
    }
  }
  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(topology)}`);
}
function deepestConfigOfSignature(signature2) {
  return isChainedSignature(signature2) ? deepestConfigOfSignature(signature2.suffix[signature2.suffix.length - 1]) : signature2.config;
}
function isUnrecoveredSignature(sig) {
  return sig.type !== void 0 && sig.decoded !== void 0 && sig.version !== void 0 && sig.version === 2;
}
function isUnrecoveredChainedSignature(sig) {
  return sig.suffix !== void 0 && Array.isArray(sig.suffix) && sig.suffix.every(isUnrecoveredSignature);
}
function isSignature(sig) {
  return sig.type !== void 0 && sig.config !== void 0 && sig.digest !== void 0 && sig.version !== void 0 && sig.version === 2;
}
function isChainedSignature(sig) {
  return sig.chain !== void 0 && Array.isArray(sig.chain) && sig.chain.every(isSignature);
}
function decodeSignature(signature2) {
  const bytes3 = arrayify(signature2);
  const type = bytes3[0];
  switch (type) {
    case SignatureType$1.Legacy:
      return {
        version: 2,
        type: SignatureType$1.Legacy,
        decoded: decodeSignatureBody(bytes3)
      };
    case SignatureType$1.Dynamic:
      return {
        version: 2,
        type: SignatureType$1.Dynamic,
        decoded: decodeSignatureBody(bytes3.slice(1))
      };
    case SignatureType$1.NoChainIdDynamic:
      return {
        version: 2,
        type: SignatureType$1.NoChainIdDynamic,
        decoded: decodeSignatureBody(bytes3.slice(1))
      };
    case SignatureType$1.Chained:
      return decodeChainedSignature(bytes3);
    default:
      throw new Error(`Invalid signature type: ${type}`);
  }
}
function decodeSignatureBody(signature2) {
  const bytes3 = arrayify(signature2);
  const threshold = bytes3[0] << 8 | bytes3[1];
  const checkpoint = bytes3[2] << 24 | bytes3[3] << 16 | bytes3[4] << 8 | bytes3[5];
  const tree = decodeSignatureTree(bytes3.slice(6));
  return {
    threshold,
    checkpoint,
    tree
  };
}
function decodeChainedSignature(signature2) {
  const arr = arrayify(signature2);
  const type = arr[0];
  if (type !== SignatureType$1.Chained) {
    throw new Error(`Expected chained signature type: ${type}`);
  }
  const chain = [];
  let index2 = 1;
  while (index2 < arr.length) {
    const size2 = arr[index2] << 16 | arr[index2 + 1] << 8 | arr[index2 + 2];
    index2 += 3;
    const sig = decodeSignature(arr.slice(index2, index2 + size2));
    chain.push(sig);
    index2 += size2;
  }
  const main2 = chain[0];
  if (isUnrecoveredChainedSignature(main2)) {
    throw new Error(`Expected first link of chained signature to be a simple signature (not chained)`);
  }
  const suffix = chain.slice(1);
  return _extends$e({}, main2, {
    suffix
  });
}
function setImageHashStruct(imageHash2) {
  return pack(["bytes32", "bytes32"], [keccak256$1(["string"], ["SetImageHash(bytes32 imageHash)"]), imageHash2]);
}
async function recoverSignature(signature2, payload, provider2) {
  const signedPayload = payload.subdigest === void 0 ? payload : void 0;
  const isNoChainId = signature2.type === SignatureType$1.NoChainIdDynamic;
  if (isNoChainId && signedPayload) {
    signedPayload.chainId = 0;
  }
  const subdigest = signedPayload ? subdigestOf(signedPayload) : payload.subdigest;
  if (!isUnrecoveredChainedSignature(signature2)) {
    const tree = await recoverTopology(signature2.decoded.tree, subdigest, provider2);
    return {
      version: 2,
      type: signature2.type,
      subdigest,
      config: _extends$e({
        version: 2
      }, signature2.decoded, {
        tree
      })
    };
  }
  if (!isSignedPayload(signedPayload)) {
    throw new Error(`Chained signature recovery requires detailed signed payload, subdigest is not enough`);
  }
  const result = [];
  let mutatedPayload = signedPayload;
  for (const sig of [_extends$e({}, signature2, {
    suffix: void 0
  }), ...signature2.suffix]) {
    const recovered = await recoverSignature(sig, mutatedPayload, provider2);
    result.unshift(recovered);
    const nextMessage = setImageHashStruct(imageHash(deepestConfigOfSignature(recovered)));
    mutatedPayload = _extends$e({}, mutatedPayload, {
      message: nextMessage,
      digest: keccak256$2(nextMessage)
    });
  }
  const main2 = result[0];
  const suffix = result.slice(1);
  return _extends$e({}, main2, {
    suffix
  });
}
function encodeChain(main2, suffix) {
  const allSignatures = [main2, ...suffix || []];
  const encodedMap = allSignatures.map((s2) => arrayify(encodeSignature(s2)));
  const body = pack(encodedMap.map(() => ["uint24", "bytes"]).flat(), encodedMap.map((s2) => [s2.length, s2]).flat());
  return pack(["uint8", "bytes"], [SignatureType$1.Chained, body]);
}
function encodeSignature(decoded) {
  if (isBytesLike(decoded))
    return hexlify(decoded);
  if (isUnrecoveredChainedSignature(decoded) || isChainedSignature(decoded)) {
    return encodeChain(encodeSignature(decoded), (decoded.suffix || []).map(encodeSignature));
  }
  const body = isUnrecoveredSignature(decoded) ? decoded.decoded : decoded.config;
  switch (decoded.type) {
    case SignatureType$1.Legacy:
      if (BigNumber.from(body.threshold).gt(255)) {
        throw new Error(`Legacy signature threshold is too large: ${body.threshold} (max 255)`);
      }
      return encodeSignatureBody(body);
    case SignatureType$1.NoChainIdDynamic:
    case SignatureType$1.Dynamic:
      return pack(["uint8", "bytes"], [decoded.type, encodeSignatureBody(body)]);
    case SignatureType$1.Chained:
      throw new Error(`Unreachable code: Chained signature should be handled above`);
    default:
      throw new Error(`Invalid signature type: ${decoded.type}`);
  }
}
function encodeSignatureBody(decoded) {
  return pack(["uint16", "uint32", "bytes"], [decoded.threshold, decoded.checkpoint, encodeSignatureTree(decoded.tree)]);
}
function encodeSignatureTree(tree) {
  if (isNode$1(tree) || isUnrecoveredNode(tree)) {
    const encodedRight = arrayify(encodeSignatureTree(tree.right));
    const encodedLeft = arrayify(encodeSignatureTree(tree.left));
    const isBranching = isNode$1(tree.right) || isUnrecoveredNode(tree.right);
    if (isBranching) {
      return pack(["bytes", "uint8", "uint24", "bytes"], [encodedLeft, SignaturePartType.Branch, encodedRight.length, encodedRight]);
    } else {
      return pack(["bytes", "bytes"], [encodedLeft, encodedRight]);
    }
  }
  if (isNestedLeaf(tree) || isUnrecoveredNestedLeaf(tree)) {
    const nested = arrayify(encodeSignatureTree(tree.tree));
    return pack(["uint8", "uint8", "uint16", "uint24", "bytes"], [SignaturePartType.Nested, tree.weight, tree.threshold, nested.length, nested]);
  }
  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== void 0) {
    const signature2 = arrayify(tree.signature);
    if (tree.isDynamic || signature2.length !== SignaturePartTypeLength) {
      if (!tree.address)
        throw new Error(`Dynamic signature leaf must have address`);
      return pack(["uint8", "uint8", "address", "uint24", "bytes"], [SignaturePartType.DynamicSignature, tree.weight, tree.address, signature2.length, signature2]);
    } else {
      return pack(["uint8", "uint8", "bytes"], [SignaturePartType.Signature, tree.weight, signature2]);
    }
  }
  if (isSignerLeaf(tree)) {
    return pack(["uint8", "uint8", "address"], [SignaturePartType.Address, tree.weight, tree.address]);
  }
  if (isNodeLeaf(tree)) {
    return pack(["uint8", "bytes32"], [SignaturePartType.Node, tree.nodeHash]);
  }
  if (isSubdigestLeaf(tree)) {
    return pack(["uint8", "bytes32"], [SignaturePartType.Subdigest, tree.subdigest]);
  }
  throw new Error(`Unknown signature tree type: ${tree}`);
}
function signaturesOf(topology) {
  if (isNode$1(topology)) {
    return [...signaturesOf(topology.left), ...signaturesOf(topology.right)];
  }
  if (isNestedLeaf(topology)) {
    return signaturesOf(topology.tree);
  }
  if (isSignerLeaf(topology) && topology.signature) {
    return [{
      address: topology.address,
      signature: topology.signature
    }];
  }
  return [];
}
function signaturesOfDecoded(utopology) {
  if (isUnrecoveredNode(utopology)) {
    return [...signaturesOfDecoded(utopology.left), ...signaturesOfDecoded(utopology.right)];
  }
  if (isUnrecoveredNestedLeaf(utopology)) {
    return signaturesOfDecoded(utopology.tree);
  }
  if (isUnrecoveredSignatureLeaf(utopology)) {
    return [utopology.signature];
  }
  return [];
}
function subdigestsOfDecoded(utopology) {
  if (isUnrecoveredNode(utopology)) {
    return [...subdigestsOfDecoded(utopology.left), ...subdigestsOfDecoded(utopology.right)];
  }
  if (isUnrecoveredNestedLeaf(utopology)) {
    return subdigestsOfDecoded(utopology.tree);
  }
  if (isSubdigestLeaf(utopology)) {
    return [utopology.subdigest];
  }
  return [];
}
async function trimSignature(signature2) {
  const decoded = typeof signature2 === "string" ? decodeSignature(signature2) : signature2;
  if (isUnrecoveredChainedSignature(decoded)) {
    const _trimmed = await Promise.all([trimSignature(_extends$e({}, decoded, {
      suffix: void 0
    })), ...decoded.suffix.map((s2) => trimSignature(s2))]);
    return encodeChain(_trimmed[0], _trimmed.slice(1));
  }
  const {
    trimmed
  } = await trimUnrecoveredTree(decoded.decoded.tree);
  return encodeSignature(_extends$e({}, decoded, {
    decoded: _extends$e({}, decoded.decoded, {
      tree: trimmed
    })
  }));
}
async function trimUnrecoveredTree(tree, trimStaticDigest = true) {
  if (isUnrecoveredNode(tree)) {
    const [left, right] = await Promise.all([trimUnrecoveredTree(tree.left), trimUnrecoveredTree(tree.right)]);
    if (left.weight === 0 && right.weight === 0) {
      try {
        const recovered = await recoverTopology(tree, HashZero, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: hashNode(recovered)
          }
        };
      } catch (_unused) {
      }
    } else {
      return {
        weight: left.weight + right.weight,
        trimmed: {
          left: left.trimmed,
          right: right.trimmed
        }
      };
    }
  }
  if (isUnrecoveredNestedLeaf(tree)) {
    const trimmed = await trimUnrecoveredTree(tree.tree);
    if (trimmed.weight === 0) {
      try {
        const recovered = await recoverTopology(tree, HashZero, void 0);
        return {
          weight: 0,
          trimmed: {
            nodeHash: hashNode(recovered)
          }
        };
      } catch (_unused2) {
      }
    }
    return {
      weight: trimmed.weight,
      trimmed: {
        weight: tree.weight,
        threshold: tree.threshold,
        tree: trimmed.trimmed
      }
    };
  }
  if (isNodeLeaf(tree) && isEncodedSignerLeaf(tree.nodeHash)) {
    return {
      weight: 0,
      trimmed: _extends$e({}, decodeSignerLeaf(tree.nodeHash))
    };
  }
  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== void 0) {
    return {
      weight: BigNumber.from(tree.weight).toNumber(),
      trimmed: tree
    };
  }
  if (!trimStaticDigest && isSubdigestLeaf(tree)) {
    return {
      weight: Infinity,
      trimmed: tree
    };
  }
  return {
    weight: 0,
    trimmed: tree
  };
}
const SignatureCoder = {
  decode: (data) => {
    return decodeSignature(data);
  },
  encode: (data) => {
    return encodeSignature(data);
  },
  trim: (data) => {
    return trimSignature(data);
  },
  supportsNoChainId: true,
  recover: (data, payload, provider2) => {
    return recoverSignature(data, payload, provider2);
  },
  encodeSigners: (config2, signatures, subdigests, chainId) => {
    return encodeSigners(config2, signatures, subdigests, chainId);
  },
  hasEnoughSigningPower: (config2, signatures) => {
    const {
      weight
    } = SignatureCoder.encodeSigners(config2, signatures, [], 0);
    return weight.gte(config2.threshold);
  },
  chainSignatures: (main2, suffix) => {
    const reversed = suffix.reverse();
    const mraw = isBytesLike(main2) ? main2 : encodeSignature(main2);
    const sraw = reversed.map((s2) => isBytesLike(s2) ? s2 : encodeSignature(s2));
    return encodeChain(mraw, sraw);
  },
  hashSetImageHash: function(imageHash2) {
    return hashSetImageHash(imageHash2);
  },
  signaturesOf(config2) {
    return signaturesOf(config2.tree);
  },
  signaturesOfDecoded: function(data) {
    return signaturesOfDecoded(data.decoded.tree);
  }
};
var signature = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SignatureType: SignatureType$1,
  SignaturePartType,
  SignaturePartTypeLength,
  isUnrecoveredNode,
  isUnrecoveredNestedLeaf,
  isUnrecoveredSignatureLeaf,
  decodeSignatureTree,
  InvalidSignatureLeafError,
  recoverTopology,
  partEncoder,
  encodeSigners,
  encodeTree,
  deepestConfigOfSignature,
  isUnrecoveredSignature,
  isUnrecoveredChainedSignature,
  isSignature,
  isChainedSignature,
  decodeSignature,
  decodeSignatureBody,
  decodeChainedSignature,
  setImageHashStruct,
  recoverSignature,
  encodeChain,
  encodeSignature,
  encodeSignatureBody,
  encodeSignatureTree,
  signaturesOf,
  signaturesOfDecoded,
  subdigestsOfDecoded,
  trimSignature,
  trimUnrecoveredTree,
  SignatureCoder
});
function isSignerLeaf(leaf) {
  return leaf.address !== void 0 && leaf.weight !== void 0;
}
function isSubdigestLeaf(leaf) {
  return leaf.subdigest !== void 0 && leaf.address === void 0;
}
function topologyToJSON(tree) {
  if (isNode$1(tree)) {
    return JSON.stringify({
      left: topologyToJSON(tree.left),
      right: topologyToJSON(tree.right)
    });
  }
  if (isNestedLeaf(tree)) {
    return JSON.stringify({
      weight: BigNumber.from(tree.weight).toString(),
      threshold: BigNumber.from(tree.threshold).toString(),
      tree: topologyToJSON(tree.tree)
    });
  }
  if (isSignerLeaf(tree)) {
    return JSON.stringify({
      address: tree.address,
      weight: BigNumber.from(tree.weight).toString()
    });
  }
  return JSON.stringify(tree);
}
function topologyFromJSON(json) {
  const parsed = typeof json === "string" ? JSON.parse(json) : json;
  if (parsed.left !== void 0 && parsed.right !== void 0) {
    return {
      left: topologyFromJSON(parsed.left),
      right: topologyFromJSON(parsed.right)
    };
  }
  if (parsed.weight !== void 0 && parsed.threshold !== void 0 && parsed.tree !== void 0) {
    return {
      weight: BigNumber.from(parsed.weight),
      threshold: BigNumber.from(parsed.threshold),
      tree: topologyFromJSON(parsed.tree)
    };
  }
  if (parsed.address !== void 0 && parsed.weight !== void 0) {
    return {
      address: parsed.address,
      weight: BigNumber.from(parsed.weight)
    };
  }
  return parsed;
}
function isNestedLeaf(leaf) {
  return leaf.tree !== void 0 && leaf.weight !== void 0 && leaf.threshold !== void 0;
}
function isNodeLeaf(leaf) {
  return leaf.nodeHash !== void 0;
}
function isLeaf$1(leaf) {
  return isSignerLeaf(leaf) || isSubdigestLeaf(leaf) || isNestedLeaf(leaf) || isNodeLeaf(leaf);
}
function isNode$1(node) {
  return node.left !== void 0 && node.right !== void 0;
}
function isTopology(topology) {
  return isNode$1(topology) || isLeaf$1(topology);
}
function encodeSignerLeaf(leaf) {
  return pack(["uint96", "address"], [leaf.weight, leaf.address]);
}
function decodeSignerLeaf(encoded) {
  const bytes3 = arrayify(encoded);
  if (bytes3.length !== 32) {
    throw new Error("Invalid encoded string length");
  }
  const weight = BigNumber.from(bytes3.slice(0, 12));
  const address = getAddress$1(hexlify(bytes3.slice(12)));
  return {
    weight,
    address
  };
}
function isEncodedSignerLeaf(encoded) {
  const bytes3 = arrayify(encoded);
  if (bytes3.length !== 32) {
    return false;
  }
  const prefix = bytes3.slice(0, 11);
  return prefix.every((byte) => byte === 0);
}
function hashNode(node) {
  if (isSignerLeaf(node)) {
    return encodeSignerLeaf(node);
  }
  if (isSubdigestLeaf(node)) {
    return keccak256$1(["string", "bytes32"], ["Sequence static digest:\n", node.subdigest]);
  }
  if (isNestedLeaf(node)) {
    const nested = hashNode(node.tree);
    return keccak256$1(["string", "bytes32", "uint256", "uint256"], ["Sequence nested config:\n", nested, node.threshold, node.weight]);
  }
  if (isNodeLeaf(node)) {
    return node.nodeHash;
  }
  return keccak256$1(["bytes32", "bytes32"], [hashNode(node.left), hashNode(node.right)]);
}
function leftFace(topology) {
  const stack = [];
  let prev = topology;
  while (!isLeaf$1(prev)) {
    stack.unshift(prev.right);
    prev = prev.left;
  }
  stack.unshift(prev);
  return stack;
}
function isWalletConfig(config2) {
  return config2.threshold !== void 0 && config2.checkpoint !== void 0 && config2.tree !== void 0 && config2.version !== void 0 && config2.version === 2;
}
function imageHash(config2) {
  return keccak256$1(["bytes32", "uint256"], [keccak256$1(["bytes32", "uint256"], [hashNode(config2.tree), config2.threshold]), config2.checkpoint]);
}
function isSimpleNestedMember(member) {
  return member.threshold !== void 0 && member.weight !== void 0 && member.members !== void 0;
}
function topologyToMembers(tree) {
  if (isSignerLeaf(tree) || isSubdigestLeaf(tree)) {
    return [tree];
  }
  if (isNestedLeaf(tree)) {
    return [{
      threshold: tree.threshold,
      weight: tree.weight,
      members: topologyToMembers(tree.tree)
    }];
  }
  if (isNodeLeaf(tree)) {
    return [];
  }
  return [...topologyToMembers(tree.left), ...topologyToMembers(tree.right)];
}
function hasUnknownNodes(tree) {
  if (isNodeLeaf(tree)) {
    return true;
  }
  if (isNode$1(tree)) {
    return hasUnknownNodes(tree.left) || hasUnknownNodes(tree.right);
  }
  return false;
}
function toSimpleWalletConfig(config2) {
  return {
    threshold: config2.threshold,
    checkpoint: config2.checkpoint,
    members: topologyToMembers(config2.tree)
  };
}
const membersAsTopologies = (members, builder) => {
  return members.map((member) => {
    if (isSimpleNestedMember(member)) {
      return {
        tree: builder(member.members),
        threshold: member.threshold,
        weight: member.weight
      };
    }
    return member;
  });
};
function legacyTopologyBuilder(members) {
  if (members.length === 0) {
    throw new Error("Empty members array");
  }
  const asTopologies = membersAsTopologies(members, legacyTopologyBuilder);
  return asTopologies.reduce((acc, member) => {
    return {
      left: acc,
      right: member
    };
  });
}
function merkleTopologyBuilder(members) {
  if (members.length === 0) {
    throw new Error("Empty members array");
  }
  const leaves = membersAsTopologies(members, merkleTopologyBuilder);
  for (let s2 = leaves.length; s2 > 1; s2 = s2 / 2) {
    for (let i = 0; i < s2 / 2; i++) {
      const j1 = i * 2;
      const j2 = j1 + 1;
      if (j2 >= s2) {
        leaves[i] = leaves[j1];
      } else {
        leaves[i] = {
          left: leaves[j1],
          right: leaves[j2]
        };
      }
    }
  }
  return leaves[0];
}
function optimized2SignersTopologyBuilder(members) {
  if (members.length > 8) {
    return merkleTopologyBuilder(members);
  }
  return legacyTopologyBuilder(members);
}
function toWalletConfig(simpleWalletConfig, builder = optimized2SignersTopologyBuilder) {
  return {
    version: 2,
    threshold: simpleWalletConfig.threshold,
    checkpoint: simpleWalletConfig.checkpoint,
    tree: builder(simpleWalletConfig.members)
  };
}
function hasSubdigest(tree, subdigest) {
  if (isSubdigestLeaf(tree)) {
    return tree.subdigest === subdigest;
  }
  if (isNode$1(tree)) {
    return hasSubdigest(tree.left, subdigest) || hasSubdigest(tree.right, subdigest);
  }
  return false;
}
function signersOf(tree) {
  const stack = [tree];
  const signers = /* @__PURE__ */ new Set();
  while (stack.length > 0) {
    const node = stack.pop();
    if (isNestedLeaf(node)) {
      stack.push(node.tree);
    } else if (isNode$1(node)) {
      stack.push(node.left);
      stack.push(node.right);
    } else if (isSignerLeaf(node)) {
      signers.add({
        address: node.address,
        weight: BigNumber.from(node.weight).toNumber()
      });
    }
  }
  return Array.from(signers);
}
function isComplete(tree) {
  if (isNode$1(tree)) {
    return isComplete(tree.left) && isComplete(tree.right);
  }
  return !isNodeLeaf(tree);
}
const ConfigCoder = {
  isWalletConfig: (config2) => {
    return config2.version === 2 && config2.threshold !== void 0 && config2.tree !== void 0;
  },
  imageHashOf: (config2) => {
    return imageHash(config2);
  },
  hasSubdigest: (config2, subdigest) => {
    return hasSubdigest(config2.tree, subdigest);
  },
  checkpointOf: (config2) => {
    return BigNumber.from(config2.checkpoint);
  },
  signersOf: (config2) => {
    return signersOf(config2.tree);
  },
  fromSimple: (config2) => {
    var _config$subdigests;
    return toWalletConfig(_extends$e({}, config2, {
      members: [...config2.signers, ...((_config$subdigests = config2.subdigests) != null ? _config$subdigests : []).map((subdigest) => ({
        subdigest
      }))]
    }));
  },
  isComplete: (config2) => {
    return isComplete(config2.tree);
  },
  // isValid = (config: WalletConfig): boolean {}
  /**
   *
   * Notice: context and kind are ignored because v2
   * doesn't need to manually update the implementation before
   * a configuration update, it's automatically done by the contract.
   *
   */
  update: {
    isKindUsed: true,
    buildTransaction: (wallet, config2, _context, _kind) => {
      const module2 = new Interface(walletContracts.mainModuleUpgradable.abi);
      return {
        entrypoint: wallet,
        transactions: [{
          to: wallet,
          data: module2.encodeFunctionData(module2.getFunction("updateImageHash"), [ConfigCoder.imageHashOf(config2)]),
          gasLimit: 0,
          delegateCall: false,
          revertOnError: true,
          value: 0
        }]
      };
    },
    decodeTransaction: function(tx) {
      var _tx$transactions$0$va, _tx$transactions$, _tx$transactions$0$ga, _tx$transactions$2;
      const module2 = new Interface(walletContracts.mainModuleUpgradable.abi);
      if (tx.transactions.length !== 1) {
        throw new Error("Invalid transaction bundle, expected 1 transaction");
      }
      const data = tx.transactions[0].data;
      if (!data) {
        throw new Error("Invalid transaction bundle, expected data");
      }
      const decoded = module2.decodeFunctionData(module2.getFunction("updateImageHash"), data);
      if (!decoded) {
        throw new Error("Invalid transaction bundle, expected valid data");
      }
      if (tx.transactions[0].to !== tx.entrypoint) {
        throw new Error("Invalid transaction bundle, expected to be sent to entrypoint");
      }
      if (tx.transactions[0].delegateCall) {
        throw new Error("Invalid transaction bundle, expected not to be a delegateCall");
      }
      if (!tx.transactions[0].revertOnError) {
        throw new Error("Invalid transaction bundle, expected revertOnError");
      }
      if (!Zero$1.eq((_tx$transactions$0$va = (_tx$transactions$ = tx.transactions[0]) == null ? void 0 : _tx$transactions$.value) != null ? _tx$transactions$0$va : 0)) {
        throw new Error("Invalid transaction bundle, expected value to be 0");
      }
      if (!Zero$1.eq((_tx$transactions$0$ga = (_tx$transactions$2 = tx.transactions[0]) == null ? void 0 : _tx$transactions$2.gasLimit) != null ? _tx$transactions$0$ga : 0)) {
        throw new Error("Invalid transaction bundle, expected value to be 0");
      }
      return {
        address: tx.entrypoint,
        newImageHash: decoded[0],
        kind: void 0
      };
    }
  },
  toJSON: function(config2) {
    return JSON.stringify({
      version: config2.version,
      threshold: BigNumber.from(config2.threshold).toString(),
      checkpoint: BigNumber.from(config2.checkpoint).toString(),
      tree: topologyToJSON(config2.tree)
    });
  },
  fromJSON: function(json) {
    const config2 = JSON.parse(json);
    return {
      version: config2.version,
      threshold: BigNumber.from(config2.threshold),
      checkpoint: BigNumber.from(config2.checkpoint),
      tree: topologyFromJSON(config2.tree)
    };
  },
  editConfig: function(config2, action) {
    var _action$threshold, _action$checkpoint;
    const members = topologyToMembers(config2.tree);
    if (action.add) {
      for (const signer2 of action.add) {
        if (members.find((s2) => isSignerLeaf(s2) && s2.address === signer2.address)) {
          continue;
        }
        members.push({
          address: signer2.address,
          weight: signer2.weight
        });
      }
    }
    if (action.remove) {
      for (const address of action.remove) {
        const index2 = members.findIndex((s2) => isSignerLeaf(s2) && s2.address === address);
        if (index2 >= 0) {
          members.splice(index2, 1);
        }
      }
    }
    return {
      version: config2.version,
      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config2.threshold,
      checkpoint: (_action$checkpoint = action.checkpoint) != null ? _action$checkpoint : config2.checkpoint,
      tree: optimized2SignersTopologyBuilder(members)
    };
  },
  buildStubSignature: function(config2, overrides) {
    const parts = /* @__PURE__ */ new Map();
    for (const [signer2, signature2] of overrides.entries()) {
      parts.set(signer2, {
        signature: signature2,
        isDynamic: true
      });
      const {
        encoded,
        weight
      } = encodeSigners(config2, parts, [], 0);
      if (weight.gte(config2.threshold)) {
        return encoded;
      }
    }
    const signers = signersOf(config2.tree);
    for (const {
      address
    } of signers.sort(({
      weight: a2
    }, {
      weight: b2
    }) => a2 - b2)) {
      const signature2 = "0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02";
      parts.set(address, {
        signature: signature2,
        isDynamic: false
      });
      const {
        encoded,
        weight
      } = encodeSigners(config2, parts, [], 0);
      if (weight.gte(config2.threshold)) {
        return encoded;
      }
    }
    return encodeSigners(config2, parts, [], 0).encoded;
  }
};
var config = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isSignerLeaf,
  isSubdigestLeaf,
  topologyToJSON,
  topologyFromJSON,
  isNestedLeaf,
  isNodeLeaf,
  isLeaf: isLeaf$1,
  isNode: isNode$1,
  isTopology,
  encodeSignerLeaf,
  decodeSignerLeaf,
  isEncodedSignerLeaf,
  hashNode,
  leftFace,
  isWalletConfig,
  imageHash,
  isSimpleNestedMember,
  topologyToMembers,
  hasUnknownNodes,
  toSimpleWalletConfig,
  legacyTopologyBuilder,
  merkleTopologyBuilder,
  optimized2SignersTopologyBuilder,
  toWalletConfig,
  hasSubdigest,
  signersOf,
  isComplete,
  ConfigCoder
});
var context$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const coders = {
  config: ConfigCoder,
  signature: SignatureCoder
};
const version$6 = 2;
const DeployedWalletContext = {
  version: version$6,
  factory: "0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A",
  guestModule: "0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE",
  mainModule: "0xfBf8f1A5E00034762D928f46d438B947f5d4065d",
  mainModuleUpgradable: "0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911",
  walletCreationCode: "0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3"
};
var v2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config,
  signature,
  context: context$1,
  chained,
  coders,
  version: version$6,
  DeployedWalletContext
});
function addressOf(context2, imageHash2) {
  const codeHash = keccak256$2(pack(["bytes", "bytes32"], [context2.walletCreationCode, hexZeroPad(context2.mainModule, 32)]));
  const hash2 = keccak256$2(pack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", context2.factory, imageHash2, codeHash]));
  return getAddress$1(hexDataSlice(hash2, 12));
}
async function isValidCounterfactual(wallet, digest9, signature2, chainId, provider2, contexts) {
  const res = await Promise.all(allVersions.map(async (version2) => {
    try {
      const decoded = version2.signature.SignatureCoder.decode(hexlify(signature2));
      const recovered1 = await version2.signature.SignatureCoder.recover(decoded, {
        address: wallet,
        digest: hexlify(digest9),
        chainId
      }, provider2);
      const imageHash2 = version2.config.ConfigCoder.imageHashOf(recovered1.config);
      const counterfactualAddress = addressOf(contexts[version2.version], imageHash2);
      if (counterfactualAddress.toLowerCase() === wallet.toLowerCase()) {
        return true;
      }
      const recovered2 = await version2.signature.SignatureCoder.recover(decoded, {
        address: wallet,
        digest: hexlify(digest9),
        chainId
      }, provider2);
      const imageHash22 = version2.config.ConfigCoder.imageHashOf(recovered2.config);
      const counterfactualAddress2 = addressOf(contexts[version2.version], imageHash22);
      return counterfactualAddress2.toLowerCase() === wallet.toLowerCase();
    } catch (_unused) {
    }
    return false;
  }));
  return res.some((r2) => r2);
}
function isValidVersionedContext(contexts) {
  const versions = Object.keys(contexts).length;
  for (let i = 1; i <= versions; i++) {
    const context2 = contexts[i];
    if (!context2 || context2.version !== i) {
      return false;
    }
  }
  return true;
}
function latestContext(contexts) {
  const versions = Object.keys(contexts).length;
  return contexts[versions];
}
const defaultContexts = {
  1: DeployedWalletContext$1,
  2: DeployedWalletContext
};
var context = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  addressOf,
  isValidCounterfactual,
  isValidVersionedContext,
  latestContext,
  defaultContexts
});
const MetaTransactionsType = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function intendTransactionBundle(bundle, wallet, chainId, id2) {
  return _extends$e({}, bundle, {
    chainId,
    intent: {
      id: id2,
      wallet
    }
  });
}
function intendedTransactionID(bundle) {
  return keccak256$2(defaultAbiCoder.encode(["address", "uint256", "bytes32"], [bundle.intent.wallet, bundle.chainId, bundle.intent.id]));
}
function unpackMetaTransactionsData(data) {
  const res = defaultAbiCoder.decode(["uint256", MetaTransactionsType], data);
  if (res.length !== 2 || !res[0] || !res[1])
    throw new Error("Invalid meta transaction data");
  return [res[0], res[1]];
}
function packMetaTransactionsData(nonce, txs) {
  return defaultAbiCoder.encode(["uint256", MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);
}
function digestOfTransactions(nonce, txs) {
  return keccak256$2(packMetaTransactionsData(nonce, txs));
}
function subdigestOfTransactions(address, chainId, nonce, txs) {
  return subdigestOf({
    address,
    chainId,
    digest: digestOfTransactions(nonce, txs)
  });
}
function subdigestOfGuestModuleTransactions(guestModule, chainId, txs) {
  return subdigestOf({
    address: guestModule,
    chainId,
    digest: keccak256$2(defaultAbiCoder.encode(["string", MetaTransactionsType], ["guest:", sequenceTxAbiEncode(txs)]))
  });
}
function toSequenceTransactions(wallet, txs) {
  return txs.map((tx) => toSequenceTransaction(wallet, tx));
}
function toSequenceTransaction(wallet, tx) {
  if (tx.to && tx.to !== AddressZero) {
    return {
      nonce: tx.nonce,
      transaction: {
        delegateCall: false,
        revertOnError: false,
        gasLimit: tx.gasLimit || 0,
        to: tx.to,
        value: tx.value || 0,
        data: tx.data || "0x"
      }
    };
  } else {
    const walletInterface = new Interface(walletContracts.mainModule.abi);
    const data = walletInterface.encodeFunctionData(walletInterface.getFunction("createContract"), [tx.data]);
    return {
      nonce: tx.nonce,
      transaction: {
        delegateCall: false,
        revertOnError: false,
        gasLimit: tx.gasLimit,
        to: wallet,
        value: tx.value || 0,
        data
      }
    };
  }
}
function isSequenceTransaction(tx) {
  return tx.delegateCall !== void 0 || tx.revertOnError !== void 0;
}
function hasSequenceTransactions(txs) {
  return txs.every(isSequenceTransaction);
}
function sequenceTxAbiEncode(txs) {
  return txs.map((t2) => {
    var _t$to;
    return {
      delegateCall: t2.delegateCall === true,
      revertOnError: t2.revertOnError === true,
      gasLimit: t2.gasLimit !== void 0 ? t2.gasLimit : Zero$1,
      target: (_t$to = t2.to) != null ? _t$to : AddressZero,
      value: t2.value !== void 0 ? t2.value : Zero$1,
      data: t2.data !== void 0 ? t2.data : []
    };
  });
}
function fromTxAbiEncode(txs) {
  return txs.map((t2) => ({
    delegateCall: t2.delegateCall,
    revertOnError: t2.revertOnError,
    gasLimit: t2.gasLimit,
    to: t2.target,
    value: t2.value,
    data: t2.data
  }));
}
function encodeNonce(space, nonce) {
  const bspace = BigNumber.from(space);
  const bnonce = BigNumber.from(nonce);
  const shl = Two.pow(BigNumber.from(96));
  if (!bnonce.div(shl).eq(Zero$1)) {
    throw new Error("Space already encoded");
  }
  return bnonce.add(bspace.mul(shl));
}
function decodeNonce(nonce) {
  const bnonce = BigNumber.from(nonce);
  const shr = Two.pow(BigNumber.from(96));
  return [bnonce.div(shr), bnonce.mod(shr)];
}
function fromTransactionish(wallet, transaction2) {
  if (Array.isArray(transaction2)) {
    if (hasSequenceTransactions(transaction2)) {
      return transaction2;
    } else {
      const stx = toSequenceTransactions(wallet, transaction2);
      return stx.map((t2) => t2.transaction);
    }
  } else if (isSequenceTransaction(transaction2)) {
    return [transaction2];
  } else {
    return [toSequenceTransaction(wallet, transaction2).transaction];
  }
}
function isTransactionBundle(cand) {
  return cand !== void 0 && cand.entrypoint !== void 0 && cand.chainId !== void 0 && cand.transactions !== void 0 && cand.nonce !== void 0 && cand.intent !== void 0 && cand.intent.id !== void 0 && cand.intent.wallet !== void 0 && Array.isArray(cand.transactions) && cand.transactions.reduce((p2, c2) => p2 && isSequenceTransaction(c2), true);
}
function isSignedTransactionBundle(cand) {
  return cand !== void 0 && cand.signature !== void 0 && cand.signature !== "" && isTransactionBundle(cand);
}
function encodeBundleExecData(bundle) {
  const walletInterface = new Interface(walletContracts.mainModule.abi);
  return walletInterface.encodeFunctionData(walletInterface.getFunction("execute"), isSignedTransactionBundle(bundle) ? [
    // Signed transaction bundle has all 3 parameters
    sequenceTxAbiEncode(bundle.transactions),
    bundle.nonce,
    bundle.signature
  ] : [
    // Unsigned bundle may be a GuestModule call, so signature and nonce are missing
    sequenceTxAbiEncode(bundle.transactions),
    0,
    []
  ]);
}
const selfExecuteSelector = "0x61c2926c";
const selfExecuteAbi = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
const unwind = (wallet, transactions2) => {
  const unwound = [];
  const walletInterface = new Interface(walletContracts.mainModule.abi);
  for (const tx of transactions2) {
    const txData = arrayify(tx.data || "0x");
    if (tx.to === wallet && hexlify(txData.slice(0, 4)) === selfExecuteSelector) {
      const data = txData.slice(4);
      const decoded = defaultAbiCoder.decode([selfExecuteAbi], data)[0];
      unwound.push(...unwind(tx.to, decoded.map((d2) => _extends$e({}, d2, {
        to: d2.target
      }))));
    } else {
      try {
        const innerTransactions = walletInterface.decodeFunctionData("execute", txData)[0];
        const unwoundTransactions = unwind(wallet, innerTransactions.map((tx2) => _extends$e({}, tx2, {
          to: tx2.target
        })));
        unwound.push(...unwoundTransactions);
      } catch (_unused) {
        unwound.push(tx);
      }
    }
  }
  return unwound;
};
var transaction = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MetaTransactionsType,
  intendTransactionBundle,
  intendedTransactionID,
  unpackMetaTransactionsData,
  packMetaTransactionsData,
  digestOfTransactions,
  subdigestOfTransactions,
  subdigestOfGuestModuleTransactions,
  toSequenceTransactions,
  toSequenceTransaction,
  isSequenceTransaction,
  hasSequenceTransactions,
  sequenceTxAbiEncode,
  fromTxAbiEncode,
  encodeNonce,
  decodeNonce,
  fromTransactionish,
  isTransactionBundle,
  isSignedTransactionBundle,
  encodeBundleExecData,
  selfExecuteSelector,
  selfExecuteAbi,
  unwind
});
const EIP_6492_OFFCHAIN_DEPLOY_CODE = "0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033";
const EIP_6492_SUFFIX = "0x6492649264926492649264926492649264926492649264926492649264926492";
async function validateEIP6492Offchain(provider2, signer2, hash2, signature2) {
  return "0x01" === await provider2.call({
    data: concat$1([EIP_6492_OFFCHAIN_DEPLOY_CODE, new AbiCoder().encode(["address", "bytes32", "bytes"], [signer2, hash2, signature2])])
  });
}
var validateEIP6492 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EIP_6492_OFFCHAIN_DEPLOY_CODE,
  EIP_6492_SUFFIX,
  validateEIP6492Offchain
});
class OnChainReader {
  constructor(provider2) {
    this.provider = provider2;
    this.isDeployedCache = /* @__PURE__ */ new Set();
  }
  module(address) {
    return new Contract(address, [...walletContracts.mainModuleUpgradable.abi, ...walletContracts.mainModule.abi, ...walletContracts.erc1271.abi], this.provider);
  }
  async isDeployed(wallet) {
    if (this.isDeployedCache.has(wallet)) {
      return true;
    }
    const code2 = await this.provider.getCode(wallet).then((c2) => arrayify(c2));
    const isDeployed = code2.length !== 0;
    if (isDeployed) {
      this.isDeployedCache.add(wallet);
    }
    return isDeployed;
  }
  async implementation(wallet) {
    const position = defaultAbiCoder.encode(["address"], [wallet]);
    const val = await this.provider.getStorageAt(wallet, position).then((c2) => arrayify(c2));
    if (val.length === 20) {
      return getAddress$1(hexlify(val));
    }
    if (val.length === 32) {
      return defaultAbiCoder.decode(["address"], val)[0];
    }
    return void 0;
  }
  async imageHash(wallet) {
    try {
      const imageHash2 = await this.module(wallet).imageHash();
      return imageHash2;
    } catch (_unused) {
    }
    return void 0;
  }
  async nonce(wallet, space = 0) {
    try {
      const nonce = await this.module(wallet).readNonce(space);
      return nonce;
    } catch (e2) {
      if (!await this.isDeployed(wallet)) {
        return 0;
      }
      throw e2;
    }
  }
  // We use the EIP-6492 validator contract to check the signature
  // this means that if the wallet is not deployed, then the signature
  // must be prefixed with a transaction that deploys the wallet
  async isValidSignature(wallet, digest9, signature2) {
    return validateEIP6492Offchain(this.provider, wallet, digest9, signature2);
  }
}
var reader = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  OnChainReader
});
function isWalletSignRequestMetadata(obj) {
  return obj && obj.address && obj.digest && obj.chainId !== void 0 && obj.config;
}
var index$1$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  config: config$2,
  signature: signature$2,
  context,
  signer,
  EIP1271: validateEIP1271,
  transaction,
  reader,
  EIP6492: validateEIP6492,
  isWalletSignRequestMetadata
});
const ALL_CODERS = [{
  config: ConfigCoder$1,
  signature: SignatureCoder$1
}, {
  config: ConfigCoder,
  signature: SignatureCoder
}];
function coderFor(version2) {
  const index2 = version2 - 1;
  if (index2 < 0 || index2 >= ALL_CODERS.length) {
    throw new Error(`No coder for version: ${version2}`);
  }
  return ALL_CODERS[index2];
}
function genericCoderFor(version2) {
  return coderFor(version2);
}
var index$7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALL_CODERS,
  coderFor,
  genericCoderFor
});
const VERSION$1 = "1.10.7";
const allVersions = [v1, v2];
const core$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: VERSION$1,
  allVersions,
  commons: index$1$2,
  universal: index$7,
  v1,
  v2
}, Symbol.toStringTag, { value: "Module" }));
function counterfactualVersion(address, firstImageHash, versions) {
  for (let i = 0; i < versions.length; i++) {
    if (index$1$2.context.addressOf(versions[i], firstImageHash) === address) {
      return versions[i].version;
    }
  }
  throw new Error("Could not find version for counterfactual address");
}
var version$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  counterfactualVersion
});
class Migration_v1v2 {
  constructor() {
    this.version = 2;
    this.configCoder = v2.config.ConfigCoder;
    this.signatureCoder = v2.signature.SignatureCoder;
  }
  buildTransaction(address, contexts, newConfig) {
    if (!v2.config.ConfigCoder.isWalletConfig(newConfig)) {
      const v2Config = v2.config.toWalletConfig({
        threshold: newConfig.threshold,
        members: newConfig.signers,
        checkpoint: 0
      });
      return this.buildTransaction(address, contexts, v2Config);
    }
    const context2 = contexts[2];
    const contract = new Interface(walletContracts.mainModule.abi);
    const updateBundle = v2.config.ConfigCoder.update.buildTransaction(address, newConfig, context2, "first");
    const tx = {
      entrypoint: address,
      nonce: index$1$2.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0),
      transactions: [{
        to: address,
        value: 0,
        gasLimit: 0,
        revertOnError: true,
        delegateCall: false,
        data: contract.encodeFunctionData(contract.getFunction("updateImplementation"), [context2.mainModuleUpgradable])
      }, ...updateBundle.transactions]
    };
    return {
      tx,
      fromVersion: this.version - 1,
      toVersion: this.version,
      toConfig: newConfig
    };
  }
  decodeTransaction(tx, contexts) {
    const address = tx.entrypoint;
    if (tx.transactions.length < 2) {
      throw new Error("Invalid transaction bundle size");
    }
    if (!tx.nonce || !index$1$2.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0).eq(tx.nonce)) {
      throw new Error("Invalid transaction bundle nonce");
    }
    if (tx.transactions[0].to !== address || tx.transactions[1].to !== address || tx.transactions[0].delegateCall || tx.transactions[1].delegateCall || !tx.transactions[0].revertOnError || !tx.transactions[1].revertOnError || tx.transactions[0].value && !Zero$1.eq(tx.transactions[0].value) || tx.transactions[1].value && !Zero$1.eq(tx.transactions[1].value) || tx.transactions[0].gasLimit && !Zero$1.eq(tx.transactions[0].gasLimit) || tx.transactions[1].gasLimit && !Zero$1.eq(tx.transactions[1].gasLimit)) {
      throw new Error("Invalid transaction bundle format");
    }
    const context2 = contexts[2];
    const contract = new Interface(walletContracts.mainModule.abi);
    const data1 = hexlify(tx.transactions[0].data || []);
    const expectData1 = hexlify(contract.encodeFunctionData(contract.getFunction("updateImplementation"), [context2.mainModuleUpgradable]));
    if (data1 !== expectData1) {
      throw new Error("Invalid new implementation on transaction");
    }
    const decoded2 = v2.config.ConfigCoder.update.decodeTransaction({
      entrypoint: address,
      transactions: [tx.transactions[1]]
    });
    if (decoded2.address !== address) {
      throw new Error("Invalid transaction bundle address");
    }
    return decoded2;
  }
}
const MIGRATION_NONCE_SPACE = "0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb";
const v1v2 = new Migration_v1v2();
var index$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MIGRATION_NONCE_SPACE,
  v1v2
});
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function validateMigrations(migrations) {
  for (const [version2, migration2] of Object.entries(migrations)) {
    if (version2 !== String(migration2.version - 1)) {
      throw new Error(`Migration with key ${version2} has version ${migration2.version}, expected version to be key + 1`);
    }
  }
}
class Migrator {
  constructor(tracker2, migrations, contexts) {
    this.tracker = tracker2;
    this.migrations = migrations;
    this.contexts = contexts;
    validateMigrations(migrations);
  }
  lastMigration() {
    let last;
    for (const migration2 of Object.values(this.migrations)) {
      if (last === void 0 || migration2.version > last.version) {
        last = migration2;
      }
    }
    if (last === void 0) {
      throw new Error("No migrations");
    }
    return last;
  }
  async getAllMigratePresignedTransaction(args) {
    const {
      address,
      fromImageHash,
      fromVersion,
      chainId
    } = args;
    let fih = fromImageHash;
    let fversion = fromVersion;
    const versions = Object.values(this.contexts);
    const migs = [];
    for (let i = 1; i < versions.length; i++) {
      const mig = await this.tracker.getMigration(address, fih, fversion, chainId);
      if (!mig)
        return {
          signedMigrations: migs,
          missing: true,
          lastImageHash: fih,
          lastVersion: fversion
        };
      migs.push(mig);
      const migration2 = this.migrations[fversion];
      if (!migration2) {
        throw new Error(`No migration found for version ${fversion}`);
      }
      const decoded = migration2.decodeTransaction(mig.tx, this.contexts);
      if (decoded.address !== address) {
        throw new Error(`Migration transaction address does not match expected address`);
      }
      fih = decoded.newImageHash;
      fversion += 1;
    }
    return {
      signedMigrations: migs,
      missing: false,
      lastImageHash: fih,
      lastVersion: fversion
    };
  }
  async signNextMigration(address, fromVersion, wallet, nextConfig) {
    const migration2 = this.migrations[fromVersion];
    if (!migration2) {
      return void 0;
    }
    const unsignedMigration = migration2.buildTransaction(address, this.contexts, nextConfig);
    const signedBundle = await wallet.signTransactionBundle(unsignedMigration.tx);
    return _extends$d({}, unsignedMigration, {
      tx: signedBundle
    });
  }
}
var migrator = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Migrator
});
const DefaultMigrations = {
  1: v1v2
};
var defaults = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DefaultMigrations
});
const migration$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaults,
  migration: index$6,
  migrator,
  version: version$5
}, Symbol.toStringTag, { value: "Module" }));
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
const DEFAULT_GAS_LIMIT = BigNumber.from(8e5);
const ProviderRelayerDefaults = {
  waitPollRate: 1e3,
  deltaBlocksLog: 12,
  fromBlockLog: -1024
};
function isProviderRelayerOptions(obj) {
  return obj.provider !== void 0 && Provider.isProvider(obj.provider);
}
class ProviderRelayer {
  constructor(options) {
    this.provider = void 0;
    this.waitPollRate = void 0;
    this.deltaBlocksLog = void 0;
    this.fromBlockLog = void 0;
    const opts = _extends$c({}, ProviderRelayerDefaults, options);
    this.provider = opts.provider;
    this.waitPollRate = opts.waitPollRate;
    this.deltaBlocksLog = opts.deltaBlocksLog;
    this.fromBlockLog = opts.fromBlockLog;
  }
  async simulate(wallet, ...transactions2) {
    var _this = this;
    return (await Promise.all(transactions2.map(async function(tx) {
      if (tx.gasLimit && !BigNumber.from(tx.gasLimit || 0).eq(Zero$1)) {
        return tx.gasLimit;
      }
      if (tx.delegateCall) {
        return DEFAULT_GAS_LIMIT;
      }
      if (tx.to === wallet && await _this.provider.getCode(wallet).then((code2) => arrayify(code2).length === 0)) {
        return DEFAULT_GAS_LIMIT;
      }
      if (!_this.provider) {
        throw new Error("signer.provider is not set, but is required");
      }
      return _this.provider.estimateGas({
        from: wallet,
        to: tx.to,
        data: tx.data,
        value: tx.value
      });
    }))).map((gasLimit) => ({
      executed: true,
      succeeded: true,
      gasUsed: BigNumber.from(gasLimit).toNumber(),
      gasLimit: BigNumber.from(gasLimit).toNumber()
    }));
  }
  async getNonce(address, space, blockTag) {
    if (!this.provider) {
      throw new Error("provider is not set");
    }
    if (await this.provider.getCode(address) === "0x") {
      return 0;
    }
    if (space === void 0) {
      space = 0;
    }
    const module2 = new Contract(address, walletContracts.mainModule.abi, this.provider);
    const nonce = await module2.readNonce(space, {
      blockTag
    });
    return index$1$2.transaction.encodeNonce(space, nonce);
  }
  async wait(metaTxnId, timeoutDuration, delay2 = this.waitPollRate, maxFails = 5) {
    var _this2 = this;
    if (typeof metaTxnId !== "string") {
      metaTxnId = index$1$2.transaction.intendedTransactionID(metaTxnId);
    }
    let timedOut = false;
    const retry = async function retry2(f2, errorMessage) {
      let fails = 0;
      while (!timedOut) {
        try {
          return await f2();
        } catch (error) {
          fails++;
          if (maxFails !== void 0 && fails >= maxFails) {
            logger.error(`giving up after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ""}`, error);
            throw error;
          } else {
            logger.warn(`attempt #${fails} failed${errorMessage ? `: ${errorMessage}` : ""}`, error);
          }
        }
        if (delay2 > 0) {
          await new Promise((resolve) => setTimeout(resolve, delay2));
        }
      }
      throw new Error(`timed out after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ""}`);
    };
    const waitReceipt = async function waitReceipt2() {
      let lastBlock = _this2.fromBlockLog;
      if (lastBlock < 0) {
        const block = await retry(() => _this2.provider.getBlockNumber(), "unable to get latest block number");
        lastBlock = block + lastBlock;
      }
      if (typeof metaTxnId !== "string") {
        throw new Error("impossible");
      }
      const normalMetaTxnId = metaTxnId.replace("0x", "");
      while (!timedOut) {
        const block = await retry(() => _this2.provider.getBlockNumber(), "unable to get latest block number");
        const logs = await retry(() => _this2.provider.getLogs({
          fromBlock: Math.max(0, lastBlock - _this2.deltaBlocksLog),
          toBlock: block,
          // Nonce change event topic
          topics: ["0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881"]
        }), `unable to get NonceChange logs for blocks ${Math.max(0, lastBlock - _this2.deltaBlocksLog)} to ${block}`);
        lastBlock = block;
        const txs = await Promise.all(logs.map((l2) => retry(() => _this2.provider.getTransactionReceipt(l2.transactionHash), `unable to get receipt for transaction ${l2.transactionHash}`)));
        const found = txs.find((tx) => tx.logs.find((l2) => l2.topics.length === 0 && l2.data.replace("0x", "") === normalMetaTxnId || l2.topics.length === 1 && // TxFailed event topic
        l2.topics[0] === "0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7" && l2.data.length >= 64 && l2.data.replace("0x", "").startsWith(normalMetaTxnId)));
        if (found) {
          return _extends$c({
            receipt: found
          }, await retry(() => _this2.provider.getTransaction(found.transactionHash), `unable to get transaction ${found.transactionHash}`));
        }
        if (!timedOut) {
          await new Promise((r2) => setTimeout(r2, delay2));
        }
      }
      throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);
    };
    if (timeoutDuration !== void 0) {
      return Promise.race([waitReceipt(), new Promise((_, reject) => setTimeout(() => {
        timedOut = true;
        reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
      }, timeoutDuration))]);
    } else {
      return waitReceipt();
    }
  }
}
function isLocalRelayerOptions(obj) {
  return obj.signer !== void 0 && Signer$1.isSigner(obj.signer);
}
class LocalRelayer extends ProviderRelayer {
  constructor(options) {
    super(Signer$1.isSigner(options) ? {
      provider: options.provider
    } : _extends$c({}, options, {
      provider: options.signer.provider
    }));
    this.signer = void 0;
    this.txnOptions = void 0;
    this.signer = Signer$1.isSigner(options) ? options : options.signer;
    if (!this.signer.provider)
      throw new Error("Signer must have a provider");
  }
  async getFeeOptions(_address, ..._transactions) {
    return {
      options: []
    };
  }
  async getFeeOptionsRaw(_entrypoint, _data2, _options) {
    return {
      options: []
    };
  }
  async gasRefundOptions(address, ...transactions2) {
    const {
      options
    } = await this.getFeeOptions(address, ...transactions2);
    return options;
  }
  setTransactionOptions(transactionRequest) {
    this.txnOptions = transactionRequest;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    if (quote !== void 0) {
      logger.warn(`LocalRelayer doesn't accept fee quotes`);
    }
    const data = index$1$2.transaction.encodeBundleExecData(signedTxs);
    const responsePromise = this.signer.sendTransaction(_extends$c({
      to: signedTxs.entrypoint,
      data
    }, this.txnOptions, {
      gasLimit: 9e6
    }));
    if (waitForReceipt) {
      const response = await responsePromise;
      response.receipt = await response.wait();
      return response;
    } else {
      return responsePromise;
    }
  }
}
const WebRPCVersion$2 = "v1";
const WebRPCSchemaVersion$2 = "v0.4.1";
const WebRPCSchemaHash$2 = "1e27d0fd295aa5897878939595ef0c6adc54b1a3";
let ETHTxnStatus = /* @__PURE__ */ function(ETHTxnStatus2) {
  ETHTxnStatus2["UNKNOWN"] = "UNKNOWN";
  ETHTxnStatus2["DROPPED"] = "DROPPED";
  ETHTxnStatus2["QUEUED"] = "QUEUED";
  ETHTxnStatus2["SENT"] = "SENT";
  ETHTxnStatus2["SUCCEEDED"] = "SUCCEEDED";
  ETHTxnStatus2["PARTIALLY_FAILED"] = "PARTIALLY_FAILED";
  ETHTxnStatus2["FAILED"] = "FAILED";
  return ETHTxnStatus2;
}({});
let TransferType = /* @__PURE__ */ function(TransferType2) {
  TransferType2["SEND"] = "SEND";
  TransferType2["RECEIVE"] = "RECEIVE";
  TransferType2["BRIDGE_DEPOSIT"] = "BRIDGE_DEPOSIT";
  TransferType2["BRIDGE_WITHDRAW"] = "BRIDGE_WITHDRAW";
  TransferType2["BURN"] = "BURN";
  TransferType2["UNKNOWN"] = "UNKNOWN";
  return TransferType2;
}({});
let FeeTokenType$1 = /* @__PURE__ */ function(FeeTokenType2) {
  FeeTokenType2["UNKNOWN"] = "UNKNOWN";
  FeeTokenType2["ERC20_TOKEN"] = "ERC20_TOKEN";
  FeeTokenType2["ERC1155_TOKEN"] = "ERC1155_TOKEN";
  return FeeTokenType2;
}({});
let SortOrder$1 = /* @__PURE__ */ function(SortOrder2) {
  SortOrder2["DESC"] = "DESC";
  SortOrder2["ASC"] = "ASC";
  return SortOrder2;
}({});
class Relayer {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Relayer/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            version: _data2.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSequenceContext = (headers, signal) => {
      return this.fetch(this.url("GetSequenceContext"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            data: _data2.data
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getChainID = (headers, signal) => {
      return this.fetch(this.url("GetChainID"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            chainID: _data2.chainID
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sendMetaTxn = (args, headers, signal) => {
      return this.fetch(this.url("SendMetaTxn"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status,
            txnHash: _data2.txnHash
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTxnNonce = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTxnNonce"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            nonce: _data2.nonce
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTxnReceipt = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTxnReceipt"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            receipt: _data2.receipt
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.simulate = (args, headers, signal) => {
      return this.fetch(this.url("Simulate"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            results: _data2.results
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateMetaTxnGasLimits = (args, headers, signal) => {
      return this.fetch(this.url("UpdateMetaTxnGasLimits"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            payload: _data2.payload
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.feeTokens = (headers, signal) => {
      return this.fetch(this.url("FeeTokens"), createHTTPRequest$6({}, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            isFeeRequired: _data2.isFeeRequired,
            tokens: _data2.tokens
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.feeOptions = (args, headers, signal) => {
      return this.fetch(this.url("FeeOptions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            options: _data2.options,
            sponsored: _data2.sponsored,
            quote: _data2.quote
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTxnNetworkFeeOptions = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTxnNetworkFeeOptions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            options: _data2.options
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getMetaTransactions = (args, headers, signal) => {
      return this.fetch(this.url("GetMetaTransactions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            page: _data2.page,
            transactions: _data2.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sentTransactions = (args, headers, signal) => {
      return this.fetch(this.url("SentTransactions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            page: _data2.page,
            transactions: _data2.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.pendingTransactions = (args, headers, signal) => {
      return this.fetch(this.url("PendingTransactions"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            page: _data2.page,
            transactions: _data2.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getGasTank = (args, headers, signal) => {
      return this.fetch(this.url("GetGasTank"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            gasTank: _data2.gasTank
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addGasTank = (args, headers, signal) => {
      return this.fetch(this.url("AddGasTank"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status,
            gasTank: _data2.gasTank
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateGasTank = (args, headers, signal) => {
      return this.fetch(this.url("UpdateGasTank"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status,
            gasTank: _data2.gasTank
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("GetGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            gasSponsor: _data2.gasSponsor
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addressGasSponsors = (args, headers, signal) => {
      return this.fetch(this.url("AddressGasSponsors"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            page: _data2.page,
            gasSponsors: _data2.gasSponsors
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listGasSponsors = (args, headers, signal) => {
      return this.fetch(this.url("ListGasSponsors"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            page: _data2.page,
            gasSponsors: _data2.gasSponsors
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("AddGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status,
            gasSponsor: _data2.gasSponsor
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("UpdateGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status,
            gasSponsor: _data2.gasSponsor
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url("RemoveGasSponsor"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.reportGasSponsorUsage = (args, headers, signal) => {
      return this.fetch(this.url("ReportGasSponsorUsage"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            gasSponsorUsage: _data2.gasSponsorUsage
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.nextGasTankBalanceAdjustmentNonce = (args, headers, signal) => {
      return this.fetch(this.url("NextGasTankBalanceAdjustmentNonce"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            nonce: _data2.nonce
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.adjustGasTankBalance = (args, headers, signal) => {
      return this.fetch(this.url("AdjustGasTankBalance"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            status: _data2.status,
            adjustment: _data2.adjustment
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getGasTankBalanceAdjustment = (args, headers, signal) => {
      return this.fetch(this.url("GetGasTankBalanceAdjustment"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            adjustment: _data2.adjustment
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listGasTankBalanceAdjustments = (args, headers, signal) => {
      return this.fetch(this.url("ListGasTankBalanceAdjustments"), createHTTPRequest$6(args, headers, signal)).then((res) => {
        return buildResponse$6(res).then((_data2) => {
          return {
            page: _data2.page,
            adjustments: _data2.adjustments
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$6.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$6 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$c({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$6 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$6.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$6[code2] || WebrpcError$6).new(data);
    }
    return data;
  });
};
let WebrpcError$6 = class WebrpcError2 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError2.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$6 = class WebrpcEndpointError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError2.prototype);
  }
};
let WebrpcRequestFailedError$6 = class WebrpcRequestFailedError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError2.prototype);
  }
};
let WebrpcBadRouteError$6 = class WebrpcBadRouteError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError2.prototype);
  }
};
let WebrpcBadMethodError$6 = class WebrpcBadMethodError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError2.prototype);
  }
};
let WebrpcBadRequestError$6 = class WebrpcBadRequestError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError2.prototype);
  }
};
let WebrpcBadResponseError$6 = class WebrpcBadResponseError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError2.prototype);
  }
};
let WebrpcServerPanicError$6 = class WebrpcServerPanicError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError2.prototype);
  }
};
let WebrpcInternalErrorError$6 = class WebrpcInternalErrorError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError2.prototype);
  }
};
let WebrpcClientDisconnectedError$6 = class WebrpcClientDisconnectedError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError2.prototype);
  }
};
let WebrpcStreamLostError$6 = class WebrpcStreamLostError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError2.prototype);
  }
};
let WebrpcStreamFinishedError$6 = class WebrpcStreamFinishedError2 extends WebrpcError$6 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError2.prototype);
  }
};
let UnauthorizedError$5 = class UnauthorizedError2 extends WebrpcError$6 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError2.prototype);
  }
};
let PermissionDeniedError$3 = class PermissionDeniedError2 extends WebrpcError$6 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError2.prototype);
  }
};
let MethodNotFoundError$2 = class MethodNotFoundError extends WebrpcError$6 {
  constructor(name2 = "MethodNotFound", code2 = 1003, message = "Method not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError.prototype);
  }
};
let AbortedError$2 = class AbortedError2 extends WebrpcError$6 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError2.prototype);
  }
};
let InvalidArgumentError$4 = class InvalidArgumentError2 extends WebrpcError$6 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError2.prototype);
  }
};
let UnavailableError$2 = class UnavailableError2 extends WebrpcError$6 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError2.prototype);
  }
};
let QueryFailedError$4 = class QueryFailedError2 extends WebrpcError$6 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError2.prototype);
  }
};
let NotFoundError$5 = class NotFoundError2 extends WebrpcError$6 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError2.prototype);
  }
};
let errors$2 = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["MethodNotFound"] = "MethodNotFound";
  errors2["Aborted"] = "Aborted";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["Unavailable"] = "Unavailable";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["NotFound"] = "NotFound";
  return errors2;
}({});
const webrpcErrorByCode$6 = {
  [0]: WebrpcEndpointError$6,
  [-1]: WebrpcRequestFailedError$6,
  [-2]: WebrpcBadRouteError$6,
  [-3]: WebrpcBadMethodError$6,
  [-4]: WebrpcBadRequestError$6,
  [-5]: WebrpcBadResponseError$6,
  [-6]: WebrpcServerPanicError$6,
  [-7]: WebrpcInternalErrorError$6,
  [-8]: WebrpcClientDisconnectedError$6,
  [-9]: WebrpcStreamLostError$6,
  [-10]: WebrpcStreamFinishedError$6,
  [1e3]: UnauthorizedError$5,
  [1001]: PermissionDeniedError$3,
  [1003]: MethodNotFoundError$2,
  [1005]: AbortedError$2,
  [2001]: InvalidArgumentError$4,
  [2002]: UnavailableError$2,
  [2003]: QueryFailedError$4,
  [3e3]: NotFoundError$5
};
var relayer_gen = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WebRPCVersion: WebRPCVersion$2,
  WebRPCSchemaVersion: WebRPCSchemaVersion$2,
  WebRPCSchemaHash: WebRPCSchemaHash$2,
  ETHTxnStatus,
  TransferType,
  FeeTokenType: FeeTokenType$1,
  SortOrder: SortOrder$1,
  Relayer,
  WebrpcError: WebrpcError$6,
  WebrpcEndpointError: WebrpcEndpointError$6,
  WebrpcRequestFailedError: WebrpcRequestFailedError$6,
  WebrpcBadRouteError: WebrpcBadRouteError$6,
  WebrpcBadMethodError: WebrpcBadMethodError$6,
  WebrpcBadRequestError: WebrpcBadRequestError$6,
  WebrpcBadResponseError: WebrpcBadResponseError$6,
  WebrpcServerPanicError: WebrpcServerPanicError$6,
  WebrpcInternalErrorError: WebrpcInternalErrorError$6,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$6,
  WebrpcStreamLostError: WebrpcStreamLostError$6,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$6,
  UnauthorizedError: UnauthorizedError$5,
  PermissionDeniedError: PermissionDeniedError$3,
  MethodNotFoundError: MethodNotFoundError$2,
  AbortedError: AbortedError$2,
  InvalidArgumentError: InvalidArgumentError$4,
  UnavailableError: UnavailableError$2,
  QueryFailedError: QueryFailedError$4,
  NotFoundError: NotFoundError$5,
  errors: errors$2
});
const FINAL_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.SUCCEEDED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
const FAILED_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
function isRpcRelayerOptions(obj) {
  return obj.url !== void 0 && typeof obj.url === "string" && obj.provider !== void 0 && Provider.isProvider(obj.provider);
}
const fetch$4 = typeof global$1 === "object" ? global$1.fetch : window.fetch;
class RpcRelayer {
  constructor(options) {
    this.options = options;
    this.service = void 0;
    this.provider = void 0;
    this._fetch = (input2, init3) => {
      const headers = {};
      const {
        jwtAuth,
        projectAccessKey: projectAccessKey2
      } = this.options;
      if (jwtAuth && jwtAuth.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth}`;
      }
      if (projectAccessKey2 && projectAccessKey2.length > 0) {
        headers["X-Access-Key"] = projectAccessKey2;
      }
      init3.headers = _extends$c({}, init3.headers, headers);
      return fetch$4(input2, init3);
    };
    this.service = new Relayer(options.url, this._fetch);
    if (Provider.isProvider(options.provider)) {
      this.provider = options.provider;
    } else {
      const {
        jwtAuth,
        projectAccessKey: projectAccessKey2
      } = this.options;
      const providerConnectionInfo = getEthersConnectionInfo(options.provider.url, projectAccessKey2, jwtAuth);
      this.provider = new StaticJsonRpcProvider(providerConnectionInfo);
    }
  }
  async waitReceipt(metaTxnId, delay2 = 1e3, maxFails = 5, isCancelled) {
    if (typeof metaTxnId !== "string") {
      metaTxnId = index$1$2.transaction.intendedTransactionID(metaTxnId);
    }
    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnId}`);
    let fails = 0;
    while (isCancelled === void 0 || !isCancelled()) {
      try {
        const {
          receipt
        } = await this.service.getMetaTxnReceipt({
          metaTxID: metaTxnId
        });
        if (receipt && receipt.txnReceipt && receipt.txnReceipt !== "null" && FINAL_STATUSES.includes(receipt.status)) {
          return {
            receipt
          };
        }
      } catch (e2) {
        fails++;
        if (fails === maxFails) {
          throw e2;
        }
      }
      if (isCancelled === void 0 || !isCancelled()) {
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
    }
    throw new Error(`Cancelled waiting for transaction receipt ${metaTxnId}`);
  }
  async simulate(wallet, ...transactions2) {
    const coder = defaultAbiCoder;
    const encoded = coder.encode([index$1$2.transaction.MetaTransactionsType], [index$1$2.transaction.sequenceTxAbiEncode(transactions2)]);
    return (await this.service.simulate({
      wallet,
      transactions: encoded
    })).results;
  }
  async getFeeOptions(address, ...transactions2) {
    const feeTokens = await this.service.feeTokens();
    if (feeTokens.isFeeRequired) {
      const symbols = feeTokens.tokens.map((token) => token.symbol).join(", ");
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);
      const nonce = await this.getNonce(address);
      if (!this.provider) {
        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);
        throw new Error("provider is not set");
      }
      const {
        options,
        quote
      } = await this.service.feeOptions({
        wallet: address,
        to: address,
        data: index$1$2.transaction.encodeBundleExecData({
          entrypoint: address,
          transactions: transactions2,
          nonce
        })
      });
      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`);
      return {
        options,
        quote: {
          _tag: "FeeQuote",
          _quote: quote
        }
      };
    } else {
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);
      return {
        options: []
      };
    }
  }
  async getFeeOptionsRaw(entrypoint, data, options) {
    const {
      options: feeOptions2,
      quote
    } = await this.service.feeOptions({
      wallet: entrypoint,
      to: entrypoint,
      data: hexlify(data),
      simulate: options == null ? void 0 : options.simulate
    });
    return {
      options: feeOptions2,
      quote: {
        _tag: "FeeQuote",
        _quote: quote
      }
    };
  }
  async gasRefundOptions(address, ...transactions2) {
    const {
      options
    } = await this.getFeeOptions(address, ...transactions2);
    return options;
  }
  async getNonce(address, space) {
    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${address} space: ${space}`);
    const encodedNonce = space !== void 0 ? BigNumber.from(space).toHexString() : void 0;
    const resp = await this.service.getMetaTxnNonce({
      walletContractAddress: address,
      space: encodedNonce
    });
    const nonce = BigNumber.from(resp.nonce);
    const [decodedSpace, decodedNonce] = index$1$2.transaction.decodeNonce(nonce);
    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${address} ${decodedNonce} space: ${decodedSpace}`);
    return nonce;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    var _this = this;
    logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`);
    let typecheckedQuote;
    if (quote !== void 0) {
      if (typeof quote._quote === "string") {
        typecheckedQuote = quote._quote;
      } else {
        logger.warn("[rpc-relayer/relay] ignoring invalid fee quote");
      }
    }
    if (!this.provider) {
      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);
      throw new Error("provider is not set");
    }
    const data = index$1$2.transaction.encodeBundleExecData(signedTxs);
    const metaTxn = await this.service.sendMetaTxn({
      call: {
        walletAddress: signedTxs.intent.wallet,
        contract: signedTxs.entrypoint,
        input: data
      },
      quote: typecheckedQuote
    });
    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);
    if (waitForReceipt) {
      return this.wait(signedTxs.intent.id);
    } else {
      const response = {
        hash: signedTxs.intent.id,
        confirmations: 0,
        from: signedTxs.intent.wallet,
        wait: (_confirmations) => Promise.reject(new Error("impossible"))
      };
      const wait2 = async function wait3(confirmations) {
        var _waitResponse$receipt;
        if (!_this.provider) {
          throw new Error("cannot wait for receipt, relayer has no provider set");
        }
        const waitResponse = await _this.wait(signedTxs.intent.id);
        const transactionHash = (_waitResponse$receipt = waitResponse.receipt) == null ? void 0 : _waitResponse$receipt.transactionHash;
        if (!transactionHash) {
          throw new Error("cannot wait for receipt, unknown native transaction hash");
        }
        Object.assign(response, waitResponse);
        return _this.provider.waitForTransaction(transactionHash, confirmations);
      };
      response.wait = wait2;
      return response;
    }
  }
  async wait(metaTxnId, timeout, delay2 = 1e3, maxFails = 5) {
    var _this2 = this;
    let timedOut = false;
    const {
      receipt
    } = await (timeout !== void 0 ? Promise.race([this.waitReceipt(metaTxnId, delay2, maxFails, () => timedOut), new Promise((_, reject) => setTimeout(() => {
      timedOut = true;
      reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
    }, timeout))]) : this.waitReceipt(metaTxnId, delay2, maxFails));
    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {
      throw new MetaTransactionResponseException(receipt);
    }
    const txReceipt = JSON.parse(receipt.txnReceipt);
    return {
      blockHash: txReceipt.blockHash,
      blockNumber: BigNumber.from(txReceipt.blockNumber).toNumber(),
      confirmations: 1,
      from: typeof metaTxnId === "string" ? void 0 : metaTxnId.intent.wallet,
      hash: txReceipt.transactionHash,
      raw: receipt.txnReceipt,
      receipt: txReceipt,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function(confirmations) {
        return _this2.provider.waitForTransaction(txReceipt.transactionHash, confirmations);
      }
    };
  }
}
class MetaTransactionResponseException {
  constructor(receipt) {
    this.receipt = receipt;
  }
}
function isRelayer(cand) {
  return typeof cand === "object" && typeof cand.simulate === "function" && typeof cand.getFeeOptions === "function" && typeof cand.gasRefundOptions === "function" && typeof cand.getNonce === "function" && typeof cand.relay === "function" && typeof cand.wait === "function";
}
const relayer$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LocalRelayer,
  ProviderRelayer,
  ProviderRelayerDefaults,
  RpcRelayer,
  RpcRelayerProto: relayer_gen,
  isLocalRelayerOptions,
  isProviderRelayerOptions,
  isRelayer,
  isRpcRelayerOptions,
  proto: relayer_gen
}, Symbol.toStringTag, { value: "Module" }));
function isSapientSigner(signer2) {
  return signer2.getAddress !== void 0 && signer2.buildDeployTransaction !== void 0 && signer2.predecorateSignedTransactions !== void 0 && signer2.decorateTransactions !== void 0 && signer2.sign !== void 0 && signer2.notifyStatusChange !== void 0;
}
class SignerWrapper {
  constructor(signer2, eoa = true) {
    this.signer = signer2;
    this.eoa = eoa;
  }
  getAddress() {
    return this.signer.getAddress();
  }
  async buildDeployTransaction(_metadata) {
    return;
  }
  async predecorateSignedTransactions(_metadata) {
    return [];
  }
  async decorateTransactions(bundle, _metadata) {
    return bundle;
  }
  sign(message, metadata2) {
    return this.signer.signMessage(message);
  }
  notifyStatusChange(_i2, _s, _m) {
  }
  suffix() {
    return [2];
  }
}
var index$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isSapientSigner,
  SignerWrapper
});
let SignerState = /* @__PURE__ */ function(SignerState2) {
  SignerState2[SignerState2["INITIAL"] = 0] = "INITIAL";
  SignerState2[SignerState2["SIGNING"] = 1] = "SIGNING";
  SignerState2[SignerState2["SIGNED"] = 2] = "SIGNED";
  SignerState2[SignerState2["ERROR"] = 3] = "ERROR";
  return SignerState2;
}({});
function isSignerStatusPending(status) {
  return status === void 0 || status.state === SignerState.INITIAL || status.state === SignerState.SIGNING;
}
class Orchestrator {
  constructor(signers, tag = Orchestrator.randomTag()) {
    this.tag = tag;
    this.observers = [];
    this.signers = [];
    this.count = 0;
    this.setSigners(signers);
  }
  static randomTag() {
    return `default-${hexlify(randomBytes$1(8)).slice(2)}`;
  }
  pullId() {
    return `${this.tag}-${this.count++}`;
  }
  setSigners(signers) {
    this.signers = signers.map((s2) => isSapientSigner(s2) ? s2 : new SignerWrapper(s2));
  }
  async getSigners() {
    return Promise.all(this.signers.map(async function(s2) {
      return s2.getAddress();
    }));
  }
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter((o2) => o2 !== observer);
    };
  }
  async notifyObservers(id2, status, metadata2) {
    await Promise.all([...this.signers.map(async function(signer2) {
      return signer2.notifyStatusChange(id2, status, metadata2);
    }), ...this.observers.map(async function(observer) {
      return observer(status, metadata2);
    })]);
  }
  async buildDeployTransaction(metadata2) {
    let bundle;
    for (const signer2 of this.signers) {
      const newBundle = await signer2.buildDeployTransaction(metadata2);
      if (bundle === void 0) {
        bundle = newBundle;
      } else if (newBundle != null && newBundle.transactions) {
        bundle.transactions = newBundle.transactions.concat(bundle.transactions);
      }
    }
    return bundle;
  }
  async predecorateSignedTransactions(metadata2) {
    const output2 = [];
    for (const signer2 of this.signers) {
      output2.push(...await signer2.predecorateSignedTransactions(metadata2 != null ? metadata2 : {}));
    }
    return output2;
  }
  async decorateTransactions(bundle, metadata2) {
    for (const signer2 of this.signers) {
      bundle = await signer2.decorateTransactions(bundle, metadata2 != null ? metadata2 : {});
    }
    return bundle;
  }
  signMessage(args) {
    var _this = this;
    const id2 = this.pullId();
    return new Promise(async function(resolve) {
      const {
        message,
        metadata: metadata2,
        callback,
        candidates
      } = args;
      const status = {
        ended: false,
        message,
        signers: {}
      };
      let lastMetadata = metadata2 != null ? metadata2 : {};
      const onNewMetadata = (newMetadata) => {
        lastMetadata = newMetadata;
        _this.notifyObservers(id2, status, lastMetadata);
      };
      const onStatusUpdate = () => {
        try {
          _this.notifyObservers(id2, status, lastMetadata);
          const pending = Object.entries(status.signers).filter(([_, s2]) => isSignerStatusPending(s2));
          if (callback && callback(status, onNewMetadata) || pending.length === 0) {
            status.ended = true;
            resolve(status);
            _this.notifyObservers(id2, status, lastMetadata);
            return;
          }
        } catch (e2) {
          console.error("Error while notifying observers", e2);
        }
      };
      let signers = _this.signers;
      if (candidates) {
        const addresses = await Promise.all(_this.signers.map(async function(s2) {
          return s2.getAddress();
        }));
        signers = _this.signers.filter((_, i) => candidates.includes(addresses[i]));
      }
      const accepted = await Promise.allSettled(signers.map(async function(s2) {
        const saddr = await s2.getAddress();
        status.signers[saddr] = {
          state: SignerState.SIGNING,
          request: s2.sign(message, metadata2 != null ? metadata2 : {}).then((signature2) => {
            const suffix = s2.suffix();
            status.signers[saddr] = {
              state: SignerState.SIGNED,
              signature: signature2,
              suffix
            };
            onStatusUpdate();
            return signature2;
          }).catch((error) => {
            status.signers[saddr] = {
              state: SignerState.ERROR,
              error
            };
            onStatusUpdate();
            throw error;
          })
        };
      }));
      for (let i = 0; i < accepted.length; i++) {
        const signer2 = _this.signers[i];
        const promise = accepted[i];
        if (promise.status === "rejected") {
          const address = await signer2.getAddress();
          console.warn(`signer ${address} rejected the request: ${promise.reason}`);
          status.signers[address] = {
            state: SignerState.ERROR,
            error: new Error(`signer ${address} rejected the request: ${promise.reason}`)
          };
        }
      }
      onStatusUpdate();
    });
  }
}
const signhub$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Orchestrator,
  SignerState,
  isSignerStatusPending,
  signers: index$5
}, Symbol.toStringTag, { value: "Module" }));
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
async function resolveArrayProperties$1(object) {
  if (Array.isArray(object)) {
    return Promise.all(object.map((o2) => resolveProperties$1(o2)));
  }
  return resolveProperties$1(object);
}
const statusToSignatureParts = (status) => {
  const parts = /* @__PURE__ */ new Map();
  for (const signer2 of Object.keys(status.signers)) {
    const value = status.signers[signer2];
    if (value.state === SignerState.SIGNED) {
      const suffix = arrayify(value.suffix);
      const suffixed = pack(["bytes", "bytes"], [value.signature, suffix]);
      parts.set(signer2, {
        signature: suffixed,
        isDynamic: suffix.length !== 1 || suffix[0] !== 2
      });
    }
  }
  return parts;
};
class Wallet2 extends Signer$1 {
  constructor(options) {
    if (Zero$1.eq(options.chainId) && !options.coders.signature.supportsNoChainId) {
      throw new Error(`Sequence version ${options.config.version} doesn't support chainId 0`);
    }
    super();
    this.context = void 0;
    this.config = void 0;
    this.address = void 0;
    this.chainId = void 0;
    this.provider = void 0;
    this.relayer = void 0;
    this.coders = void 0;
    this.orchestrator = void 0;
    this._reader = void 0;
    this.context = options.context;
    this.config = options.config;
    this.orchestrator = options.orchestrator;
    this.coders = options.coders;
    this.address = options.address;
    this.chainId = options.chainId;
    this.provider = options.provider;
    this.relayer = options.relayer;
    this._reader = options.reader;
  }
  static newWallet(options) {
    const address = index$1$2.context.addressOf(options.context, options.coders.config.imageHashOf(options.config));
    return new Wallet2(_extends$b({}, options, {
      address
    }));
  }
  reader() {
    if (this._reader)
      return this._reader;
    if (!this.provider)
      throw new Error("Wallet status provider requires a provider");
    return new index$1$2.reader.OnChainReader(this.provider);
  }
  setConfig(config2) {
    this.config = config2;
  }
  setOrchestrator(orchestrator) {
    this.orchestrator = orchestrator;
  }
  setAddress(address) {
    this.address = address;
  }
  getSigners() {
    return this.orchestrator.getSigners();
  }
  async getAddress() {
    return this.address;
  }
  async decorateTransactions(bundle) {
    const decorated = await this.orchestrator.decorateTransactions(bundle);
    if (await this.reader().isDeployed(this.address)) {
      return decorated;
    }
    const transactions2 = [{
      to: decorated.entrypoint,
      data: index$1$2.transaction.encodeBundleExecData(decorated),
      revertOnError: true
    }];
    const deployTx = await this.buildDeployTransaction();
    if (deployTx) {
      transactions2.unshift(...deployTx.transactions);
    }
    return {
      entrypoint: this.context.guestModule,
      chainId: this.chainId,
      intent: decorated.intent,
      transactions: transactions2
    };
  }
  async buildDeployTransaction(metadata2) {
    if (metadata2 != null && metadata2.ignoreDeployed && await this.reader().isDeployed(this.address)) {
      return;
    }
    const imageHash2 = this.coders.config.imageHashOf(this.config);
    if (index$1$2.context.addressOf(this.context, imageHash2) !== this.address) {
      throw new Error(`First address of config ${imageHash2} doesn't match wallet address ${this.address}`);
    }
    const bundle = Wallet2.buildDeployTransaction(this.context, imageHash2);
    if (metadata2 != null && metadata2.includeChildren) {
      const childBundle = await this.orchestrator.buildDeployTransaction(metadata2);
      if (childBundle) {
        bundle.transactions = childBundle.transactions.concat(bundle.transactions);
      }
    }
    return bundle;
  }
  async deploy(metadata2) {
    const deployTx = await this.buildDeployTransaction(metadata2);
    if (deployTx === void 0) {
      return;
    }
    if (!this.relayer)
      throw new Error("Wallet deploy requires a relayer");
    return this.relayer.relay(_extends$b({}, deployTx, {
      chainId: this.chainId,
      intent: {
        id: hexlify(randomBytes$1(32)),
        wallet: this.address
      }
    }));
  }
  static buildDeployTransaction(context2, imageHash2) {
    const factoryInterface = new Interface(walletContracts.factory.abi);
    return {
      entrypoint: context2.guestModule,
      transactions: [{
        to: context2.factory,
        data: factoryInterface.encodeFunctionData(factoryInterface.getFunction("deploy"), [context2.mainModule, imageHash2]),
        gasLimit: 1e5,
        delegateCall: false,
        revertOnError: true,
        value: 0
      }]
    };
  }
  async buildUpdateConfigurationTransaction(config2) {
    if (this.coders.config.update.isKindUsed) {
      const implementation = await this.reader().implementation(this.address);
      const isLaterUpdate = implementation && implementation === this.context.mainModuleUpgradable;
      return this.coders.config.update.buildTransaction(this.address, config2, this.context, isLaterUpdate ? "later" : "first");
    }
    return this.coders.config.update.buildTransaction(this.address, config2, this.context);
  }
  async getNonce(space = 0) {
    const nonce = await this.reader().nonce(this.address, space);
    if (nonce === void 0)
      throw new Error("Unable to determine nonce");
    return nonce;
  }
  async signDigest(digest9, metadata2) {
    const subdigest = subDigestOf(this.address, this.chainId, digest9);
    if (this.coders.config.hasSubdigest(this.config, subdigest)) {
      return this.coders.signature.encodeSigners(this.config, /* @__PURE__ */ new Map(), [subdigest], this.chainId).encoded;
    }
    const childMetadata = _extends$b({}, metadata2, {
      // Keep other metadata fields
      digest: digest9,
      chainId: this.chainId,
      address: this.address,
      config: this.config
    });
    const subdigestBytes = arrayify(subdigest);
    const signature2 = await this.orchestrator.signMessage({
      candidates: this.coders.config.signersOf(this.config).map((s2) => s2.address),
      message: subdigestBytes,
      metadata: childMetadata,
      callback: (status, onNewMetadata) => {
        const parts2 = statusToSignatureParts(status);
        const newMetadata = _extends$b({}, childMetadata, {
          parts: parts2
        });
        onNewMetadata(newMetadata);
        return this.coders.signature.hasEnoughSigningPower(this.config, parts2);
      }
    });
    const parts = statusToSignatureParts(signature2);
    return this.coders.signature.encodeSigners(this.config, parts, [], this.chainId).encoded;
  }
  signMessage(message) {
    return this.signDigest(keccak256$2(message), {
      message
    });
  }
  signTransactionBundle(bundle) {
    if (bundle.entrypoint !== this.address) {
      throw new Error(`Invalid entrypoint: ${bundle.entrypoint} !== ${this.address}`);
    }
    return this.signTransactions(bundle.transactions, bundle.nonce);
  }
  async fetchNonceOrSpace(nonce) {
    let spaceValue;
    if (nonce && nonce.space !== void 0) {
      spaceValue = BigNumber.from(nonce.space);
    } else if (nonce === void 0) {
      return this.randomNonce();
    } else if (nonce && nonce.serial === true) {
      spaceValue = 0;
    } else {
      return nonce;
    }
    const resultNonce = await this.reader().nonce(this.address, spaceValue);
    if (resultNonce === void 0)
      throw new Error("Unable to determine nonce");
    return index$1$2.transaction.encodeNonce(spaceValue, resultNonce);
  }
  // Generate nonce with random space
  randomNonce() {
    const randomNonceSpace = BigNumber.from(hexlify(randomBytes$1(12)));
    const randomNonce = index$1$2.transaction.encodeNonce(randomNonceSpace, 0);
    return randomNonce;
  }
  async signTransactions(txs, nonce, metadata2) {
    const transaction2 = await resolveArrayProperties$1(txs);
    const transactions2 = index$1$2.transaction.fromTransactionish(this.address, transaction2);
    if (transactions2.length === 0) {
      transactions2.push({
        to: this.address,
        data: "0x",
        value: 0,
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true
      });
    }
    const defaultedNonce = await this.fetchNonceOrSpace(nonce);
    const digest9 = index$1$2.transaction.digestOfTransactions(defaultedNonce, transactions2);
    const meta = _extends$b({
      digest: digest9,
      transactions: transactions2
    }, metadata2);
    const signature2 = await this.signDigest(digest9, meta);
    return {
      intent: {
        // Maybe is better if signDigest returns the subdigest directly
        id: subDigestOf(this.address, this.chainId, digest9),
        wallet: this.address
      },
      chainId: this.chainId,
      transactions: transactions2,
      entrypoint: this.address,
      nonce: defaultedNonce,
      signature: signature2
    };
  }
  async sendSignedTransaction(signedBundle, quote) {
    if (!this.relayer)
      throw new Error("Wallet sendTransaction requires a relayer");
    return this.relayer.relay(signedBundle, quote);
  }
  // sendTransaction will dispatch the transaction to the relayer for submission to the network.
  // This method is able to send transactions in serial or parallel (default). You can specify
  // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).
  //
  // By default, nonces are generated randomly and assigned so transactioned can be executed
  // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.
  async sendTransaction(txs, options) {
    let nonce;
    if ((options == null ? void 0 : options.nonce) !== void 0) {
      nonce = options.nonce;
    } else if (options != null && options.serial) {
      nonce = {
        serial: true
      };
    } else {
      nonce = this.randomNonce();
    }
    const signed2 = await this.signTransactions(txs, nonce);
    const decorated = await this.decorateTransactions(signed2);
    return this.sendSignedTransaction(decorated, options == null ? void 0 : options.quote);
  }
  async fillGasLimits(txs) {
    const transaction2 = await resolveArrayProperties$1(txs);
    const transactions2 = index$1$2.transaction.fromTransactionish(this.address, transaction2);
    const relayer2 = this.relayer;
    if (!relayer2)
      throw new Error("Wallet fillGasLimits requires a relayer");
    const simulations = await relayer2.simulate(this.address, ...transactions2);
    return transactions2.map((tx, i) => {
      const gasLimit = tx.gasLimit ? BigNumber.from(tx.gasLimit).toNumber() : simulations[i].gasLimit;
      return _extends$b({}, tx, simulations[i], {
        gasLimit
      });
    });
  }
  connect(provider2, relayer2) {
    this.provider = provider2;
    this.relayer = relayer2;
    return this;
  }
  signTransaction(transaction2) {
    throw new Error("Method not implemented.");
  }
}
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function isPromise(value) {
  return !!value && typeof value.then === "function";
}
function isDeferrable(value) {
  if (typeof value === "object") {
    return Object.keys(value).some((key2) => isPromise(value[key2]));
  }
  return false;
}
function encodeGasRefundTransaction(option) {
  if (!option)
    return [];
  const value = BigNumber.from(option.value);
  switch (option.token.type) {
    case relayer_gen.FeeTokenType.UNKNOWN:
      return [{
        delegateCall: false,
        revertOnError: true,
        gasLimit: option.gasLimit,
        to: option.to,
        value: value.toHexString(),
        data: []
      }];
    case relayer_gen.FeeTokenType.ERC20_TOKEN:
      if (!option.token.contractAddress) {
        throw new Error(`No contract address for ERC-20 fee option`);
      }
      return [{
        delegateCall: false,
        revertOnError: true,
        gasLimit: option.gasLimit,
        to: option.token.contractAddress,
        value: 0,
        data: new Interface([{
          constant: false,
          inputs: [{
            type: "address"
          }, {
            type: "uint256"
          }],
          name: "transfer",
          outputs: [],
          type: "function"
        }]).encodeFunctionData("transfer", [option.to, value.toHexString()])
      }];
    default:
      throw new Error(`Unhandled fee token type ${option.token.type}`);
  }
}
class AccountSigner {
  constructor(account2, chainId, options) {
    this.account = account2;
    this.chainId = chainId;
    this.options = options;
    this._isSigner = true;
  }
  get provider() {
    return this.account.providerFor(this.chainId);
  }
  async getAddress() {
    return this.account.address;
  }
  signMessage(message) {
    var _this$options$cantVal, _this$options;
    return this.account.signMessage(message, this.chainId, (_this$options$cantVal = (_this$options = this.options) == null ? void 0 : _this$options.cantValidateBehavior) != null ? _this$options$cantVal : "throw");
  }
  async defaultSelectFee(_txs, options) {
    if (options.length === 0)
      return void 0;
    const balanceOfAbi = [{
      constant: true,
      inputs: [{
        type: "address"
      }],
      name: "balanceOf",
      outputs: [{
        type: "uint256"
      }],
      type: "function"
    }];
    for (const option of options) {
      if (option.token.type === relayer_gen.FeeTokenType.UNKNOWN) {
        const balance = await this.getBalance();
        if (balance.gte(BigNumber.from(option.value))) {
          return option;
        }
      } else if (option.token.contractAddress && option.token.type === relayer_gen.FeeTokenType.ERC20_TOKEN) {
        const token = new Contract(option.token.contractAddress, balanceOfAbi, this.provider);
        const balance = await token.balanceOf(this.account.address);
        if (balance.gte(BigNumber.from(option.value))) {
          return option;
        }
      } else
        ;
    }
    throw new Error("No fee option available - not enough balance");
  }
  async sendTransaction(txsPromise, options) {
    var _this$options$stubSig, _this$options2, _this$options$selectF, _this$options3, _this$options4;
    const txs = isDeferrable(txsPromise) ? await resolveProperties$1(txsPromise) : txsPromise;
    const prepare = await this.account.prepareTransactions({
      txs,
      chainId: this.chainId,
      stubSignatureOverrides: (_this$options$stubSig = (_this$options2 = this.options) == null ? void 0 : _this$options2.stubSignatureOverrides) != null ? _this$options$stubSig : /* @__PURE__ */ new Map(),
      simulateForFeeOptions: options == null ? void 0 : options.simulateForFeeOptions
    });
    const selectMethod = (_this$options$selectF = (_this$options3 = this.options) == null ? void 0 : _this$options3.selectFee) != null ? _this$options$selectF : this.defaultSelectFee.bind(this);
    const feeOption = await selectMethod(txs, prepare.feeOptions);
    const finalTransactions = [...prepare.transactions, ...encodeGasRefundTransaction(feeOption)];
    return this.account.sendTransaction(finalTransactions, this.chainId, prepare.feeQuote, void 0, void 0, ((_this$options4 = this.options) == null ? void 0 : _this$options4.nonceSpace) !== void 0 ? {
      nonceSpace: this.options.nonceSpace
    } : void 0);
  }
  getBalance(blockTag) {
    return this.provider.getBalance(this.account.address, blockTag);
  }
  call(transaction2, blockTag) {
    return this.provider.call(transaction2, blockTag);
  }
  async resolveName(name2) {
    const res = await this.provider.resolveName(name2);
    if (!res)
      throw new Error(`Could not resolve name ${name2}`);
    return res;
  }
  connect(_provider) {
    throw new Error("Method not implemented.");
  }
  signTransaction(transaction2) {
    throw new Error("Method not implemented.");
  }
  getTransactionCount(blockTag) {
    throw new Error("Method not implemented.");
  }
  estimateGas(transaction2) {
    throw new Error("Method not implemented.");
  }
  getChainId() {
    return Promise.resolve(BigNumber.from(this.chainId).toNumber());
  }
  getGasPrice() {
    throw new Error("Method not implemented.");
  }
  getFeeData() {
    throw new Error("Method not implemented.");
  }
  checkTransaction(transaction2) {
    throw new Error("Method not implemented.");
  }
  populateTransaction(transaction2) {
    throw new Error("Method not implemented.");
  }
  _checkProvider(operation) {
    throw new Error("Method not implemented.");
  }
}
class Chain0Reader {
  async isDeployed(_wallet) {
    return false;
  }
  async implementation(_wallet) {
    return void 0;
  }
  async imageHash(_wallet) {
    return void 0;
  }
  async nonce(_wallet, _space) {
    return Zero$1;
  }
  async isValidSignature(_wallet, _digest, _signature) {
    throw new Error("Method not supported.");
  }
}
class Account {
  constructor(options) {
    this.address = void 0;
    this.networks = void 0;
    this.tracker = void 0;
    this.contexts = void 0;
    this.migrator = void 0;
    this.migrations = void 0;
    this.orchestrator = void 0;
    this.jwt = void 0;
    this.projectAccessKey = void 0;
    this.address = getAddress$1(options.address);
    this.contexts = options.contexts;
    this.tracker = options.tracker;
    this.networks = options.networks;
    this.orchestrator = options.orchestrator;
    this.jwt = options.jwt;
    this.projectAccessKey = options.projectAccessKey;
    this.migrations = options.migrations || defaults.DefaultMigrations;
    this.migrator = new migrator.Migrator(options.tracker, this.migrations, this.contexts);
  }
  getSigner(chainId, options) {
    return new AccountSigner(this, chainId, options);
  }
  static async new(options) {
    var _options$migrations;
    const mig = new migrator.Migrator(options.tracker, (_options$migrations = options.migrations) != null ? _options$migrations : defaults.DefaultMigrations, options.contexts);
    const lastMigration = mig.lastMigration();
    const lastCoder = lastMigration.configCoder;
    const config2 = lastCoder.fromSimple(options.config);
    const imageHash2 = lastCoder.imageHashOf(config2);
    const context2 = options.contexts[lastMigration.version];
    const address = index$1$2.context.addressOf(context2, imageHash2);
    await options.tracker.saveCounterfactualWallet({
      config: config2,
      context: Object.values(options.contexts)
    });
    return new Account({
      address,
      tracker: options.tracker,
      contexts: options.contexts,
      networks: options.networks,
      orchestrator: options.orchestrator,
      migrations: options.migrations,
      projectAccessKey: options.projectAccessKey
    });
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  get version() {
    return this.migrator.lastMigration().version;
  }
  get coders() {
    const lastMigration = this.migrator.lastMigration();
    return {
      signature: lastMigration.signatureCoder,
      config: lastMigration.configCoder
    };
  }
  network(chainId) {
    const tcid = BigNumber.from(chainId);
    const found = this.networks.find((n2) => tcid.eq(n2.chainId));
    if (!found)
      throw new Error(`Network not found for chainId ${chainId}`);
    return found;
  }
  providerFor(chainId) {
    const found = this.network(chainId);
    if (!found.provider && !found.rpcUrl)
      throw new Error(`Provider not found for chainId ${chainId}`);
    return found.provider || new StaticJsonRpcProvider(getEthersConnectionInfo(found.rpcUrl, this.projectAccessKey, this.jwt), {
      name: "",
      chainId: BigNumber.from(chainId).toNumber()
    });
  }
  reader(chainId) {
    if (Zero$1.eq(chainId))
      return new Chain0Reader();
    return new index$1$2.reader.OnChainReader(this.providerFor(chainId));
  }
  relayer(chainId) {
    const found = this.network(chainId);
    if (!found.relayer)
      throw new Error(`Relayer not found for chainId ${chainId}`);
    if (isRelayer(found.relayer))
      return found.relayer;
    return new RpcRelayer(_extends$a({}, found.relayer, this.projectAccessKey ? {
      projectAccessKey: this.projectAccessKey
    } : {
      jwtAuth: this.jwt
    }));
  }
  setOrchestrator(orchestrator) {
    this.orchestrator = orchestrator;
  }
  setJwt(jwt) {
    this.jwt = jwt;
  }
  contextFor(version2) {
    const ctx = this.contexts[version2];
    if (!ctx)
      throw new Error(`Context not found for version ${version2}`);
    return ctx;
  }
  walletForStatus(chainId, status) {
    const coder = index$7.coderFor(status.version);
    return this.walletFor(chainId, this.contextFor(status.version), status.config, coder);
  }
  walletFor(chainId, context2, config2, coders2) {
    const isNetworkZero = Zero$1.eq(chainId);
    return new Wallet2({
      config: config2,
      context: context2,
      chainId,
      coders: coders2,
      relayer: isNetworkZero ? void 0 : this.relayer(chainId),
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this.reader(chainId)
    });
  }
  // Get the status of the account on a given network
  // this does the following process:
  // 1. Get the current on-chain status of the wallet (version + imageHash)
  // 2. Get any pending migrations that have been signed by the wallet
  // 3. Get any pending configuration updates that have been signed by the wallet
  // 4. Fetch reverse lookups for both on-chain and pending configurations
  async status(chainId, longestPath = false) {
    var _this = this;
    const isDeployedPromise = this.reader(chainId).isDeployed(this.address);
    const counterfactualImageHashPromise = this.tracker.imageHashOfCounterfactualWallet({
      wallet: this.address
    }).then((r2) => {
      if (!r2)
        throw new Error(`Counterfactual imageHash not found for wallet ${this.address}`);
      return r2;
    });
    const counterFactualVersionPromise = counterfactualImageHashPromise.then((r2) => {
      return version$5.counterfactualVersion(this.address, r2.imageHash, Object.values(this.contexts));
    });
    const onChainVersionPromise = async function() {
      const isDeployed2 = await isDeployedPromise;
      if (!isDeployed2)
        return counterFactualVersionPromise;
      const implementation = await _this.reader(chainId).implementation(_this.address);
      if (!implementation)
        throw new Error(`Implementation not found for wallet ${_this.address}`);
      const versions = Object.values(_this.contexts);
      for (let i = 0; i < versions.length; i++) {
        if (versions[i].mainModule === implementation || versions[i].mainModuleUpgradable === implementation) {
          return versions[i].version;
        }
      }
      throw new Error(`Version not found for implementation ${implementation}`);
    }();
    const onChainImageHashPromise = async function() {
      const deployedImageHash = await _this.reader(chainId).imageHash(_this.address);
      if (deployedImageHash)
        return deployedImageHash;
      const counterfactualImageHash2 = await counterfactualImageHashPromise;
      if (counterfactualImageHash2)
        return counterfactualImageHash2.imageHash;
      throw new Error(`On-chain imageHash not found for wallet ${_this.address}`);
    }();
    const onChainConfigPromise = async function() {
      const onChainImageHash2 = await onChainImageHashPromise;
      const onChainConfig = await _this.tracker.configOfImageHash({
        imageHash: onChainImageHash2
      });
      if (onChainConfig)
        return onChainConfig;
      throw new Error(`On-chain config not found for imageHash ${onChainImageHash2}`);
    }();
    const onChainVersion = await onChainVersionPromise;
    const onChainImageHash = await onChainImageHashPromise;
    let fromImageHash = onChainImageHash;
    let lastVersion = onChainVersion;
    let signedMigrations = [];
    if (onChainVersion !== this.version) {
      const presignedMigrate = await this.migrator.getAllMigratePresignedTransaction({
        address: this.address,
        fromImageHash: onChainImageHash,
        fromVersion: onChainVersion,
        chainId
      });
      fromImageHash = presignedMigrate.lastImageHash;
      lastVersion = presignedMigrate.lastVersion;
      signedMigrations = presignedMigrate.signedMigrations;
    }
    const presigned = await this.tracker.loadPresignedConfiguration({
      wallet: this.address,
      fromImageHash,
      longestPath
    });
    const imageHash2 = presigned && presigned.length > 0 ? presigned[presigned.length - 1].nextImageHash : fromImageHash;
    const config2 = await this.tracker.configOfImageHash({
      imageHash: imageHash2
    });
    if (!config2) {
      throw new Error(`Config not found for imageHash ${imageHash2}`);
    }
    const isDeployed = await isDeployedPromise;
    const counterfactualImageHash = await counterfactualImageHashPromise;
    const checkpoint = index$7.coderFor(lastVersion).config.checkpointOf(config2);
    return {
      original: _extends$a({}, counterfactualImageHash, {
        version: await counterFactualVersionPromise
      }),
      onChain: {
        imageHash: onChainImageHash,
        config: await onChainConfigPromise,
        version: onChainVersion,
        deployed: isDeployed
      },
      fullyMigrated: lastVersion === this.version,
      signedMigrations,
      version: lastVersion,
      presignedConfigurations: presigned,
      imageHash: imageHash2,
      config: config2,
      checkpoint,
      canOnchainValidate: onChainVersion === this.version && isDeployed
    };
  }
  mustBeFullyMigrated(status) {
    if (!status.fullyMigrated) {
      throw new Error(`Wallet ${this.address} is not fully migrated`);
    }
  }
  async predecorateSignedTransactions(status, chainId) {
    const bundles = await this.orchestrator.predecorateSignedTransactions({
      chainId
    });
    const predecorated = await this.predecorateTransactions([], status, chainId);
    if (index$1$2.transaction.fromTransactionish(this.address, predecorated).length > 0) {
      bundles.push(await this.signTransactions(predecorated, chainId));
    }
    return bundles;
  }
  async predecorateTransactions(txs, status, chainId) {
    if (status.onChain.imageHash !== status.imageHash) {
      const wallet = this.walletForStatus(chainId, status);
      const updateConfig = await wallet.buildUpdateConfigurationTransaction(status.config);
      return [Array.isArray(txs) ? txs : [txs], updateConfig.transactions].flat();
    }
    return txs;
  }
  async decorateTransactions(bundles, status, chainId) {
    var _chainId, _bundles$;
    if (!Array.isArray(bundles)) {
      return this.decorateTransactions([bundles], status, chainId);
    }
    chainId = (_chainId = chainId) != null ? _chainId : bundles[0].chainId;
    const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId);
    const hasBootstrapTxs = bootstrapBundle.transactions.length > 0;
    if (!hasBootstrapTxs && bundles.length === 1) {
      return bundles[0];
    }
    const {
      entrypoint
    } = hasBootstrapTxs ? bootstrapBundle : bundles[0];
    const decoratedBundle = {
      entrypoint,
      chainId,
      // Intent of the first bundle is used
      intent: (_bundles$ = bundles[0]) == null ? void 0 : _bundles$.intent,
      transactions: [...bootstrapBundle.transactions, ...bundles.map((bundle) => ({
        to: bundle.entrypoint,
        data: index$1$2.transaction.encodeBundleExecData(bundle),
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true,
        value: 0
      }))]
    };
    if (!status.onChain.deployed) {
      const id2 = index$1$2.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, chainId, decoratedBundle.transactions);
      if (decoratedBundle.intent === void 0) {
        decoratedBundle.intent = {
          id: id2,
          wallet: this.address
        };
      } else {
        decoratedBundle.intent.id = id2;
      }
    }
    return decoratedBundle;
  }
  async decorateSignature(signature2, status) {
    if (!status.presignedConfigurations || status.presignedConfigurations.length === 0) {
      return signature2;
    }
    const coder = this.coders.signature;
    const chain = status.presignedConfigurations.map((c2) => c2.signature);
    const chainedSignature = coder.chainSignatures(signature2, chain);
    return coder.trim(chainedSignature);
  }
  async publishWitness() {
    const digest9 = keccak256$2(toUtf8Bytes(`This is a Sequence account woo! ${Date.now()}`));
    const signature2 = await this.signDigest(digest9, 0, false);
    const decoded = this.coders.signature.decode(signature2);
    const signatures = this.coders.signature.signaturesOfDecoded(decoded);
    return this.tracker.saveWitnesses({
      wallet: this.address,
      digest: digest9,
      chainId: 0,
      signatures
    });
  }
  async signDigest(digest9, chainId, decorate = true, cantValidateBehavior = "ignore", metadata2) {
    const chainRef = Zero$1.eq(chainId) ? this.networks[0].chainId : chainId;
    const status = await this.status(chainRef);
    this.mustBeFullyMigrated(status);
    if (!status.canOnchainValidate && cantValidateBehavior === "throw") {
      throw new Error("Wallet cannot validate onchain");
    }
    const wallet = this.walletForStatus(chainId, status);
    const signature2 = await wallet.signDigest(digest9, metadata2);
    const decorated = decorate ? this.decorateSignature(signature2, status) : signature2;
    if (!status.canOnchainValidate) {
      switch (cantValidateBehavior) {
        case "ignore":
          return decorated;
        case "eip6492":
          return this.buildEIP6492Signature(await decorated, status, chainId);
      }
    }
    return decorated;
  }
  buildOnChainSignature(digest9) {
    const subdigest = index$1$2.signature.subdigestOf({
      digest: hexlify(digest9),
      chainId: 0,
      address: this.address
    });
    const hexSubdigest = hexlify(subdigest);
    const config2 = this.coders.config.fromSimple({
      // Threshold *only* needs to be > 0, this is not a magic number
      // we only use 2 ** 15 because it may lead to lower gas costs in some chains
      threshold: 32768,
      checkpoint: 0,
      signers: [],
      subdigests: [hexSubdigest]
    });
    const walletInterface = new Interface(walletContracts.mainModule.abi);
    const bundle = {
      entrypoint: this.address,
      transactions: [{
        to: this.address,
        data: walletInterface.encodeFunctionData(
          // *NEVER* use updateImageHash here, as it would effectively destroy the wallet
          // setExtraImageHash sets an additional imageHash, without changing the current one
          "setExtraImageHash",
          [
            this.coders.config.imageHashOf(config2),
            // 2 ** 255 instead of max uint256, to have more zeros in the calldata
            "57896044618658097711785492504343953926634992332820282019728792003956564819968"
          ]
        ),
        // Conservative gas limit, used because the current relayer
        // has trouble estimating gas for this transaction
        gasLimit: 25e4
      }]
    };
    this.tracker.saveWalletConfig({
      config: config2
    });
    const signature2 = this.coders.signature.encodeSigners(config2, /* @__PURE__ */ new Map(), [hexSubdigest], 0).encoded;
    return {
      bundle,
      signature: signature2
    };
  }
  async buildEIP6492Signature(signature2, status, chainId) {
    const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId);
    if (bootstrapBundle.transactions.length === 0) {
      throw new Error("Cannot build EIP-6492 signature without bootstrap transactions");
    }
    const encoded = defaultAbiCoder.encode(["address", "bytes", "bytes"], [bootstrapBundle.entrypoint, index$1$2.transaction.encodeBundleExecData(bootstrapBundle), signature2]);
    return pack(["bytes", "bytes32"], [encoded, index$1$2.EIP6492.EIP_6492_SUFFIX]);
  }
  async editConfig(changes) {
    const currentConfig = await this.status(0).then((s2) => s2.config);
    const newConfig = this.coders.config.editConfig(currentConfig, _extends$a({}, changes, {
      checkpoint: this.coders.config.checkpointOf(currentConfig).add(1)
    }));
    return this.updateConfig(newConfig);
  }
  async updateConfig(config2) {
    if (!this.coders.config.isWalletConfig(config2)) {
      throw new Error(`Invalid config for wallet ${this.address}`);
    }
    const nextImageHash = this.coders.config.imageHashOf(config2);
    const updateStruct = this.coders.signature.hashSetImageHash(nextImageHash);
    const signature2 = await this.signDigest(updateStruct, 0, false);
    await this.tracker.savePresignedConfiguration({
      wallet: this.address,
      nextConfig: config2,
      signature: signature2
    });
    const reverseConfig = await this.tracker.configOfImageHash({
      imageHash: nextImageHash,
      noCache: true
    });
    if (!reverseConfig || this.coders.config.imageHashOf(reverseConfig) !== nextImageHash) {
      throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`);
    }
  }
  /**
   *  This method is used to bootstrap the wallet on a given chain.
   *  this deploys the wallets and executes all the necessary transactions
   *  for that wallet to start working with the given version.
   *
   *  This usually involves: (a) deploying the wallet, (b) executing migrations
   *
   *  Notice: It should NOT explicitly include chained signatures. Unless internally used
   *  by any of the migrations.
   *
   */
  async buildBootstrapTransactions(status, chainId) {
    var _bundle$transactions;
    const bundle = await this.orchestrator.buildDeployTransaction({
      chainId
    });
    const transactions2 = (_bundle$transactions = bundle == null ? void 0 : bundle.transactions) != null ? _bundle$transactions : [];
    if (!status.onChain.deployed) {
      const deployTransaction = Wallet2.buildDeployTransaction(status.original.context, status.original.imageHash);
      transactions2.push(...deployTransaction.transactions);
    }
    transactions2.length;
    transactions2.push(...status.signedMigrations.map((m2) => ({
      to: m2.tx.entrypoint,
      data: index$1$2.transaction.encodeBundleExecData(m2.tx),
      value: 0,
      gasLimit: 0,
      revertOnError: true,
      delegateCall: false
    })));
    const id2 = status.signedMigrations.length > 0 ? status.signedMigrations[0].tx.intent.id : index$1$2.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, chainId, transactions2);
    const {
      guestModule
    } = this.contextFor(status.version);
    return {
      entrypoint: guestModule,
      transactions: transactions2,
      chainId,
      intent: {
        id: id2,
        wallet: this.address
      }
    };
  }
  async bootstrapTransactions(chainId, prestatus) {
    const status = prestatus || await this.status(chainId);
    return this.buildBootstrapTransactions(status, chainId);
  }
  async doBootstrap(chainId, feeQuote, prestatus) {
    const bootstrapTxs = await this.bootstrapTransactions(chainId, prestatus);
    return this.relayer(chainId).relay(_extends$a({}, bootstrapTxs, {
      chainId
    }), feeQuote);
  }
  signMessage(message, chainId, cantValidateBehavior = "ignore") {
    return this.signDigest(keccak256$2(message), chainId, true, cantValidateBehavior);
  }
  async signTransactions(txs, chainId, pstatus, options) {
    const status = pstatus || await this.status(chainId);
    this.mustBeFullyMigrated(status);
    const wallet = this.walletForStatus(chainId, status);
    const metadata2 = {
      address: this.address,
      digest: "",
      // Set in wallet.signTransactions
      chainId,
      config: {
        version: this.version
      },
      decorate: true,
      cantValidateBehavior: "ignore"
    };
    const nonceOptions = options != null && options.serial ? {
      serial: true
    } : (options == null ? void 0 : options.nonceSpace) !== void 0 ? {
      space: options.nonceSpace
    } : void 0;
    const signed2 = await wallet.signTransactions(txs, nonceOptions, metadata2);
    return _extends$a({}, signed2, {
      signature: await this.decorateSignature(signed2.signature, status)
    });
  }
  async signMigrations(chainId, editConfig) {
    const status = await this.status(chainId);
    if (status.fullyMigrated)
      return false;
    const wallet = this.walletForStatus(chainId, status);
    const nextConfig = editConfig(wallet.config);
    const signed2 = await this.migrator.signNextMigration(this.address, status.version, wallet, nextConfig);
    if (!signed2)
      return false;
    await this.tracker.saveWalletConfig({
      config: nextConfig
    });
    const nextCoder = index$7.coderFor(nextConfig.version).config;
    const nextImageHash = nextCoder.imageHashOf(nextConfig);
    const reverseConfig = await this.tracker.configOfImageHash({
      imageHash: nextImageHash,
      noCache: true
    });
    if (!reverseConfig || nextCoder.imageHashOf(reverseConfig) !== nextImageHash) {
      throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`);
    }
    await this.tracker.saveMigration(this.address, signed2, this.contexts);
    return true;
  }
  async signAllMigrations(editConfig) {
    var _this2 = this;
    const failedChains = [];
    const signedMigrations = await Promise.all(this.networks.map(async function(n2) {
      try {
        return await _this2.signMigrations(n2.chainId, editConfig);
      } catch (error) {
        console.warn(`Failed to sign migrations for chain ${n2.chainId}`, error);
        failedChains.push(n2.chainId);
        return null;
      }
    }));
    const successfulSignedMigrations = signedMigrations.filter((migration2) => migration2 !== null);
    return {
      signedMigrations: successfulSignedMigrations,
      failedChains
    };
  }
  async isMigratedAllChains() {
    var _this3 = this;
    const failedChains = [];
    const statuses = await Promise.all(this.networks.map(async function(n2) {
      try {
        return await _this3.status(n2.chainId);
      } catch (error) {
        failedChains.push(n2.chainId);
        console.warn(`Failed to get status for chain ${n2.chainId}`, error);
        return {
          fullyMigrated: true
        };
      }
    }));
    const migratedAllChains = statuses.every((s2) => s2.fullyMigrated);
    return {
      migratedAllChains,
      failedChains
    };
  }
  async sendSignedTransactions(signedBundle, chainId, quote, pstatus, callback) {
    if (!Array.isArray(signedBundle)) {
      return this.sendSignedTransactions([signedBundle], chainId, quote, pstatus, callback);
    }
    const status = pstatus || await this.status(chainId);
    this.mustBeFullyMigrated(status);
    const decoratedBundle = await this.decorateTransactions(signedBundle, status, chainId);
    callback == null || callback(decoratedBundle);
    return this.relayer(chainId).relay(decoratedBundle, quote);
  }
  async fillGasLimits(txs, chainId, status) {
    const wallet = this.walletForStatus(chainId, status || await this.status(chainId));
    return wallet.fillGasLimits(txs);
  }
  async gasRefundQuotes(txs, chainId, stubSignatureOverrides, status, options) {
    const wstatus = status || await this.status(chainId);
    const wallet = this.walletForStatus(chainId, wstatus);
    const predecorated = await this.predecorateTransactions(txs, wstatus, chainId);
    const transactions2 = index$1$2.transaction.fromTransactionish(this.address, predecorated);
    const stubSignature = wallet.coders.config.buildStubSignature(wallet.config, stubSignatureOverrides);
    const intentId = hexlify(randomBytes$1(32));
    const signedBundle = {
      chainId,
      intent: {
        id: intentId,
        wallet: this.address
      },
      signature: stubSignature,
      transactions: transactions2,
      entrypoint: this.address,
      nonce: 0
      // The relayer also ignored the nonce
    };
    const decoratedBundle = await this.decorateTransactions(signedBundle, wstatus);
    const data = index$1$2.transaction.encodeBundleExecData(decoratedBundle);
    const res = await this.relayer(chainId).getFeeOptionsRaw(decoratedBundle.entrypoint, data, options);
    return _extends$a({}, res, {
      decorated: decoratedBundle
    });
  }
  async prepareTransactions(args) {
    const status = await this.status(args.chainId);
    const transactions2 = await this.fillGasLimits(args.txs, args.chainId, status);
    const gasRefundQuote = await this.gasRefundQuotes(transactions2, args.chainId, args.stubSignatureOverrides, status, {
      simulate: args.simulateForFeeOptions
    });
    const flatDecorated = index$1$2.transaction.unwind(this.address, gasRefundQuote.decorated.transactions);
    return {
      transactions: transactions2,
      flatDecorated,
      feeOptions: gasRefundQuote.options,
      feeQuote: gasRefundQuote.quote
    };
  }
  async sendTransaction(txs, chainId, quote, skipPreDecorate = false, callback, options) {
    const status = await this.status(chainId);
    const predecorated = skipPreDecorate ? txs : await this.predecorateTransactions(txs, status, chainId);
    const hasTxs = index$1$2.transaction.fromTransactionish(this.address, predecorated).length > 0;
    const signed2 = hasTxs ? await this.signTransactions(predecorated, chainId, void 0, options) : void 0;
    const childBundles = await this.orchestrator.predecorateSignedTransactions({
      chainId
    });
    const bundles = [];
    if (signed2 !== void 0 && signed2.transactions.length > 0) {
      bundles.push(signed2);
    }
    bundles.push(...childBundles.filter((b2) => b2.transactions.length > 0));
    return this.sendSignedTransactions(bundles, chainId, quote, void 0, callback);
  }
  async signTypedData(domain2, types2, message, chainId, cantValidateBehavior = "ignore") {
    const digest9 = encodeTypedDataDigest({
      domain: domain2,
      types: types2,
      message
    });
    return this.signDigest(digest9, chainId, true, cantValidateBehavior);
  }
  async getSigners() {
    var _this4 = this;
    const last = (ts) => ts.length ? ts[ts.length - 1] : void 0;
    return (await Promise.all(this.networks.map(async function({
      chainId,
      name: name2
    }) {
      try {
        var _last;
        const status = await _this4.status(chainId);
        let latestImageHash = (_last = last(status.presignedConfigurations)) == null ? void 0 : _last.nextImageHash;
        if (!latestImageHash) {
          if (status.onChain.version !== status.version) {
            const migration2 = last(status.signedMigrations);
            if (migration2) {
              const {
                toVersion,
                toConfig
              } = migration2;
              const _coder = index$7.genericCoderFor(toVersion);
              latestImageHash = _coder.config.imageHashOf(toConfig);
            }
          }
        }
        if (!latestImageHash) {
          latestImageHash = status.onChain.imageHash;
        }
        const latestConfig = await _this4.tracker.configOfImageHash({
          imageHash: latestImageHash
        });
        if (!latestConfig) {
          throw new Error(`unable to find config for image hash ${latestImageHash}`);
        }
        const coder = index$7.genericCoderFor(latestConfig.version);
        const signers = coder.config.signersOf(latestConfig);
        return signers.map((signer2) => _extends$a({}, signer2, {
          network: chainId
        }));
      } catch (error) {
        console.warn(`unable to get signers on network ${chainId} ${name2}`, error);
        return [];
      }
    }))).flat();
  }
  async getAllSigners() {
    var _this5 = this;
    const allSigners = [];
    await Promise.all(this.networks.map(async function(network2) {
      const chainId = network2.chainId;
      const status = await _this5.status(chainId, true);
      const fullChain = [status.onChain.imageHash, ...status.onChain.version !== status.version ? status.signedMigrations.map((m2) => index$7.coderFor(m2.toVersion).config.imageHashOf(m2.toConfig)) : [], ...status.presignedConfigurations.map((update5) => update5.nextImageHash)];
      return Promise.all(fullChain.map(async function(nextImageHash, iconf) {
        const isLast = iconf === fullChain.length - 1;
        const config2 = await _this5.tracker.configOfImageHash({
          imageHash: nextImageHash
        });
        if (!config2) {
          console.warn(`AllSigners may be incomplete, config not found for imageHash ${nextImageHash}`);
          return;
        }
        const coder = index$7.genericCoderFor(config2.version);
        const signers = coder.config.signersOf(config2);
        signers.forEach((signer2) => {
          const exists2 = allSigners.find((s2) => s2.address === signer2.address && s2.network === chainId);
          if (exists2 && isLast && exists2.flaggedForRemoval) {
            exists2.flaggedForRemoval = false;
            return;
          }
          if (exists2)
            return;
          allSigners.push({
            address: signer2.address,
            weight: signer2.weight,
            network: chainId,
            flaggedForRemoval: !isLast
          });
        });
      }));
    }));
    return allSigners;
  }
}
function isAccount(value) {
  return value instanceof Account;
}
const account$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account,
  isAccount
}, Symbol.toStringTag, { value: "Module" }));
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
const WebRPCVersion$1 = "v1";
const WebRPCSchemaVersion$1 = "v0.4.0";
const WebRPCSchemaHash$1 = "9accea267e7db3d66f40d5e0f27db92eb5a29e2f";
let ContractType$1 = /* @__PURE__ */ function(ContractType2) {
  ContractType2["UNKNOWN"] = "UNKNOWN";
  ContractType2["NATIVE"] = "NATIVE";
  ContractType2["ERC20"] = "ERC20";
  ContractType2["ERC721"] = "ERC721";
  ContractType2["ERC1155"] = "ERC1155";
  ContractType2["SEQUENCE_WALLET"] = "SEQUENCE_WALLET";
  ContractType2["ERC20_BRIDGE"] = "ERC20_BRIDGE";
  ContractType2["ERC721_BRIDGE"] = "ERC721_BRIDGE";
  ContractType2["ERC1155_BRIDGE"] = "ERC1155_BRIDGE";
  ContractType2["SEQ_MARKETPLACE"] = "SEQ_MARKETPLACE";
  return ContractType2;
}({});
let EventLogType = /* @__PURE__ */ function(EventLogType2) {
  EventLogType2["UNKNOWN"] = "UNKNOWN";
  EventLogType2["BLOCK_ADDED"] = "BLOCK_ADDED";
  EventLogType2["BLOCK_REMOVED"] = "BLOCK_REMOVED";
  return EventLogType2;
}({});
let EventLogDataType = /* @__PURE__ */ function(EventLogDataType2) {
  EventLogDataType2["EVENT"] = "EVENT";
  EventLogDataType2["TOKEN_TRANSFER"] = "TOKEN_TRANSFER";
  EventLogDataType2["NATIVE_TOKEN_TRANSFER"] = "NATIVE_TOKEN_TRANSFER";
  EventLogDataType2["SEQUENCE_TXN"] = "SEQUENCE_TXN";
  return EventLogDataType2;
}({});
let OrderStatus = /* @__PURE__ */ function(OrderStatus2) {
  OrderStatus2["OPEN"] = "OPEN";
  OrderStatus2["CLOSED"] = "CLOSED";
  OrderStatus2["CANCELLED"] = "CANCELLED";
  return OrderStatus2;
}({});
let TxnTransferType = /* @__PURE__ */ function(TxnTransferType2) {
  TxnTransferType2["UNKNOWN"] = "UNKNOWN";
  TxnTransferType2["SEND"] = "SEND";
  TxnTransferType2["RECEIVE"] = "RECEIVE";
  return TxnTransferType2;
}({});
let TransactionStatus = /* @__PURE__ */ function(TransactionStatus2) {
  TransactionStatus2["FAILED"] = "FAILED";
  TransactionStatus2["SUCCESSFUL"] = "SUCCESSFUL";
  return TransactionStatus2;
}({});
let TransactionType = /* @__PURE__ */ function(TransactionType2) {
  TransactionType2["LegacyTxnType"] = "LegacyTxnType";
  TransactionType2["AccessListTxnType"] = "AccessListTxnType";
  TransactionType2["DynamicFeeTxnType"] = "DynamicFeeTxnType";
  return TransactionType2;
}({});
let SortOrder = /* @__PURE__ */ function(SortOrder2) {
  SortOrder2["DESC"] = "DESC";
  SortOrder2["ASC"] = "ASC";
  return SortOrder2;
}({});
class Indexer {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Indexer/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            version: _data2.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getChainID = (headers, signal) => {
      return this.fetch(this.url("GetChainID"), createHTTPRequest$5({}, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            chainID: _data2.chainID
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getEtherBalance = (args, headers, signal) => {
      return this.fetch(this.url("GetEtherBalance"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            balance: _data2.balance
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenBalances = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenBalances"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            page: _data2.page,
            balances: _data2.balances
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenSupplies = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenSupplies"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            page: _data2.page,
            contractType: _data2.contractType,
            tokenIDs: _data2.tokenIDs
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenSuppliesMap = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenSuppliesMap"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            supplies: _data2.supplies
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getBalanceUpdates = (args, headers, signal) => {
      return this.fetch(this.url("GetBalanceUpdates"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            page: _data2.page,
            balances: _data2.balances
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTransactionHistory = (args, headers, signal) => {
      return this.fetch(this.url("GetTransactionHistory"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            page: _data2.page,
            transactions: _data2.transactions
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.syncBalance = (args, headers, signal) => {
      return this.fetch(this.url("SyncBalance"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.fetchTransactionReceipt = (args, headers, signal) => {
      return this.fetch(this.url("FetchTransactionReceipt"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            receipt: _data2.receipt
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getOrderbookOrders = (args, headers, signal) => {
      return this.fetch(this.url("GetOrderbookOrders"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            page: _data2.page,
            orders: _data2.orders
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTopOrders = (args, headers, signal) => {
      return this.fetch(this.url("GetTopOrders"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            orders: _data2.orders
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.fetchTransactionReceiptWithFilter = (args, headers, signal) => {
      return this.fetch(this.url("FetchTransactionReceiptWithFilter"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            receipt: _data2.receipt
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url("GetAllWebhookListeners"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            listeners: _data2.listeners
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("GetWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            listener: _data2.listener
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("AddWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            status: _data2.status,
            listener: _data2.listener
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("UpdateWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("RemoveWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.toggleWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url("ToggleWebhookListener"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            webhookListener: _data2.webhookListener
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.pauseAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url("PauseAllWebhookListeners"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resumeAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url("ResumeAllWebhookListeners"), createHTTPRequest$5(args, headers, signal)).then((res) => {
        return buildResponse$5(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$5.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.subscribeReceipts = (args, options) => {
      const _fetch = () => this.fetch(this.url("SubscribeReceipts"), createHTTPRequest$5(args, options.headers, options.signal)).then(async function(res) {
        await sseResponse(res, options, _fetch);
      }, (error) => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.subscribeEvents = (args, options) => {
      const _fetch = () => this.fetch(this.url("SubscribeEvents"), createHTTPRequest$5(args, options.headers, options.signal)).then(async function(res) {
        await sseResponse(res, options, _fetch);
      }, (error) => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.subscribeBalanceUpdates = (args, options) => {
      const _fetch = () => this.fetch(this.url("SubscribeBalanceUpdates"), createHTTPRequest$5(args, options.headers, options.signal)).then(async function(res) {
        await sseResponse(res, options, _fetch);
      }, (error) => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const sseResponse = async (res, options, retryFetch) => {
  const {
    onMessage,
    onOpen,
    onClose,
    onError
  } = options;
  if (!res.ok) {
    try {
      await buildResponse$5(res);
    } catch (error) {
      onError(error, retryFetch);
    }
    return;
  }
  if (!res.body) {
    onError(WebrpcBadResponseError$5.new({
      status: res.status,
      cause: "Invalid response, missing body"
    }), retryFetch);
    return;
  }
  onOpen && onOpen();
  const reader2 = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer2 = "";
  let lastReadTime = Date.now();
  const timeout = (10 + 1) * 1e3;
  let intervalId;
  try {
    intervalId = setInterval(() => {
      if (Date.now() - lastReadTime > timeout) {
        throw WebrpcStreamLostError$5.new({
          cause: "Stream timed out"
        });
      }
    }, timeout);
    while (true) {
      let value;
      let done;
      try {
        ;
        ({
          value,
          done
        } = await reader2.read());
        lastReadTime = Date.now();
        buffer2 += decoder.decode(value, {
          stream: true
        });
      } catch (error) {
        let message = "";
        if (error instanceof Error) {
          message = error.message;
        }
        if (error instanceof DOMException && error.name === "AbortError") {
          onError(WebrpcRequestFailedError$5.new({
            message: "AbortError",
            cause: `AbortError: ${message}`
          }), () => {
            throw new Error("Abort signal cannot be used to reconnect");
          });
        } else {
          onError(WebrpcStreamLostError$5.new({
            cause: `reader.read(): ${message}`
          }), retryFetch);
        }
        return;
      }
      let lines = buffer2.split("\n");
      for (let i = 0; i < lines.length - 1; i++) {
        if (lines[i].length == 0) {
          continue;
        }
        let data;
        try {
          data = JSON.parse(lines[i]);
          if (data.hasOwnProperty("webrpcError")) {
            const error = data.webrpcError;
            const code2 = typeof error.code === "number" ? error.code : 0;
            onError((webrpcErrorByCode$5[code2] || WebrpcError$5).new(error), retryFetch);
            return;
          }
        } catch (error) {
          if (error instanceof Error && error.message === "Abort signal cannot be used to reconnect") {
            throw error;
          }
          onError(WebrpcBadResponseError$5.new({
            status: res.status,
            // @ts-ignore
            cause: `JSON.parse(): ${error.message}`
          }), retryFetch);
        }
        onMessage(data);
      }
      if (!done) {
        buffer2 = lines[lines.length - 1];
        continue;
      }
      onClose && onClose();
      return;
    }
  } catch (error) {
    if (error instanceof WebrpcStreamLostError$5) {
      onError(error, retryFetch);
    } else {
      throw error;
    }
  } finally {
    clearInterval(intervalId);
  }
};
const createHTTPRequest$5 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$9({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$5 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$5.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$5[code2] || WebrpcError$5).new(data);
    }
    return data;
  });
};
let WebrpcError$5 = class WebrpcError3 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError3.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$5 = class WebrpcEndpointError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError3.prototype);
  }
};
let WebrpcRequestFailedError$5 = class WebrpcRequestFailedError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError3.prototype);
  }
};
let WebrpcBadRouteError$5 = class WebrpcBadRouteError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError3.prototype);
  }
};
let WebrpcBadMethodError$5 = class WebrpcBadMethodError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError3.prototype);
  }
};
let WebrpcBadRequestError$5 = class WebrpcBadRequestError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError3.prototype);
  }
};
let WebrpcBadResponseError$5 = class WebrpcBadResponseError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError3.prototype);
  }
};
let WebrpcServerPanicError$5 = class WebrpcServerPanicError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError3.prototype);
  }
};
let WebrpcInternalErrorError$5 = class WebrpcInternalErrorError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError3.prototype);
  }
};
let WebrpcClientDisconnectedError$5 = class WebrpcClientDisconnectedError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError3.prototype);
  }
};
let WebrpcStreamLostError$5 = class WebrpcStreamLostError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError3.prototype);
  }
};
let WebrpcStreamFinishedError$5 = class WebrpcStreamFinishedError3 extends WebrpcError$5 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError3.prototype);
  }
};
let UnauthorizedError$4 = class UnauthorizedError3 extends WebrpcError$5 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError3.prototype);
  }
};
let PermissionDeniedError$2 = class PermissionDeniedError3 extends WebrpcError$5 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError3.prototype);
  }
};
let SessionExpiredError$3 = class SessionExpiredError2 extends WebrpcError$5 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError2.prototype);
  }
};
let MethodNotFoundError$1 = class MethodNotFoundError2 extends WebrpcError$5 {
  constructor(name2 = "MethodNotFound", code2 = 1003, message = "Method not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError2.prototype);
  }
};
let RequestConflictError$1 = class RequestConflictError extends WebrpcError$5 {
  constructor(name2 = "RequestConflict", code2 = 1004, message = "Conflict with target resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RequestConflictError.prototype);
  }
};
let AbortedError$1 = class AbortedError3 extends WebrpcError$5 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError3.prototype);
  }
};
let TimeoutError$2 = class TimeoutError extends WebrpcError$5 {
  constructor(name2 = "Timeout", code2 = 2e3, message = "Request timed out", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TimeoutError.prototype);
  }
};
let InvalidArgumentError$3 = class InvalidArgumentError3 extends WebrpcError$5 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError3.prototype);
  }
};
let UnavailableError$1 = class UnavailableError3 extends WebrpcError$5 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError3.prototype);
  }
};
let QueryFailedError$3 = class QueryFailedError3 extends WebrpcError$5 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError3.prototype);
  }
};
class ResourceExhaustedError extends WebrpcError$5 {
  constructor(name2 = "ResourceExhausted", code2 = 2004, message = "Resource exhausted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ResourceExhaustedError.prototype);
  }
}
let NotFoundError$4 = class NotFoundError3 extends WebrpcError$5 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError3.prototype);
  }
};
let ProjectNotFoundError$1 = class ProjectNotFoundError extends WebrpcError$5 {
  constructor(name2 = "ProjectNotFound", code2 = 3002, message = "Project not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype);
  }
};
class MetadataCallFailedError extends WebrpcError$5 {
  constructor(name2 = "MetadataCallFailed", code2 = 3003, message = "Metadata service call failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MetadataCallFailedError.prototype);
  }
}
let errors$1 = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["SessionExpired"] = "SessionExpired";
  errors2["MethodNotFound"] = "MethodNotFound";
  errors2["RequestConflict"] = "RequestConflict";
  errors2["Aborted"] = "Aborted";
  errors2["Timeout"] = "Timeout";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["Unavailable"] = "Unavailable";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["ResourceExhausted"] = "ResourceExhausted";
  errors2["NotFound"] = "NotFound";
  errors2["ProjectNotFound"] = "ProjectNotFound";
  errors2["MetadataCallFailed"] = "MetadataCallFailed";
  return errors2;
}({});
const webrpcErrorByCode$5 = {
  [0]: WebrpcEndpointError$5,
  [-1]: WebrpcRequestFailedError$5,
  [-2]: WebrpcBadRouteError$5,
  [-3]: WebrpcBadMethodError$5,
  [-4]: WebrpcBadRequestError$5,
  [-5]: WebrpcBadResponseError$5,
  [-6]: WebrpcServerPanicError$5,
  [-7]: WebrpcInternalErrorError$5,
  [-8]: WebrpcClientDisconnectedError$5,
  [-9]: WebrpcStreamLostError$5,
  [-10]: WebrpcStreamFinishedError$5,
  [1e3]: UnauthorizedError$4,
  [1001]: PermissionDeniedError$2,
  [1002]: SessionExpiredError$3,
  [1003]: MethodNotFoundError$1,
  [1004]: RequestConflictError$1,
  [1005]: AbortedError$1,
  [2e3]: TimeoutError$2,
  [2001]: InvalidArgumentError$3,
  [2002]: UnavailableError$1,
  [2003]: QueryFailedError$3,
  [2004]: ResourceExhaustedError,
  [3e3]: NotFoundError$4,
  [3002]: ProjectNotFoundError$1,
  [3003]: MetadataCallFailedError
};
const fetch$3 = typeof global$1 === "object" ? global$1.fetch : window.fetch;
class SequenceIndexer extends Indexer {
  constructor(hostname, projectAccessKey2, jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$3);
    this.projectAccessKey = projectAccessKey2;
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init3) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      const projectAccessKey3 = this.projectAccessKey;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      if (projectAccessKey3 && projectAccessKey3.length > 0) {
        headers["X-Access-Key"] = projectAccessKey3;
      }
      init3.headers = _extends$9({}, init3.headers, headers);
      return fetch$3(input2, init3);
    };
    this.fetch = this._fetch;
  }
}
const indexer$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortedError: AbortedError$1,
  ContractType: ContractType$1,
  EventLogDataType,
  EventLogType,
  Indexer,
  InvalidArgumentError: InvalidArgumentError$3,
  MetadataCallFailedError,
  MethodNotFoundError: MethodNotFoundError$1,
  NotFoundError: NotFoundError$4,
  OrderStatus,
  PermissionDeniedError: PermissionDeniedError$2,
  ProjectNotFoundError: ProjectNotFoundError$1,
  QueryFailedError: QueryFailedError$3,
  RequestConflictError: RequestConflictError$1,
  ResourceExhaustedError,
  SequenceIndexer,
  SessionExpiredError: SessionExpiredError$3,
  SortOrder,
  TimeoutError: TimeoutError$2,
  TransactionStatus,
  TransactionType,
  TxnTransferType,
  UnauthorizedError: UnauthorizedError$4,
  UnavailableError: UnavailableError$1,
  WebRPCSchemaHash: WebRPCSchemaHash$1,
  WebRPCSchemaVersion: WebRPCSchemaVersion$1,
  WebRPCVersion: WebRPCVersion$1,
  WebrpcBadMethodError: WebrpcBadMethodError$5,
  WebrpcBadRequestError: WebrpcBadRequestError$5,
  WebrpcBadResponseError: WebrpcBadResponseError$5,
  WebrpcBadRouteError: WebrpcBadRouteError$5,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$5,
  WebrpcEndpointError: WebrpcEndpointError$5,
  WebrpcError: WebrpcError$5,
  WebrpcInternalErrorError: WebrpcInternalErrorError$5,
  WebrpcRequestFailedError: WebrpcRequestFailedError$5,
  WebrpcServerPanicError: WebrpcServerPanicError$5,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$5,
  WebrpcStreamLostError: WebrpcStreamLostError$5,
  errors: errors$1
}, Symbol.toStringTag, { value: "Module" }));
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
const WebRPCVersion = "v1";
const WebRPCSchemaVersion = "v0.4.0";
const WebRPCSchemaHash = "d5ad7dcea438ee205efb2a08dcfde61c2226625d";
let ContractType = /* @__PURE__ */ function(ContractType2) {
  ContractType2["UNKNOWN"] = "UNKNOWN";
  ContractType2["ERC20"] = "ERC20";
  ContractType2["ERC721"] = "ERC721";
  ContractType2["ERC1155"] = "ERC1155";
  return ContractType2;
}({});
let PropertyType = /* @__PURE__ */ function(PropertyType2) {
  PropertyType2["INT"] = "INT";
  PropertyType2["STRING"] = "STRING";
  PropertyType2["ARRAY"] = "ARRAY";
  PropertyType2["GENERIC"] = "GENERIC";
  return PropertyType2;
}({});
let SwapType = /* @__PURE__ */ function(SwapType2) {
  SwapType2["UNKNOWN"] = "UNKNOWN";
  SwapType2["BUY"] = "BUY";
  SwapType2["SELL"] = "SELL";
  return SwapType2;
}({});
let TaskStatus = /* @__PURE__ */ function(TaskStatus2) {
  TaskStatus2["PENDING"] = "PENDING";
  TaskStatus2["PAUSED"] = "PAUSED";
  TaskStatus2["FAILED"] = "FAILED";
  TaskStatus2["COMPLETED"] = "COMPLETED";
  TaskStatus2["DISABLED"] = "DISABLED";
  return TaskStatus2;
}({});
class Metadata {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Metadata/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$4({}, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$4({}, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            version: _data2.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$4({}, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenMetadata = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            tokenMetadata: _data2.tokenMetadata
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.refreshTokenMetadata = (args, headers, signal) => {
      return this.fetch(this.url("RefreshTokenMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            taskId: _data2.taskId
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.enqueueTokensForRefresh = (args, headers, signal) => {
      return this.fetch(this.url("EnqueueTokensForRefresh"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            taskId: _data2.taskId
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenRefreshStatus = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenRefreshStatus"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenRefreshResult = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenRefreshResult"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            status: _data2.status,
            tokens: _data2.tokens,
            failureReasons: _data2.failureReasons
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.cancelRefreshJob = (args, headers, signal) => {
      return this.fetch(this.url("CancelRefreshJob"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getTokenMetadataBatch = (args, headers, signal) => {
      return this.fetch(this.url("GetTokenMetadataBatch"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            contractTokenMetadata: _data2.contractTokenMetadata
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchTokenMetadata = (args, headers, signal) => {
      return this.fetch(this.url("SearchTokenMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            page: _data2.page,
            tokenMetadata: _data2.tokenMetadata
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchTokenIDs = (args, headers, signal) => {
      return this.fetch(this.url("SearchTokenIDs"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            page: _data2.page,
            tokenIds: _data2.tokenIds
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.tokenCollectionFilters = (args, headers, signal) => {
      return this.fetch(this.url("TokenCollectionFilters"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            filters: _data2.filters
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getContractInfo = (args, headers, signal) => {
      return this.fetch(this.url("GetContractInfo"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            contractInfo: _data2.contractInfo
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getContractInfoBatch = (args, headers, signal) => {
      return this.fetch(this.url("GetContractInfoBatch"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            contractInfoMap: _data2.contractInfoMap
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchContractInfo = (args, headers, signal) => {
      return this.fetch(this.url("SearchContractInfo"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            contractInfoList: _data2.contractInfoList
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchContractInfoBatch = (args, headers, signal) => {
      return this.fetch(this.url("SearchContractInfoBatch"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            contractInfoByChain: _data2.contractInfoByChain
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchMetadata = (args, headers, signal) => {
      return this.fetch(this.url("SearchMetadata"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            tokenMetadata: _data2.tokenMetadata,
            contractInfo: _data2.contractInfo
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchTokens = (args, headers, signal) => {
      return this.fetch(this.url("SearchTokens"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            tokenMetadata: _data2.tokenMetadata,
            nextPage: _data2.nextPage
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.searchContracts = (args, headers, signal) => {
      return this.fetch(this.url("SearchContracts"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            contractInfo: _data2.contractInfo,
            nextPage: _data2.nextPage
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getNiftyswapTokenQuantity = (args, headers, signal) => {
      return this.fetch(this.url("GetNiftyswapTokenQuantity"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            quantity: _data2.quantity
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getNiftyswapUnitPrices = (args, headers, signal) => {
      return this.fetch(this.url("GetNiftyswapUnitPrices"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            prices: _data2.prices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getNiftyswapUnitPricesWithQuantities = (args, headers, signal) => {
      return this.fetch(this.url("GetNiftyswapUnitPricesWithQuantities"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            prices: _data2.prices
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.addContractToMintMonitor = (args, headers, signal) => {
      return this.fetch(this.url("AddContractToMintMonitor"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeContractFromMintMonitor = (args, headers, signal) => {
      return this.fetch(this.url("RemoveContractFromMintMonitor"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.mintMonitorJobStatus = (args, headers, signal) => {
      return this.fetch(this.url("MintMonitorJobStatus"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            task: _data2.task
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.mintMonitorTriggerJob = (args, headers, signal) => {
      return this.fetch(this.url("MintMonitorTriggerJob"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.syncContractTokens = (args, headers, signal) => {
      return this.fetch(this.url("SyncContractTokens"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            taskID: _data2.taskID
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.abortContractSync = (args, headers, signal) => {
      return this.fetch(this.url("AbortContractSync"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.contractSyncJobStatus = (args, headers, signal) => {
      return this.fetch(this.url("ContractSyncJobStatus"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            refreshTask: _data2.refreshTask,
            syncTask: _data2.syncTask
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.directoryGetNetworks = (args, headers, signal) => {
      return this.fetch(this.url("DirectoryGetNetworks"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            networks: _data2.networks
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.directoryGetCollections = (args, headers, signal) => {
      return this.fetch(this.url("DirectoryGetCollections"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collections: _data2.collections,
            page: _data2.page
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.directorySearchCollections = (args, headers, signal) => {
      return this.fetch(this.url("DirectorySearchCollections"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collections: _data2.collections,
            page: _data2.page
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
class Collections {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Collections/";
    this.createCollection = (args, headers, signal) => {
      return this.fetch(this.url("CreateCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collection: _data2.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getCollection = (args, headers, signal) => {
      return this.fetch(this.url("GetCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collection: _data2.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listCollections = (args, headers, signal) => {
      return this.fetch(this.url("ListCollections"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            page: _data2.page,
            collections: _data2.collections
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateCollection = (args, headers, signal) => {
      return this.fetch(this.url("UpdateCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collection: _data2.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteCollection = (args, headers, signal) => {
      return this.fetch(this.url("DeleteCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.publishCollection = (args, headers, signal) => {
      return this.fetch(this.url("PublishCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collection: _data2.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.unpublishCollection = (args, headers, signal) => {
      return this.fetch(this.url("UnpublishCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collection: _data2.collection
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.createToken = (args, headers, signal) => {
      return this.fetch(this.url("CreateToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            token: _data2.token,
            assets: _data2.assets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getToken = (args, headers, signal) => {
      return this.fetch(this.url("GetToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            token: _data2.token,
            assets: _data2.assets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listTokens = (args, headers, signal) => {
      return this.fetch(this.url("ListTokens"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            page: _data2.page,
            tokens: _data2.tokens
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateToken = (args, headers, signal) => {
      return this.fetch(this.url("UpdateToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            token: _data2.token
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteToken = (args, headers, signal) => {
      return this.fetch(this.url("DeleteToken"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.createAsset = (args, headers, signal) => {
      return this.fetch(this.url("CreateAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            asset: _data2.asset
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getAsset = (args, headers, signal) => {
      return this.fetch(this.url("GetAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            asset: _data2.asset
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.updateAsset = (args, headers, signal) => {
      return this.fetch(this.url("UpdateAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            asset: _data2.asset
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deleteAsset = (args, headers, signal) => {
      return this.fetch(this.url("DeleteAsset"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
class Admin {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Admin/";
    this.addContractsToTokenDirectory = (args, headers, signal) => {
      return this.fetch(this.url("AddContractsToTokenDirectory"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.removeContractsFromTokenDirectory = (args, headers, signal) => {
      return this.fetch(this.url("RemoveContractsFromTokenDirectory"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.modifyFeatureIndex = (args, headers, signal) => {
      return this.fetch(this.url("ModifyFeatureIndex"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getFeatureIndex = (args, headers, signal) => {
      return this.fetch(this.url("GetFeatureIndex"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            featured: _data2.featured
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listTokenDirectory = (args, headers, signal) => {
      return this.fetch(this.url("ListTokenDirectory"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            page: _data2.page,
            collections: _data2.collections
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.linkCollection = (args, headers, signal) => {
      return this.fetch(this.url("LinkCollection"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.listLinkedContracts = (args, headers, signal) => {
      return this.fetch(this.url("ListLinkedContracts"), createHTTPRequest$4(args, headers, signal)).then((res) => {
        return buildResponse$4(res).then((_data2) => {
          return {
            collections: _data2.collections,
            page: _data2.page
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$4.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$4 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$8({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$4 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$4.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$4[code2] || WebrpcError$4).new(data);
    }
    return data;
  });
};
let WebrpcError$4 = class WebrpcError4 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError4.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$4 = class WebrpcEndpointError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError4.prototype);
  }
};
let WebrpcRequestFailedError$4 = class WebrpcRequestFailedError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError4.prototype);
  }
};
let WebrpcBadRouteError$4 = class WebrpcBadRouteError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError4.prototype);
  }
};
let WebrpcBadMethodError$4 = class WebrpcBadMethodError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError4.prototype);
  }
};
let WebrpcBadRequestError$4 = class WebrpcBadRequestError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError4.prototype);
  }
};
let WebrpcBadResponseError$4 = class WebrpcBadResponseError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError4.prototype);
  }
};
let WebrpcServerPanicError$4 = class WebrpcServerPanicError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError4.prototype);
  }
};
let WebrpcInternalErrorError$4 = class WebrpcInternalErrorError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError4.prototype);
  }
};
let WebrpcClientDisconnectedError$4 = class WebrpcClientDisconnectedError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError4.prototype);
  }
};
let WebrpcStreamLostError$4 = class WebrpcStreamLostError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError4.prototype);
  }
};
let WebrpcStreamFinishedError$4 = class WebrpcStreamFinishedError4 extends WebrpcError$4 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError4.prototype);
  }
};
let UnauthorizedError$3 = class UnauthorizedError4 extends WebrpcError$4 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError4.prototype);
  }
};
let PermissionDeniedError$1 = class PermissionDeniedError4 extends WebrpcError$4 {
  constructor(name2 = "PermissionDenied", code2 = 1001, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError4.prototype);
  }
};
let SessionExpiredError$2 = class SessionExpiredError3 extends WebrpcError$4 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError3.prototype);
  }
};
class MethodNotFoundError3 extends WebrpcError$4 {
  constructor(name2 = "MethodNotFound", code2 = 1003, message = "Method not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError3.prototype);
  }
}
class RequestConflictError2 extends WebrpcError$4 {
  constructor(name2 = "RequestConflict", code2 = 1004, message = "Conflict with target resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RequestConflictError2.prototype);
  }
}
class FailError extends WebrpcError$4 {
  constructor(name2 = "Fail", code2 = 1005, message = "Request Failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, FailError.prototype);
  }
}
class GeoblockedError extends WebrpcError$4 {
  constructor(name2 = "Geoblocked", code2 = 1006, message = "Geoblocked region", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, GeoblockedError.prototype);
  }
}
let TimeoutError$1 = class TimeoutError2 extends WebrpcError$4 {
  constructor(name2 = "Timeout", code2 = 2e3, message = "Request timed out", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TimeoutError2.prototype);
  }
};
let InvalidArgumentError$2 = class InvalidArgumentError4 extends WebrpcError$4 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError4.prototype);
  }
};
class RequiredArgumentError extends WebrpcError$4 {
  constructor(name2 = "RequiredArgument", code2 = 2002, message = "Required argument missing", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RequiredArgumentError.prototype);
  }
}
let QueryFailedError$2 = class QueryFailedError4 extends WebrpcError$4 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError4.prototype);
  }
};
let ValidationFailedError$1 = class ValidationFailedError extends WebrpcError$4 {
  constructor(name2 = "ValidationFailed", code2 = 2004, message = "Validation failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ValidationFailedError.prototype);
  }
};
class RateLimitedError extends WebrpcError$4 {
  constructor(name2 = "RateLimited", code2 = 2005, message = "Rate limited", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, RateLimitedError.prototype);
  }
}
let NotFoundError$3 = class NotFoundError4 extends WebrpcError$4 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError4.prototype);
  }
};
class ProjectNotFoundError2 extends WebrpcError$4 {
  constructor(name2 = "ProjectNotFound", code2 = 3002, message = "Project not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ProjectNotFoundError2.prototype);
  }
}
let ChainNotFoundError$1 = class ChainNotFoundError extends WebrpcError$4 {
  constructor(name2 = "ChainNotFound", code2 = 3003, message = "Chain not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ChainNotFoundError.prototype);
  }
};
class TokenDirectoryDisabledError extends WebrpcError$4 {
  constructor(name2 = "TokenDirectoryDisabled", code2 = 4001, message = "Token Directory is disabled", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TokenDirectoryDisabledError.prototype);
  }
}
let errors = /* @__PURE__ */ function(errors2) {
  errors2["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors2["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors2["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors2["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors2["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors2["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors2["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors2["WebrpcInternalError"] = "WebrpcInternalError";
  errors2["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors2["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors2["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors2["Unauthorized"] = "Unauthorized";
  errors2["PermissionDenied"] = "PermissionDenied";
  errors2["SessionExpired"] = "SessionExpired";
  errors2["MethodNotFound"] = "MethodNotFound";
  errors2["RequestConflict"] = "RequestConflict";
  errors2["Fail"] = "Fail";
  errors2["Geoblocked"] = "Geoblocked";
  errors2["Timeout"] = "Timeout";
  errors2["InvalidArgument"] = "InvalidArgument";
  errors2["RequiredArgument"] = "RequiredArgument";
  errors2["QueryFailed"] = "QueryFailed";
  errors2["ValidationFailed"] = "ValidationFailed";
  errors2["RateLimited"] = "RateLimited";
  errors2["NotFound"] = "NotFound";
  errors2["ProjectNotFound"] = "ProjectNotFound";
  errors2["ChainNotFound"] = "ChainNotFound";
  errors2["TokenDirectoryDisabled"] = "TokenDirectoryDisabled";
  return errors2;
}({});
const webrpcErrorByCode$4 = {
  [0]: WebrpcEndpointError$4,
  [-1]: WebrpcRequestFailedError$4,
  [-2]: WebrpcBadRouteError$4,
  [-3]: WebrpcBadMethodError$4,
  [-4]: WebrpcBadRequestError$4,
  [-5]: WebrpcBadResponseError$4,
  [-6]: WebrpcServerPanicError$4,
  [-7]: WebrpcInternalErrorError$4,
  [-8]: WebrpcClientDisconnectedError$4,
  [-9]: WebrpcStreamLostError$4,
  [-10]: WebrpcStreamFinishedError$4,
  [1e3]: UnauthorizedError$3,
  [1001]: PermissionDeniedError$1,
  [1002]: SessionExpiredError$2,
  [1003]: MethodNotFoundError3,
  [1004]: RequestConflictError2,
  [1005]: FailError,
  [1006]: GeoblockedError,
  [2e3]: TimeoutError$1,
  [2001]: InvalidArgumentError$2,
  [2002]: RequiredArgumentError,
  [2003]: QueryFailedError$2,
  [2004]: ValidationFailedError$1,
  [2005]: RateLimitedError,
  [3e3]: NotFoundError$3,
  [3002]: ProjectNotFoundError2,
  [3003]: ChainNotFoundError$1,
  [4001]: TokenDirectoryDisabledError
};
const fetch$2 = typeof global$1 === "object" ? global$1.fetch : window.fetch;
class SequenceMetadata extends Metadata {
  constructor(hostname = "https://metadata.sequence.app", projectAccessKey2, jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$2);
    this.projectAccessKey = projectAccessKey2;
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init3) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      const projectAccessKey3 = this.projectAccessKey;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      if (projectAccessKey3 && projectAccessKey3.length > 0) {
        headers["X-Access-Key"] = projectAccessKey3;
      }
      init3.headers = _extends$8({}, init3.headers, headers);
      return fetch$2(input2, init3);
    };
    this.fetch = this._fetch;
  }
}
class SequenceCollections extends Collections {
  constructor(hostname = "https://metadata.sequence.app", jwtAuth) {
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, fetch$2);
    this.jwtAuth = jwtAuth;
    this._fetch = (input2, init3) => {
      const headers = {};
      const jwtAuth2 = this.jwtAuth;
      if (jwtAuth2 && jwtAuth2.length > 0) {
        headers["Authorization"] = `BEARER ${jwtAuth2}`;
      }
      init3.headers = _extends$8({}, init3.headers, headers);
      return fetch$2(input2, init3);
    };
    this.fetch = this._fetch;
  }
  // TODO: add uploadAsset() method similar to,
  // https://github.com/0xsequence/go-sequence/blob/master/metadata/collections.go#L52
}
const metadata$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Admin,
  ChainNotFoundError: ChainNotFoundError$1,
  Collections,
  ContractType,
  FailError,
  GeoblockedError,
  InvalidArgumentError: InvalidArgumentError$2,
  Metadata,
  MethodNotFoundError: MethodNotFoundError3,
  NotFoundError: NotFoundError$3,
  PermissionDeniedError: PermissionDeniedError$1,
  ProjectNotFoundError: ProjectNotFoundError2,
  PropertyType,
  QueryFailedError: QueryFailedError$2,
  RateLimitedError,
  RequestConflictError: RequestConflictError2,
  RequiredArgumentError,
  SequenceCollections,
  SequenceMetadata,
  SessionExpiredError: SessionExpiredError$2,
  SwapType,
  TaskStatus,
  TimeoutError: TimeoutError$1,
  TokenDirectoryDisabledError,
  UnauthorizedError: UnauthorizedError$3,
  ValidationFailedError: ValidationFailedError$1,
  WebRPCSchemaHash,
  WebRPCSchemaVersion,
  WebRPCVersion,
  WebrpcBadMethodError: WebrpcBadMethodError$4,
  WebrpcBadRequestError: WebrpcBadRequestError$4,
  WebrpcBadResponseError: WebrpcBadResponseError$4,
  WebrpcBadRouteError: WebrpcBadRouteError$4,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError$4,
  WebrpcEndpointError: WebrpcEndpointError$4,
  WebrpcError: WebrpcError$4,
  WebrpcInternalErrorError: WebrpcInternalErrorError$4,
  WebrpcRequestFailedError: WebrpcRequestFailedError$4,
  WebrpcServerPanicError: WebrpcServerPanicError$4,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError$4,
  WebrpcStreamLostError: WebrpcStreamLostError$4,
  errors
}, Symbol.toStringTag, { value: "Module" }));
function useGateway(uri, gateway) {
  const clean = uri.replace("ipfs://ipfs/", "").replace("ipfs://", "");
  if (uri.startsWith("ipfs://"))
    return `${gateway}${clean}`;
  return uri;
}
function isIPFS(uri) {
  return uri.startsWith("ipfs://");
}
class CachedEIP5719 {
  constructor(provider2, solver, window2 = 1e3) {
    this.provider = provider2;
    this.solver = solver;
    this.window = window2;
    this.pending = /* @__PURE__ */ new Map();
  }
  async runByEIP5719(address, digest9, signature2) {
    const key2 = `${address}-${digest9}-${signature2}`;
    const now2 = Date.now();
    if (this.pending.has(key2) && now2 - this.pending.get(key2).timestamp < this.window) {
      return this.pending.get(key2).promise;
    }
    const promise = runByEIP5719(address, this.provider, digest9, signature2, this.solver);
    this.pending.set(key2, {
      timestamp: now2,
      promise
    });
    return promise;
  }
}
function eip5719Contract(address, provider2) {
  const abi2 = [{
    inputs: [{
      internalType: "bytes32",
      type: "bytes32"
    }],
    name: "getAlternativeSignature",
    outputs: [{
      internalType: "string",
      type: "string"
    }],
    stateMutability: "view",
    type: "function"
  }];
  return new Contract(address, abi2, provider2);
}
async function tryAwait(promise) {
  try {
    return await promise;
  } catch (_unused3) {
    return void 0;
  }
}
async function runByEIP5719(address, provider2, digest9, signature2, solver, tries = 0) {
  if (tries > 10)
    throw new Error("EIP5719 - Too many tries");
  if (index$1$2.signer.canRecover(signature2)) {
    const recoveredAddr = index$1$2.signer.recoverSigner(digest9, signature2);
    if (recoveredAddr && recoveredAddr.toLowerCase() === address.toLowerCase())
      return signature2;
  }
  try {
    if (await index$1$2.signer.isValidSignature(address, digest9, signature2, provider2)) {
      return signature2;
    }
  } catch (_unused4) {
  }
  const altUri = await tryAwait(eip5719Contract(address, provider2).getAlternativeSignature(digest9));
  if (!altUri || altUri === "")
    throw new Error("EIP5719 - Invalid signature and no alternative signature");
  const altSignature = hexlify(await (solver || new URISolverIPFS()).resolve(altUri));
  if (!altSignature || altSignature === "")
    throw new Error("EIP5719 - Empty alternative signature");
  if (altSignature === hexlify(signature2))
    throw new Error("EIP5719 - Alternative signature is invalid or the same");
  return runByEIP5719(address, provider2, digest9, altSignature, solver, tries + 1);
}
class URISolverIPFS {
  constructor(gateway = "https://cloudflare-ipfs.com/ipfs/") {
    var _this = this;
    this.gateway = gateway;
    this.uri = (uri) => {
      if (isIPFS(uri))
        return useGateway(uri, this.gateway);
      return uri;
    };
    this.resolve = async function(uri) {
      const url = _this.uri(uri);
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(`URISolverIPFS - Failed to fetch ${url}`);
      return await res.text();
    };
  }
}
const instanceOfAny = (object, constructors) => constructors.some((c2) => object instanceof c2);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db2) => {
    if (terminated)
      db2.addEventListener("close", () => terminated());
    if (blocking) {
      db2.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
class ConfigTracker {
  constructor() {
    this.loadPresignedConfiguration = void 0;
    this.savePresignedConfiguration = void 0;
    this.saveWitnesses = void 0;
    this.configOfImageHash = void 0;
    this.saveWalletConfig = void 0;
    this.imageHashOfCounterfactualWallet = void 0;
    this.saveCounterfactualWallet = void 0;
    this.walletsOfSigner = void 0;
  }
}
var tracker = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ConfigTracker
});
class DebugConfigTracker {
  constructor(tracker2) {
    this.tracker = tracker2;
  }
  async loadPresignedConfiguration(args) {
    console.debug("? loadPresignedConfiguration");
    debug(args, "? ");
    return debug(await this.tracker.loadPresignedConfiguration(args), "! ");
  }
  savePresignedConfiguration(args) {
    console.debug("? savePresignedConfiguration");
    debug(args, "? ");
    return this.tracker.savePresignedConfiguration(args);
  }
  saveWitnesses(args) {
    console.debug("? saveWitnesses");
    debug(args, "? ");
    return this.tracker.saveWitnesses(args);
  }
  async configOfImageHash(args) {
    console.debug("? configOfImageHash");
    debug(args, "? ");
    return debug(await this.tracker.configOfImageHash(args), "! ");
  }
  saveWalletConfig(args) {
    console.debug("? saveWalletConfig");
    debug(args, "? ");
    return this.tracker.saveWalletConfig(args);
  }
  async imageHashOfCounterfactualWallet(args) {
    console.debug("? imageHashOfCounterfactualWallet");
    debug(args, "? ");
    return debug(await this.tracker.imageHashOfCounterfactualWallet(args), "! ");
  }
  saveCounterfactualWallet(args) {
    console.debug("? saveCounterfactualWallet");
    debug(args, "? ");
    return this.tracker.saveCounterfactualWallet(args);
  }
  async walletsOfSigner(args) {
    console.debug("? walletsOfSigner");
    debug(args, "? ");
    return debug(await this.tracker.walletsOfSigner(args), "! ");
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    console.debug("? getMigration");
    debug({
      address,
      fromImageHash,
      fromVersion,
      chainId
    }, "? ");
    return debug(await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId), "! ");
  }
  saveMigration(address, signed2, contexts) {
    console.debug("? saveMigration");
    debug({
      address,
      signed: signed2,
      contexts
    }, "? ");
    return this.tracker.saveMigration(address, signed2, contexts);
  }
}
function debug(value, prefix = "") {
  switch (value) {
    case void 0:
      console.debug(prefix + "undefined");
      break;
    default:
      JSON.stringify(value, void 0, 2).split("\n").map((line) => prefix + line).forEach((line) => console.debug(line));
      break;
  }
  return value;
}
var debug$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DebugConfigTracker
});
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
class MemoryTrackerStore {
  constructor() {
    this.configs = {};
    this.v2Nodes = {};
    this.counterfactualWallets = {};
    this.payloads = {};
    this.signatures = {};
    this.migrations = {};
    this.loadConfig = (imageHash2) => {
      return Promise.resolve(this.configs[imageHash2]);
    };
    this.saveConfig = (imageHash2, config2) => {
      this.configs[imageHash2] = config2;
      return Promise.resolve();
    };
    this.loadV2Node = (nodeHash) => {
      return Promise.resolve(this.v2Nodes[nodeHash]);
    };
    this.saveV2Node = (nodeHash, node) => {
      this.v2Nodes[nodeHash] = node;
      return Promise.resolve();
    };
    this.loadCounterfactualWallet = (wallet) => {
      return Promise.resolve(this.counterfactualWallets[wallet]);
    };
    this.saveCounterfactualWallet = (wallet, imageHash2, context2) => {
      this.counterfactualWallets[wallet] = {
        imageHash: imageHash2,
        context: context2
      };
      return Promise.resolve();
    };
    this.loadPayloadOfSubdigest = (subdigest) => {
      return Promise.resolve(this.payloads[subdigest]);
    };
    this.savePayloadOfSubdigest = (subdigest, payload) => {
      this.payloads[subdigest] = payload;
      return Promise.resolve();
    };
    this.loadSubdigestsOfSigner = (signer2) => {
      return Promise.resolve(Object.keys(this.signatures[signer2] || {}));
    };
    this.loadSignatureOfSubdigest = (signer2, subdigest) => {
      var _this$signatures$sign;
      return Promise.resolve((_this$signatures$sign = this.signatures[signer2]) == null ? void 0 : _this$signatures$sign[subdigest]);
    };
    this.saveSignatureOfSubdigest = (signer2, subdigest, payload) => {
      if (!this.signatures[signer2])
        this.signatures[signer2] = {};
      this.signatures[signer2][subdigest] = payload;
      return Promise.resolve();
    };
    this.loadMigrationsSubdigest = (wallet, fromVersion, toVersion) => {
      var _this$migrations$wall;
      return Promise.resolve(((_this$migrations$wall = this.migrations[wallet]) == null || (_this$migrations$wall = _this$migrations$wall[fromVersion]) == null ? void 0 : _this$migrations$wall[toVersion]) || []);
    };
    this.saveMigrationsSubdigest = (wallet, fromVersion, toVersion, subdigest, toImageHash) => {
      if (!this.migrations[wallet])
        this.migrations[wallet] = {};
      if (!this.migrations[wallet][fromVersion])
        this.migrations[wallet][fromVersion] = {};
      if (!this.migrations[wallet][fromVersion][toVersion])
        this.migrations[wallet][fromVersion][toVersion] = [];
      this.migrations[wallet][fromVersion][toVersion].push({
        subdigest,
        toImageHash
      });
      return Promise.resolve();
    };
  }
}
function recreateBigNumbers(object) {
  if (object === void 0)
    return void 0;
  const result = {};
  for (const key2 of Object.keys(object)) {
    const val = object[key2];
    if (val._isBigNumber === true && val._hex !== void 0 && typeof val._hex === "string" && val._hex.length !== "") {
      result[key2] = BigNumber.from(val);
    } else if (Array.isArray(val)) {
      result[key2] = val.map((v3) => recreateBigNumbers(v3));
    } else if (typeof val === "object" && val !== null) {
      result[key2] = recreateBigNumbers(val);
    } else {
      result[key2] = val;
    }
  }
  return result;
}
class IndexedDBStore {
  constructor(dbName) {
    var _this = this;
    this.dbName = dbName;
    this._lazyDb = void 0;
    this.loadConfig = async function(imageHash2) {
      const db2 = await _this.getDb();
      return db2.get("configs", imageHash2).then((c2) => recreateBigNumbers(c2));
    };
    this.saveConfig = async function(imageHash2, config2) {
      const db2 = await _this.getDb();
      await db2.put("configs", config2, imageHash2);
    };
    this.loadV2Node = async function(nodeHash) {
      const db2 = await _this.getDb();
      return db2.get("v2Nodes", nodeHash).then((c2) => recreateBigNumbers(c2));
    };
    this.saveV2Node = async function(nodeHash, node) {
      const db2 = await _this.getDb();
      await db2.put("v2Nodes", node, nodeHash);
    };
    this.loadCounterfactualWallet = async function(wallet) {
      const db2 = await _this.getDb();
      return db2.get("counterfactualWallets", wallet);
    };
    this.saveCounterfactualWallet = async function(wallet, imageHash2, context2) {
      const db2 = await _this.getDb();
      await db2.put("counterfactualWallets", {
        imageHash: imageHash2,
        context: context2
      }, wallet);
    };
    this.loadPayloadOfSubdigest = async function(subdigest) {
      const db2 = await _this.getDb();
      return db2.get("payloads", subdigest).then((c2) => recreateBigNumbers(c2));
    };
    this.savePayloadOfSubdigest = async function(subdigest, payload) {
      const db2 = await _this.getDb();
      await db2.put("payloads", payload, subdigest);
    };
    this.loadSubdigestsOfSigner = async function(signer2) {
      const db2 = await _this.getDb();
      const index2 = await db2.getAllKeysFromIndex("signatures", "signer", IDBKeyRange.only(signer2));
      return index2.map((key2) => key2.split("-")[0]);
    };
    this.loadSignatureOfSubdigest = async function(signer2, subdigest) {
      const db2 = await _this.getDb();
      const signature2 = await db2.get("signatures", [subdigest, signer2].join("-"));
      return signature2 == null ? void 0 : signature2.signature;
    };
    this.saveSignatureOfSubdigest = async function(signer2, subdigest, payload) {
      const db2 = await _this.getDb();
      await db2.put("signatures", {
        signature: payload,
        signer: signer2
      }, [subdigest, signer2].join("-"));
    };
    this.loadMigrationsSubdigest = async function(wallet, fromVersion, toVersion) {
      const db2 = await _this.getDb();
      const index2 = await db2.getAllFromIndex("migrations", "jump", IDBKeyRange.only([wallet, fromVersion, toVersion]));
      return index2.map((key2) => ({
        subdigest: key2.subdigest,
        toImageHash: key2.toImageHash
      }));
    };
    this.saveMigrationsSubdigest = async function(wallet, fromVersion, toVersion, subdigest, toImageHash) {
      const db2 = await _this.getDb();
      await db2.put("migrations", {
        wallet,
        fromVersion,
        toVersion,
        subdigest,
        toImageHash
      }, subdigest);
    };
  }
  async getDb() {
    if (this._lazyDb)
      return this._lazyDb;
    const dbName = this.dbName;
    this._lazyDb = await openDB(dbName, 1, {
      upgrade(db2, oldVersion, newVersion, transaction2) {
        console.log(`upgrading ${dbName} from ${oldVersion} to ${newVersion} - ${transaction2}`);
        if (oldVersion === 0) {
          db2.createObjectStore("configs");
          db2.createObjectStore("v2Nodes");
          db2.createObjectStore("counterfactualWallets");
          db2.createObjectStore("payloads");
          const signatures = db2.createObjectStore("signatures");
          signatures.createIndex("signer", "signer", {
            unique: false
          });
          const migrations = db2.createObjectStore("migrations");
          migrations.createIndex("jump", ["wallet", "fromVersion", "toVersion"]);
        }
      }
    });
    return this._lazyDb;
  }
}
function isPlainNode(node) {
  return node.left !== void 0 && node.right !== void 0;
}
function isPlainNested(node) {
  return node.weight !== void 0 && node.threshold !== void 0 && node.tree !== void 0;
}
function isPlainV2Config(config2) {
  return config2.version === 2 && config2.threshold !== void 0 && config2.checkpoint !== void 0 && config2.tree !== void 0 && typeof config2.tree === "string";
}
var index$2$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isPlainNode,
  isPlainNested,
  isPlainV2Config,
  MemoryTrackerStore,
  recreateBigNumbers,
  IndexedDBStore
});
class LocalConfigTracker {
  constructor(provider2, store = new MemoryTrackerStore(), useEIP5719 = false) {
    var _this = this;
    this.provider = provider2;
    this.store = store;
    this.useEIP5719 = useEIP5719;
    this.cachedEIP5719 = void 0;
    this.loadTopology = async function(hash2) {
      const node = await _this.store.loadV2Node(hash2);
      if (!node)
        return {
          nodeHash: hash2
        };
      if (isPlainNode(node)) {
        const [left, right] = await Promise.all([_this.loadTopology(node.left), _this.loadTopology(node.right)]);
        return {
          left,
          right
        };
      }
      if (isPlainNested(node)) {
        return {
          weight: BigNumber.from(node.weight),
          threshold: BigNumber.from(node.threshold),
          tree: await _this.loadTopology(node.tree)
        };
      }
      return node;
    };
    this.saveTopology = async function(node) {
      if (v2.config.isNodeLeaf(node)) {
        return;
      }
      const hash2 = v2.config.hashNode(node);
      if (v2.config.isNode(node)) {
        const saveLeft = _this.saveTopology(node.left);
        const saveRight = _this.saveTopology(node.right);
        const saveThis = _this.store.saveV2Node(hash2, {
          left: v2.config.hashNode(node.left),
          right: v2.config.hashNode(node.right)
        });
        await Promise.all([saveLeft, saveRight, saveThis]);
        return;
      }
      if (v2.config.isNestedLeaf(node)) {
        const saveTree = _this.saveTopology(node.tree);
        const saveThis = _this.store.saveV2Node(hash2, {
          weight: BigNumber.from(node.weight).toString(),
          threshold: BigNumber.from(node.threshold).toString(),
          tree: v2.config.hashNode(node.tree)
        });
        await Promise.all([saveTree, saveThis]);
        return;
      }
      if (v2.config.isSignerLeaf(node)) {
        return _this.store.saveV2Node(hash2, {
          address: node.address,
          weight: node.weight
        });
      }
      if (v2.config.isSubdigestLeaf(node)) {
        return _this.store.saveV2Node(hash2, {
          subdigest: node.subdigest
        });
      }
      throw new Error(`Unknown topology type: ${node}`);
    };
    this.saveWalletConfig = async function(args) {
      const {
        config: config2
      } = args;
      if (v1.config.ConfigCoder.isWalletConfig(config2)) {
        const imageHash2 = v1.config.ConfigCoder.imageHashOf(config2);
        return _this.store.saveConfig(imageHash2, config2);
      }
      if (v2.config.ConfigCoder.isWalletConfig(config2)) {
        const imageHash2 = v2.config.ConfigCoder.imageHashOf(config2);
        if (v2.config.isComplete(config2.tree)) {
          return _this.store.saveConfig(imageHash2, config2);
        }
      }
      return;
    };
    this.configOfImageHashCache = {};
    this.configOfImageHash = async function(args) {
      const {
        imageHash: imageHash2
      } = args;
      if (_this.configOfImageHashCache[args.imageHash]) {
        return _this.configOfImageHashCache[args.imageHash];
      }
      const config2 = await _this.store.loadConfig(imageHash2);
      if (!config2) {
        return void 0;
      }
      if (config2.version === 1 || config2.version === 2 && !isPlainV2Config(config2)) {
        _this.configOfImageHashCache[args.imageHash] = config2;
        return config2;
      }
      if (isPlainV2Config(config2)) {
        const fullConfig = {
          version: 2,
          threshold: BigNumber.from(config2.threshold),
          checkpoint: BigNumber.from(config2.checkpoint),
          tree: await _this.loadTopology(config2.tree)
        };
        _this.configOfImageHashCache[args.imageHash] = fullConfig;
        return fullConfig;
      }
      throw new Error(`Unknown config type: ${config2}`);
    };
    this.saveCounterfactualWallet = async function(args) {
      const {
        config: config2,
        context: context2
      } = args;
      const imageHash2 = index$7.genericCoderFor(config2.version).config.imageHashOf(config2);
      await Promise.all([_this.saveWalletConfig({
        config: config2
      }), ...context2.map((ctx) => {
        const address = index$1$2.context.addressOf(ctx, imageHash2);
        return _this.store.saveCounterfactualWallet(address, imageHash2, ctx);
      })]);
    };
    this.imageHashOfCounterfactualWallet = async function(args) {
      const {
        wallet
      } = args;
      const result = await _this.store.loadCounterfactualWallet(wallet);
      if (!result)
        return void 0;
      return {
        imageHash: result.imageHash,
        context: result.context
      };
    };
    this.savePayload = async function(args) {
      const {
        payload
      } = args;
      const subdigest = index$1$2.signature.subdigestOf(payload);
      await _this.store.savePayloadOfSubdigest(subdigest, payload);
    };
    this.payloadOfSubdigestCache = {};
    this.payloadOfSubdigest = async function(args) {
      if (_this.payloadOfSubdigestCache[args.subdigest]) {
        return _this.payloadOfSubdigestCache[args.subdigest];
      }
      const {
        subdigest
      } = args;
      const res = await _this.store.loadPayloadOfSubdigest(subdigest);
      if (res) {
        _this.payloadOfSubdigestCache[subdigest] = res;
      }
      return res;
    };
    this.savePresignedConfiguration = async function(args) {
      const decoded = v2.signature.SignatureCoder.decode(args.signature);
      const nextImageHash = index$7.genericCoderFor(args.nextConfig.version).config.imageHashOf(args.nextConfig);
      const message = v2.chained.messageSetImageHash(nextImageHash);
      const digest9 = keccak256$2(message);
      const payload = {
        message,
        address: args.wallet,
        chainId: 0,
        digest: digest9
      };
      const savePayload = _this.savePayload({
        payload
      });
      const saveNextConfig = _this.saveWalletConfig({
        config: args.nextConfig
      });
      const recovered = await v2.signature.SignatureCoder.recover(decoded, payload, _this.provider);
      const signatures = v2.signature.signaturesOf(recovered.config.tree);
      await Promise.all([savePayload, saveNextConfig, _this.saveWalletConfig({
        config: recovered.config
      }), ...signatures.map((sig) => _this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))]);
    };
    this.loadPresignedConfiguration = async function(args) {
      const {
        wallet,
        fromImageHash,
        longestPath
      } = args;
      const fromConfig = await _this.configOfImageHash({
        imageHash: fromImageHash
      });
      if (!fromConfig || !v2.config.ConfigCoder.isWalletConfig(fromConfig)) {
        return [];
      }
      const signers = v2.config.signersOf(fromConfig.tree).map((s2) => s2.address);
      const subdigestsOfSigner = await Promise.all(signers.map((s2) => _this.store.loadSubdigestsOfSigner(s2)));
      const subdigests = [...new Set(subdigestsOfSigner.flat())];
      const payloads = await Promise.all([...new Set(subdigests)].map(async function(s2) {
        return _extends$7({}, await _this.payloadOfSubdigest({
          subdigest: s2
        }), {
          subdigest: s2
        });
      }));
      const nextImageHashes = payloads.filter((p2) => (p2 == null ? void 0 : p2.message) && (p2 == null ? void 0 : p2.address) && p2.address === wallet).map((p2) => ({
        payload: p2,
        nextImageHash: v2.chained.decodeMessageSetImageHash(p2.message)
      })).filter((p2) => p2 == null ? void 0 : p2.nextImageHash);
      let bestCandidate;
      const nextConfigsAndCheckpoints = await Promise.all(nextImageHashes.map(async function({
        nextImageHash,
        payload
      }) {
        const nextConfig = await _this.configOfImageHash({
          imageHash: nextImageHash
        });
        if (!nextConfig || !v2.config.isWalletConfig(nextConfig))
          return void 0;
        const nextCheckpoint = BigNumber.from(nextConfig.checkpoint);
        return {
          nextConfig,
          nextCheckpoint,
          nextImageHash,
          payload
        };
      }));
      const sortedNextConfigsAndCheckpoints = nextConfigsAndCheckpoints.filter((c2) => c2 !== void 0).filter((c2) => c2.nextCheckpoint.gt(fromConfig.checkpoint)).sort((a2, b2) => (
        // If we are looking for the longest path, sort by ascending checkpoint
        // because we want to find the smalles jump, and we should start with the
        // closest one. If we are not looking for the longest path, sort by
        // descending checkpoint, because we want to find the largest jump.
        //
        // We don't have a guarantee that all "next configs" will be valid
        // so worst case scenario we will need to try all of them.
        // But we can try to optimize for the most common case.
        a2.nextCheckpoint.gt(b2.nextCheckpoint) ? longestPath ? 1 : -1 : longestPath ? -1 : 1
      ));
      for (const entry of sortedNextConfigsAndCheckpoints) {
        const {
          nextConfig,
          nextCheckpoint,
          nextImageHash,
          payload
        } = entry;
        if (bestCandidate) {
          const bestCheckpoint = bestCandidate.checkpoint;
          if (longestPath) {
            if (nextCheckpoint.gte(bestCheckpoint))
              continue;
          } else {
            if (nextCheckpoint.lte(bestCheckpoint))
              continue;
          }
        }
        const signatures = new Map((await Promise.all(signers.map(async function(signer2) {
          const signature2 = await _this.store.loadSignatureOfSubdigest(signer2, payload.subdigest);
          if (!signature2) {
            return [signer2, void 0];
          }
          const replacedSignature = hexlify(_this.useEIP5719 ? await _this.cachedEIP5719.runByEIP5719(signer2, payload.subdigest, signature2) : signature2);
          const isDynamic = index$1$2.signer.tryRecoverSigner(payload.subdigest, replacedSignature) !== signer2;
          return [signer2, {
            isDynamic,
            signature: replacedSignature
          }];
        }))).filter((signature2) => Boolean(signature2[1])));
        if (signatures.size === 0)
          continue;
        const encoded = v2.signature.SignatureCoder.encodeSigners(fromConfig, signatures, [], 0);
        if (encoded.weight.lt(fromConfig.threshold))
          continue;
        bestCandidate = {
          nextImageHash,
          checkpoint: BigNumber.from(nextConfig.checkpoint),
          signature: encoded.encoded
        };
      }
      if (!bestCandidate) {
        return [];
      }
      const nextStep = await _this.loadPresignedConfiguration({
        wallet,
        fromImageHash: bestCandidate.nextImageHash,
        longestPath
      });
      return [{
        wallet,
        nextImageHash: bestCandidate.nextImageHash,
        signature: bestCandidate.signature
      }, ...nextStep];
    };
    this.saveWitnesses = async function(args) {
      const payload = {
        digest: args.digest,
        address: args.wallet,
        chainId: args.chainId
      };
      const subdigest = index$1$2.signature.subdigestOf(payload);
      await Promise.all([_this.savePayload({
        payload
      }), ...args.signatures.filter((signature2) => {
        return index$1$2.signer.canRecover(signature2);
      }).map((signature2) => {
        const signer2 = index$1$2.signer.recoverSigner(subdigest, signature2);
        return _this.store.saveSignatureOfSubdigest(signer2, subdigest, signature2);
      })]);
    };
    this.walletsOfSigner = async function(args) {
      const subdigests = await _this.store.loadSubdigestsOfSigner(args.signer);
      const payloads = await Promise.all(subdigests.map((s2) => _this.payloadOfSubdigest({
        subdigest: s2
      }))).then((p2) => p2.filter((p3) => p3 !== void 0));
      const result = [];
      for (const payload of payloads) {
        const wallet = payload.address;
        if (result.find((r2) => r2.wallet === wallet))
          continue;
        const subdigest = index$1$2.signature.subdigestOf(payload);
        const signature2 = await _this.store.loadSignatureOfSubdigest(args.signer, subdigest);
        if (!signature2)
          continue;
        result.push({
          wallet,
          proof: {
            digest: payload.digest,
            chainId: BigNumber.from(payload.chainId),
            signature: hexlify(signature2)
          }
        });
      }
      return result;
    };
    this.cachedEIP5719 = new CachedEIP5719(provider2);
  }
  async saveMigration(address, signed2, contexts) {
    const fromVersion = signed2.fromVersion;
    if (fromVersion !== 1)
      throw new Error("Migration not supported");
    if (!v2.config.isWalletConfig(signed2.toConfig))
      throw new Error("Invalid to config");
    const {
      newImageHash,
      address: decodedAddress
    } = index$6.v1v2.decodeTransaction(signed2.tx, contexts);
    if (decodedAddress !== address)
      throw new Error("Invalid migration transaction - address");
    if (v2.config.ConfigCoder.imageHashOf(signed2.toConfig) != newImageHash)
      throw new Error("Invalid migration transaction - config");
    const message = index$1$2.transaction.packMetaTransactionsData(signed2.tx.nonce, signed2.tx.transactions);
    const digest9 = keccak256$2(message);
    const payload = {
      chainId: signed2.tx.chainId,
      message,
      address,
      digest: digest9
    };
    const subdigest = index$1$2.signature.subdigestOf(payload);
    const savePayload = this.savePayload({
      payload
    });
    const saveToConfig = this.saveWalletConfig({
      config: signed2.toConfig
    });
    const decoded = v1.signature.SignatureCoder.decode(signed2.tx.signature);
    const recovered = await v1.signature.SignatureCoder.recover(decoded, payload, this.provider);
    const signatures = v1.signature.SignatureCoder.signaturesOf(recovered.config);
    await Promise.all([savePayload, saveToConfig, this.saveWalletConfig({
      config: recovered.config
    }), this.store.saveMigrationsSubdigest(address, fromVersion, fromVersion + 1, subdigest, newImageHash), ...signatures.map((sig) => this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))]);
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    var _this2 = this;
    const [currentConfig, txs] = await Promise.all([this.configOfImageHash({
      imageHash: fromImageHash
    }), this.store.loadMigrationsSubdigest(address, fromVersion, fromVersion + 1)]);
    const coder = index$7.coderFor(fromVersion);
    if (!currentConfig) {
      return void 0;
    }
    if (!coder.config.isWalletConfig(currentConfig)) {
      return void 0;
    }
    const candidates = await Promise.all(txs.map(async function(tx) {
      const {
        subdigest,
        toImageHash
      } = tx;
      const payload = await _this2.payloadOfSubdigest({
        subdigest
      });
      if (!payload || !payload.message)
        return void 0;
      if (!BigNumber.from(chainId).eq(payload.chainId))
        return void 0;
      const signers = coder.config.signersOf(currentConfig).map((s2) => s2.address);
      const signatures = new Map((await Promise.all(signers.map(async function(signer2) {
        const signature2 = await _this2.store.loadSignatureOfSubdigest(signer2, subdigest);
        if (!signature2) {
          return [signer2, void 0];
        }
        const replacedSignature = hexlify(_this2.useEIP5719 ? await _this2.cachedEIP5719.runByEIP5719(signer2, subdigest, signature2) : signature2);
        const isDynamic = index$1$2.signer.tryRecoverSigner(subdigest, replacedSignature) !== signer2;
        return [signer2, {
          isDynamic,
          signature: replacedSignature
        }];
      }))).filter((signature2) => Boolean(signature2[1])));
      const encoded = coder.signature.encodeSigners(currentConfig, signatures, [], chainId);
      if (!encoded || encoded.weight < currentConfig.threshold)
        return void 0;
      const [nonce, transactions2] = index$1$2.transaction.unpackMetaTransactionsData(payload.message);
      return {
        tx: {
          entrypoint: address,
          transactions: index$1$2.transaction.fromTxAbiEncode(transactions2),
          chainId,
          nonce,
          signature: encoded.encoded,
          intent: {
            id: subdigest,
            wallet: address
          }
        },
        toConfig: await _this2.configOfImageHash({
          imageHash: toImageHash
        }),
        fromVersion,
        toVersion: fromVersion + 1
      };
    })).then((c2) => c2.filter((c3) => c3 !== void 0));
    return candidates[0];
  }
  updateProvider(provider2) {
    this.provider = provider2;
  }
}
var local = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LocalConfigTracker
});
let SignatureType = /* @__PURE__ */ function(SignatureType2) {
  SignatureType2["EIP712"] = "EIP712";
  SignatureType2["EthSign"] = "EthSign";
  SignatureType2["EIP1271"] = "EIP1271";
  return SignatureType2;
}({});
class Sessions {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Sessions/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$3({}, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.config = (args, headers, signal) => {
      return this.fetch(this.url("Config"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {
            version: _data2.version,
            config: _data2.config
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.wallets = (args, headers, signal) => {
      return this.fetch(this.url("Wallets"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {
            wallets: _data2.wallets
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.deployHash = (args, headers, signal) => {
      return this.fetch(this.url("DeployHash"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {
            deployHash: _data2.deployHash,
            context: _data2.context
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.configUpdates = (args, headers, signal) => {
      return this.fetch(this.url("ConfigUpdates"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {
            updates: _data2.updates
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.migrations = (args, headers, signal) => {
      return this.fetch(this.url("Migrations"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {
            migrations: _data2.migrations
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveConfig = (args, headers, signal) => {
      return this.fetch(this.url("SaveConfig"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveWallet = (args, headers, signal) => {
      return this.fetch(this.url("SaveWallet"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveSignature = (args, headers, signal) => {
      return this.fetch(this.url("SaveSignature"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveSignerSignatures = (args, headers, signal) => {
      return this.fetch(this.url("SaveSignerSignatures"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.saveMigration = (args, headers, signal) => {
      return this.fetch(this.url("SaveMigration"), createHTTPRequest$3(args, headers, signal)).then((res) => {
        return buildResponse$3(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$3.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$3 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$7({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$3 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$3.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$3[code2] || WebrpcError$3).new(data);
    }
    return data;
  });
};
let WebrpcError$3 = class WebrpcError5 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError5.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$3 = class WebrpcEndpointError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError5.prototype);
  }
};
let WebrpcRequestFailedError$3 = class WebrpcRequestFailedError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError5.prototype);
  }
};
let WebrpcBadRouteError$3 = class WebrpcBadRouteError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError5.prototype);
  }
};
let WebrpcBadMethodError$3 = class WebrpcBadMethodError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError5.prototype);
  }
};
let WebrpcBadRequestError$3 = class WebrpcBadRequestError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError5.prototype);
  }
};
let WebrpcBadResponseError$3 = class WebrpcBadResponseError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError5.prototype);
  }
};
let WebrpcServerPanicError$3 = class WebrpcServerPanicError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError5.prototype);
  }
};
let WebrpcInternalErrorError$3 = class WebrpcInternalErrorError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError5.prototype);
  }
};
let WebrpcClientDisconnectedError$3 = class WebrpcClientDisconnectedError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError5.prototype);
  }
};
let WebrpcStreamLostError$3 = class WebrpcStreamLostError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError5.prototype);
  }
};
let WebrpcStreamFinishedError$3 = class WebrpcStreamFinishedError5 extends WebrpcError$3 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError5.prototype);
  }
};
let InvalidArgumentError$1 = class InvalidArgumentError5 extends WebrpcError$3 {
  constructor(name2 = "InvalidArgument", code2 = 1, message = "invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError5.prototype);
  }
};
let NotFoundError$2 = class NotFoundError5 extends WebrpcError$3 {
  constructor(name2 = "NotFound", code2 = 2, message = "not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError5.prototype);
  }
};
const webrpcErrorByCode$3 = {
  [0]: WebrpcEndpointError$3,
  [-1]: WebrpcRequestFailedError$3,
  [-2]: WebrpcBadRouteError$3,
  [-3]: WebrpcBadMethodError$3,
  [-4]: WebrpcBadRequestError$3,
  [-5]: WebrpcBadResponseError$3,
  [-6]: WebrpcServerPanicError$3,
  [-7]: WebrpcInternalErrorError$3,
  [-8]: WebrpcClientDisconnectedError$3,
  [-9]: WebrpcStreamLostError$3,
  [-10]: WebrpcStreamFinishedError$3,
  [1]: InvalidArgumentError$1,
  [2]: NotFoundError$2
};
class RemoteConfigTracker {
  constructor(hostname, onlyRecoverable = true) {
    this.onlyRecoverable = onlyRecoverable;
    this.sessions = void 0;
    this.sessions = new Sessions(hostname, fetch);
  }
  async loadPresignedConfiguration(args) {
    try {
      const {
        updates
      } = await this.sessions.configUpdates({
        wallet: args.wallet,
        fromImageHash: args.fromImageHash,
        allUpdates: args.longestPath
      });
      return updates.map(({
        toImageHash,
        signature: signature2
      }) => ({
        wallet: args.wallet,
        nextImageHash: toImageHash,
        signature: signature2
      }));
    } catch (error) {
      if (is404NotFound(error)) {
        return [];
      } else {
        throw error;
      }
    }
  }
  async savePresignedConfiguration(args) {
    const config2 = args.nextConfig;
    const imageHash2 = index$7.genericCoderFor(config2.version).config.imageHashOf(config2);
    const message = v2.signature.setImageHashStruct(imageHash2);
    const digest9 = keccak256$2(message);
    await this.sessions.saveSignature({
      wallet: args.wallet,
      digest: digest9,
      chainID: "0",
      signature: args.signature,
      toConfig: encodeConfig(config2)
    });
  }
  async saveWitnesses(args) {
    let filteredSignatures = args.signatures;
    if (this.onlyRecoverable) {
      filteredSignatures = filteredSignatures.filter((signature2) => {
        return index$1$2.signer.canRecover(signature2);
      });
    }
    await this.sessions.saveSignerSignatures({
      wallet: args.wallet,
      digest: args.digest,
      chainID: numberString(args.chainId),
      signatures: filteredSignatures
    });
  }
  async configOfImageHash(args) {
    try {
      const {
        version: version2,
        config: config2
      } = await this.sessions.config(args);
      return decodeConfig(version2, config2);
    } catch (error) {
      if (is404NotFound(error)) {
        return;
      } else {
        throw error;
      }
    }
  }
  async saveWalletConfig(args) {
    const config2 = encodeConfig(args.config);
    await this.sessions.saveConfig({
      version: args.config.version,
      config: config2
    });
  }
  async imageHashOfCounterfactualWallet(args) {
    try {
      const {
        deployHash,
        context: context2
      } = await this.sessions.deployHash(args);
      return {
        imageHash: deployHash,
        context: context2
      };
    } catch (error) {
      if (is404NotFound(error)) {
        return;
      } else {
        throw error;
      }
    }
  }
  async saveCounterfactualWallet(args) {
    const deployConfig = encodeConfig(args.config);
    await this.sessions.saveWallet({
      version: args.config.version,
      deployConfig
    });
  }
  async walletsOfSigner(args) {
    const {
      wallets
    } = await this.sessions.wallets(args);
    return Object.entries(wallets).map(([wallet, {
      digest: digest9,
      chainID,
      type,
      signature: signature2
    }]) => {
      switch (type) {
        case SignatureType.EIP712:
          signature2 += hexlify(index$1$2.signer.SigType.EIP712).slice(2);
          break;
        case SignatureType.EthSign:
          signature2 += hexlify(index$1$2.signer.SigType.ETH_SIGN).slice(2);
          break;
        case SignatureType.EIP1271:
          signature2 += hexlify(index$1$2.signer.SigType.WALLET_BYTES32).slice(2);
          break;
      }
      return {
        wallet,
        proof: {
          digest: digest9,
          signature: signature2,
          chainId: BigNumber.from(chainID)
        }
      };
    });
  }
  async getMigration(wallet, fromImageHash, fromVersion, chainId) {
    var _this = this;
    const chainIdString = numberString(chainId);
    const {
      migrations
    } = await this.sessions.migrations({
      wallet,
      fromVersion,
      fromImageHash,
      chainID: chainIdString
    });
    const chooseMigration = async function chooseMigration2(chainId2) {
      const migrations_ = migrations[chainId2];
      if (migrations_) {
        const toVersions = Object.keys(migrations_).map(Number).sort((a2, b2) => b2 - a2);
        for (const toVersion of toVersions) {
          for (const [toHash, transactions2] of Object.entries(migrations_[toVersion])) {
            try {
              const toConfig = await _this.configOfImageHash({
                imageHash: toHash
              });
              if (toConfig) {
                return {
                  fromVersion,
                  toVersion,
                  toConfig,
                  tx: {
                    entrypoint: transactions2.executor,
                    transactions: transactions2.transactions,
                    nonce: transactions2.nonce,
                    signature: transactions2.signature,
                    chainId: chainId2,
                    intent: {
                      id: index$1$2.transaction.subdigestOfTransactions(wallet, chainId2, transactions2.nonce, transactions2.transactions),
                      wallet
                    }
                  }
                };
              }
            } catch (error) {
              console.error(error);
            }
          }
        }
      }
      return;
    };
    const migration2 = await chooseMigration(chainIdString);
    if (migration2) {
      return migration2;
    }
    for (const _chainId in migrations) {
      if (_chainId !== chainIdString) {
        const _migration = await chooseMigration(_chainId);
        if (_migration) {
          return _migration;
        }
      }
    }
    return;
  }
  async saveMigration(wallet, signed2, _contexts) {
    await this.sessions.saveMigration({
      wallet,
      fromVersion: signed2.fromVersion,
      toVersion: signed2.toVersion,
      toConfig: encodeConfig(signed2.toConfig),
      executor: signed2.tx.entrypoint,
      transactions: signed2.tx.transactions.map(encodeTransaction),
      nonce: numberString(signed2.tx.nonce),
      signature: signed2.tx.signature,
      chainID: numberString(signed2.tx.chainId)
    });
  }
}
function encodeConfig(config2) {
  switch (config2.version) {
    case 1:
      if (v1.config.ConfigCoder.isWalletConfig(config2)) {
        return {
          threshold: numberNumber(config2.threshold),
          signers: config2.signers.map(({
            weight,
            address
          }) => ({
            weight: numberNumber(weight),
            address
          }))
        };
      } else {
        throw new Error(`not a v${config2.version} config: ${config2}`);
      }
    case 2:
      if (v2.config.ConfigCoder.isWalletConfig(config2)) {
        return {
          threshold: numberNumber(config2.threshold),
          checkpoint: numberNumber(config2.checkpoint),
          tree: encodeV2ConfigTree(config2.tree)
        };
      } else {
        throw new Error(`not a v${config2.version} config: ${config2}`);
      }
    default:
      throw new Error(`unknown version ${config2.version}`);
  }
}
function encodeV2ConfigTree(tree) {
  if (v2.config.isNode(tree)) {
    return {
      left: encodeV2ConfigTree(tree.left),
      right: encodeV2ConfigTree(tree.right)
    };
  } else if (v2.config.isSignerLeaf(tree)) {
    return {
      weight: numberNumber(tree.weight),
      address: tree.address
    };
  } else if (v2.config.isNestedLeaf(tree)) {
    return {
      weight: numberNumber(tree.weight),
      threshold: numberNumber(tree.threshold),
      tree: encodeV2ConfigTree(tree.tree)
    };
  } else if (v2.config.isNodeLeaf(tree)) {
    return {
      node: tree.nodeHash
    };
  } else {
    return _extends$7({}, tree);
  }
}
function decodeConfig(version2, config2) {
  switch (version2) {
    case 1:
      return _extends$7({}, config2, {
        version: version2
      });
    case 2:
      return _extends$7({}, config2, {
        version: version2,
        tree: decodeV2ConfigTree(config2.tree)
      });
    default:
      throw new Error(`unknown version ${version2}`);
  }
}
function decodeV2ConfigTree(tree) {
  switch (typeof tree) {
    case "object":
      const tree_ = _extends$7({}, tree);
      if (tree_.left !== void 0) {
        tree_.left = decodeV2ConfigTree(tree_.left);
      }
      if (tree_.right !== void 0) {
        tree_.right = decodeV2ConfigTree(tree_.right);
      }
      if (tree_.tree !== void 0) {
        tree_.tree = decodeV2ConfigTree(tree_.tree);
      }
      if (tree_.node !== void 0) {
        tree_.nodeHash = tree_.node;
        delete tree_.node;
      }
      return tree_;
    default:
      throw new Error(`v2 config tree ${tree} is not an object`);
  }
}
function encodeTransaction(transaction2) {
  return {
    to: transaction2.to,
    value: transaction2.value !== void 0 ? numberString(transaction2.value) : void 0,
    data: transaction2.data !== void 0 ? hexlify(transaction2.data) : void 0,
    gasLimit: transaction2.gasLimit !== void 0 ? numberString(transaction2.gasLimit) : void 0,
    delegateCall: transaction2.delegateCall,
    revertOnError: transaction2.revertOnError
  };
}
function numberNumber(n2) {
  return BigNumber.from(n2).toNumber();
}
function numberString(n2) {
  return BigNumber.from(n2).toString();
}
function is404NotFound(error) {
  return typeof error === "object" && error.status === 404;
}
var index$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  RemoteConfigTracker
});
function raceUntil(promises, fallback2, evalRes) {
  return new Promise((resolve) => {
    let count2 = 0;
    promises.forEach((p2) => p2.then((val) => {
      if (evalRes(val)) {
        resolve(val);
      } else {
        count2++;
        if (count2 === promises.length) {
          resolve(fallback2);
        }
      }
    }).catch(() => {
      count2++;
      if (count2 === promises.length) {
        resolve(fallback2);
      }
    }));
  });
}
async function allSafe(promises, fallback2) {
  return Promise.all(promises.map((promise) => promise.catch(() => fallback2)));
}
class MultipleTracker {
  constructor(trackers) {
    this.trackers = trackers;
  }
  async configOfImageHash(args) {
    const requests = this.trackers.map(async function(t2, i) {
      return {
        res: await t2.configOfImageHash(args),
        i
      };
    });
    const result1 = await raceUntil(requests, void 0, (val) => {
      if ((val == null ? void 0 : val.res) === void 0)
        return false;
      return index$7.genericCoderFor(val.res.version).config.isComplete(val.res);
    });
    if (result1 != null && result1.res) {
      this.saveWalletConfig({
        config: result1.res,
        skipTracker: result1.i
      });
      return result1.res;
    }
    const tmptracker = new LocalConfigTracker(void 0);
    const results2 = await allSafe(requests, void 0);
    for (const r2 of results2) {
      if (r2 != null && r2.res)
        await tmptracker.saveWalletConfig({
          config: r2.res
        });
    }
    const result2 = await tmptracker.configOfImageHash(args);
    if (result2)
      this.saveWalletConfig({
        config: result2
      });
    return result2;
  }
  async saveWalletConfig(args) {
    await Promise.all(this.trackers.map((t2, i) => {
      if (i === args.skipTracker)
        return;
      return t2.saveWalletConfig(args);
    }));
  }
  async imageHashOfCounterfactualWallet(args) {
    const imageHash2 = await raceUntil(this.trackers.map((t2) => t2.imageHashOfCounterfactualWallet(args)), void 0, (result) => Boolean(result));
    if (imageHash2) {
      this.configOfImageHash({
        imageHash: imageHash2.imageHash
      }).then((config2) => {
        if (config2) {
          this.saveCounterfactualWallet({
            config: config2,
            context: [imageHash2.context]
          });
        }
      });
    }
    return imageHash2;
  }
  async saveCounterfactualWallet(args) {
    await Promise.all(this.trackers.map((t2, i) => {
      if (i === args.skipTracker)
        return;
      return t2.saveCounterfactualWallet(args);
    }));
  }
  async walletsOfSigner(args) {
    const results2 = await allSafe(this.trackers.map((t2) => t2.walletsOfSigner(args)), []).then((r2) => r2.flat());
    const wallets = {};
    for (const r2 of results2) {
      wallets[r2.wallet] = r2.proof;
    }
    const result = Object.keys(wallets).map((w2) => ({
      wallet: w2,
      proof: wallets[w2]
    }));
    const witnesses = /* @__PURE__ */ new Map();
    result.forEach(({
      wallet,
      proof: {
        digest: digest9,
        chainId,
        signature: signature2
      }
    }) => {
      const key2 = `${wallet}-${digest9}-${chainId}`;
      let signatures = witnesses.get(key2);
      if (!signatures) {
        signatures = {
          wallet,
          digest: digest9,
          chainId,
          signatures: []
        };
        witnesses.set(key2, signatures);
      }
      signatures.signatures.push(signature2);
    });
    witnesses.forEach((witnesses2) => this.saveWitnesses(witnesses2));
    return result;
  }
  async saveWitnesses(args) {
    await Promise.all(this.trackers.map((t2) => t2.saveWitnesses(args)));
  }
  async loadPresignedConfiguration(args) {
    var _this = this;
    const results2 = await allSafe(this.trackers.map((t2) => t2.loadPresignedConfiguration(args)), []);
    const checkpoints = await allSafe(results2.map(async function(r2) {
      const last = r2[r2.length - 1];
      const config3 = await _this.configOfImageHash({
        imageHash: last.nextImageHash
      });
      if (!config3)
        return void 0;
      return {
        checkpoint: index$7.genericCoderFor(config3.version).config.checkpointOf(config3),
        result: r2
      };
    }), void 0);
    const best = checkpoints.reduce((acc, val) => {
      if (!val)
        return acc;
      if (!acc)
        return val;
      if (val.checkpoint.gt(acc.checkpoint))
        return val;
      return acc;
    });
    if (!best)
      return [];
    const configs = /* @__PURE__ */ new Map();
    const config2 = (imageHash2) => {
      if (!configs.has(imageHash2)) {
        configs.set(imageHash2, this.configOfImageHash({
          imageHash: imageHash2
        }));
      }
      return configs.get(imageHash2);
    };
    best.result.forEach(async function(res) {
      const nextConfig = await config2(res.nextImageHash);
      if (nextConfig) {
        _this.savePresignedConfiguration({
          wallet: args.wallet,
          nextConfig,
          signature: res.signature
        });
      }
    });
    return best.result;
  }
  async savePresignedConfiguration(args) {
    await Promise.all(this.trackers.map((t2) => t2.savePresignedConfiguration(args)));
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    const results2 = await Promise.all(this.trackers.map((t2) => t2.getMigration(address, fromImageHash, fromVersion, chainId)));
    return results2.find((r2) => !!r2);
  }
  async saveMigration(address, signed2, contexts) {
    await Promise.all(this.trackers.map((t2) => t2.saveMigration(address, signed2, contexts)));
  }
}
class CachedTracker {
  constructor(tracker2, cache, contexts) {
    this.tracker = tracker2;
    this.cache = cache;
    this.contexts = contexts;
  }
  async loadPresignedConfiguration(args) {
    var _this = this;
    const results2 = [this.tracker.loadPresignedConfiguration(args), this.cache.loadPresignedConfiguration(args)];
    let best;
    const [result1, result2] = await Promise.all(results2);
    if (result1.length > 0 && result2.length > 0 && result1[result1.length - 1].nextImageHash === result2[result2.length - 1].nextImageHash) {
      best = args.longestPath === true ? result1.length > result2.length ? result1 : result2 : result1.length < result2.length ? result1 : result2;
    } else {
      var _checkpoints$reduce$r, _checkpoints$reduce;
      const checkpoints = await Promise.all(results2.map(async function(result) {
        const r2 = await result;
        const last = r2[r2.length - 1];
        if (!last)
          return void 0;
        const config2 = await _this.configOfImageHash({
          imageHash: last.nextImageHash
        });
        if (!config2)
          return void 0;
        return {
          checkpoint: index$7.genericCoderFor(config2.version).config.checkpointOf(config2),
          result: r2
        };
      }));
      best = (_checkpoints$reduce$r = (_checkpoints$reduce = checkpoints.reduce((acc, val) => {
        if (!val)
          return acc;
        if (!acc)
          return val;
        if (val.checkpoint.gt(acc.checkpoint))
          return val;
        return acc;
      })) == null ? void 0 : _checkpoints$reduce.result) != null ? _checkpoints$reduce$r : [];
    }
    if (!best)
      return [];
    return best;
  }
  async savePresignedConfiguration(args) {
    await Promise.all([this.tracker.savePresignedConfiguration(args), this.cache.savePresignedConfiguration(args)]);
  }
  async configOfImageHash(args) {
    if (args.noCache !== true) {
      const config3 = await this.cache.configOfImageHash(args);
      if (config3)
        return config3;
    }
    const config2 = await this.tracker.configOfImageHash(args);
    if (config2) {
      await this.cache.saveWalletConfig({
        config: config2
      });
    }
    return config2;
  }
  async saveWalletConfig(args) {
    await Promise.all([this.tracker.saveWalletConfig(args), this.cache.saveWalletConfig(args)]);
  }
  async imageHashOfCounterfactualWallet(args) {
    if (args.noCache !== true) {
      const result1 = await this.cache.imageHashOfCounterfactualWallet(args);
      if (result1)
        return result1;
    }
    const result2 = await this.tracker.imageHashOfCounterfactualWallet(args);
    if (result2) {
      const config2 = await this.configOfImageHash({
        imageHash: result2.imageHash
      });
      if (config2) {
        await this.cache.saveCounterfactualWallet({
          config: config2,
          context: [result2.context]
        });
      }
    }
    return result2;
  }
  async saveCounterfactualWallet(args) {
    await Promise.all([this.tracker.saveCounterfactualWallet(args), this.cache.saveCounterfactualWallet(args)]);
  }
  async walletsOfSigner(args) {
    if (args.noCache) {
      return this.tracker.walletsOfSigner(args);
    }
    const results2 = await Promise.all([this.tracker.walletsOfSigner(args), this.cache.walletsOfSigner(args)]);
    const wallets = /* @__PURE__ */ new Map();
    for (const result of results2) {
      for (const wallet of result) {
        wallets.set(wallet.wallet, wallet);
      }
    }
    return Array.from(wallets.values());
  }
  async saveWitnesses(args) {
    await Promise.all([this.tracker.saveWitnesses(args), this.cache.saveWitnesses(args)]);
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    const migration1 = await this.cache.getMigration(address, fromImageHash, fromVersion, chainId);
    if (migration1)
      return migration1;
    const migration2 = await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId);
    if (migration2) {
      await this.cache.saveMigration(address, migration2, this.contexts);
    }
    return migration2;
  }
  async saveMigration(address, signed2, contexts) {
    await Promise.all([this.tracker.saveMigration(address, signed2, contexts), this.cache.saveMigration(address, signed2, contexts)]);
  }
}
class PromiseCache2 {
  constructor() {
    this.cache = void 0;
    this.cache = /* @__PURE__ */ new Map();
  }
  do(key2, validMilliseconds, task, ...args) {
    key2 = `${key2}:${keccak256$2(toUtf8Bytes(JSON.stringify(args, deterministically)))}`;
    let entry = this.cache.get(key2);
    if (entry) {
      if (entry.expiration) {
        if (/* @__PURE__ */ new Date() >= entry.expiration) {
          entry = void 0;
          this.cache.delete(key2);
        }
      }
    }
    if (!entry) {
      const entry_ = {
        promise: task(...args)
      };
      if (validMilliseconds !== void 0) {
        entry_.promise = entry_.promise.then((result) => {
          entry_.expiration = new Date(Date.now() + validMilliseconds);
          return result;
        });
      }
      entry = entry_;
      this.cache.set(key2, entry);
    }
    return entry.promise;
  }
}
function deterministically(_key, value) {
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    return Object.fromEntries(Object.entries(value).sort());
  }
  return value;
}
function isDedupedTracker(tracker2) {
  return tracker2 instanceof DedupedTracker;
}
class DedupedTracker {
  constructor(tracker2, window2 = 50, verbose = false) {
    this.tracker = tracker2;
    this.window = window2;
    this.verbose = verbose;
    this.cache = new PromiseCache2();
  }
  invalidateCache() {
    this.cache = new PromiseCache2();
  }
  configOfImageHash(args) {
    return this.cache.do("configOfImageHash", this.window, (args2) => this.tracker.configOfImageHash(args2), args);
  }
  getMigration(address, fromImageHash, fromVersion, chainId) {
    return this.cache.do("getMigration", this.window, (...args) => this.tracker.getMigration(...args), address, fromImageHash, fromVersion, chainId);
  }
  saveMigration(address, signed2, contexts) {
    return this.cache.do("saveMigration", void 0, (...args) => this.tracker.saveMigration(...args), address, signed2, contexts);
  }
  loadPresignedConfiguration(args) {
    return this.cache.do("loadPresignedConfiguration", this.window, (args2) => this.tracker.loadPresignedConfiguration(args2), args);
  }
  savePresignedConfiguration(args) {
    return this.cache.do("savePresignedConfiguration", void 0, (args2) => this.tracker.savePresignedConfiguration(args2), args);
  }
  saveWitnesses(args) {
    return this.cache.do("saveWitnesses", void 0, (args2) => this.tracker.saveWitnesses(args2), args);
  }
  saveWalletConfig(args) {
    return this.cache.do("saveWalletConfig", void 0, (args2) => this.tracker.saveWalletConfig(args2), args);
  }
  imageHashOfCounterfactualWallet(args) {
    return this.cache.do("imageHashOfCounterfactualWallet", void 0, (args2) => this.tracker.imageHashOfCounterfactualWallet(args2), args);
  }
  saveCounterfactualWallet(args) {
    return this.cache.do("saveCounterfactualWallet", void 0, (args2) => this.tracker.saveCounterfactualWallet(args2), args);
  }
  walletsOfSigner(args) {
    return this.cache.do("walletsOfSigner", this.window, (args2) => this.tracker.walletsOfSigner(args2), args);
  }
  updateProvider(provider2) {
    if (this.tracker instanceof LocalConfigTracker) {
      this.tracker.updateProvider(provider2);
    }
  }
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  debug: debug$1,
  local,
  remote: index$1$1,
  stores: index$2$1,
  raceUntil,
  allSafe,
  MultipleTracker,
  CachedTracker,
  isDedupedTracker,
  DedupedTracker
});
const sessions$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  tracker,
  trackers: index$4
}, Symbol.toStringTag, { value: "Module" }));
const DEFAULT_SESSION_EXPIRATION$1 = 60 * 60 * 24 * 7;
const EXPIRATION_JWT_MARGIN = 60;
class Services {
  constructor(account2, settings, status = {}, projectAccessKey2) {
    this.account = account2;
    this.settings = settings;
    this.status = status;
    this._initialAuthRequest = void 0;
    this.proofStrings = /* @__PURE__ */ new Map();
    this.onAuthCallbacks = [];
    this.apiClient = void 0;
    this.metadataClient = void 0;
    this.indexerClients = /* @__PURE__ */ new Map();
    this.projectAccessKey = void 0;
    this.projectAccessKey = projectAccessKey2;
  }
  now() {
    return Math.floor(Date.now() / 1e3);
  }
  get expiration() {
    var _this$settings$metada;
    return Math.max((_this$settings$metada = this.settings.metadata.expiration) != null ? _this$settings$metada : DEFAULT_SESSION_EXPIRATION$1, 120);
  }
  onAuth(cb2) {
    this.onAuthCallbacks.push(cb2);
    return () => this.onAuthCallbacks = this.onAuthCallbacks.filter((c2) => c2 !== cb2);
  }
  async dump() {
    if (!this.status.jwt)
      return {
        metadata: this.settings.metadata
      };
    return {
      jwt: {
        token: await this.status.jwt.token,
        expiration: this.status.jwt.expiration
      },
      metadata: this.status.metadata
    };
  }
  auth(maxTries = 5) {
    var _this = this;
    if (this._initialAuthRequest)
      return this._initialAuthRequest;
    this._initialAuthRequest = async function() {
      const url = _this.settings.sequenceApiUrl;
      if (!url)
        throw Error("No sequence api url");
      let jwtAuth;
      for (let i = 1; ; i++) {
        try {
          jwtAuth = (await _this.getJWT(true)).token;
          break;
        } catch (error) {
          if (i === maxTries) {
            console.error(`couldn't authenticate after ${maxTries} attempts`, error);
            throw error;
          }
        }
      }
      return new SequenceAPIClient(url, void 0, jwtAuth);
    }();
    return this._initialAuthRequest;
  }
  async getJWT(tryAuth) {
    var _this2 = this;
    const url = this.settings.sequenceApiUrl;
    if (!url)
      throw Error("No sequence api url");
    if (this.status.jwt) {
      const _jwt = this.status.jwt;
      const _token = await _jwt.token;
      if (this.now() < _jwt.expiration) {
        return {
          token: _token,
          expiration: _jwt.expiration
        };
      }
      this.status.jwt = void 0;
    }
    if (!tryAuth) {
      throw new Error("no auth token in memory");
    }
    const proofStringKey = this.getProofStringKey();
    const {
      proofString,
      expiration
    } = this.getProofString(proofStringKey);
    const jwt = {
      token: proofString.then(async function(proofString2) {
        const api2 = new SequenceAPIClient(url);
        const authResp = await api2.getAuthToken({
          ewtString: proofString2
        });
        if ((authResp == null ? void 0 : authResp.status) === true && authResp.jwtToken.length !== 0) {
          return authResp.jwtToken;
        } else {
          if (!await _this2.isProofStringValid(proofString2)) {
            _this2.proofStrings.delete(proofStringKey);
          }
          throw new Error("no auth token from server");
        }
      }).catch((reason) => {
        this.status.jwt = void 0;
        throw reason;
      }),
      expiration
    };
    this.status.jwt = jwt;
    jwt.token.then((token2) => {
      this.onAuthCallbacks.forEach((cb2) => {
        try {
          cb2({
            status: "fulfilled",
            value: token2
          });
        } catch (_unused) {
        }
      });
    }).catch((reason) => {
      this.onAuthCallbacks.forEach((cb2) => {
        try {
          cb2({
            status: "rejected",
            reason
          });
        } catch (_unused2) {
        }
      });
    });
    const token = await jwt.token;
    return {
      token,
      expiration
    };
  }
  getProofStringKey() {
    return `${this.account.address} - ${this.settings.metadata.name}`;
  }
  async isProofStringValid(proofString) {
    try {
      const ethAuth = new ETHAuth();
      const chainId = BigNumber.from(this.settings.sequenceApiChainId);
      const network2 = findNetworkConfig(this.account.networks, chainId);
      if (!network2)
        throw Error("No network found");
      ethAuth.chainId = chainId.toNumber();
      ethAuth.provider = new StaticJsonRpcProvider(getEthersConnectionInfo(network2.rpcUrl, this.projectAccessKey), {
        name: "",
        chainId: chainId.toNumber()
      });
      await ethAuth.decodeProof(proofString);
      return true;
    } catch (_unused3) {
      return false;
    }
  }
  async getAPIClient(tryAuth = true) {
    if (!this.apiClient) {
      const url = this.settings.sequenceApiUrl;
      if (!url)
        throw Error("No sequence api url");
      const jwtAuth = (await this.getJWT(tryAuth)).token;
      this.apiClient = new SequenceAPIClient(url, void 0, jwtAuth);
    }
    return this.apiClient;
  }
  async getMetadataClient(tryAuth = true) {
    if (!this.metadataClient) {
      const jwtAuth = (await this.getJWT(tryAuth)).token;
      this.metadataClient = new SequenceMetadata(this.settings.sequenceMetadataUrl, void 0, jwtAuth);
    }
    return this.metadataClient;
  }
  async getIndexerClient(chainId, tryAuth = true) {
    const network2 = findNetworkConfig(this.account.networks, chainId);
    if (!network2) {
      throw Error(`No network for chain ${chainId}`);
    }
    if (!this.indexerClients.has(network2.chainId)) {
      if (network2.indexer) {
        this.indexerClients.set(network2.chainId, network2.indexer);
      } else if (network2.indexerUrl) {
        const jwtAuth = (await this.getJWT(tryAuth)).token;
        this.indexerClients.set(network2.chainId, new SequenceIndexer(network2.indexerUrl, void 0, jwtAuth));
      } else {
        throw Error(`No indexer url for chain ${chainId}`);
      }
    }
    return this.indexerClients.get(network2.chainId);
  }
  getProofString(key2) {
    if (this.proofStrings.has(key2)) {
      const _proofString = this.proofStrings.get(key2);
      if (this.now() < _proofString.expiration) {
        return _proofString;
      }
      this.proofStrings.delete(key2);
    }
    const proof = new Proof({
      address: this.account.address
    });
    proof.claims.app = this.settings.metadata.name;
    if (typeof window === "object") {
      proof.claims.ogn = window.location.origin;
    }
    proof.setExpiryIn(this.expiration);
    const ethAuth = new ETHAuth();
    const chainId = BigNumber.from(this.settings.sequenceApiChainId);
    const network2 = findNetworkConfig(this.account.networks, chainId);
    if (!network2)
      throw Error("No network found");
    ethAuth.chainId = chainId.toNumber();
    ethAuth.provider = new StaticJsonRpcProvider(getEthersConnectionInfo(network2.rpcUrl, this.projectAccessKey), {
      name: "",
      chainId: chainId.toNumber()
    });
    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN;
    const proofString = {
      proofString: Promise.resolve(
        // NOTICE: TODO: Here we ask the account to sign the message
        // using whatever configuration we have ON-CHAIN, this means
        // that the account will still use the v1 wallet, even if the migration
        // was signed.
        //
        // This works for Sequence webapp v1 -> v2 because all v1 configurations share the same formula
        // (torus + guard), but if we ever decide to allow cross-device login, then it will not work, because
        // those other signers may not be part of the configuration.
        //
        this.account.signDigest(proof.messageDigest(), this.settings.sequenceApiChainId, true, "eip6492")
      ).then((s2) => {
        proof.signature = s2;
        return ethAuth.encodeProof(proof, true);
      }).catch((reason) => {
        this.proofStrings.delete(key2);
        throw reason;
      }),
      expiration
    };
    this.proofStrings.set(key2, proofString);
    return proofString;
  }
}
const signAuthorization = async (signer2, chainId, options) => {
  const address = getAddress$1(await signer2.getAddress());
  if (!address || address === "" || address === "0x") {
    throw ErrAccountIsRequired;
  }
  const proof = new Proof();
  proof.address = address;
  if (!options || !options.app || options.app === "") {
    throw new AuthError("authorization options requires app to be set");
  }
  proof.claims.app = options.app;
  proof.claims.ogn = options.origin;
  proof.claims.n = options.nonce;
  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION$1);
  const typedData = proof.messageTypedData();
  const chainIdNumber = toChainIdNumber(chainId);
  proof.signature = await (signer2 instanceof Account ? (
    // Account can sign EIP-6492 signatures, so it doesn't require deploying the wallet
    signer2.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber, "eip6492")
  ) : signer2.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber));
  const ethAuth = new ETHAuth();
  const proofString = await ethAuth.encodeProof(proof, true);
  return {
    typedData,
    proofString
  };
};
class AuthError extends Error {
  constructor(message) {
    super(message);
    this.name = "AuthError";
  }
}
const ErrAccountIsRequired = new AuthError("auth error: account address is empty");
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function isSessionDumpV1(obj) {
  return obj.config && obj.metadata && obj.version === void 0;
}
function isSessionDumpV2(obj) {
  return obj.version === 2 && obj.address;
}
const CRITICAL_CHAINS = [1, 137];
const SessionSettingsDefault = {
  contexts: index$1$2.context.defaultContexts,
  networks: allNetworks,
  tracker: new index$4.remote.RemoteConfigTracker("https://sessions.sequence.app")
};
class Session {
  constructor(networks2, contexts, account2, services) {
    this.networks = networks2;
    this.contexts = contexts;
    this.account = account2;
    this.services = services;
  }
  async dump() {
    const base2 = {
      version: 2,
      address: this.account.address
    };
    if (this.services) {
      return _extends$6({}, base2, await this.services.dump());
    }
    return base2;
  }
  static async singleSigner(args) {
    let {
      signer: signer2
    } = args;
    if (typeof signer2 === "string") {
      signer2 = new Wallet$1(signer2);
    }
    const orchestrator = new Orchestrator([signer2]);
    const referenceSigner = await signer2.getAddress();
    const threshold = 1;
    const addSigners = [{
      weight: 1,
      address: referenceSigner
    }];
    const selectWallet = args.selectWallet || async function(wallets) {
      var _args$settings$tracke, _args$settings;
      if (wallets.length === 0)
        return void 0;
      const tracker2 = (_args$settings$tracke = (_args$settings = args.settings) == null ? void 0 : _args$settings.tracker) != null ? _args$settings$tracke : SessionSettingsDefault.tracker;
      const configs = await Promise.all(wallets.map(async function(wallet) {
        const imageHash2 = await tracker2.imageHashOfCounterfactualWallet({
          wallet
        });
        return {
          wallet,
          config: imageHash2 && await tracker2.configOfImageHash({
            imageHash: imageHash2.imageHash
          })
        };
      }));
      for (const config2 of configs) {
        if (!config2.config) {
          continue;
        }
        const coder = index$7.genericCoderFor(config2.config.version);
        const signers = coder.config.signersOf(config2.config);
        if (signers.length === 1 && signers[0].address === referenceSigner) {
          return config2.wallet;
        }
      }
      return void 0;
    };
    return Session.open(_extends$6({}, args, {
      orchestrator,
      referenceSigner,
      threshold,
      addSigners,
      selectWallet
    }));
  }
  static async open(args) {
    var _findNetworkConfig$ch, _findNetworkConfig, _settings$services$se, _settings$services, _networks$;
    const {
      referenceSigner,
      threshold,
      addSigners,
      selectWallet,
      onAccountAddress,
      settings,
      editConfigOnMigration,
      onMigration,
      orchestrator,
      projectAccessKey: projectAccessKey2
    } = args;
    const {
      contexts,
      networks: networks2,
      tracker: tracker2,
      services
    } = _extends$6({}, SessionSettingsDefault, settings);
    const referenceChainId = (_findNetworkConfig$ch = (_findNetworkConfig = findNetworkConfig(networks2, (_settings$services$se = settings == null || (_settings$services = settings.services) == null ? void 0 : _settings$services.sequenceApiChainId) != null ? _settings$services$se : ChainId.MAINNET)) == null ? void 0 : _findNetworkConfig.chainId) != null ? _findNetworkConfig$ch : (_networks$ = networks2[0]) == null ? void 0 : _networks$.chainId;
    if (!referenceChainId)
      throw Error("No reference chain found");
    const foundWallets = await tracker2.walletsOfSigner({
      signer: referenceSigner
    });
    const selectedWallet = await selectWallet(foundWallets.map((w2) => w2.wallet));
    let account2;
    if (selectedWallet) {
      onAccountAddress == null || onAccountAddress(selectedWallet);
      account2 = new Account({
        address: selectedWallet,
        tracker: tracker2,
        networks: networks2,
        contexts,
        orchestrator,
        projectAccessKey: projectAccessKey2
      });
      if (addSigners && addSigners.length > 0) {
        let status = await account2.status(referenceChainId);
        if (status.original.version !== status.version || account2.version !== status.version) {
          const {
            migratedAllChains: isFullyMigrated,
            failedChains
          } = await account2.isMigratedAllChains();
          if (failedChains.some((c2) => CRITICAL_CHAINS.includes(c2))) {
            throw Error(`Failed to fetch account status on ${failedChains.join(", ")}`);
          }
          if (!isFullyMigrated) {
            if (onMigration && !await onMigration(account2)) {
              throw Error("Migration cancelled, cannot open session");
            }
            const {
              failedChains: _failedChains
            } = await account2.signAllMigrations(editConfigOnMigration || ((c2) => c2));
            if (_failedChains.some((c2) => CRITICAL_CHAINS.includes(c2))) {
              throw Error(`Failed to sign migrations on ${_failedChains.join(", ")}`);
            }
            if (index$4.isDedupedTracker(tracker2)) {
              tracker2.invalidateCache();
            }
            let isFullyMigrated2;
            [isFullyMigrated2, status] = await Promise.all([account2.isMigratedAllChains().then((r2) => r2.migratedAllChains), account2.status(referenceChainId)]);
            if (!isFullyMigrated2)
              throw Error("Failed to migrate account");
          }
        }
        if (status.onChain.version !== status.version) {
          await account2.doBootstrap(referenceChainId, void 0, status);
        }
        const prevConfig = status.config;
        const nextConfig = account2.coders.config.editConfig(prevConfig, {
          add: addSigners,
          threshold
        });
        if (account2.coders.config.imageHashOf(prevConfig) !== account2.coders.config.imageHashOf(nextConfig)) {
          const newConfig = account2.coders.config.editConfig(nextConfig, {
            checkpoint: account2.coders.config.checkpointOf(prevConfig).add(1)
          });
          await account2.updateConfig(newConfig);
        }
      }
    } else {
      if (!addSigners || addSigners.length === 0) {
        throw Error("Cannot create new account without signers");
      }
      if (!threshold) {
        throw Error("Cannot create new account without threshold");
      }
      account2 = await Account.new({
        config: {
          threshold,
          checkpoint: 0,
          signers: addSigners
        },
        tracker: tracker2,
        contexts,
        orchestrator,
        networks: networks2,
        projectAccessKey: projectAccessKey2
      });
      onAccountAddress == null || onAccountAddress(account2.address);
      await account2.publishWitness();
      const _foundWallets = await tracker2.walletsOfSigner({
        signer: referenceSigner,
        noCache: true
      });
      if (!_foundWallets.some((w2) => w2.wallet === account2.address)) {
        throw Error("Account not found on tracker");
      }
    }
    let servicesObj;
    if (services) {
      servicesObj = new Services(account2, services);
      servicesObj.auth();
      servicesObj.onAuth((result) => {
        if (result.status === "fulfilled") {
          account2.setJwt(result.value);
        }
      });
    }
    return new Session(networks2, contexts, account2, servicesObj);
  }
  static async load(args) {
    const {
      dump,
      settings,
      editConfigOnMigration,
      onMigration,
      orchestrator
    } = args;
    const {
      contexts,
      networks: networks2,
      tracker: tracker2,
      services
    } = _extends$6({}, SessionSettingsDefault, settings);
    let account2;
    if (isSessionDumpV1(dump)) {
      var _dump$jwt$expiration, _dump$jwt, _dump$jwt2;
      const oldAddress = dump.config.address || index$1$2.context.addressOf(contexts[1], v1.config.ConfigCoder.imageHashOf(_extends$6({}, dump.config, {
        version: 1
      })));
      const jwtExpired = ((_dump$jwt$expiration = (_dump$jwt = dump.jwt) == null ? void 0 : _dump$jwt.expiration) != null ? _dump$jwt$expiration : 0) < Math.floor(Date.now() / 1e3);
      account2 = new Account({
        address: oldAddress,
        tracker: tracker2,
        networks: networks2,
        contexts,
        orchestrator,
        jwt: jwtExpired ? void 0 : (_dump$jwt2 = dump.jwt) == null ? void 0 : _dump$jwt2.token
      });
      if (!await account2.isMigratedAllChains().then((r2) => r2.migratedAllChains)) {
        if (onMigration && !await onMigration(account2)) {
          throw Error("Migration cancelled, cannot open session");
        }
        console.log("Migrating account...");
        await account2.signAllMigrations(editConfigOnMigration);
        if (!await account2.isMigratedAllChains().then((r2) => r2.migratedAllChains))
          throw Error("Failed to migrate account");
      }
    } else if (isSessionDumpV2(dump)) {
      var _dump$jwt$expiration2, _dump$jwt3, _dump$jwt4;
      const jwtExpired = ((_dump$jwt$expiration2 = (_dump$jwt3 = dump.jwt) == null ? void 0 : _dump$jwt3.expiration) != null ? _dump$jwt$expiration2 : 0) < Math.floor(Date.now() / 1e3);
      account2 = new Account({
        address: dump.address,
        tracker: tracker2,
        networks: networks2,
        contexts,
        orchestrator,
        jwt: jwtExpired ? void 0 : (_dump$jwt4 = dump.jwt) == null ? void 0 : _dump$jwt4.token
      });
    } else {
      throw Error("Invalid dump format");
    }
    let servicesObj;
    if (services) {
      var _dump$jwt$expiration3;
      servicesObj = new Services(account2, services, dump.jwt && {
        jwt: {
          token: Promise.resolve(dump.jwt.token),
          expiration: (_dump$jwt$expiration3 = dump.jwt.expiration) != null ? _dump$jwt$expiration3 : jwtDecodeClaims(dump.jwt.token).exp
        },
        metadata: dump.metadata
      });
    }
    return new Session(networks2, contexts, account2, servicesObj);
  }
}
const ValidateSequenceWalletProof = (readerFor, tracker2, context2) => {
  return async (_provider, chainId, proof) => {
    const digest9 = proof.messageDigest();
    const isValid2 = await readerFor(chainId).isValidSignature(proof.address, digest9, proof.signature);
    return {
      isValid: isValid2
    };
  };
};
const auth$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AuthError,
  CRITICAL_CHAINS,
  ErrAccountIsRequired,
  Session,
  SessionSettingsDefault,
  ValidateSequenceWalletProof,
  isSessionDumpV1,
  isSessionDumpV2,
  signAuthorization
}, Symbol.toStringTag, { value: "Module" }));
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
class Guard {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/Guard/";
    this.ping = (headers, signal) => {
      return this.fetch(this.url("Ping"), createHTTPRequest$2({}, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url("Version"), createHTTPRequest$2({}, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            version: _data2.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url("RuntimeStatus"), createHTTPRequest$2({}, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.getSignerConfig = (args, headers, signal) => {
      return this.fetch(this.url("GetSignerConfig"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            signerConfig: _data2.signerConfig
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sign = (args, headers, signal) => {
      return this.fetch(this.url("Sign"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            sig: _data2.sig
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.signWith = (args, headers, signal) => {
      return this.fetch(this.url("SignWith"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            sig: _data2.sig
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.patch = (args, headers, signal) => {
      return this.fetch(this.url("Patch"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            txs: _data2.txs
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.authMethods = (args, headers, signal) => {
      return this.fetch(this.url("AuthMethods"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            methods: _data2.methods,
            active: _data2.active
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.setPIN = (args, headers, signal) => {
      return this.fetch(this.url("SetPIN"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resetPIN = (args, headers, signal) => {
      return this.fetch(this.url("ResetPIN"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.createTOTP = (args, headers, signal) => {
      return this.fetch(this.url("CreateTOTP"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            uri: _data2.uri
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.commitTOTP = (args, headers, signal) => {
      return this.fetch(this.url("CommitTOTP"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            codes: _data2.codes
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resetTOTP = (args, headers, signal) => {
      return this.fetch(this.url("ResetTOTP"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.reset2FA = (args, headers, signal) => {
      return this.fetch(this.url("Reset2FA"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {};
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.recoveryCodes = (args, headers, signal) => {
      return this.fetch(this.url("RecoveryCodes"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            codes: _data2.codes
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.resetRecoveryCodes = (args, headers, signal) => {
      return this.fetch(this.url("ResetRecoveryCodes"), createHTTPRequest$2(args, headers, signal)).then((res) => {
        return buildResponse$2(res).then((_data2) => {
          return {
            codes: _data2.codes
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$2.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest$2 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$5({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse$2 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$2.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$2[code2] || WebrpcError$2).new(data);
    }
    return data;
  });
};
let WebrpcError$2 = class WebrpcError6 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError6.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
let WebrpcEndpointError$2 = class WebrpcEndpointError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError6.prototype);
  }
};
let WebrpcRequestFailedError$2 = class WebrpcRequestFailedError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError6.prototype);
  }
};
let WebrpcBadRouteError$2 = class WebrpcBadRouteError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError6.prototype);
  }
};
let WebrpcBadMethodError$2 = class WebrpcBadMethodError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError6.prototype);
  }
};
let WebrpcBadRequestError$2 = class WebrpcBadRequestError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError6.prototype);
  }
};
let WebrpcBadResponseError$2 = class WebrpcBadResponseError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError6.prototype);
  }
};
let WebrpcServerPanicError$2 = class WebrpcServerPanicError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError6.prototype);
  }
};
let WebrpcInternalErrorError$2 = class WebrpcInternalErrorError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError6.prototype);
  }
};
let WebrpcClientDisconnectedError$2 = class WebrpcClientDisconnectedError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError6.prototype);
  }
};
let WebrpcStreamLostError$2 = class WebrpcStreamLostError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError6.prototype);
  }
};
let WebrpcStreamFinishedError$2 = class WebrpcStreamFinishedError6 extends WebrpcError$2 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError6.prototype);
  }
};
let UnauthorizedError$2 = class UnauthorizedError5 extends WebrpcError$2 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError5.prototype);
  }
};
let SessionExpiredError$1 = class SessionExpiredError4 extends WebrpcError$2 {
  constructor(name2 = "SessionExpired", code2 = 1002, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError4.prototype);
  }
};
class AbortedError4 extends WebrpcError$2 {
  constructor(name2 = "Aborted", code2 = 1005, message = "Request aborted", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AbortedError4.prototype);
  }
}
class InvalidArgumentError6 extends WebrpcError$2 {
  constructor(name2 = "InvalidArgument", code2 = 2001, message = "Invalid argument", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError6.prototype);
  }
}
class UnavailableError4 extends WebrpcError$2 {
  constructor(name2 = "Unavailable", code2 = 2002, message = "Unavailable resource", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError4.prototype);
  }
}
let QueryFailedError$1 = class QueryFailedError5 extends WebrpcError$2 {
  constructor(name2 = "QueryFailed", code2 = 2003, message = "Query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError5.prototype);
  }
};
class ValidationFailedError2 extends WebrpcError$2 {
  constructor(name2 = "ValidationFailed", code2 = 2004, message = "Validation Failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ValidationFailedError2.prototype);
  }
}
let NotFoundError$1 = class NotFoundError6 extends WebrpcError$2 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError6.prototype);
  }
};
const webrpcErrorByCode$2 = {
  [0]: WebrpcEndpointError$2,
  [-1]: WebrpcRequestFailedError$2,
  [-2]: WebrpcBadRouteError$2,
  [-3]: WebrpcBadMethodError$2,
  [-4]: WebrpcBadRequestError$2,
  [-5]: WebrpcBadResponseError$2,
  [-6]: WebrpcServerPanicError$2,
  [-7]: WebrpcInternalErrorError$2,
  [-8]: WebrpcClientDisconnectedError$2,
  [-9]: WebrpcStreamLostError$2,
  [-10]: WebrpcStreamFinishedError$2,
  [1e3]: UnauthorizedError$2,
  [1002]: SessionExpiredError$1,
  [1005]: AbortedError4,
  [2001]: InvalidArgumentError6,
  [2002]: UnavailableError4,
  [2003]: QueryFailedError$1,
  [2004]: ValidationFailedError2,
  [3e3]: NotFoundError$1
};
const fetch$1 = typeof global$1 === "object" ? global$1.fetch : window.fetch;
class GuardSigner {
  constructor(address, url, appendSuffix = false) {
    this.address = address;
    this.url = url;
    this.appendSuffix = appendSuffix;
    this.guard = void 0;
    this.guard = new Guard(url, fetch$1);
  }
  async getAddress() {
    return this.address;
  }
  async buildDeployTransaction(_metadata) {
    return void 0;
  }
  async predecorateSignedTransactions(_metadata) {
    return [];
  }
  async decorateTransactions(bundle, _metadata) {
    return bundle;
  }
  async sign(message, metadata2) {
    var _metadata$parts;
    if (!index$1$2.isWalletSignRequestMetadata(metadata2)) {
      throw new Error("expected sequence signature request metadata");
    }
    const guardTotpCode = metadata2.guardTotpCode;
    const coder = index$7.genericCoderFor(metadata2.config.version);
    const {
      encoded
    } = coder.signature.encodeSigners(metadata2.config, (_metadata$parts = metadata2.parts) != null ? _metadata$parts : /* @__PURE__ */ new Map(), [], metadata2.chainId);
    return (await this.guard.signWith({
      signer: this.address,
      request: {
        msg: hexlify(message),
        auxData: this.packMsgAndSig(metadata2.address, metadata2.digest, encoded, metadata2.chainId),
        chainId: BigNumber.from(metadata2.chainId).toNumber()
      },
      token: guardTotpCode ? {
        id: AuthMethod.TOTP,
        token: guardTotpCode
      } : void 0
    })).sig;
  }
  notifyStatusChange(_id, _status, _metadata) {
  }
  async getAuthMethods(proof) {
    let response;
    if ("jwt" in proof) {
      response = await this.guard.authMethods({}, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      const signedProof = await signOwnershipProof(proof);
      response = await this.guard.authMethods({
        proof: {
          wallet: signedProof.walletAddress,
          timestamp: signedProof.timestamp.getTime(),
          signer: signedProof.signerAddress,
          signature: signedProof.signature
        }
      });
    }
    return _extends$5({}, response, {
      methods: response.methods.map(parseAuthMethod)
    });
  }
  async setPin(pin, proof) {
    const signedProof = await signAuthUpdateProof(proof);
    if (pin === void 0) {
      await this.guard.resetPIN({
        timestamp: signedProof.timestamp.getTime(),
        signature: signedProof.signature
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      await this.guard.setPIN({
        pin,
        timestamp: signedProof.timestamp.getTime(),
        signature: signedProof.signature
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    }
  }
  resetPin(proof) {
    return this.setPin(void 0, proof);
  }
  async createTotp(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      uri
    } = await this.guard.createTOTP({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return new URL(uri);
  }
  async commitTotp(token, jwt) {
    const {
      codes
    } = await this.guard.commitTOTP({
      token
    }, {
      Authorization: `BEARER ${jwt}`
    });
    return codes;
  }
  async resetTotp(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    await this.guard.resetTOTP({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
  }
  async reset2fa(recoveryCode, proof) {
    if ("jwt" in proof) {
      await this.guard.reset2FA({
        code: recoveryCode
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      const signedProof = await signOwnershipProof(proof);
      await this.guard.reset2FA({
        code: recoveryCode,
        proof: {
          wallet: signedProof.walletAddress,
          timestamp: signedProof.timestamp.getTime(),
          signer: signedProof.signerAddress,
          signature: signedProof.signature
        }
      });
    }
  }
  async getRecoveryCodes(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      codes
    } = await this.guard.recoveryCodes({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return codes;
  }
  async resetRecoveryCodes(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      codes
    } = await this.guard.resetRecoveryCodes({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return codes;
  }
  packMsgAndSig(address, msg, sig, chainId) {
    return defaultAbiCoder.encode(["address", "uint256", "bytes", "bytes"], [address, chainId, msg, sig]);
  }
  suffix() {
    return this.appendSuffix ? [3] : [];
  }
}
let AuthMethod = /* @__PURE__ */ function(AuthMethod2) {
  AuthMethod2["PIN"] = "PIN";
  AuthMethod2["TOTP"] = "TOTP";
  return AuthMethod2;
}({});
function parseAuthMethod(method) {
  switch (method) {
    case AuthMethod.PIN:
    case AuthMethod.TOTP:
      return method;
    default:
      throw new Error(`unknown auth method '${method}'`);
  }
}
function isSignedOwnershipProof(proof) {
  return "signerAddress" in proof && typeof proof.signerAddress === "string";
}
async function signOwnershipProof(proof) {
  if (isSignedOwnershipProof(proof)) {
    return proof;
  } else {
    const signer2 = index$5.isSapientSigner(proof.signer) ? proof.signer : new index$5.SignerWrapper(proof.signer);
    const signerAddress = await signer2.getAddress();
    const timestamp = /* @__PURE__ */ new Date();
    const typedData = getOwnershipProofTypedData(proof.walletAddress, timestamp);
    const digest9 = encodeTypedDataDigest(typedData);
    return {
      walletAddress: proof.walletAddress,
      timestamp,
      signerAddress,
      signature: hexlify(await signer2.sign(digest9, {}))
    };
  }
}
async function signAuthUpdateProof(proof) {
  if ("wallet" in proof) {
    var _typedData$domain$cha;
    const timestamp = /* @__PURE__ */ new Date();
    const typedData = getAuthUpdateProofTypedData(timestamp);
    const signature2 = await proof.wallet.signTypedData(typedData.domain, typedData.types, typedData.message, (_typedData$domain$cha = typedData.domain.chainId) != null ? _typedData$domain$cha : 1, "eip6492");
    return {
      jwt: proof.jwt,
      timestamp,
      signature: signature2
    };
  } else {
    return proof;
  }
}
function getOwnershipProofTypedData(wallet, timestamp) {
  return {
    domain,
    types: {
      AuthMethods: [{
        name: "wallet",
        type: "address"
      }, {
        name: "timestamp",
        type: "string"
      }]
    },
    message: {
      wallet: getAddress$1(wallet),
      timestamp: toUTCString(timestamp)
    }
  };
}
function getAuthUpdateProofTypedData(timestamp) {
  return {
    domain,
    types: {
      AuthUpdate: [{
        name: "timestamp",
        type: "string"
      }]
    },
    message: {
      timestamp: toUTCString(timestamp)
    }
  };
}
const domain = {
  name: "Sequence Guard",
  version: "1",
  chainId: 1
};
function toUTCString(date) {
  return date.toUTCString().replace("GMT", "UTC");
}
const guard$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AuthMethod,
  Guard,
  GuardSigner,
  getAuthUpdateProofTypedData,
  getOwnershipProofTypedData,
  isSignedOwnershipProof,
  signOwnershipProof
}, Symbol.toStringTag, { value: "Module" }));
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
let JsonRpcMethod = /* @__PURE__ */ function(JsonRpcMethod2) {
  JsonRpcMethod2["ethCall"] = "eth_call";
  JsonRpcMethod2["ethGetBalance"] = "eth_getBalance";
  JsonRpcMethod2["ethGetCode"] = "eth_getCode";
  return JsonRpcMethod2;
}({});
async function safeSolve(promise, def) {
  try {
    return await promise;
  } catch (e2) {
    const d2 = def instanceof Function ? def(e2) : def;
    return d2;
  }
}
function partition$1(array, callback) {
  return array.reduce(function(result, element, i) {
    callback(element, i) ? result[0].push(element) : result[1].push(element);
    return result;
  }, [[], []]);
}
function parseBlockTag(cand) {
  if (cand === void 0)
    return "latest";
  switch (cand) {
    case "earliest":
    case "latest":
    case "pending":
      return cand;
  }
  return BigNumber.from(cand);
}
function eqBlockTag(a2, b2) {
  if (a2 === b2)
    return true;
  if (BigNumber.isBigNumber(a2)) {
    if (BigNumber.isBigNumber(b2))
      return a2.eq(b2);
    return false;
  }
  if (BigNumber.isBigNumber(b2))
    return false;
  return a2 === b2;
}
const DefaultMulticallOptions = {
  batchSize: 50,
  timeWindow: 50,
  // SequenceUtils: v2
  contract: "0xdbbFa3cB3B087B64F4ef5E3D20Dda2488AA244e6",
  verbose: false
};
class Multicall {
  constructor(options) {
    var _this = this;
    this.batchableJsonRpcMethods = [JsonRpcMethod.ethCall, JsonRpcMethod.ethGetCode, JsonRpcMethod.ethGetBalance];
    this.multicallInterface = new Interface(walletContracts.sequenceUtils.abi);
    this.options = void 0;
    this.timeout = void 0;
    this.queue = [];
    this.scheduleExecution = () => {
      if (this.queue.length > 0) {
        if (this.timeout)
          clearTimeout(this.timeout);
        this.timeout = setTimeout(this.run, this.options.timeWindow);
      }
    };
    this.handle = (next, request, callback) => {
      if (this.batchableJsonRpcMethods.find((m2) => m2 === request.method)) {
        this.queue.push({
          request,
          callback,
          next
        });
        if (this.options.verbose)
          console.log("Scheduling call", request.method);
        this.scheduleExecution();
        return;
      }
      if (this.options.verbose)
        console.log("Forwarded call", request.method);
      return next(request, callback);
    };
    this.run = async function() {
      if (_this.options.verbose)
        console.log("Processing multicall");
      const limit = Math.min(_this.options.batchSize, _this.queue.length);
      if (limit === 0) {
        if (_this.options.verbose)
          console.log("Skip multicall, empty queue");
        return;
      }
      if (limit === 1) {
        _this.forward(_this.queue[0]);
        _this.queue = [];
        if (_this.options.verbose)
          console.log("Skip multicall, single item");
        return;
      }
      if (_this.options.verbose)
        console.log("Resolving", limit);
      var items = _this.queue.slice(0, limit);
      _this.queue = limit === _this.queue.length ? [] : _this.queue.slice(limit);
      if (_this.options.verbose)
        console.log("Updated queue", _this.queue.length);
      if (_this.queue.length !== 0) {
        if (_this.options.verbose)
          console.log("Scheduling next batch");
        _this.scheduleExecution();
      }
      const next = items[0].next;
      let blockTag;
      var [items, discartItems] = partition$1(items, (item2) => {
        try {
          if (item2.next !== next)
            return false;
          switch (item2.request.method) {
            case JsonRpcMethod.ethCall:
              if (item2.request.params[0].from || item2.request.params[0].gasPrice || item2.request.params[0].value) {
                return false;
              }
            case JsonRpcMethod.ethGetBalance:
            case JsonRpcMethod.ethGetCode:
              const itemBlockTag = parseBlockTag(item2.request.params[1]);
              if (blockTag === void 0)
                blockTag = itemBlockTag;
              if (!eqBlockTag(itemBlockTag, blockTag))
                return false;
          }
          return true;
        } catch (_unused) {
          return false;
        }
      });
      if (discartItems.length !== 0) {
        if (_this.options.verbose)
          console.log("Forwarding incompatible calls", discartItems.length);
        _this.forward(discartItems);
        if (items.length === 0) {
          if (_this.options.verbose)
            console.log("Skip multicall, all calls are incompatible");
          return;
        }
      }
      let callParams = items.map((v3) => {
        try {
          switch (v3.request.method) {
            case JsonRpcMethod.ethCall:
              return {
                delegateCall: false,
                revertOnError: false,
                target: v3.request.params[0].to,
                data: v3.request.params[0].data,
                gasLimit: v3.request.params[0].gas ? v3.request.params[0].gas : 0,
                value: 0
              };
            case JsonRpcMethod.ethGetCode:
              return {
                delegateCall: false,
                revertOnError: false,
                target: _this.options.contract,
                gasLimit: 0,
                value: 0,
                data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction("callCode"), [v3.request.params[0]])
              };
            case JsonRpcMethod.ethGetBalance:
              return {
                delegateCall: false,
                revertOnError: false,
                target: _this.options.contract,
                gasLimit: 0,
                value: 0,
                data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction("callBalanceOf"), [v3.request.params[0]])
              };
            default:
              return null;
          }
        } catch (_unused2) {
          return null;
        }
      });
      var [items, discartItems] = partition$1(items, (_, i) => callParams[i] !== void 0);
      callParams = callParams.filter((c2) => c2);
      if (discartItems.length !== 0) {
        if (_this.options.verbose)
          console.log("Forwarding calls on error", discartItems.length);
        _this.forward(discartItems);
        if (items.length === 0) {
          if (_this.options.verbose)
            console.log("Skip multicall, all calls had encoding errors");
          return;
        }
      }
      let encodedCall;
      try {
        if (_this.options.verbose)
          console.log("Encoding multicall");
        encodedCall = _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction("multiCall"), [callParams]);
      } catch (err) {
        if (_this.options.verbose)
          console.warn("Error encoding multicall, forwarding one by one", err);
        _this.forward(items);
        return;
      }
      const reqId = getRandomInt();
      const res = await safeSolve(
        // @ts-ignore
        promisify(next)({
          id: reqId,
          jsonrpc: JsonRpcVersion,
          method: JsonRpcMethod.ethCall,
          params: [{
            to: _this.options.contract,
            value: 0,
            data: encodedCall
          }, BigNumber.isBigNumber(blockTag) ? blockTag.toNumber() : blockTag]
          // @ts-ignore
        }),
        (e2) => ({
          jsonrpc: JsonRpcVersion,
          id: reqId,
          result: void 0,
          error: e2
        })
      );
      if (res.error) {
        if (_this.options.verbose)
          console.warn("Error calling multicall, forwarding one by one", res.error);
        return _this.forward(items);
      }
      let decoded;
      try {
        decoded = _this.multicallInterface.decodeFunctionResult(_this.multicallInterface.getFunction("multiCall"), res.result);
      } catch (err) {
        if (_this.options.verbose)
          console.warn("Error decoding multicall result, forwarding one by one", err);
        _this.forward(items);
        return;
      }
      if (_this.options.verbose)
        console.log("Got response for", items.length);
      items.forEach((item2, index2) => {
        if (!decoded[0][index2]) {
          if (_this.options.verbose)
            console.warn(`Multicall error for ${item2.request.method} not found`);
          _this.forward(item2);
        } else {
          switch (item2.request.method) {
            case JsonRpcMethod.ethCall:
              item2.callback(void 0, {
                jsonrpc: item2.request.jsonrpc,
                id: item2.request.id,
                result: decoded[1][index2]
              });
              break;
            case JsonRpcMethod.ethGetCode:
              item2.callback(void 0, {
                jsonrpc: item2.request.jsonrpc,
                id: item2.request.id,
                result: defaultAbiCoder.decode(["bytes"], decoded[1][index2])[0]
              });
              break;
            case JsonRpcMethod.ethGetBalance:
              item2.callback(void 0, {
                jsonrpc: item2.request.jsonrpc,
                id: item2.request.id,
                result: defaultAbiCoder.decode(["uint256"], decoded[1][index2])[0]
              });
              break;
          }
        }
      });
    };
    this.options = options ? _extends$4({}, Multicall.DefaultOptions, options) : Multicall.DefaultOptions;
    if (this.options.batchSize <= 0)
      throw new Error(`Invalid batch size of ${this.options.batchSize}`);
  }
  forward(entries) {
    if (Array.isArray(entries)) {
      entries.forEach((e2) => e2.next(e2.request, e2.callback));
    } else {
      entries.next(entries.request, entries.callback);
    }
  }
  static isMulticall(cand) {
    return cand && cand.handle !== void 0 && cand.conf !== void 0 && Multicall.isMulticallOptions(cand.options);
  }
  static isMulticallOptions(cand) {
    return cand !== void 0 && cand.batchSize !== void 0 && cand.timeWindow !== void 0 && cand.contract !== void 0;
  }
}
Multicall.DefaultOptions = _extends$4({}, DefaultMulticallOptions);
const ProxyMethods = ["getNetwork", "getBlockNumber", "getGasPrice", "getTransactionCount", "getStorageAt", "sendTransaction", "estimateGas", "getBlock", "getTransaction", "getTransactionReceipt", "getLogs", "emit", "litenerCount", "addListener", "removeListener", "waitForTransaction", "detectNetwork", "getBlockWithTransactions"];
class MulticallProvider extends BaseProvider {
  constructor(provider2, multicall2) {
    var _this;
    super(provider2.getNetwork());
    _this = this;
    this.provider = provider2;
    this.multicall = void 0;
    this.getResolver = async function(name2) {
      const provider3 = _this.provider;
      if (provider3.getResolver) {
        const ogResolver = await provider3.getResolver(await name2);
        if (!ogResolver)
          return null;
        return new Resolver(_this, ogResolver.address, ogResolver.name);
      }
      return provider3.getResolver(await name2);
    };
    this.next = async function(req, callback) {
      try {
        switch (req.method) {
          case JsonRpcMethod.ethCall:
            _this.callback(req, callback, await _this.provider.call(req.params[0], req.params[1]));
            break;
          case JsonRpcMethod.ethGetCode:
            _this.callback(req, callback, await _this.provider.getCode(req.params[0], req.params[1]));
            break;
          case JsonRpcMethod.ethGetBalance:
            _this.callback(req, callback, await _this.provider.getBalance(req.params[0], req.params[1]));
            break;
        }
      } catch (e2) {
        _this.callback(req, callback, void 0, e2);
      }
    };
    this.listenerCount = provider2.listenerCount.bind(provider2);
    this.multicall = Multicall.isMulticall(multicall2) ? multicall2 : new Multicall(multicall2);
    ProxyMethods.forEach((m2) => {
      if (provider2[m2] !== void 0) {
        this[m2] = (...args) => provider2[m2](...args);
      }
    });
  }
  callback(req, callback, resp, err) {
    callback(err, {
      jsonrpc: JsonRpcVersion,
      id: req.id,
      result: resp,
      error: err
    });
  }
  async call(transaction2, blockTag) {
    return this.rpcCall(JsonRpcMethod.ethCall, transaction2, blockTag);
  }
  async getCode(addressOrName, blockTag) {
    return this.rpcCall(JsonRpcMethod.ethGetCode, addressOrName, blockTag);
  }
  async getBalance(addressOrName, blockTag) {
    return this.rpcCall(JsonRpcMethod.ethGetBalance, addressOrName, blockTag);
  }
  async rpcCall(method, ...params) {
    const reqId = getRandomInt();
    const resp = await promisify(this.multicall.handle)(this.next, {
      jsonrpc: JsonRpcVersion,
      id: reqId,
      method,
      params
    });
    return resp.result;
  }
}
class MulticallExternalProvider {
  constructor(provider2, multicall2) {
    this.provider = provider2;
    this.multicall = void 0;
    this.multicall = Multicall.isMulticall(multicall2) ? multicall2 : new Multicall(multicall2);
    if (provider2.send) {
      const next = async function next2(req, callback) {
        provider2.send(req, callback);
      };
      this.send = (request, callback) => {
        this.multicall.handle(next, request, callback);
      };
    }
    if (provider2.sendAsync) {
      const next = async function next2(req, callback) {
        provider2.sendAsync(req, callback);
      };
      this.sendAsync = (request, callback) => {
        this.multicall.handle(next, request, callback);
      };
    }
  }
  get isMetaMask() {
    return this.provider.isMetaMask;
  }
  get isStatus() {
    return this.provider.isStatus;
  }
}
const multicallMiddleware = (multicall2) => (next) => {
  const lib2 = Multicall.isMulticall(multicall2) ? multicall2 : new Multicall(multicall2);
  return (request, callback) => {
    return lib2.handle(next, request, callback);
  };
};
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ProxyMethods,
  MulticallProvider,
  MulticallExternalProvider,
  multicallMiddleware
});
const multicall$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Multicall,
  providers: index$3
}, Symbol.toStringTag, { value: "Module" }));
var eventemitter2 = { exports: {} };
(function(module2, exports) {
  !function(undefined$1) {
    var hasOwnProperty = Object.hasOwnProperty;
    var isArray2 = Array.isArray ? Array.isArray : function _isArray(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    var defaultMaxListeners = 10;
    var nextTickSupported = typeof process$1 == "object" && typeof process$1.nextTick == "function";
    var symbolsSupported = typeof Symbol === "function";
    var reflectSupported = typeof Reflect === "object";
    var setImmediateSupported = typeof setImmediate === "function";
    var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;
    var ownKeys2 = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
      var arr = Object.getOwnPropertyNames(obj);
      arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
      return arr;
    } : Object.keys;
    function init3() {
      this._events = {};
      if (this._conf) {
        configure.call(this, this._conf);
      }
    }
    function configure(conf) {
      if (conf) {
        this._conf = conf;
        conf.delimiter && (this.delimiter = conf.delimiter);
        if (conf.maxListeners !== undefined$1) {
          this._maxListeners = conf.maxListeners;
        }
        conf.wildcard && (this.wildcard = conf.wildcard);
        conf.newListener && (this._newListener = conf.newListener);
        conf.removeListener && (this._removeListener = conf.removeListener);
        conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
        conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
        if (this.wildcard) {
          this.listenerTree = {};
        }
      }
    }
    function logPossibleMemoryLeak(count2, eventName) {
      var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count2 + " listeners added. Use emitter.setMaxListeners() to increase limit.";
      if (this.verboseMemoryLeak) {
        errorMsg += " Event name: " + eventName + ".";
      }
      if (typeof process$1 !== "undefined" && process$1.emitWarning) {
        var e2 = new Error(errorMsg);
        e2.name = "MaxListenersExceededWarning";
        e2.emitter = this;
        e2.count = count2;
        process$1.emitWarning(e2);
      } else {
        console.error(errorMsg);
        if (console.trace) {
          console.trace();
        }
      }
    }
    var toArray2 = function(a2, b2, c2) {
      var n2 = arguments.length;
      switch (n2) {
        case 0:
          return [];
        case 1:
          return [a2];
        case 2:
          return [a2, b2];
        case 3:
          return [a2, b2, c2];
        default:
          var arr = new Array(n2);
          while (n2--) {
            arr[n2] = arguments[n2];
          }
          return arr;
      }
    };
    function toObject(keys, values) {
      var obj = {};
      var key2;
      var len = keys.length;
      var valuesCount = 0;
      for (var i = 0; i < len; i++) {
        key2 = keys[i];
        obj[key2] = i < valuesCount ? values[i] : undefined$1;
      }
      return obj;
    }
    function TargetObserver(emitter, target, options) {
      this._emitter = emitter;
      this._target = target;
      this._listeners = {};
      this._listenersCount = 0;
      var on, off;
      if (options.on || options.off) {
        on = options.on;
        off = options.off;
      }
      if (target.addEventListener) {
        on = target.addEventListener;
        off = target.removeEventListener;
      } else if (target.addListener) {
        on = target.addListener;
        off = target.removeListener;
      } else if (target.on) {
        on = target.on;
        off = target.off;
      }
      if (!on && !off) {
        throw Error("target does not implement any known event API");
      }
      if (typeof on !== "function") {
        throw TypeError("on method must be a function");
      }
      if (typeof off !== "function") {
        throw TypeError("off method must be a function");
      }
      this._on = on;
      this._off = off;
      var _observers2 = emitter._observers;
      if (_observers2) {
        _observers2.push(this);
      } else {
        emitter._observers = [this];
      }
    }
    Object.assign(TargetObserver.prototype, {
      subscribe: function(event, localEvent, reducer) {
        var observer = this;
        var target = this._target;
        var emitter = this._emitter;
        var listeners = this._listeners;
        var handler = function() {
          var args = toArray2.apply(null, arguments);
          var eventObj = {
            data: args,
            name: localEvent,
            original: event
          };
          if (reducer) {
            var result = reducer.call(target, eventObj);
            if (result !== false) {
              emitter.emit.apply(emitter, [eventObj.name].concat(args));
            }
            return;
          }
          emitter.emit.apply(emitter, [localEvent].concat(args));
        };
        if (listeners[event]) {
          throw Error("Event '" + event + "' is already listening");
        }
        this._listenersCount++;
        if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
          this._onNewListener = function(_event) {
            if (_event === localEvent && listeners[event] === null) {
              listeners[event] = handler;
              observer._on.call(target, event, handler);
            }
          };
          emitter.on("newListener", this._onNewListener);
          this._onRemoveListener = function(_event) {
            if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
              listeners[event] = null;
              observer._off.call(target, event, handler);
            }
          };
          listeners[event] = null;
          emitter.on("removeListener", this._onRemoveListener);
        } else {
          listeners[event] = handler;
          observer._on.call(target, event, handler);
        }
      },
      unsubscribe: function(event) {
        var observer = this;
        var listeners = this._listeners;
        var emitter = this._emitter;
        var handler;
        var events;
        var off = this._off;
        var target = this._target;
        var i;
        if (event && typeof event !== "string") {
          throw TypeError("event must be a string");
        }
        function clearRefs() {
          if (observer._onNewListener) {
            emitter.off("newListener", observer._onNewListener);
            emitter.off("removeListener", observer._onRemoveListener);
            observer._onNewListener = null;
            observer._onRemoveListener = null;
          }
          var index2 = findTargetIndex.call(emitter, observer);
          emitter._observers.splice(index2, 1);
        }
        if (event) {
          handler = listeners[event];
          if (!handler)
            return;
          off.call(target, event, handler);
          delete listeners[event];
          if (!--this._listenersCount) {
            clearRefs();
          }
        } else {
          events = ownKeys2(listeners);
          i = events.length;
          while (i-- > 0) {
            event = events[i];
            off.call(target, event, listeners[event]);
          }
          this._listeners = {};
          this._listenersCount = 0;
          clearRefs();
        }
      }
    });
    function resolveOptions(options, schema, reducers, allowUnknown) {
      var computedOptions = Object.assign({}, schema);
      if (!options)
        return computedOptions;
      if (typeof options !== "object") {
        throw TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var length = keys.length;
      var option, value;
      var reducer;
      function reject(reason) {
        throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
      }
      for (var i = 0; i < length; i++) {
        option = keys[i];
        if (!hasOwnProperty.call(schema, option)) {
          throw Error('Unknown "' + option + '" option');
        }
        value = options[option];
        if (value !== undefined$1) {
          reducer = reducers[option];
          computedOptions[option] = reducer ? reducer(value, reject) : value;
        }
      }
      return computedOptions;
    }
    function constructorReducer(value, reject) {
      if (typeof value !== "function" || !value.hasOwnProperty("prototype")) {
        reject("value must be a constructor");
      }
      return value;
    }
    function makeTypeReducer(types2) {
      var message = "value must be type of " + types2.join("|");
      var len = types2.length;
      var firstType = types2[0];
      var secondType = types2[1];
      if (len === 1) {
        return function(v3, reject) {
          if (typeof v3 === firstType) {
            return v3;
          }
          reject(message);
        };
      }
      if (len === 2) {
        return function(v3, reject) {
          var kind = typeof v3;
          if (kind === firstType || kind === secondType)
            return v3;
          reject(message);
        };
      }
      return function(v3, reject) {
        var kind = typeof v3;
        var i = len;
        while (i-- > 0) {
          if (kind === types2[i])
            return v3;
        }
        reject(message);
      };
    }
    var functionReducer = makeTypeReducer(["function"]);
    var objectFunctionReducer = makeTypeReducer(["object", "function"]);
    function makeCancelablePromise(Promise2, executor, options) {
      var isCancelable;
      var callbacks;
      var timer2 = 0;
      var subscriptionClosed;
      var promise = new Promise2(function(resolve, reject, onCancel) {
        options = resolveOptions(options, {
          timeout: 0,
          overload: false
        }, {
          timeout: function(value, reject2) {
            value *= 1;
            if (typeof value !== "number" || value < 0 || !Number.isFinite(value)) {
              reject2("timeout must be a positive number");
            }
            return value;
          }
        });
        isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
        function cleanup() {
          if (callbacks) {
            callbacks = null;
          }
          if (timer2) {
            clearTimeout(timer2);
            timer2 = 0;
          }
        }
        var _resolve = function(value) {
          cleanup();
          resolve(value);
        };
        var _reject = function(err) {
          cleanup();
          reject(err);
        };
        if (isCancelable) {
          executor(_resolve, _reject, onCancel);
        } else {
          callbacks = [function(reason) {
            _reject(reason || Error("canceled"));
          }];
          executor(_resolve, _reject, function(cb2) {
            if (subscriptionClosed) {
              throw Error("Unable to subscribe on cancel event asynchronously");
            }
            if (typeof cb2 !== "function") {
              throw TypeError("onCancel callback must be a function");
            }
            callbacks.push(cb2);
          });
          subscriptionClosed = true;
        }
        if (options.timeout > 0) {
          timer2 = setTimeout(function() {
            var reason = Error("timeout");
            reason.code = "ETIMEDOUT";
            timer2 = 0;
            promise.cancel(reason);
            reject(reason);
          }, options.timeout);
        }
      });
      if (!isCancelable) {
        promise.cancel = function(reason) {
          if (!callbacks) {
            return;
          }
          var length = callbacks.length;
          for (var i = 1; i < length; i++) {
            callbacks[i](reason);
          }
          callbacks[0](reason);
          callbacks = null;
        };
      }
      return promise;
    }
    function findTargetIndex(observer) {
      var observers2 = this._observers;
      if (!observers2) {
        return -1;
      }
      var len = observers2.length;
      for (var i = 0; i < len; i++) {
        if (observers2[i]._target === observer)
          return i;
      }
      return -1;
    }
    function searchListenerTree(handlers, type, tree, i, typeLength) {
      if (!tree) {
        return null;
      }
      if (i === 0) {
        var kind = typeof type;
        if (kind === "string") {
          var ns, n2, l2 = 0, j2 = 0, delimiter = this.delimiter, dl2 = delimiter.length;
          if ((n2 = type.indexOf(delimiter)) !== -1) {
            ns = new Array(5);
            do {
              ns[l2++] = type.slice(j2, n2);
              j2 = n2 + dl2;
            } while ((n2 = type.indexOf(delimiter, j2)) !== -1);
            ns[l2++] = type.slice(j2);
            type = ns;
            typeLength = l2;
          } else {
            type = [type];
            typeLength = 1;
          }
        } else if (kind === "object") {
          typeLength = type.length;
        } else {
          type = [type];
          typeLength = 1;
        }
      }
      var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;
      if (i === typeLength) {
        if (tree._listeners) {
          if (typeof tree._listeners === "function") {
            handlers && handlers.push(tree._listeners);
            listeners = [tree];
          } else {
            handlers && handlers.push.apply(handlers, tree._listeners);
            listeners = [tree];
          }
        }
      } else {
        if (currentType === "*") {
          branches = ownKeys2(tree);
          n2 = branches.length;
          while (n2-- > 0) {
            branch = branches[n2];
            if (branch !== "_listeners") {
              _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
              if (_listeners) {
                if (listeners) {
                  listeners.push.apply(listeners, _listeners);
                } else {
                  listeners = _listeners;
                }
              }
            }
          }
          return listeners;
        } else if (currentType === "**") {
          endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
          if (endReached && tree._listeners) {
            listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
          }
          branches = ownKeys2(tree);
          n2 = branches.length;
          while (n2-- > 0) {
            branch = branches[n2];
            if (branch !== "_listeners") {
              if (branch === "*" || branch === "**") {
                if (tree[branch]._listeners && !endReached) {
                  _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
                  if (_listeners) {
                    if (listeners) {
                      listeners.push.apply(listeners, _listeners);
                    } else {
                      listeners = _listeners;
                    }
                  }
                }
                _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
              } else if (branch === nextType) {
                _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
              } else {
                _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
              }
              if (_listeners) {
                if (listeners) {
                  listeners.push.apply(listeners, _listeners);
                } else {
                  listeners = _listeners;
                }
              }
            }
          }
          return listeners;
        } else if (tree[currentType]) {
          listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
        }
      }
      xTree = tree["*"];
      if (xTree) {
        searchListenerTree(handlers, type, xTree, i + 1, typeLength);
      }
      xxTree = tree["**"];
      if (xxTree) {
        if (i < typeLength) {
          if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
          }
          branches = ownKeys2(xxTree);
          n2 = branches.length;
          while (n2-- > 0) {
            branch = branches[n2];
            if (branch !== "_listeners") {
              if (branch === nextType) {
                searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
              } else if (branch === currentType) {
                searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
              } else {
                isolatedBranch = {};
                isolatedBranch[branch] = xxTree[branch];
                searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1, typeLength);
              }
            }
          }
        } else if (xxTree._listeners) {
          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
        } else if (xxTree["*"] && xxTree["*"]._listeners) {
          searchListenerTree(handlers, type, xxTree["*"], typeLength, typeLength);
        }
      }
      return listeners;
    }
    function growListenerTree(type, listener, prepend) {
      var len = 0, j2 = 0, i, delimiter = this.delimiter, dl2 = delimiter.length, ns;
      if (typeof type === "string") {
        if ((i = type.indexOf(delimiter)) !== -1) {
          ns = new Array(5);
          do {
            ns[len++] = type.slice(j2, i);
            j2 = i + dl2;
          } while ((i = type.indexOf(delimiter, j2)) !== -1);
          ns[len++] = type.slice(j2);
        } else {
          ns = [type];
          len = 1;
        }
      } else {
        ns = type;
        len = type.length;
      }
      if (len > 1) {
        for (i = 0; i + 1 < len; i++) {
          if (ns[i] === "**" && ns[i + 1] === "**") {
            return;
          }
        }
      }
      var tree = this.listenerTree, name2;
      for (i = 0; i < len; i++) {
        name2 = ns[i];
        tree = tree[name2] || (tree[name2] = {});
        if (i === len - 1) {
          if (!tree._listeners) {
            tree._listeners = listener;
          } else {
            if (typeof tree._listeners === "function") {
              tree._listeners = [tree._listeners];
            }
            if (prepend) {
              tree._listeners.unshift(listener);
            } else {
              tree._listeners.push(listener);
            }
            if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
              tree._listeners.warned = true;
              logPossibleMemoryLeak.call(this, tree._listeners.length, name2);
            }
          }
          return true;
        }
      }
      return true;
    }
    function collectTreeEvents(tree, events, root2, asArray) {
      var branches = ownKeys2(tree);
      var i = branches.length;
      var branch, branchName, path;
      var hasListeners = tree["_listeners"];
      var isArrayPath;
      while (i-- > 0) {
        branchName = branches[i];
        branch = tree[branchName];
        if (branchName === "_listeners") {
          path = root2;
        } else {
          path = root2 ? root2.concat(branchName) : [branchName];
        }
        isArrayPath = asArray || typeof branchName === "symbol";
        hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));
        if (typeof branch === "object") {
          collectTreeEvents.call(this, branch, events, path, isArrayPath);
        }
      }
      return events;
    }
    function recursivelyGarbageCollect(root2) {
      var keys = ownKeys2(root2);
      var i = keys.length;
      var obj, key2, flag;
      while (i-- > 0) {
        key2 = keys[i];
        obj = root2[key2];
        if (obj) {
          flag = true;
          if (key2 !== "_listeners" && !recursivelyGarbageCollect(obj)) {
            delete root2[key2];
          }
        }
      }
      return flag;
    }
    function Listener(emitter, event, listener) {
      this.emitter = emitter;
      this.event = event;
      this.listener = listener;
    }
    Listener.prototype.off = function() {
      this.emitter.off(this.event, this.listener);
      return this;
    };
    function setupListener(event, listener, options) {
      if (options === true) {
        promisify2 = true;
      } else if (options === false) {
        async = true;
      } else {
        if (!options || typeof options !== "object") {
          throw TypeError("options should be an object or true");
        }
        var async = options.async;
        var promisify2 = options.promisify;
        var nextTick = options.nextTick;
        var objectify = options.objectify;
      }
      if (async || nextTick || promisify2) {
        var _listener = listener;
        var _origin = listener._origin || listener;
        if (nextTick && !nextTickSupported) {
          throw Error("process.nextTick is not supported");
        }
        if (promisify2 === undefined$1) {
          promisify2 = listener.constructor.name === "AsyncFunction";
        }
        listener = function() {
          var args = arguments;
          var context2 = this;
          var event2 = this.event;
          return promisify2 ? nextTick ? Promise.resolve() : new Promise(function(resolve) {
            _setImmediate(resolve);
          }).then(function() {
            context2.event = event2;
            return _listener.apply(context2, args);
          }) : (nextTick ? process$1.nextTick : _setImmediate)(function() {
            context2.event = event2;
            _listener.apply(context2, args);
          });
        };
        listener._async = true;
        listener._origin = _origin;
      }
      return [listener, objectify ? new Listener(this, event, listener) : this];
    }
    function EventEmitter2(conf) {
      this._events = {};
      this._newListener = false;
      this._removeListener = false;
      this.verboseMemoryLeak = false;
      configure.call(this, conf);
    }
    EventEmitter2.EventEmitter2 = EventEmitter2;
    EventEmitter2.prototype.listenTo = function(target, events, options) {
      if (typeof target !== "object") {
        throw TypeError("target musts be an object");
      }
      var emitter = this;
      options = resolveOptions(options, {
        on: undefined$1,
        off: undefined$1,
        reducers: undefined$1
      }, {
        on: functionReducer,
        off: functionReducer,
        reducers: objectFunctionReducer
      });
      function listen(events2) {
        if (typeof events2 !== "object") {
          throw TypeError("events must be an object");
        }
        var reducers = options.reducers;
        var index2 = findTargetIndex.call(emitter, target);
        var observer;
        if (index2 === -1) {
          observer = new TargetObserver(emitter, target, options);
        } else {
          observer = emitter._observers[index2];
        }
        var keys = ownKeys2(events2);
        var len = keys.length;
        var event;
        var isSingleReducer = typeof reducers === "function";
        for (var i = 0; i < len; i++) {
          event = keys[i];
          observer.subscribe(
            event,
            events2[event] || event,
            isSingleReducer ? reducers : reducers && reducers[event]
          );
        }
      }
      isArray2(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
      return this;
    };
    EventEmitter2.prototype.stopListeningTo = function(target, event) {
      var observers2 = this._observers;
      if (!observers2) {
        return false;
      }
      var i = observers2.length;
      var observer;
      var matched = false;
      if (target && typeof target !== "object") {
        throw TypeError("target should be an object");
      }
      while (i-- > 0) {
        observer = observers2[i];
        if (!target || observer._target === target) {
          observer.unsubscribe(event);
          matched = true;
        }
      }
      return matched;
    };
    EventEmitter2.prototype.delimiter = ".";
    EventEmitter2.prototype.setMaxListeners = function(n2) {
      if (n2 !== undefined$1) {
        this._maxListeners = n2;
        if (!this._conf)
          this._conf = {};
        this._conf.maxListeners = n2;
      }
    };
    EventEmitter2.prototype.getMaxListeners = function() {
      return this._maxListeners;
    };
    EventEmitter2.prototype.event = "";
    EventEmitter2.prototype.once = function(event, fn, options) {
      return this._once(event, fn, false, options);
    };
    EventEmitter2.prototype.prependOnceListener = function(event, fn, options) {
      return this._once(event, fn, true, options);
    };
    EventEmitter2.prototype._once = function(event, fn, prepend, options) {
      return this._many(event, 1, fn, prepend, options);
    };
    EventEmitter2.prototype.many = function(event, ttl, fn, options) {
      return this._many(event, ttl, fn, false, options);
    };
    EventEmitter2.prototype.prependMany = function(event, ttl, fn, options) {
      return this._many(event, ttl, fn, true, options);
    };
    EventEmitter2.prototype._many = function(event, ttl, fn, prepend, options) {
      var self2 = this;
      if (typeof fn !== "function") {
        throw new Error("many only accepts instances of Function");
      }
      function listener() {
        if (--ttl === 0) {
          self2.off(event, listener);
        }
        return fn.apply(this, arguments);
      }
      listener._origin = fn;
      return this._on(event, listener, prepend, options);
    };
    EventEmitter2.prototype.emit = function() {
      if (!this._events && !this._all) {
        return false;
      }
      this._events || init3.call(this);
      var type = arguments[0], ns, wildcard = this.wildcard;
      var args, l2, i, j2, containsSymbol;
      if (type === "newListener" && !this._newListener) {
        if (!this._events.newListener) {
          return false;
        }
      }
      if (wildcard) {
        ns = type;
        if (type !== "newListener" && type !== "removeListener") {
          if (typeof type === "object") {
            l2 = type.length;
            if (symbolsSupported) {
              for (i = 0; i < l2; i++) {
                if (typeof type[i] === "symbol") {
                  containsSymbol = true;
                  break;
                }
              }
            }
            if (!containsSymbol) {
              type = type.join(this.delimiter);
            }
          }
        }
      }
      var al2 = arguments.length;
      var handler;
      if (this._all && this._all.length) {
        handler = this._all.slice();
        for (i = 0, l2 = handler.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              handler[i].call(this, type);
              break;
            case 2:
              handler[i].call(this, type, arguments[1]);
              break;
            case 3:
              handler[i].call(this, type, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, arguments);
          }
        }
      }
      if (wildcard) {
        handler = [];
        searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l2);
      } else {
        handler = this._events[type];
        if (typeof handler === "function") {
          this.event = type;
          switch (al2) {
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            default:
              args = new Array(al2 - 1);
              for (j2 = 1; j2 < al2; j2++)
                args[j2 - 1] = arguments[j2];
              handler.apply(this, args);
          }
          return true;
        } else if (handler) {
          handler = handler.slice();
        }
      }
      if (handler && handler.length) {
        if (al2 > 3) {
          args = new Array(al2 - 1);
          for (j2 = 1; j2 < al2; j2++)
            args[j2 - 1] = arguments[j2];
        }
        for (i = 0, l2 = handler.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              handler[i].call(this);
              break;
            case 2:
              handler[i].call(this, arguments[1]);
              break;
            case 3:
              handler[i].call(this, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, args);
          }
        }
        return true;
      } else if (!this.ignoreErrors && !this._all && type === "error") {
        if (arguments[1] instanceof Error) {
          throw arguments[1];
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
      }
      return !!this._all;
    };
    EventEmitter2.prototype.emitAsync = function() {
      if (!this._events && !this._all) {
        return false;
      }
      this._events || init3.call(this);
      var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;
      var args, l2, i, j2;
      if (type === "newListener" && !this._newListener) {
        if (!this._events.newListener) {
          return Promise.resolve([false]);
        }
      }
      if (wildcard) {
        ns = type;
        if (type !== "newListener" && type !== "removeListener") {
          if (typeof type === "object") {
            l2 = type.length;
            if (symbolsSupported) {
              for (i = 0; i < l2; i++) {
                if (typeof type[i] === "symbol") {
                  containsSymbol = true;
                  break;
                }
              }
            }
            if (!containsSymbol) {
              type = type.join(this.delimiter);
            }
          }
        }
      }
      var promises = [];
      var al2 = arguments.length;
      var handler;
      if (this._all) {
        for (i = 0, l2 = this._all.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              promises.push(this._all[i].call(this, type));
              break;
            case 2:
              promises.push(this._all[i].call(this, type, arguments[1]));
              break;
            case 3:
              promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
              break;
            default:
              promises.push(this._all[i].apply(this, arguments));
          }
        }
      }
      if (wildcard) {
        handler = [];
        searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
      } else {
        handler = this._events[type];
      }
      if (typeof handler === "function") {
        this.event = type;
        switch (al2) {
          case 1:
            promises.push(handler.call(this));
            break;
          case 2:
            promises.push(handler.call(this, arguments[1]));
            break;
          case 3:
            promises.push(handler.call(this, arguments[1], arguments[2]));
            break;
          default:
            args = new Array(al2 - 1);
            for (j2 = 1; j2 < al2; j2++)
              args[j2 - 1] = arguments[j2];
            promises.push(handler.apply(this, args));
        }
      } else if (handler && handler.length) {
        handler = handler.slice();
        if (al2 > 3) {
          args = new Array(al2 - 1);
          for (j2 = 1; j2 < al2; j2++)
            args[j2 - 1] = arguments[j2];
        }
        for (i = 0, l2 = handler.length; i < l2; i++) {
          this.event = type;
          switch (al2) {
            case 1:
              promises.push(handler[i].call(this));
              break;
            case 2:
              promises.push(handler[i].call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler[i].call(this, arguments[1], arguments[2]));
              break;
            default:
              promises.push(handler[i].apply(this, args));
          }
        }
      } else if (!this.ignoreErrors && !this._all && type === "error") {
        if (arguments[1] instanceof Error) {
          return Promise.reject(arguments[1]);
        } else {
          return Promise.reject("Uncaught, unspecified 'error' event.");
        }
      }
      return Promise.all(promises);
    };
    EventEmitter2.prototype.on = function(type, listener, options) {
      return this._on(type, listener, false, options);
    };
    EventEmitter2.prototype.prependListener = function(type, listener, options) {
      return this._on(type, listener, true, options);
    };
    EventEmitter2.prototype.onAny = function(fn) {
      return this._onAny(fn, false);
    };
    EventEmitter2.prototype.prependAny = function(fn) {
      return this._onAny(fn, true);
    };
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prototype._onAny = function(fn, prepend) {
      if (typeof fn !== "function") {
        throw new Error("onAny only accepts instances of Function");
      }
      if (!this._all) {
        this._all = [];
      }
      if (prepend) {
        this._all.unshift(fn);
      } else {
        this._all.push(fn);
      }
      return this;
    };
    EventEmitter2.prototype._on = function(type, listener, prepend, options) {
      if (typeof type === "function") {
        this._onAny(type, listener);
        return this;
      }
      if (typeof listener !== "function") {
        throw new Error("on only accepts instances of Function");
      }
      this._events || init3.call(this);
      var returnValue = this, temp;
      if (options !== undefined$1) {
        temp = setupListener.call(this, type, listener, options);
        listener = temp[0];
        returnValue = temp[1];
      }
      if (this._newListener) {
        this.emit("newListener", type, listener);
      }
      if (this.wildcard) {
        growListenerTree.call(this, type, listener, prepend);
        return returnValue;
      }
      if (!this._events[type]) {
        this._events[type] = listener;
      } else {
        if (typeof this._events[type] === "function") {
          this._events[type] = [this._events[type]];
        }
        if (prepend) {
          this._events[type].unshift(listener);
        } else {
          this._events[type].push(listener);
        }
        if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {
          this._events[type].warned = true;
          logPossibleMemoryLeak.call(this, this._events[type].length, type);
        }
      }
      return returnValue;
    };
    EventEmitter2.prototype.off = function(type, listener) {
      if (typeof listener !== "function") {
        throw new Error("removeListener only takes instances of Function");
      }
      var handlers, leafs = [];
      if (this.wildcard) {
        var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
        leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
        if (!leafs)
          return this;
      } else {
        if (!this._events[type])
          return this;
        handlers = this._events[type];
        leafs.push({ _listeners: handlers });
      }
      for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        handlers = leaf._listeners;
        if (isArray2(handlers)) {
          var position = -1;
          for (var i = 0, length = handlers.length; i < length; i++) {
            if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
              position = i;
              break;
            }
          }
          if (position < 0) {
            continue;
          }
          if (this.wildcard) {
            leaf._listeners.splice(position, 1);
          } else {
            this._events[type].splice(position, 1);
          }
          if (handlers.length === 0) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
          }
          if (this._removeListener)
            this.emit("removeListener", type, listener);
          return this;
        } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
          if (this.wildcard) {
            delete leaf._listeners;
          } else {
            delete this._events[type];
          }
          if (this._removeListener)
            this.emit("removeListener", type, listener);
        }
      }
      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
      return this;
    };
    EventEmitter2.prototype.offAny = function(fn) {
      var i = 0, l2 = 0, fns;
      if (fn && this._all && this._all.length > 0) {
        fns = this._all;
        for (i = 0, l2 = fns.length; i < l2; i++) {
          if (fn === fns[i]) {
            fns.splice(i, 1);
            if (this._removeListener)
              this.emit("removeListenerAny", fn);
            return this;
          }
        }
      } else {
        fns = this._all;
        if (this._removeListener) {
          for (i = 0, l2 = fns.length; i < l2; i++)
            this.emit("removeListenerAny", fns[i]);
        }
        this._all = [];
      }
      return this;
    };
    EventEmitter2.prototype.removeListener = EventEmitter2.prototype.off;
    EventEmitter2.prototype.removeAllListeners = function(type) {
      if (type === undefined$1) {
        !this._events || init3.call(this);
        return this;
      }
      if (this.wildcard) {
        var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
        if (!leafs)
          return this;
        for (i = 0; i < leafs.length; i++) {
          leaf = leafs[i];
          leaf._listeners = null;
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
      } else if (this._events) {
        this._events[type] = null;
      }
      return this;
    };
    EventEmitter2.prototype.listeners = function(type) {
      var _events = this._events;
      var keys, listeners, allListeners;
      var i;
      var listenerTree;
      if (type === undefined$1) {
        if (this.wildcard) {
          throw Error("event name required for wildcard emitter");
        }
        if (!_events) {
          return [];
        }
        keys = ownKeys2(_events);
        i = keys.length;
        allListeners = [];
        while (i-- > 0) {
          listeners = _events[keys[i]];
          if (typeof listeners === "function") {
            allListeners.push(listeners);
          } else {
            allListeners.push.apply(allListeners, listeners);
          }
        }
        return allListeners;
      } else {
        if (this.wildcard) {
          listenerTree = this.listenerTree;
          if (!listenerTree)
            return [];
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, listenerTree, 0);
          return handlers;
        }
        if (!_events) {
          return [];
        }
        listeners = _events[type];
        if (!listeners) {
          return [];
        }
        return typeof listeners === "function" ? [listeners] : listeners;
      }
    };
    EventEmitter2.prototype.eventNames = function(nsAsArray) {
      var _events = this._events;
      return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys2(_events) : [];
    };
    EventEmitter2.prototype.listenerCount = function(type) {
      return this.listeners(type).length;
    };
    EventEmitter2.prototype.hasListeners = function(type) {
      if (this.wildcard) {
        var handlers = [];
        var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
        searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
        return handlers.length > 0;
      }
      var _events = this._events;
      var _all = this._all;
      return !!(_all && _all.length || _events && (type === undefined$1 ? ownKeys2(_events).length : _events[type]));
    };
    EventEmitter2.prototype.listenersAny = function() {
      if (this._all) {
        return this._all;
      } else {
        return [];
      }
    };
    EventEmitter2.prototype.waitFor = function(event, options) {
      var self2 = this;
      var type = typeof options;
      if (type === "number") {
        options = { timeout: options };
      } else if (type === "function") {
        options = { filter: options };
      }
      options = resolveOptions(options, {
        timeout: 0,
        filter: undefined$1,
        handleError: false,
        Promise,
        overload: false
      }, {
        filter: functionReducer,
        Promise: constructorReducer
      });
      return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
        function listener() {
          var filter2 = options.filter;
          if (filter2 && !filter2.apply(self2, arguments)) {
            return;
          }
          self2.off(event, listener);
          if (options.handleError) {
            var err = arguments[0];
            err ? reject(err) : resolve(toArray2.apply(null, arguments).slice(1));
          } else {
            resolve(toArray2.apply(null, arguments));
          }
        }
        onCancel(function() {
          self2.off(event, listener);
        });
        self2._on(event, listener, false);
      }, {
        timeout: options.timeout,
        overload: options.overload
      });
    };
    function once(emitter, name2, options) {
      options = resolveOptions(options, {
        Promise,
        timeout: 0,
        overload: false
      }, {
        Promise: constructorReducer
      });
      var _Promise = options.Promise;
      return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
        var handler;
        if (typeof emitter.addEventListener === "function") {
          handler = function() {
            resolve(toArray2.apply(null, arguments));
          };
          onCancel(function() {
            emitter.removeEventListener(name2, handler);
          });
          emitter.addEventListener(
            name2,
            handler,
            { once: true }
          );
          return;
        }
        var eventListener = function() {
          errorListener && emitter.removeListener("error", errorListener);
          resolve(toArray2.apply(null, arguments));
        };
        var errorListener;
        if (name2 !== "error") {
          errorListener = function(err) {
            emitter.removeListener(name2, eventListener);
            reject(err);
          };
          emitter.once("error", errorListener);
        }
        onCancel(function() {
          errorListener && emitter.removeListener("error", errorListener);
          emitter.removeListener(name2, eventListener);
        });
        emitter.once(name2, eventListener);
      }, {
        timeout: options.timeout,
        overload: options.overload
      });
    }
    var prototype = EventEmitter2.prototype;
    Object.defineProperties(EventEmitter2, {
      defaultMaxListeners: {
        get: function() {
          return prototype._maxListeners;
        },
        set: function(n2) {
          if (typeof n2 !== "number" || n2 < 0 || Number.isNaN(n2)) {
            throw TypeError("n must be a non-negative number");
          }
          prototype._maxListeners = n2;
        },
        enumerable: true
      },
      once: {
        value: once,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperties(prototype, {
      _maxListeners: {
        value: defaultMaxListeners,
        writable: true,
        configurable: true
      },
      _observers: { value: null, writable: true, configurable: true }
    });
    {
      module2.exports = EventEmitter2;
    }
  }();
})(eventemitter2);
var eventemitter2Exports = eventemitter2.exports;
function isBytes(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function bytes$1(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function exists$1(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(out, instance) {
  bytes$1(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr$1 = (word, shift2) => word << 32 - shift2 | word >>> shift2;
new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex$2(bytes3) {
  bytes$1(bytes3);
  let hex2 = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex2 += hexes$2[bytes3[i]];
  }
  return hex2;
}
function utf8ToBytes$2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$2(data) {
  if (typeof data === "string")
    data = utf8ToBytes$2(data);
  bytes$1(data);
  return data;
}
let Hash$1 = class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function setBigUint64$1(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
const Chi$1 = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj$1 = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
class HashMD extends Hash$1 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    exists$1(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes$2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$1(this);
    output$1(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class SHA256 extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W$1[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W$1[i - 15];
      const W2 = SHA256_W$1[i - 2];
      const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
      const s1 = rotr$1(W2, 17) ^ rotr$1(W2, 19) ^ W2 >>> 10;
      SHA256_W$1[i] = s1 + SHA256_W$1[i - 7] + s0 + SHA256_W$1[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr$1(E2, 6) ^ rotr$1(E2, 11) ^ rotr$1(E2, 25);
      const T1 = H2 + sigma1 + Chi$1(E2, F2, G2) + SHA256_K$1[i] + SHA256_W$1[i] | 0;
      const sigma0 = rotr$1(A2, 2) ^ rotr$1(A2, 13) ^ rotr$1(A2, 22);
      const T2 = sigma0 + Maj$1(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
const sha256$2 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
var Databeat = class {
  constructor(hostname, fetch2) {
    __publicField(this, "hostname");
    __publicField(this, "fetch");
    __publicField(this, "path", "/rpc/Databeat/");
    __publicField(this, "ping", (headers, signal) => {
      return this.fetch(
        this.url("Ping"),
        createHTTPRequest$1({}, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "version", (headers, signal) => {
      return this.fetch(
        this.url("Version"),
        createHTTPRequest$1({}, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data2) => {
          return {
            version: _data2.version
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "runtimeStatus", (headers, signal) => {
      return this.fetch(
        this.url("RuntimeStatus"),
        createHTTPRequest$1({}, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data2) => {
          return {
            status: _data2.status
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "tick", (args, headers, signal) => {
      return this.fetch(
        this.url("Tick"),
        createHTTPRequest$1(args, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    __publicField(this, "rawEvents", (args, headers, signal) => {
      return this.fetch(
        this.url("RawEvents"),
        createHTTPRequest$1(args, headers, signal)
      ).then((res) => {
        return buildResponse$1(res).then((_data2) => {
          return {
            ok: _data2.ok
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError$1.new({ cause: `fetch(): ${error.message || ""}` });
      });
    });
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
};
var createHTTPRequest$1 = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: { ...headers, "Content-Type": "application/json" },
    body: JSON.stringify(body || {}),
    signal
  };
};
var buildResponse$1 = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError$1.new(
        {
          status: res.status,
          cause: `JSON.parse(): ${message}: response text: ${text2}`
        }
      );
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode$1[code2] || WebrpcError$1).new(data);
    }
    return data;
  });
};
var WebrpcError$1 = class _WebrpcError extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "message");
    __publicField(this, "status");
    __publicField(this, "cause");
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    __publicField(this, "msg");
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, _WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
var WebrpcEndpointError$1 = class _WebrpcEndpointError extends WebrpcError$1 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcEndpointError.prototype);
  }
};
var WebrpcRequestFailedError$1 = class _WebrpcRequestFailedError extends WebrpcError$1 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcRequestFailedError.prototype);
  }
};
var WebrpcBadRouteError$1 = class _WebrpcBadRouteError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadRouteError.prototype);
  }
};
var WebrpcBadMethodError$1 = class _WebrpcBadMethodError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadMethodError.prototype);
  }
};
var WebrpcBadRequestError$1 = class _WebrpcBadRequestError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadRequestError.prototype);
  }
};
var WebrpcBadResponseError$1 = class _WebrpcBadResponseError extends WebrpcError$1 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadResponseError.prototype);
  }
};
var WebrpcServerPanicError$1 = class _WebrpcServerPanicError extends WebrpcError$1 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcServerPanicError.prototype);
  }
};
var WebrpcInternalErrorError$1 = class _WebrpcInternalErrorError extends WebrpcError$1 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcInternalErrorError.prototype);
  }
};
var WebrpcClientDisconnectedError$1 = class _WebrpcClientDisconnectedError extends WebrpcError$1 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcClientDisconnectedError.prototype);
  }
};
var WebrpcStreamLostError$1 = class _WebrpcStreamLostError extends WebrpcError$1 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcStreamLostError.prototype);
  }
};
var WebrpcStreamFinishedError$1 = class _WebrpcStreamFinishedError extends WebrpcError$1 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcStreamFinishedError.prototype);
  }
};
var UnauthorizedError$1 = class _UnauthorizedError extends WebrpcError$1 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _UnauthorizedError.prototype);
  }
};
var PermissionDeniedError5 = class _PermissionDeniedError extends WebrpcError$1 {
  constructor(name2 = "PermissionDenied", code2 = 2e3, message = "Permission denied", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _PermissionDeniedError.prototype);
  }
};
var SessionExpiredError5 = class _SessionExpiredError extends WebrpcError$1 {
  constructor(name2 = "SessionExpired", code2 = 2001, message = "Session expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _SessionExpiredError.prototype);
  }
};
var NotFoundError7 = class _NotFoundError extends WebrpcError$1 {
  constructor(name2 = "NotFound", code2 = 3e3, message = "Resource not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _NotFoundError.prototype);
  }
};
var InvalidAppKeyError = class _InvalidAppKeyError extends WebrpcError$1 {
  constructor(name2 = "InvalidAppKey", code2 = 4e3, message = "Invalid app key", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _InvalidAppKeyError.prototype);
  }
};
var QueryFailedError6 = class _QueryFailedError extends WebrpcError$1 {
  constructor(name2 = "QueryFailed", code2 = 4001, message = "DB query failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _QueryFailedError.prototype);
  }
};
var InvalidProjectIdError = class _InvalidProjectIdError extends WebrpcError$1 {
  constructor(name2 = "InvalidProjectId", code2 = 4002, message = "Invalid project id", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, _InvalidProjectIdError.prototype);
  }
};
var webrpcErrorByCode$1 = {
  [0]: WebrpcEndpointError$1,
  [-1]: WebrpcRequestFailedError$1,
  [-2]: WebrpcBadRouteError$1,
  [-3]: WebrpcBadMethodError$1,
  [-4]: WebrpcBadRequestError$1,
  [-5]: WebrpcBadResponseError$1,
  [-6]: WebrpcServerPanicError$1,
  [-7]: WebrpcInternalErrorError$1,
  [-8]: WebrpcClientDisconnectedError$1,
  [-9]: WebrpcStreamLostError$1,
  [-10]: WebrpcStreamFinishedError$1,
  [1e3]: UnauthorizedError$1,
  [2e3]: PermissionDeniedError5,
  [2001]: SessionExpiredError5,
  [3e3]: NotFoundError7,
  [4e3]: InvalidAppKeyError,
  [4001]: QueryFailedError6,
  [4002]: InvalidProjectIdError
};
var DatabeatRpcClient = class extends Databeat {
  constructor(hostname, auth2) {
    const globalFetch = typeof global$1 === "object" ? global$1.fetch.bind(global$1) : window.fetch.bind(window);
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, globalFetch);
    __publicField(this, "_globalFetch");
    __publicField(this, "_fetch", (input2, init3) => {
      var _a2;
      if (this.auth) {
        let headers = {};
        if (((_a2 = this.auth.jwt) == null ? void 0 : _a2.length) > 0) {
          headers["Authorization"] = `BEARER ${this.auth.jwt}`;
        }
        if (this.auth.headers) {
          headers = { ...headers, ...this.auth.headers };
        }
        init3.headers = { ...init3.headers, ...headers };
      }
      return this._globalFetch(input2, init3);
    });
    this.auth = auth2;
    this._globalFetch = globalFetch;
    this.fetch = this._fetch;
  }
};
var MAX_QUEUE_SIZE = 150;
var defaultDatabeatOptions = {
  defaultEnabled: true,
  noop: false,
  privacy: { userIdHash: true, userAgentSalt: false },
  userIdentTracking: false,
  strictMode: false,
  flushInterval: 500,
  initProps: () => {
    return {};
  }
};
var Databeat2 = class {
  constructor(host, auth2, options) {
    __publicField(this, "rpc");
    __publicField(this, "auth");
    __publicField(this, "options");
    __publicField(this, "enabled");
    __publicField(this, "ident");
    __publicField(this, "userId");
    __publicField(this, "sessionId");
    __publicField(this, "allowUserTracking");
    __publicField(this, "projectId");
    __publicField(this, "queue");
    __publicField(this, "flushTimeout");
    __publicField(this, "defaultProps");
    __publicField(this, "previousPageKey");
    __publicField(this, "ts");
    __publicField(this, "flush", async () => {
      if (this.flushTimeout !== null) {
        clearTimeout(this.flushTimeout);
        this.flushTimeout = null;
      }
      if (!this.enabled)
        return;
      if (this.options.noop)
        return;
      if (this.options.strictMode && !this.allowUserTracking)
        return;
      if (this.queue.length === 0)
        return;
      const events = this.dedupedQueue();
      this.queue = [];
      try {
        await this.rpc.tick({ events });
      } catch (err) {
        console.warn(`databeat flush failed: ${err}`);
      }
    });
    __publicField(this, "dedupedQueue", () => {
      const uniqEvents = /* @__PURE__ */ new Map();
      for (let i = 0; i < this.queue.length; i++) {
        const ev = this.queue[i];
        const key2 = `${ev.event}:${ev.source}:${ev.userId}:${ev.sessionId}:${JSON.stringify(ev.props)}:${JSON.stringify(ev.nums)}`;
        if (!uniqEvents.has(key2)) {
          uniqEvents.set(key2, ev);
        }
      }
      return Array.from(uniqEvents.values());
    });
    this.auth = auth2;
    this.rpc = new DatabeatRpcClient(host, auth2);
    this.options = defaultDatabeatOptions;
    if (options) {
      this.options = {
        defaultEnabled: options.defaultEnabled || defaultDatabeatOptions.defaultEnabled,
        projectId: options.projectId || null,
        privacy: options.privacy || defaultDatabeatOptions.privacy,
        userIdentTracking: options.userIdentTracking || defaultDatabeatOptions.userIdentTracking,
        strictMode: options.strictMode || defaultDatabeatOptions.strictMode,
        flushInterval: options.flushInterval || defaultDatabeatOptions.flushInterval,
        noop: options.noop || false,
        initProps: options.initProps || defaultDatabeatOptions.initProps
      };
    }
    this.init();
  }
  // init is called on load by the constructor and also by reset().
  init() {
    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);
    this.projectId = this.options.projectId || null;
    this.userId = null;
    this.sessionId = genSessionId();
    this.queue = [];
    this.flushTimeout = null;
    this.defaultProps = { ...getDefaultProps(), ...this.options.initProps() };
    this.identify();
  }
  // reset will reset the user_id and session_id details. Similar to a "logout" action.
  reset(skipInit) {
    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);
    if (this.userId && !this.isAnon()) {
      this.userId = null;
    }
    this.ident = 0;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    if (skipInit === true) {
      return;
    }
    this.init();
  }
  // identify can be called to seed the userId, where the behaviour changes
  // depending on privacy or strict modes. identify is also called on init,
  // where we load the data from localStorage.
  identify(userId, options) {
    if (!isBrowser())
      return;
    if (options && options.allowTracking !== void 0) {
      this.allowTracking(options.allowTracking);
    }
    if (!userId) {
      const val = getStorageVal();
      if (val !== null && val.id !== null) {
        this.userId = val.id;
        this.ident = val.it;
        this.allowUserTracking = val.ut;
        if (val.it === void 0) {
          if (this.userId.startsWith("anon:")) {
            this.ident = 0;
          } else {
            this.ident = 1;
          }
          this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
        } else {
          this.ident = val.it;
        }
      }
    }
    if (userId || this.userId === null) {
      const v3 = genUserId(userId, this.allowUserTracking, this.options);
      this.userId = v3.userId;
      this.ident = v3.ident;
      this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    }
    this.track({ event: "INIT", source: getPagePath(), props: this.defaultProps });
    this.flush();
  }
  // allowTracking is used by strict mode to enable/disable tracking.
  allowTracking(allowTracking) {
    this.allowUserTracking = allowTracking;
    setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    if (this.options.strictMode) {
      if (allowTracking) {
        this.enable();
      } else {
        this.disable();
      }
    }
  }
  async track(events, options) {
    if (isBrowser() && this.userId === null) {
      throw new Error("databeat: init first");
    }
    if (Array.isArray(events)) {
      for (let i = 0; i < events.length; i++) {
        events[i].ident = this.ident;
        events[i].userId = this.userId;
        events[i].sessionId = this.sessionId;
        if (!events[i].projectId && this.projectId) {
          events[i].projectId = this.projectId;
        }
      }
      this.queue.push(...events);
    } else {
      events.ident = this.ident;
      events.userId = this.userId;
      events.sessionId = this.sessionId;
      if (!events.projectId && this.projectId) {
        events.projectId = this.projectId;
      }
      this.queue.push(events);
    }
    if (this.queue.length > MAX_QUEUE_SIZE) {
      this.queue = this.queue.splice(this.queue.length - MAX_QUEUE_SIZE);
    }
    if (!this.enabled)
      return;
    if (options && options.flush) {
      await this.flush();
    } else if (this.flushTimeout === null) {
      this.flushTimeout = setTimeout(() => {
        this.flush();
      }, this.options.flushInterval);
    }
  }
  trackView(props = {}) {
    const eventProps = { ...this.defaultProps, ...props };
    const eventSource = getPagePath();
    const pageKey = `${eventSource}:${JSON.stringify(eventProps)}:${this.userId}:${this.sessionId}`;
    if (this.previousPageKey === pageKey)
      return;
    this.previousPageKey = pageKey;
    this.track({ event: "VIEW", source: eventSource, props: eventProps });
  }
  isEnabled() {
    return this.enabled;
  }
  isAnon() {
    return this.ident === 0;
  }
  getIdent() {
    return this.ident;
  }
  getUserId() {
    return this.userId;
  }
  getSessionId() {
    return this.sessionId;
  }
  getStorageTS() {
    if (this.ts) {
      return this.ts;
    }
    const val = getStorageVal();
    if (val === void 0 || val === null || val.id === null) {
      return void 0;
    }
    this.ts = val.ts;
    return this.ts;
  }
  enable() {
    if (!isAuthEnabled(this.auth)) {
      this.enabled = false;
      return;
    }
    if (!isBrowser())
      return;
    this.enabled = true;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    this.identify();
  }
  disable() {
    if (!isBrowser())
      return;
    this.enabled = false;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
  }
};
var isBrowser = () => {
  return typeof window === "object" && typeof window.localStorage === "object" && typeof window.localStorage.getItem === "function" && typeof window.localStorage.setItem === "function";
};
var isEnabled = (defaultEnabled, auth2) => {
  if (!isAuthEnabled(auth2)) {
    return false;
  }
  if (!isBrowser()) {
    return true;
  }
  const val = getStorageVal();
  if (val === null) {
    if (defaultEnabled !== null && defaultEnabled !== void 0) {
      return defaultEnabled;
    } else {
      return true;
    }
  } else {
    return val.on;
  }
};
var isAuthEnabled = (auth2) => {
  var _a2;
  if (((_a2 = auth2 == null ? void 0 : auth2.jwt) == null ? void 0 : _a2.length) > 0) {
    return true;
  }
  if ((auth2 == null ? void 0 : auth2.headers) && Object.keys(auth2.headers).length > 0) {
    return true;
  }
  return false;
};
var getPagePath = () => {
  try {
    return window.location.pathname;
  } catch (err) {
    return "";
  }
};
var getDefaultProps = () => {
  if (!isBrowser())
    return {};
  const params = new URL(window.location.href).searchParams;
  const props = {};
  props["origin"] = window.location.origin;
  if (params.get("ref") && params.get("ref") !== "") {
    props["ref"] = params.get("ref") || "";
  }
  if (params.get("source") && params.get("source") !== "") {
    props["source"] = params.get("source") || "";
  }
  if (params.get("utm_source") && params.get("utm_source") !== "") {
    props["utmSource"] = params.get("utm_source") || "";
  }
  if (params.get("utm_campaign") && params.get("utm_campaign") !== "") {
    props["utmCampaign"] = params.get("utm_campaign") || "";
  }
  if (params.get("utm_medium") && params.get("utm_medium") !== "") {
    props["utmMedium"] = params.get("utm_medium") || "";
  }
  if (params.get("utm_content") && params.get("utm_content") !== "") {
    props["utmContent"] = params.get("utm_content") || "";
  }
  if (params.get("utm_term") && params.get("utm_term") !== "") {
    props["utmTerm"] = params.get("utm_term") || "";
  }
  if (document.referrer && document.referrer !== "") {
    props["referrer"] = document.referrer;
  }
  if (params.get("gclid") && params.get("gclid") !== "") {
    props["gclid"] = params.get("gclid") || "";
  }
  return props;
};
var storageKey = "_dbeat";
var getStorageVal = () => {
  try {
    return JSON.parse(window.localStorage.getItem(storageKey));
  } catch (err) {
    return null;
  }
};
var setStorageVal = (val) => {
  try {
    if (!val.ts) {
      val.ts = Math.floor(Date.now() / 1e3);
    }
    window.localStorage.setItem(storageKey, JSON.stringify(val));
    return val.ts;
  } catch (err) {
    return;
  }
};
var genUserId = (seed, allowUserTracking, options) => {
  if (!seed || seed === null || seed === "") {
    const id2 = Math.floor(Math.random() * 1e14);
    return {
      userId: `${id2}`,
      ident: 0
      /* ANON */
    };
  }
  if (options.userIdentTracking && allowUserTracking) {
    return {
      userId: seed,
      ident: 2
      /* USER */
    };
  }
  if (options.privacy.userIdHash === true || !options.userIdentTracking || !allowUserTracking) {
    if (isBrowser() && options.privacy.userAgentSalt === true) {
      seed = seed + ":" + navigator.userAgent;
    }
    if (options.privacy.extraSalt && options.privacy.extraSalt.length > 0) {
      seed = seed + ":" + options.privacy.extraSalt;
    }
    return {
      userId: bytesToHex$2(sha256$2(seed)).substring(0, 50),
      ident: 1
      /* PRIVATE */
    };
  } else {
    throw new Error("invalid configuration");
  }
};
var genSessionId = () => {
  const isSessionStorageAvail = isBrowser() && typeof window.sessionStorage === "object" && typeof window.sessionStorage.getItem === "function" && typeof window.sessionStorage.setItem === "function";
  if (!isSessionStorageAvail) {
    return genRandHex(16);
  } else {
    const sid = window.sessionStorage.getItem(storageKey);
    if (!!sid && sid.length > 0) {
      return sid;
    } else {
      const sid2 = genRandHex(16);
      window.sessionStorage.setItem(storageKey, sid2);
      return sid2;
    }
  }
};
var genRandHex = (n2) => {
  let hexString = "";
  for (let i = 0; i < n2; i++) {
    hexString += Math.floor(Math.random() * 16).toString(16);
  }
  return "0x" + hexString;
};
if (typeof process$1 === "object" && process$1.version && process$1.version < "v18") {
  console.error(`ERROR! expecting node v18+ but your node version is reporting ${process$1.version}`);
  if (process$1 && process$1.exit) {
    process$1.exit(1);
  }
}
const PROHIBITED_FUNCTIONS = new Map(["addHook(bytes4,address)", "clearExtraImageHashes(bytes32[])", "removeHook(bytes4)", "setExtraImageHash(bytes32,uint256)", "updateIPFSRoot(bytes32)", "updateImageHash(bytes32)", "updateImageHashAndIPFS(bytes32,bytes32)", "updateImplementation(address)"].map((signature2) => [keccak256$2(toUtf8Bytes(signature2)).slice(0, 10), signature2]));
function validateTransactionRequest(wallet, transaction2) {
  const transactions2 = index$1$2.transaction.fromTransactionish(wallet, transaction2);
  const unwound = index$1$2.transaction.unwind(wallet, transactions2);
  unwound.forEach((transaction22) => validateTransaction(wallet, transaction22));
}
function validateTransaction(wallet, transaction2) {
  if (transaction2.to.toLowerCase() === wallet.toLowerCase()) {
    if (transaction2.data) {
      const data = arrayify(transaction2.data);
      if (data.length >= 4 && !isCreateContractCall(data)) {
        throw new Error("self calls are forbidden");
      }
    }
  }
  if (transaction2.delegateCall) {
    throw new Error("delegate calls are forbidden");
  }
  if (transaction2.data) {
    const data = hexlify(transaction2.data);
    const selector2 = data.slice(0, 10);
    const signature2 = PROHIBITED_FUNCTIONS.get(selector2);
    if (signature2) {
      const name2 = signature2.slice(0, signature2.indexOf("("));
      throw new Error(`${name2} calls are forbidden`);
    }
  }
}
function isCreateContractCall(data) {
  const walletInterface = new Interface(walletContracts.mainModule.abi);
  try {
    walletInterface.decodeFunctionData("createContract", data);
    return true;
  } catch (_unused) {
    return false;
  }
}
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function isProviderTransport(transport) {
  return transport && typeof transport === "object" && typeof transport.register === "function" && typeof transport.unregister === "function" && typeof transport.openWallet === "function" && typeof transport.closeWallet === "function" && typeof transport.isOpened === "function" && typeof transport.isConnected === "function" && typeof transport.on === "function";
}
class WindowSessionParams extends URLSearchParams {
  static new(init3) {
    return new URLSearchParams(init3);
  }
}
let EventType = /* @__PURE__ */ function(EventType2) {
  EventType2["OPEN"] = "open";
  EventType2["CLOSE"] = "close";
  EventType2["MESSAGE"] = "message";
  EventType2["CONNECT"] = "connect";
  EventType2["DISCONNECT"] = "disconnect";
  EventType2["ACCOUNTS_CHANGED"] = "accountsChanged";
  EventType2["CHAIN_CHANGED"] = "chainChanged";
  EventType2["NETWORKS"] = "networks";
  EventType2["WALLET_CONTEXT"] = "walletContext";
  EventType2["INIT"] = "init";
  EventType2["DEBUG"] = "_debug";
  return EventType2;
}({});
let OpenState = /* @__PURE__ */ function(OpenState2) {
  OpenState2[OpenState2["CLOSED"] = 0] = "CLOSED";
  OpenState2[OpenState2["OPENING"] = 1] = "OPENING";
  OpenState2[OpenState2["OPENED"] = 2] = "OPENED";
  return OpenState2;
}({});
let InitState = /* @__PURE__ */ function(InitState2) {
  InitState2[InitState2["NIL"] = 0] = "NIL";
  InitState2[InitState2["SENT_NONCE"] = 1] = "SENT_NONCE";
  InitState2[InitState2["OK"] = 2] = "OK";
  return InitState2;
}({});
class ProviderError extends Error {
  constructor(message) {
    super(message);
    this.name = "ProviderError";
  }
}
const ErrSignedInRequired = new ProviderError("Wallet is not signed in. Connect a wallet and try again.");
const PROVIDER_OPEN_TIMEOUT = 3e4;
let _messageIdx = 0;
const nextMessageIdx = () => ++_messageIdx;
class BaseProviderTransport {
  constructor() {
    var _this = this;
    this.pendingMessageRequests = [];
    this.responseCallbacks = /* @__PURE__ */ new Map();
    this.state = void 0;
    this.confirmationOnly = false;
    this.events = new eventemitter2Exports.EventEmitter2();
    this.openPayload = void 0;
    this.connectPayload = void 0;
    this.accountsChangedPayload = void 0;
    this.networksPayload = void 0;
    this.walletContextPayload = void 0;
    this._sessionId = void 0;
    this._init = void 0;
    this._registered = void 0;
    this.sendAsync = async function(request, callback, chainId) {
      if (_this.state === OpenState.CLOSED) {
        _this.confirmationOnly = true;
      }
      _this.openWallet(void 0, {
        type: "jsonRpcRequest",
        method: request.method
      }, chainId);
      try {
        if (!_this.isOpened()) {
          await _this.waitUntilOpened();
        }
        const response = await _this.sendMessageRequest({
          idx: nextMessageIdx(),
          type: EventType.MESSAGE,
          data: request,
          chainId
        });
        callback(void 0, response.data);
      } catch (err) {
        callback(err);
      }
    };
    this.sendMessageRequest = async function(message) {
      return new Promise((resolve, reject) => {
        if ((!message.idx || message.idx <= 0) && message.type !== "init") {
          reject(new Error("message idx not set"));
        }
        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error("no valid response to return");
          }
        };
        const idx = message.idx;
        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error("duplicate message idx, should never happen"));
        }
        if (!_this.isOpened()) {
          logger.debug("pushing to pending requests", message);
          _this.pendingMessageRequests.push(message);
        } else {
          _this.sendMessage(message);
        }
      });
    };
    this.waitUntilOpened = async function(openTimeout = PROVIDER_OPEN_TIMEOUT) {
      let opened = false;
      return Promise.race([new Promise((_, reject) => {
        const timeout = setTimeout(() => {
          clearTimeout(timeout);
          if (!opened) {
            _this.state = OpenState.CLOSED;
            _this.events.emit("close", {
              code: 1005,
              message: "opening wallet timed out"
            });
          }
          reject(new Error("opening wallet timed out"));
        }, openTimeout);
      }), new Promise((resolve) => {
        if (_this.isOpened()) {
          var _this$openPayload;
          opened = true;
          resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);
          return;
        }
        _this.events.once("open", (openInfo) => {
          _this.openPayload = openInfo;
          opened = true;
          resolve(openInfo.session);
        });
      })]);
    };
    this.waitUntilConnected = async function() {
      await _this.waitUntilOpened();
      const connect2 = new Promise((resolve) => {
        if (_this.connectPayload) {
          resolve(_this.connectPayload);
          return;
        }
        _this.events.once("connect", (connectDetails) => {
          _this.connectPayload = connectDetails;
          resolve(connectDetails);
        });
      });
      const closeWallet = new Promise((_, reject) => {
        _this.events.once("close", (error) => {
          if (error) {
            reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));
          } else {
            reject(new Error(`user closed the wallet`));
          }
        });
      });
      return Promise.race([connect2, closeWallet]);
    };
    this.state = OpenState.CLOSED;
    this._registered = false;
    this._init = InitState.NIL;
  }
  get registered() {
    return this._registered;
  }
  register() {
    throw new Error("abstract method");
  }
  unregister() {
    throw new Error("abstract method");
  }
  openWallet(path, intent, networkId) {
    throw new Error("abstract method");
  }
  closeWallet() {
    throw new Error("abstract method");
  }
  isOpened() {
    return this.registered && this.state === OpenState.OPENED;
  }
  isConnected() {
    var _this$openPayload2;
    const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;
    return this.registered && session !== void 0 && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;
  }
  // handleMessage will handle message received from the remote wallet
  handleMessage(message) {
    var _this2 = this;
    if (message.type === EventType.INIT) {
      logger.debug("MessageProvider, received INIT message", message);
      const {
        nonce
      } = message.data;
      if (!nonce || nonce.length == 0) {
        logger.error("invalid init nonce");
        return;
      }
      this._init = InitState.OK;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          sessionId: this._sessionId,
          nonce
        }
      });
    }
    if (this._init !== InitState.OK) {
      return;
    }
    logger.debug("RECEIVED MESSAGE FROM WALLET", message.idx, message);
    const requestIdx = message.idx;
    const responseCallback = this.responseCallbacks.get(requestIdx);
    if (requestIdx) {
      this.responseCallbacks.delete(requestIdx);
    }
    if (message.type === EventType.OPEN && !this.isOpened()) {
      var _message$data, _message$data2;
      if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {
        logger.debug("open event received from wallet, but does not match sessionId", this._sessionId);
        return;
      }
      if ((_message$data2 = message.data) != null && _message$data2.error) {
        var _message$data3;
        const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);
        logger.error(err);
        this.close();
        throw err;
      }
      this.state = OpenState.OPENED;
      this.openPayload = message.data;
      this.events.emit("open", this.openPayload);
      if (this.pendingMessageRequests.length !== 0) {
        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);
        pendingMessageRequests.forEach(async function(pendingMessageRequest) {
          _this2.sendMessage(pendingMessageRequest);
        });
      }
      return;
    }
    if (message.type === EventType.MESSAGE) {
      if (this.confirmationOnly) {
        setTimeout(() => {
          if (this.responseCallbacks.size === 0) {
            this.closeWallet();
          }
        }, 500);
      }
      if (!responseCallback) {
        throw new Error("impossible state");
      }
      if (responseCallback) {
        this.events.emit("message", message);
        responseCallback(message.data.error, message);
        return;
      }
    }
    if (message.type === EventType.ACCOUNTS_CHANGED) {
      this.accountsChangedPayload = {
        accounts: []
      };
      if (message.data && message.data.length > 0) {
        this.accountsChangedPayload = {
          accounts: [getAddress$1(message.data[0])],
          origin: message.origin
        };
        this.events.emit("accountsChanged", this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);
      } else {
        this.events.emit("accountsChanged", [], message.origin);
      }
      return;
    }
    if (message.type === EventType.CHAIN_CHANGED) {
      this.events.emit("chainChanged", message.data, message.origin);
      return;
    }
    if (message.type === EventType.NETWORKS) {
      this.networksPayload = message.data;
      this.events.emit("networks", this.networksPayload);
      return;
    }
    if (message.type === EventType.WALLET_CONTEXT) {
      this.walletContextPayload = message.data;
      this.events.emit("walletContext", this.walletContextPayload);
      return;
    }
    if (message.type === EventType.CLOSE) {
      if (this.state !== OpenState.CLOSED) {
        this.close(message.data);
      }
    }
    if (message.type === EventType.CONNECT) {
      this.connectPayload = message.data;
      this.events.emit("connect", this.connectPayload);
    }
    if (message.type === EventType.DISCONNECT) {
      if (this.isConnected()) {
        this.events.emit("disconnect", message.data, message.origin);
        this.close();
      }
    }
  }
  sendMessage(message) {
    throw new Error("abstract method");
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
  emit(event, ...args) {
    return this.events.emit(event, ...args);
  }
  close(error) {
    if (this.state === OpenState.CLOSED)
      return;
    this.state = OpenState.CLOSED;
    this.confirmationOnly = false;
    this._sessionId = void 0;
    logger.info("closing wallet and flushing!");
    this.pendingMessageRequests.length = 0;
    this.responseCallbacks.forEach((responseCallback) => {
      responseCallback(_extends$3({}, new Error("wallet closed"), {
        code: 4001
      }));
    });
    this.responseCallbacks.clear();
    this.connectPayload = void 0;
    this.openPayload = void 0;
    this.accountsChangedPayload = void 0;
    this.networksPayload = void 0;
    this.walletContextPayload = void 0;
    this.events.emit("close", error);
  }
}
function messageIsExemptFromEIP191Prefix(message) {
  return EIP_191_PREFIX_EXCEPTIONS.some((e2) => e2.predicate(message));
}
const EIP_191_PREFIX_EXCEPTIONS = [
  // NOTE: Decentraland does not support 191 correctly.
  {
    name: "Decentraland Exception",
    predicate: isDecentralandLoginMessage
  },
  // NOTE: 0x v3 does not support 191 correctly.
  // See https://gov.0x.org/t/zeip-proposal-fix-v3-eip-191-non-compliance-when-validating-eip-1271-signatures/3396 for more info.
  {
    name: "0x v3 Exception",
    predicate: isZeroExV3Order
  }
];
const DCL_REGEX = /^Decentraland Login\nEphemeral address: 0x[a-fA-F0-9]{40}\nExpiration: (\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)((-(\d{2}):(\d{2})|Z)?)$/;
function isDecentralandLoginMessage(bytes3) {
  try {
    const stringified = toUtf8String(bytes3);
    return DCL_REGEX.test(stringified);
  } catch (_unused) {
    return false;
  }
}
function isZeroExV3Order(bytes3) {
  const abi2 = new Interface(ZeroXV3EIP1271OrderWithHashAbi);
  try {
    abi2.decodeFunctionData("OrderWithHash", bytes3);
    return true;
  } catch (err) {
    return false;
  }
}
const ZeroXV3EIP1271OrderWithHashAbi = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "makerAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "takerAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "feeRecipientAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "senderAddress",
      type: "address"
    }, {
      internalType: "uint256",
      name: "makerAssetAmount",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "takerAssetAmount",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "makerFee",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "takerFee",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "expirationTimeSeconds",
      type: "uint256"
    }, {
      internalType: "uint256",
      name: "salt",
      type: "uint256"
    }, {
      internalType: "bytes",
      name: "makerAssetData",
      type: "bytes"
    }, {
      internalType: "bytes",
      name: "takerAssetData",
      type: "bytes"
    }, {
      internalType: "bytes",
      name: "makerFeeAssetData",
      type: "bytes"
    }, {
      internalType: "bytes",
      name: "takerFeeAssetData",
      type: "bytes"
    }],
    internalType: "struct IEIP1271Data.Order",
    name: "order",
    type: "tuple"
  }, {
    internalType: "bytes32",
    name: "orderHash",
    type: "bytes32"
  }],
  name: "OrderWithHash",
  outputs: [],
  stateMutability: "pure",
  type: "function"
}];
const eip191prefix = toUtf8Bytes("Ethereum Signed Message:\n");
const messageToBytes = (message) => {
  if (isBytesLike(message)) {
    return arrayify(message);
  }
  return toUtf8Bytes(message);
};
const prefixEIP191Message = (message) => {
  const messageBytes = messageToBytes(message);
  if (messageIsExemptFromEIP191Prefix(messageBytes)) {
    return messageBytes;
  } else {
    return concat$1([eip191prefix, toUtf8Bytes(String(messageBytes.length)), messageBytes]);
  }
};
const trimEIP191Prefix = (prefixedMessage) => {
  if (JSON.stringify(prefixedMessage.slice(0, eip191prefix.length)) !== JSON.stringify(eip191prefix)) {
    return prefixedMessage;
  }
  const ethereumSignedMessagePartSlicedArray = prefixedMessage.slice(eip191prefix.length);
  const maxPrefixCharLength = String(ethereumSignedMessagePartSlicedArray.length).length;
  let prefixCharLenght;
  let prefixAsNumber;
  try {
    prefixAsNumber = Number(toUtf8String(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
  } catch (_unused) {
    prefixAsNumber = Number(hexlify(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
  }
  if (prefixAsNumber > ethereumSignedMessagePartSlicedArray.length || !Number.isInteger(prefixAsNumber)) {
    prefixCharLenght = maxPrefixCharLength - 1;
  } else {
    prefixCharLenght = maxPrefixCharLength;
  }
  const prefixRevertedMessage = ethereumSignedMessagePartSlicedArray.slice(prefixCharLenght);
  return prefixRevertedMessage;
};
const isValidSignature = async (address, digest9, sig, provider2) => {
  const reader2 = new index$1$2.reader.OnChainReader(provider2);
  return reader2.isValidSignature(address, digest9, sig);
};
const isValidMessageSignature = async (address, message, signature2, provider2) => {
  const prefixed = prefixEIP191Message(message);
  const digest9 = encodeMessageDigest(prefixed);
  return isValidSignature(address, digest9, signature2, provider2);
};
const isValidTypedDataSignature = (address, typedData, signature2, provider2) => {
  return isValidSignature(address, encodeTypedDataDigest(typedData), signature2, provider2);
};
const isBrowserExtension = () => window.location.protocol === "chrome-extension:" || window.location.protocol === "moz-extension:";
const isUnityPlugin = () => !!navigator.userAgent.match(/UnitySequence/i);
const isWalletUpToDate = (status) => {
  return status.onChain.deployed && status.fullyMigrated;
};
class MemoryItemStore {
  constructor() {
    this.callbacks = [];
    this.store = {};
  }
  getItem(key2) {
    return this.store[key2] || null;
  }
  setItem(key2, value) {
    this.store[key2] = value;
    this.callbacks.filter((c2) => c2.key === key2).forEach((c2) => c2.cb(value));
  }
  removeItem(key2) {
    delete this.store[key2];
  }
  onItemChange(key2, cb2) {
    this.callbacks.push({
      key: key2,
      cb: cb2
    });
    return () => {
      this.callbacks = this.callbacks.filter((c2) => c2.cb !== cb2);
    };
  }
}
class LocalStorage {
  static isAvailable() {
    return typeof window === "object" && typeof window.localStorage === "object";
  }
  constructor() {
    this.callbacks = [];
    if (!LocalStorage.isAvailable()) {
      throw new Error("LocalStorage is not available");
    }
    window.addEventListener("storage", (e2) => {
      const {
        key: key2
      } = e2;
      const cb2 = this.callbacks.filter((c2) => c2.key === key2);
      cb2.forEach((c2) => c2.cb(this.getItem(key2)));
    });
  }
  getItem(key2) {
    return window.localStorage.getItem(key2);
  }
  setItem(key2, value) {
    window.localStorage.setItem(key2, value);
    this.callbacks.filter((c2) => c2.key === key2).forEach((c2) => c2.cb(value));
  }
  removeItem(key2) {
    window.localStorage.removeItem(key2);
    this.callbacks.filter((c2) => c2.key === key2).forEach((c2) => c2.cb(null));
  }
  onItemChange(key2, cb2) {
    this.callbacks.push({
      key: key2,
      cb: cb2
    });
    return () => {
      this.callbacks = this.callbacks.filter((c2) => c2.cb !== cb2);
    };
  }
}
function useBestStore() {
  if (LocalStorage.isAvailable()) {
    return new LocalStorage();
  }
  return new MemoryItemStore();
}
async function resolveArrayProperties(object) {
  if (Array.isArray(object)) {
    return Promise.all(object.map((o2) => resolveProperties$1(o2)));
  }
  return resolveProperties$1(object);
}
const TRANSPORT_SESSION_LS_KEY = "@sequence.transportSession";
class BaseWalletTransport {
  constructor(walletRequestHandler) {
    var _this = this;
    this.walletRequestHandler = void 0;
    this._sessionId = void 0;
    this._registered = void 0;
    this._init = void 0;
    this._initNonce = void 0;
    this._initCallback = void 0;
    this.appOrigin = void 0;
    this.sendAsync = async function(request, callback, chainId) {
      throw new Error("abstract method");
    };
    this.handleMessage = async function(message) {
      const request = message;
      if (_this._init !== InitState.OK) {
        if (request.type === EventType.INIT) {
          if (_this.isValidInitAck(message)) {
            if (_this._initCallback)
              _this._initCallback();
          } else {
            if (_this._initCallback)
              _this._initCallback("invalid init");
            return;
          }
        }
        return;
      }
      switch (request.type) {
        case EventType.OPEN: {
          if (_this._init !== InitState.OK)
            return;
          const session = {
            sessionId: request.data.sessionId,
            intent: request.data.intent,
            networkId: request.data.networkId
          };
          await _this.open(session);
          return;
        }
        case EventType.CLOSE: {
          if (_this._init !== InitState.OK)
            return;
          return;
        }
        case EventType.MESSAGE: {
          const response = await _this.walletRequestHandler.sendMessageRequest(request);
          _this.sendMessage(response);
          if (response.data.error)
            ;
          return;
        }
        default: {
          logger.error(`unexpected payload type ${request.type}`);
        }
      }
    };
    this.sendMessageRequest = async function(message) {
      return _this.walletRequestHandler.sendMessageRequest(message);
    };
    this.open = async function({
      sessionId,
      intent,
      networkId
    }) {
      if (sessionId) {
        _this._sessionId = sanitizeNumberString(sessionId);
        _this.saveTransportSession({
          sessionId,
          intent,
          networkId
        });
      }
      _this.walletRequestHandler.setOpenIntent(intent);
      await _this.init();
      let chainId = void 0;
      try {
        if (networkId) {
          const network2 = findSupportedNetwork(networkId);
          if (network2) {
            chainId = network2.chainId;
          } else {
            throw new Error(`unknown network ${networkId}`);
          }
        } else {
          chainId = _this.walletRequestHandler.defaultChainId();
        }
      } catch (err) {
        console.error(err);
      }
      if (intent && intent.type === "connect" && intent.options) {
        const connectOptions = intent.options;
        const authorizeOptions = connectOptions;
        if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          if (!isBrowserExtension()) {
            if (authorizeOptions.origin !== _this.appOrigin) {
              throw new Error("origin is invalid");
            }
          }
        } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          connectOptions.origin = sanitizeHost(authorizeOptions.origin);
        } else if (_this.appOrigin) {
          connectOptions.origin = _this.appOrigin;
        }
        if (connectOptions.app) {
          connectOptions.app = sanitizeAlphanumeric(connectOptions.app);
        }
        if (connectOptions.networkId) {
          networkId = connectOptions.networkId;
        } else if (networkId) {
          connectOptions.networkId = networkId;
        }
        _this.walletRequestHandler.setConnectOptions(connectOptions);
      } else {
        _this.walletRequestHandler.setConnectOptions(void 0);
      }
      await _this.walletRequestHandler.getAccount();
      if (!await _this.walletRequestHandler.isSignedIn()) {
        _this.notifyOpen({
          sessionId: _this._sessionId
        });
        return true;
      } else {
        if (intent && intent.type === "connect") {
          if (!chainId || chainId <= 0) {
            console.log("Failed to set default network on open");
          }
          _this.notifyOpen({
            sessionId: _this._sessionId
          });
          try {
            const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);
            if (connectDetails.connected) {
              _this.walletRequestHandler.notifyConnect(connectDetails);
            }
          } catch (err) {
            logger.warn("promptConnect not connected:", err);
          } finally {
            if (!intent.options || intent.options.keepWalletOpened !== true) {
              _this.notifyClose();
            }
          }
        } else {
          if (!chainId || chainId <= 0) {
            _this.notifyOpen({
              sessionId: _this._sessionId,
              error: `failed to open wallet on network ${networkId}`
            });
            return false;
          }
          _this.notifyOpen({
            sessionId: _this._sessionId,
            chainId: `${chainId}`,
            session: await _this.walletRequestHandler.walletSession(chainId)
          });
        }
      }
      return true;
    };
    this.saveTransportSession = (session) => {
      useBestStore().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));
    };
    this.getCachedTransportSession = async function() {
      const session = useBestStore().getItem(TRANSPORT_SESSION_LS_KEY);
      try {
        return session ? JSON.parse(session) : null;
      } catch (err) {
        console.error(`unable to parse transport session: ${session}`);
        return null;
      }
    };
    this.walletRequestHandler = walletRequestHandler;
    this._init = InitState.NIL;
    this.walletRequestHandler.on("connect", (connectDetails) => {
      if (!this.registered)
        return;
      this.notifyConnect(connectDetails);
    });
    this.walletRequestHandler.on("disconnect", (error, origin) => {
      if (!this.registered)
        return;
      this.notifyDisconnect(error, origin);
    });
    this.walletRequestHandler.on("accountsChanged", (accounts, origin) => {
      if (!this.registered)
        return;
      this.notifyAccountsChanged(accounts, origin);
    });
    this.walletRequestHandler.on("networks", (networks2) => {
      if (!this.registered)
        return;
      this.notifyNetworks(networks2);
      if (!networks2 || networks2.length === 0) {
        this.notifyChainChanged("0x0");
      } else {
        this.notifyChainChanged(hexValue(networks2.find((network2) => network2.isDefaultChain).chainId));
      }
    });
    this.walletRequestHandler.on("chainChanged", (chainIdHex, origin) => {
      this.notifyChainChanged(chainIdHex, origin);
    });
    this.walletRequestHandler.on("walletContext", (walletContext) => {
      if (!this.registered || !walletContext)
        return;
      this.notifyWalletContext(walletContext);
    });
    this.walletRequestHandler.on("close", (error) => {
      if (!this.registered)
        return;
      this.notifyClose(error);
    });
  }
  get registered() {
    return this._registered;
  }
  register() {
    throw new Error("abstract method");
  }
  unregister() {
    throw new Error("abstract method");
  }
  sendMessage(message) {
    throw new Error("abstract method");
  }
  notifyOpen(openInfo) {
    const {
      chainId,
      sessionId,
      session,
      error
    } = openInfo;
    this.sendMessage({
      idx: -1,
      type: EventType.OPEN,
      data: {
        chainId,
        sessionId,
        session,
        error
      }
    });
  }
  notifyClose(error) {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: error ? {
        error
      } : null
    });
  }
  notifyConnect(connectDetails) {
    this.sendMessage({
      idx: -1,
      type: EventType.CONNECT,
      data: connectDetails
    });
  }
  notifyDisconnect(error, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.DISCONNECT,
      data: error ? {
        error
      } : null,
      origin
    });
  }
  notifyAccountsChanged(accounts, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.ACCOUNTS_CHANGED,
      data: accounts,
      origin
    });
  }
  notifyChainChanged(chainIdHex, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.CHAIN_CHANGED,
      data: chainIdHex,
      origin
    });
  }
  notifyNetworks(networks2) {
    this.sendMessage({
      idx: -1,
      type: EventType.NETWORKS,
      data: networks2
    });
  }
  notifyWalletContext(walletContext) {
    this.sendMessage({
      idx: -1,
      type: EventType.WALLET_CONTEXT,
      data: walletContext
    });
  }
  isValidInitAck(message) {
    if (this._init === InitState.OK) {
      logger.warn("isValidInitAck, already in init'd state, so inquiry is invalid.");
      return false;
    }
    if (message.type !== EventType.INIT) {
      logger.warn("isValidInitAck, invalid message type, expecting init");
      return false;
    }
    const {
      sessionId,
      nonce
    } = message.data;
    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {
      logger.error("invalid init ack");
      return false;
    }
    if (sessionId !== this._sessionId || nonce !== this._initNonce) {
      logger.error("invalid init ack match");
      return false;
    }
    return true;
  }
  init() {
    return new Promise((resolve, reject) => {
      if (this._init === InitState.OK) {
        resolve();
        return;
      }
      if (this._init !== InitState.NIL || this._initCallback) {
        reject("transport init is in progress");
        return;
      }
      const initTimeout = setTimeout(() => {
        logger.warn("transport init timed out");
        if (this._initCallback) {
          this._initCallback("transport init timed out");
        }
      }, PROVIDER_OPEN_TIMEOUT / 2);
      this._initCallback = (error) => {
        this._initCallback = void 0;
        clearTimeout(initTimeout);
        if (error) {
          reject(error);
        } else {
          this._init = InitState.OK;
          resolve();
        }
      };
      this._initNonce = `${performance.now()}`;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          nonce: this._initNonce
        }
      });
      this._init = InitState.SENT_NONCE;
    });
  }
}
class ProxyMessageChannel {
  constructor() {
    this.app = void 0;
    this.wallet = void 0;
    const port1 = new ProxyMessageChannelPort();
    const port2 = new ProxyMessageChannelPort();
    port1.conn = port2;
    port2.conn = port1;
    this.app = port1;
    this.wallet = port2;
  }
}
class ProxyMessageChannelPort {
  constructor() {
    this.conn = void 0;
    this.events = new eventemitter2Exports.EventEmitter2();
    this.handleMessage = (message) => {
      throw new Error("ProxyMessageChannelPort is not registered");
    };
    this.sendMessage = (message) => {
      this.conn.handleMessage(message);
      if (message.type === "open") {
        this.events.emit("open", message);
      }
      if (message.type === "close") {
        this.events.emit("close", message);
      }
      if (message.type === "connect") {
        this.events.emit("connect", message);
      }
      if (message.type === "disconnect") {
        this.events.emit("disconnect", message);
      }
    };
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
}
class ProxyMessageProvider extends BaseProviderTransport {
  constructor(port) {
    super();
    this.port = void 0;
    this.register = () => {
      this.port.handleMessage = (message) => {
        this.handleMessage(message);
      };
      this.on("open", (...args) => {
        this.port.events.emit("open", ...args);
      });
      this.on("close", (...args) => {
        this.port.events.emit("close", ...args);
      });
      this.on("connect", (...args) => {
        this.port.events.emit("connect", ...args);
      });
      this.on("disconnect", (...args) => {
        this.port.events.emit("disconnect", ...args);
      });
      this._registered = true;
    };
    this.unregister = () => {
      this._registered = false;
      this.closeWallet();
      this.events.removeAllListeners();
      this.port.handleMessage = void 0;
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.state === OpenState.CLOSED) {
        this.state = OpenState.OPENING;
        const sessionId = `${performance.now()}`;
        this._sessionId = sessionId;
        this.sendMessage({
          idx: -1,
          type: EventType.OPEN,
          data: {
            path,
            intent,
            networkId,
            sessionId
          }
        });
      }
    };
    this.state = OpenState.CLOSED;
    this.port = port;
    if (!port) {
      throw new Error("port argument cannot be empty");
    }
    this._init = InitState.OK;
  }
  closeWallet() {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: null
    });
    this.close();
  }
  sendMessage(message) {
    if (!message.idx) {
      throw new Error("message idx is empty");
    }
    this.port.sendMessage(message);
  }
}
class ProxyMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, port) {
    super(walletRequestHandler);
    this.port = void 0;
    this.port = port;
    this._init = InitState.OK;
  }
  register() {
    this.port.handleMessage = (message) => {
      this.handleMessage(message);
    };
    this._registered = true;
  }
  // note: we can't decide whether to restore the session within register(), because session info is
  // received asyncronously via EventType.OPEN after register() is executed.
  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,
  // because the wallet is already open.
  //
  // call this method from wallet redirect hander when a session restore is needed
  async restoreSession() {
    const cachedSession = await this.getCachedTransportSession();
    if (cachedSession) {
      this.open(cachedSession);
    }
  }
  unregister() {
    this.port.handleMessage = void 0;
    this._registered = false;
  }
  sendMessage(message) {
    this.port.sendMessage(message);
  }
}
function overrideLogs(side) {
  var _window$ue;
  if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport && !window.logsOverriddenForUnreal) {
    var _window$ue2;
    const t2 = (_window$ue2 = window.ue) == null ? void 0 : _window$ue2.sequencewallettransport;
    console.log = (...args) => {
      t2.logfromjs(`${side}: ${stringify$1(args)}`);
    };
    console.warn = (...args) => {
      t2.warnfromjs(`${side}: ${stringify$1(args)}`);
    };
    console.error = (...args) => {
      t2.errorfromjs(`${side}: ${stringify$1(args)}`);
    };
    window.logsOverriddenForUnreal = true;
  }
}
function stringify$1(things) {
  return things.map((a2) => typeof a2 === "object" ? a2 instanceof Error ? a2.message : JSON.stringify(a2) : String(a2)).join(" ");
}
let registeredUnrealMessageProvider;
class UnrealMessageProvider extends BaseProviderTransport {
  constructor(walletAppURL) {
    super();
    this.walletURL = void 0;
    this.register = () => {
      var _window$ue;
      overrideLogs("dapp");
      if (registeredUnrealMessageProvider) {
        registeredUnrealMessageProvider.unregister();
        registeredUnrealMessageProvider = this;
      }
      if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport) {
        window.ue.sequencewallettransport.onmessagefromwallet = this.onUnrealCallback;
      }
      registeredUnrealMessageProvider = this;
      this._registered = true;
      console.log("registering transport!");
    };
    this.unregister = () => {
      var _window$ue2;
      this._registered = false;
      this.closeWallet();
      if (registeredUnrealMessageProvider === this) {
        registeredUnrealMessageProvider = void 0;
      }
      if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromwallet) === this.onUnrealCallback) {
        delete window.ue.sequencewallettransport.onmessagefromwallet;
      }
      this.events.removeAllListeners();
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.isOpened()) {
        console.log("wallet already open!");
        return;
      }
      console.log("opening wallet!");
      const walletURL = new URL(this.walletURL.href);
      const windowSessionParams = new WindowSessionParams();
      if (path) {
        walletURL.pathname = path.toLowerCase();
      }
      this._init = InitState.NIL;
      this._sessionId = `${performance.now()}`;
      windowSessionParams.set("sid", this._sessionId);
      if (intent) {
        windowSessionParams.set("intent", base64EncodeObject(intent));
      }
      if (networkId) {
        windowSessionParams.set("net", `${networkId}`);
      }
      walletURL.search = windowSessionParams.toString();
      console.log("opening wallet to", walletURL.href);
      window.open(walletURL.href);
    };
    this.onUnrealCallback = (message) => {
      if (!message) {
        throw new Error("ProviderMessage object is empty");
      }
      this.handleMessage(message);
    };
    this.walletURL = new URL(walletAppURL);
  }
  closeWallet() {
    this.close();
  }
  // all lowercase is an annoying limitation of Unreal CEF BindUObject
  sendMessage(message) {
    var _window$ue3;
    const postedMessage = typeof message !== "string" ? JSON.stringify(message) : message;
    console.log("Sending message to wallet:", postedMessage);
    (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetowallet(postedMessage);
  }
}
class UnrealMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler) {
    super(walletRequestHandler);
    this.onMessageFromUnreal = (request) => {
      logger.debug("RECEIVED MESSAGE", request);
      this.handleMessage(request);
    };
    this.getUnrealTransportSession = (windowParams) => {
      const params = new WindowSessionParams(windowParams);
      return {
        sessionId: params.get("sid"),
        networkId: params.get("net"),
        intent: base64DecodeObject(params.get("intent"))
      };
    };
    this._init = InitState.NIL;
  }
  async register(windowHref) {
    var _window$ue;
    if (((_window$ue = window.ue) == null ? void 0 : _window$ue.sequencewallettransport) === void 0) {
      return;
    }
    overrideLogs("wallet");
    const {
      search: rawParams
    } = new URL(windowHref || window.location.href);
    let session = this.getUnrealTransportSession(rawParams);
    const isNewWindowSession = !!session.sessionId;
    if (!isNewWindowSession) {
      session = await this.getCachedTransportSession();
    }
    if (!session) {
      logger.error("unreal session is undefined");
      return;
    }
    window.ue.sequencewallettransport.onmessagefromsequencejs = this.onMessageFromUnreal;
    this._registered = true;
    this.open(session).then((opened) => {
      if (!opened) {
        var _session;
        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
        logger.error(err);
        this.notifyClose({
          message: err
        });
        window.close();
      }
    }).catch((e2) => {
      var _session2;
      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e2}`;
      logger.error(err);
      this.notifyClose({
        message: err
      });
      window.close();
    });
  }
  unregister() {
    var _window$ue2;
    if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromsequencejs) === this.onMessageFromUnreal) {
      delete window.ue.sequencewallettransport.onmessagefromsequencejs;
    }
    this._registered = false;
  }
  // sendMessage sends message to the dapp window
  sendMessage(message) {
    var _window$ue3;
    if (message.type !== EventType.INIT && this._init !== InitState.OK) {
      logger.error("impossible state, should not be calling postMessage until inited");
      return;
    }
    const payload = JSON.stringify(message);
    (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetosequencejs(payload);
  }
}
const CHANNEL_ID = "sequence-extension-message-handler";
class ExtensionMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, runtime) {
    super(walletRequestHandler);
    this.runtime = runtime;
    this.port = void 0;
    this._init = InitState.OK;
  }
  register() {
    this._registered = true;
    this.port = this.runtime.connect({
      name: CHANNEL_ID
    });
  }
  sendMessage(message) {
    logger.info("[ExtensionMessageHandler send]", message);
    this.port.postMessage(message);
  }
}
class ExtensionMessageProvider extends BaseProviderTransport {
  constructor(runtime) {
    super();
    this.register = () => {
      this._registered = true;
    };
    runtime.onConnect.addListener((port) => {
      if (port.name === CHANNEL_ID) {
        this._init = InitState.OK;
        port.onMessage.addListener((message) => {
          this.handleMessage(message);
        });
      }
    });
  }
  sendMessage(message) {
  }
  unregister() {
  }
  openWallet(path, intent, networkId) {
  }
  closeWallet() {
  }
}
class BaseInjectedTransport extends eventemitter2Exports.EventEmitter2 {
  constructor(stream) {
    var _this;
    super();
    _this = this;
    this.stream = stream;
    this.responseCallbacks = /* @__PURE__ */ new Map();
    this._messageIdx = 0;
    this.nextMessageIdx = () => ++this._messageIdx;
    this.handleMessage = (message) => {
      if (!message.type || !message.data) {
        return;
      }
      logger.info("[received message]", message);
      const requestIdx = message.idx;
      const responseCallback = this.responseCallbacks.get(requestIdx);
      if (requestIdx) {
        this.responseCallbacks.delete(requestIdx);
      }
      switch (message.type) {
        case EventType.MESSAGE:
          if (responseCallback) {
            this.emit(EventType.MESSAGE, message);
            responseCallback(message.data.error, message);
          } else {
            throw new Error("impossible state");
          }
          break;
        case EventType.DISCONNECT:
        case EventType.ACCOUNTS_CHANGED:
        case EventType.CHAIN_CHANGED:
          this.emit(message.type, message.data);
          break;
        default:
          console.error("unknown message type", message);
          break;
      }
    };
    this.sendMessageRequest = async function(message) {
      return new Promise((resolve, reject) => {
        if (!message.idx || message.idx <= 0) {
          reject(new Error("message idx not set"));
        }
        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error("no valid response to return");
          }
        };
        const {
          idx
        } = message;
        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error("duplicate message idx, should never happen"));
        }
        _this.sendMessage(message);
      });
    };
    this.stream.on("data", this.handleMessage);
  }
  sendMessage(message) {
    if (!this.stream.writable) {
      console.error("window post message stream is not writable");
    }
    this.stream.write(message);
  }
}
let registeredWindowMessageProvider;
class WindowMessageProvider extends BaseProviderTransport {
  constructor(walletAppURL) {
    super();
    this.walletURL = void 0;
    this.walletWindow = void 0;
    this.register = () => {
      if (registeredWindowMessageProvider) {
        registeredWindowMessageProvider.unregister();
        registeredWindowMessageProvider = this;
      }
      window.addEventListener("message", this.onWindowEvent);
      registeredWindowMessageProvider = this;
      this.on("open", () => {
        const popup = this.walletWindow;
        const interval = setInterval(() => {
          if (popup && popup.closed) {
            clearInterval(interval);
            this.close();
          }
        }, 500);
      });
      this.on("close", () => {
        if (this.walletWindow) {
          this.walletWindow.close();
          this.walletWindow = null;
        }
      });
      this._registered = true;
    };
    this.unregister = () => {
      this._registered = false;
      this.closeWallet();
      if (registeredWindowMessageProvider === this) {
        registeredWindowMessageProvider = void 0;
      }
      window.removeEventListener("message", this.onWindowEvent);
      this.events.removeAllListeners();
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.walletWindow && this.isOpened()) {
        this.walletWindow.focus();
        return;
      }
      const walletURL = new URL(this.walletURL.href);
      const windowSessionParams = new WindowSessionParams();
      if (path && path !== "") {
        walletURL.pathname = path.toLowerCase();
      }
      this._init = InitState.NIL;
      this._sessionId = `${performance.now()}`;
      windowSessionParams.set("sid", this._sessionId);
      if (intent) {
        if (intent.type === "connect") {
          if (!intent.options)
            intent.options = {
              app: window.location.origin
            };
          if (!isBrowserExtension() && !isUnityPlugin() && intent.options) {
            intent.options.origin = window.location.origin;
          }
        }
        windowSessionParams.set("intent", base64EncodeObject(intent));
      }
      if (networkId) {
        windowSessionParams.set("net", `${networkId}`);
      }
      let windowSize;
      let windowPos;
      if (isBrowserExtension()) {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)];
      } else {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2), Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)];
      }
      const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes,width=${windowSize[0]},height=${windowSize[1]},left=${windowPos[0]},top=${windowPos[1]}`;
      walletURL.search = windowSessionParams.toString();
      this.walletWindow = window.open(walletURL.href, "sequence.app", windowFeatures);
    };
    this.onWindowEvent = (event) => {
      if (event.origin !== this.walletURL.origin) {
        return;
      }
      let message;
      try {
        message = JSON.parse(event.data);
      } catch (err) {
        return;
      }
      if (!message) {
        throw new Error("ProviderMessage object is empty");
      }
      this.handleMessage(message);
    };
    this.walletURL = new URL(walletAppURL);
  }
  closeWallet() {
    var _this$walletWindow;
    this.close();
    (_this$walletWindow = this.walletWindow) == null || _this$walletWindow.close();
  }
  sendMessage(message) {
    if (!this.walletWindow) {
      logger.warn("WindowMessageProvider: sendMessage failed as walletWindow is unavailable");
      return;
    }
    const postedMessage = typeof message !== "string" ? JSON.stringify(message) : message;
    this.walletWindow.postMessage(postedMessage, this.walletURL.origin);
  }
}
class WindowMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler) {
    var _this;
    super(walletRequestHandler);
    _this = this;
    this.parentWindow = void 0;
    this._isPopup = false;
    this.onWindowEvent = async function(event) {
      if (!event.origin || event.origin === "") {
        return;
      }
      if (_this.appOrigin && event.origin !== _this.appOrigin) {
        return;
      }
      let request;
      try {
        request = JSON.parse(event.data);
      } catch (err) {
        return;
      }
      logger.debug("RECEIVED MESSAGE", request);
      if (_this._init !== InitState.OK && _this.isValidInitAck(request)) {
        _this.appOrigin = event.origin;
      }
      if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {
        logger.error("impossible state, init.OK and appOrigin required");
        return;
      }
      _this.handleMessage(request);
    };
    this.getWindowTransportSession = (windowParams) => {
      const params = new WindowSessionParams(windowParams);
      return {
        sessionId: params.get("sid"),
        networkId: params.get("net"),
        intent: base64DecodeObject(params.get("intent"))
      };
    };
    this._init = InitState.NIL;
  }
  async register(windowHref) {
    const isPopup = parent.window.opener !== null;
    this._isPopup = isPopup;
    if (isPopup !== true) {
      return;
    }
    const {
      pathname,
      search: rawParams
    } = new URL(windowHref || window.location.href);
    let session = this.getWindowTransportSession(rawParams);
    const isNewWindowSession = !!session.sessionId;
    if (!isNewWindowSession) {
      session = await this.getCachedTransportSession();
    }
    if (!session) {
      logger.error("window session is undefined");
      return;
    }
    this.parentWindow = parent.window.opener;
    window.addEventListener("message", this.onWindowEvent, false);
    this._registered = true;
    this.open(session).then((opened) => {
      if (!opened) {
        var _session;
        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
        logger.error(err);
        this.notifyClose({
          message: err
        });
        window.close();
      }
    }).catch((e2) => {
      var _session2;
      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e2}`;
      logger.error(err);
      this.notifyClose({
        message: err
      });
      window.close();
    });
  }
  unregister() {
    window.removeEventListener("message", this.onWindowEvent);
    this._registered = false;
  }
  // postMessage sends message to the dapp window
  sendMessage(message) {
    const payload = JSON.stringify(message);
    if (message.type === EventType.INIT) {
      this.postMessage(payload, true);
    } else {
      this.postMessage(payload);
    }
  }
  get isPopup() {
    return this._isPopup;
  }
  postMessage(message, init3 = false) {
    if (init3 !== true && this._init !== InitState.OK) {
      logger.error("impossible state, should not be calling postMessage until inited");
      return;
    }
    if (init3) {
      this.parentWindow.postMessage(message, "*");
    } else {
      if (this.appOrigin && this.appOrigin.length > 4) {
        this.parentWindow.postMessage(message, this.appOrigin);
      } else {
        logger.error("unable to postMessage as parentOrigin is invalid");
      }
    }
  }
}
function isMuxTransportTemplate(obj) {
  return obj && typeof obj === "object" && (obj.windowTransport && typeof obj.windowTransport === "object" || obj.proxyTransport && typeof obj.proxyTransport === "object" || obj.extensionTransport && typeof obj.extensionTransport === "object" || obj.unrealTransport && typeof obj.unrealTransport === "object") && // One of the transports must be enabled
  (obj.windowTransport && obj.windowTransport.enabled || obj.proxyTransport && obj.proxyTransport.enabled || obj.extensionTransport && obj.extensionTransport.enabled || obj.unrealTransport && obj.unrealTransport.enabled);
}
class MuxMessageProvider {
  constructor(...messageProviders) {
    var _this = this;
    this.messageProviders = void 0;
    this.provider = void 0;
    this.register = () => {
      if (this.messageProviders.length === 1) {
        this.provider = this.messageProviders[0];
        this.provider.register();
        return;
      }
      this.messageProviders.forEach((m2) => {
        m2.register();
        m2.once("open", () => {
          if (!this.provider) {
            this.provider = m2;
            this.messageProviders.forEach((m22) => {
              if (this.provider !== m22) {
                m22.unregister();
              }
            });
          }
        });
      });
    };
    this.unregister = () => {
      this.messageProviders.forEach((m2) => m2.unregister());
      this.provider = void 0;
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.provider) {
        this.provider.openWallet(path, intent, networkId);
        return;
      }
      this.messageProviders.forEach((m2) => m2.openWallet(path, intent, networkId));
    };
    this.sendAsync = async function(request, callback, chainId) {
      if (_this.provider) {
        _this.provider.sendAsync(request, callback, chainId);
        return;
      }
      throw new Error("impossible state, wallet must be opened first");
    };
    this.sendMessageRequest = async function(message) {
      if (_this.provider) {
        return _this.provider.sendMessageRequest(message);
      }
      throw new Error("impossible state, wallet must be opened first");
    };
    this.waitUntilOpened = async function() {
      if (_this.provider) {
        return _this.provider.waitUntilOpened();
      }
      return Promise.race(_this.messageProviders.map((p2) => p2.waitUntilOpened()));
    };
    this.waitUntilConnected = async function() {
      if (_this.provider) {
        return _this.provider.waitUntilConnected();
      }
      throw new Error("impossible state, wallet must be opened first");
    };
    this.messageProviders = messageProviders;
    this.provider = void 0;
  }
  static new(template) {
    var _template$windowTrans, _template$proxyTransp, _template$extensionTr, _template$unrealTrans;
    const muxMessageProvider = new MuxMessageProvider();
    if ((_template$windowTrans = template.windowTransport) != null && _template$windowTrans.enabled && typeof window === "object" && template.walletAppURL) {
      const windowMessageProvider = new WindowMessageProvider(template.walletAppURL);
      muxMessageProvider.add(windowMessageProvider);
    }
    if ((_template$proxyTransp = template.proxyTransport) != null && _template$proxyTransp.enabled) {
      const proxyMessageProvider = new ProxyMessageProvider(template.proxyTransport.appPort);
      muxMessageProvider.add(proxyMessageProvider);
    }
    if ((_template$extensionTr = template.extensionTransport) != null && _template$extensionTr.enabled) {
      const extensionMessageProvider = new ExtensionMessageProvider(template.extensionTransport.runtime);
      muxMessageProvider.add(extensionMessageProvider);
    }
    if ((_template$unrealTrans = template.unrealTransport) != null && _template$unrealTrans.enabled && template.windowTransport && template.walletAppURL) {
      const unrealMessageProvider = new UnrealMessageProvider(template.walletAppURL);
      muxMessageProvider.add(unrealMessageProvider);
    }
    muxMessageProvider.register();
    return muxMessageProvider;
  }
  add(...messageProviders) {
    this.messageProviders.push(...messageProviders);
  }
  closeWallet() {
    if (this.provider) {
      this.provider.closeWallet();
    }
  }
  isOpened() {
    if (this.provider) {
      return this.provider.isOpened();
    }
    return false;
  }
  isConnected() {
    if (this.provider) {
      return this.provider.isConnected();
    }
    return false;
  }
  on(event, fn) {
    if (this.provider) {
      this.provider.on(event, fn);
      return;
    }
    this.messageProviders.forEach((m2) => {
      m2.on(event, fn);
    });
  }
  once(event, fn) {
    if (this.provider) {
      this.provider.once(event, fn);
      return;
    }
    this.messageProviders.forEach((m2) => {
      m2.once(event, fn);
    });
  }
  emit(event, ...args) {
    if (this.provider) {
      return this.provider.emit(event, ...args);
    }
    for (let i = 0; i < this.messageProviders.length; i++) {
      this.messageProviders[i].emit(event, ...args);
    }
    return true;
  }
  sendMessage(message) {
    if (!message.idx || message.idx <= 0) {
      throw new Error("message idx is empty");
    }
    if (this.provider) {
      this.provider.sendMessage(message);
    } else {
      throw new Error("impossible state, wallet must be opened first");
    }
  }
  handleMessage(message) {
    if (this.provider) {
      this.provider.handleMessage(message);
      return;
    }
    throw new Error("impossible state, wallet must be opened first");
  }
}
function toExtended(transactions2) {
  if (transactions2.length === 0) {
    throw new Error("No transaction provided");
  }
  const [first, ...rest] = transactions2;
  return _extends$3({}, first, {
    auxiliary: rest
  });
}
function fromExtended(transaction2) {
  return [transaction2, ...transaction2.auxiliary || []];
}
const SIGNER_READY_TIMEOUT = 1e4;
class WalletRequestHandler {
  constructor(_account, prompter, networks2) {
    var _this = this;
    this.account = void 0;
    this.signerReadyCallbacks = [];
    this.prompter = void 0;
    this.networks = void 0;
    this._openIntent = void 0;
    this._connectOptions = void 0;
    this.events = new eventemitter2Exports.EventEmitter2();
    this.onConnectOptionsChange = void 0;
    this.promptConnect = async function(options) {
      if (!options && !_this._connectOptions) {
        throw new Error("prompter connect options are empty");
      }
      if (!_this.prompter) {
        return _this.connect(options);
      }
      const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch((_) => {
        return {
          connected: false
        };
      });
      const connectDetails = promptConnectDetails;
      if (connectDetails.connected && !connectDetails.session) {
        connectDetails.session = await _this.walletSession(options == null ? void 0 : options.networkId);
      }
      return promptConnectDetails;
    };
    this.sendAsync = async function(request, callback, chainId) {
      const response = {
        jsonrpc: "2.0",
        id: request.id,
        result: null
      };
      await _this.getAccount();
      try {
        var _this$account;
        if ((!_this.account || _this.account === null) && !permittedJsonRpcMethods.includes(request.method)) {
          throw ErrSignedInRequired;
        }
        const account2 = _this.account;
        if (!account2)
          throw new Error("WalletRequestHandler: wallet account is not configured");
        const provider2 = (_this$account = _this.account) == null ? void 0 : _this$account.providerFor(chainId != null ? chainId : _this.defaultChainId());
        if (!provider2)
          throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${chainId}`);
        const jsonRpcProvider = provider2 instanceof JsonRpcProvider$1 ? provider2 : void 0;
        switch (request.method) {
          case "net_version": {
            if (!jsonRpcProvider) {
              throw new Error(`Account provider doesn't support send method`);
            }
            const result = await jsonRpcProvider.send("net_version", []);
            response.result = result;
            break;
          }
          case "eth_chainId": {
            if (!jsonRpcProvider) {
              throw new Error(`Account provider doesn't support send method`);
            }
            const result = await jsonRpcProvider.send("eth_chainId", []);
            response.result = result;
            break;
          }
          case "eth_accounts": {
            const walletAddress = account2.address;
            response.result = [walletAddress];
            break;
          }
          case "eth_getBalance": {
            const [accountAddress, blockTag] = request.params;
            const walletBalance = await provider2.getBalance(accountAddress, blockTag);
            response.result = walletBalance.toHexString();
            break;
          }
          case "sequence_sign":
          case "personal_sign":
          case "eth_sign": {
            let message;
            switch (request.method) {
              case "sequence_sign":
              case "personal_sign": {
                const [data, _address] = request.params;
                message = data;
                break;
              }
              case "eth_sign": {
                const [_address, data] = request.params;
                message = data;
                break;
              }
            }
            let sig = "";
            const prefixedMessage = prefixEIP191Message(message);
            const sequenceVerified = request.method === "sequence_sign";
            if (_this.prompter === null) {
              sig = await account2.signMessage(prefixedMessage, chainId != null ? chainId : _this.defaultChainId(), sequenceVerified ? "eip6492" : "ignore");
            } else {
              sig = await _this.prompter.promptSignMessage({
                chainId,
                message: prefixedMessage,
                eip6492: sequenceVerified
              }, _this.connectOptions);
            }
            if (sig && sig.length > 0) {
              response.result = sig;
            } else {
              throw new Error("declined by user");
            }
            break;
          }
          case "sequence_signTypedData_v4":
          case "eth_signTypedData":
          case "eth_signTypedData_v4": {
            const [signingAddress, typedDataObject] = request.params;
            let typedData = void 0;
            if (typeof typedDataObject === "string") {
              try {
                typedData = JSON.parse(typedDataObject);
              } catch (e2) {
                console.warn("walletRequestHandler: error parsing typedData", e2);
              }
            } else {
              typedData = typedDataObject;
            }
            if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {
              throw new Error("invalid typedData object");
            }
            let sig = "";
            const sequenceVerified = request.method === "sequence_signTypedData_v4";
            if (_this.prompter === null) {
              sig = await account2.signTypedData(typedData.domain, typedData.types, typedData.message, chainId != null ? chainId : _this.defaultChainId(), sequenceVerified ? "eip6492" : "ignore");
            } else {
              sig = await _this.prompter.promptSignMessage({
                chainId,
                typedData,
                eip6492: sequenceVerified
              }, _this.connectOptions);
            }
            if (sig && sig.length > 0) {
              response.result = sig;
            } else {
              throw new Error("declined by user");
            }
            break;
          }
          case "eth_sendTransaction": {
            const transactionParams = fromExtended(request.params[0]).map((tx) => {
              if ("gas" in tx && tx.gasLimit === void 0) {
                tx.gasLimit = tx.gas;
                delete tx.gas;
              }
              return tx;
            });
            validateTransactionRequest(account2.address, transactionParams);
            let txnHash = "";
            if (_this.prompter === null) {
              var _txnResponse$hash;
              const txnResponse = await account2.sendTransaction(transactionParams, chainId != null ? chainId : _this.defaultChainId());
              txnHash = (_txnResponse$hash = txnResponse == null ? void 0 : txnResponse.hash) != null ? _txnResponse$hash : "";
            } else {
              txnHash = await _this.prompter.promptSendTransaction(transactionParams, chainId, _this.connectOptions);
            }
            if (txnHash) {
              response.result = txnHash;
            } else {
              throw new Error("declined by user");
            }
            break;
          }
          case "eth_signTransaction": {
            const [transaction2] = request.params;
            const sender = getAddress$1(transaction2.from);
            if (sender !== account2.address) {
              throw new Error("sender address does not match wallet");
            }
            validateTransactionRequest(account2.address, transaction2);
            if (_this.prompter === null) {
              response.result = await account2.signTransactions(transaction2, chainId != null ? chainId : _this.defaultChainId());
            } else {
              response.result = await _this.prompter.promptSignTransaction(transaction2, chainId, _this.connectOptions);
            }
            break;
          }
          case "eth_sendRawTransaction": {
            if (index$1$2.transaction.isSignedTransactionBundle(request.params[0])) {
              const txChainId = BigNumber.from(request.params[0].chainId).toNumber();
              const tx = await account2.relayer(txChainId).relay(request.params[0]);
              response.result = tx.hash;
            } else {
              const tx = await provider2.sendTransaction(request.params[0]);
              response.result = tx.hash;
            }
            break;
          }
          case "eth_getTransactionCount": {
            const address = getAddress$1(request.params[0]);
            const tag = request.params[1];
            const count2 = await provider2.getTransactionCount(address, tag);
            response.result = BigNumber.from(count2).toHexString();
            break;
          }
          case "eth_blockNumber": {
            response.result = await provider2.getBlockNumber();
            break;
          }
          case "eth_getBlockByNumber": {
            response.result = await provider2.getBlock(
              request.params[0]
              /* , jsonRpcRequest.params[1] */
            );
            break;
          }
          case "eth_getBlockByHash": {
            response.result = await provider2.getBlock(
              request.params[0]
              /* , jsonRpcRequest.params[1] */
            );
            break;
          }
          case "eth_getTransactionByHash": {
            response.result = await provider2.getTransaction(request.params[0]);
            break;
          }
          case "eth_call": {
            const [transactionObject, blockTag] = request.params;
            response.result = await provider2.call(transactionObject, blockTag);
            break;
          }
          case "eth_getCode": {
            const [contractAddress, blockTag] = request.params;
            response.result = await provider2.getCode(contractAddress, blockTag);
            break;
          }
          case "eth_estimateGas": {
            const [transactionObject] = request.params;
            response.result = await provider2.estimateGas(transactionObject);
            break;
          }
          case "eth_gasPrice": {
            const gasPrice = await provider2.getGasPrice();
            response.result = gasPrice.toHexString();
            break;
          }
          case "wallet_switchEthereumChain": {
            const [switchParams] = request.params;
            if (!switchParams.chainId || switchParams.chainId.length === 0) {
              throw new Error("invalid chainId");
            }
            const _chainId = BigNumber.from(switchParams.chainId);
            _this.setDefaultChainId(_chainId.toNumber());
            response.result = null;
            break;
          }
          case "sequence_getWalletContext": {
            response.result = account2.contexts;
            break;
          }
          case "sequence_getWalletConfig": {
            const [_chainId2] = request.params;
            if (_chainId2) {
              response.result = [(await account2.status(_chainId2)).onChain.config];
            } else {
              response.result = await Promise.all(account2.networks.map(async function(network2) {
                const status = await account2.status(network2.chainId);
                return status.onChain.config;
              }));
            }
            break;
          }
          case "sequence_getWalletState": {
            const [_chainId3] = request.params;
            if (_chainId3) {
              response.result = [getLegacyWalletState(_chainId3, await account2.status(_chainId3))];
            } else {
              response.result = await Promise.all(account2.networks.map(async function(network2) {
                const status = await account2.status(network2.chainId);
                return getLegacyWalletState(network2.chainId, status);
              }));
            }
            break;
          }
          case "sequence_getNetworks": {
            response.result = await _this.getNetworks(true);
            break;
          }
          case "sequence_isSequence": {
            response.result = true;
            break;
          }
          case "sequence_updateConfig": {
            throw new Error("sequence_updateConfig method is not allowed from a dapp");
            break;
          }
          case "sequence_publishConfig": {
            throw new Error("sequence_publishConfig method is not allowed from a dapp");
            break;
          }
          case "sequence_gasRefundOptions": {
            break;
          }
          case "sequence_getNonce": {
            break;
          }
          case "sequence_relay": {
            break;
          }
          case "sequence_setDefaultNetwork": {
            const [defaultChainId] = request.params;
            if (!defaultChainId) {
              throw new Error("invalid request, method argument defaultChainId cannot be empty");
            }
            _this.setDefaultChainId(defaultChainId);
            response.result = await _this.getNetworks(true);
            break;
          }
          default: {
            if (!jsonRpcProvider) {
              throw new Error(`Account provider doesn't support send method`);
            }
            const providerResponse = await jsonRpcProvider.send(request.method, request.params);
            response.result = providerResponse;
          }
        }
      } catch (err) {
        logger.error(err);
        response.result = null;
        response.error = _extends$3({}, new Error(err), {
          code: 4001
        });
      }
      callback(void 0, response);
    };
    this.isSignedIn = async function() {
      await _this.signerReady();
      return !!_this.account;
    };
    this.getAccount = async function() {
      await _this.signerReady();
      if (_this.account === void 0) {
        throw new Error("signerReady failed resolve");
      }
      return _this.account;
    };
    this.account = _account;
    this.prompter = prompter;
    this.networks = networks2;
  }
  defaultChainId() {
    var _this$prompter$getDef, _this$prompter;
    return (_this$prompter$getDef = (_this$prompter = this.prompter) == null ? void 0 : _this$prompter.getDefaultChainId()) != null ? _this$prompter$getDef : this.networks[0].chainId;
  }
  async signIn(account2, options = {}) {
    this.setAccount(account2);
    const {
      connect: connect2,
      defaultNetworkId
    } = options;
    if (connect2) {
      const connectOptions = this._connectOptions;
      let connectDetails;
      if (this.prompter !== null) {
        var _this$prompter2;
        connectDetails = await ((_this$prompter2 = this.prompter) == null ? void 0 : _this$prompter2.promptSignInConnect(connectOptions));
      } else {
        connectDetails = await this.connect(connectOptions);
      }
      this.notifyConnect(connectDetails);
      if (!connectOptions || connectOptions.keepWalletOpened !== true) {
        this.notifyClose();
      }
    }
    if (defaultNetworkId && this.defaultChainId() !== defaultNetworkId) {
      var _this$prompter3;
      await ((_this$prompter3 = this.prompter) == null ? void 0 : _this$prompter3.promptChangeNetwork(defaultNetworkId));
    }
  }
  signOut() {
    if (this.account) {
      this.notifyDisconnect();
    }
    this.setAccount(null);
  }
  signerReset() {
    this.account = void 0;
  }
  signerReady(timeout = SIGNER_READY_TIMEOUT) {
    return new Promise((resolve, reject) => {
      if (this.account !== void 0) {
        resolve();
      } else {
        setTimeout(() => {
          if (this.account === void 0) {
            this.signerReadyCallbacks = [];
            reject(`signerReady timed out`);
          }
        }, timeout);
        this.signerReadyCallbacks.push(resolve);
      }
    });
  }
  async connect(options) {
    var _ref, _options$networkId;
    if (!this.account) {
      return {
        connected: false,
        chainId: "0x0",
        error: "unable to connect without signed in account"
      };
    }
    const networkId = (_ref = (_options$networkId = options == null ? void 0 : options.networkId) != null ? _options$networkId : this.defaultChainId()) != null ? _ref : ChainId.MAINNET;
    const chainId = findSupportedNetwork(networkId).chainId;
    const connectDetails = {
      connected: true,
      chainId: hexValue(chainId)
    };
    if (options && options.authorize) {
      const authOptions = {
        app: options.app,
        origin: options.origin,
        expiry: options.expiry,
        nonce: options.authorizeNonce
      };
      try {
        connectDetails.proof = await signAuthorization(this.account, chainId, authOptions);
      } catch (err) {
        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);
        return {
          connected: false,
          chainId: "0x0",
          error: `signAuthorization failed: ${err.message}`
        };
      }
    }
    connectDetails.session = this.walletSession(chainId);
    return connectDetails;
  }
  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler
  // (aka, the signer in this instance) and then responds with a wrapped response of
  // ProviderMessageResponse to be sent over the transport
  sendMessageRequest(message) {
    return new Promise((resolve) => {
      this.sendAsync(message.data, (error, response) => {
        const responseMessage = _extends$3({}, message, {
          data: response
        });
        resolve(responseMessage);
      }, message.chainId);
    });
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
  async getAddress() {
    var _this$account$address, _this$account2;
    return (_this$account$address = (_this$account2 = this.account) == null ? void 0 : _this$account2.address) != null ? _this$account$address : "";
  }
  get openIntent() {
    return this._openIntent;
  }
  setOpenIntent(intent) {
    this._openIntent = intent;
  }
  get connectOptions() {
    return this._connectOptions;
  }
  setConnectOptions(options) {
    var _this$onConnectOption;
    this._connectOptions = options;
    (_this$onConnectOption = this.onConnectOptionsChange) == null || _this$onConnectOption.call(this, options);
  }
  async setDefaultChainId(chainId) {
    var _this$prompter4;
    await ((_this$prompter4 = this.prompter) == null ? void 0 : _this$prompter4.promptChangeNetwork(chainId));
    return this.defaultChainId();
  }
  async getNetworks(jsonRpcResponse) {
    if (!this.account) {
      logger.warn("signer not set: getNetworks is returning an empty list");
      return [];
    }
    if (jsonRpcResponse) {
      return this.account.networks.map((n2) => {
        const network2 = _extends$3({}, n2);
        network2.provider = void 0;
        network2.relayer = void 0;
        return network2;
      });
    } else {
      return this.account.networks;
    }
  }
  walletSession(networkId) {
    if (!this.account) {
      return void 0;
    }
    const session = {
      walletContext: this.account.contexts,
      accountAddress: this.account.address,
      // The dapp shouldn't access the relayer directly, and the provider (as an object) is not serializable.
      networks: this.account.networks.map((n2) => _extends$3({}, n2, {
        provider: void 0,
        relayer: void 0
      }))
    };
    if (networkId) {
      const network2 = findNetworkConfig(session.networks, networkId);
      if (network2) {
        var _session$networks;
        (_session$networks = session.networks) == null || _session$networks.forEach((n2) => delete n2.isDefaultChain);
        network2.isDefaultChain = true;
      }
    }
    return session;
  }
  notifyConnect(connectDetails, origin) {
    var _connectDetails$sessi;
    console.log("emit connect", connectDetails);
    this.events.emit("connect", connectDetails);
    if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
      var _connectDetails$sessi2;
      this.events.emit("accountsChanged", [(_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress], origin);
    }
  }
  notifyDisconnect(origin) {
    this.events.emit("accountsChanged", [], origin);
    this.events.emit("disconnect", void 0, origin);
  }
  notifyChainChanged(chainId, origin) {
    this.events.emit("chainChanged", hexValue(chainId), origin);
  }
  async notifyNetworks(networks2) {
    const n2 = networks2 || await this.getNetworks(true);
    this.events.emit("networks", n2);
    if (n2.length > 0) {
      const defaultNetwork = n2.find((network2) => network2.chainId === this.defaultChainId());
      if (defaultNetwork) {
        this.events.emit("chainChanged", hexValue(defaultNetwork.chainId));
      }
    } else {
      this.events.emit("chainChanged", "0x0");
    }
  }
  async notifyWalletContext() {
    if (!this.account) {
      logger.warn("signer not set: skipping to notify wallet context");
      return;
    }
    const walletContext = this.account.contexts;
    this.events.emit("walletContext", walletContext);
  }
  notifyClose(error) {
    this.events.emit("close", error);
  }
  setAccount(account2) {
    this.account = account2;
    if (account2 !== void 0) {
      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {
        this.signerReadyCallbacks[i]();
      }
      this.signerReadyCallbacks = [];
    }
  }
  async handleConfirmWalletDeployPrompt(prompter, account2, sequenceVerified, chainId) {
    if (!chainId) {
      return true;
    }
    const skipsDeploy = (status2) => {
      return status2.canOnchainValidate || status2.original.version === 2 && sequenceVerified;
    };
    const status = await account2.status(chainId);
    if (skipsDeploy(status)) {
      return true;
    }
    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions);
    if (promptResult) {
      const status2 = await account2.status(chainId);
      if (skipsDeploy(status2)) {
        return true;
      } else {
        logger.error("WalletRequestHandler: result for promptConfirmWalletDeploy is not correct");
        return false;
      }
    }
    return false;
  }
}
function getLegacyWalletState(chainId, status) {
  return {
    context: status.original.context,
    config: status.onChain.config,
    address: index$1$2.context.addressOf(status.original.context, status.original.imageHash),
    chainId,
    deployed: status.onChain.deployed,
    imageHash: status.imageHash,
    lastImageHash: status.onChain.imageHash,
    published: true,
    status
  };
}
const permittedJsonRpcMethods = ["net_version", "eth_chainId", "eth_getBalance", "eth_getTransactionCount", "eth_blockNumber", "eth_getBlockByNumber", "eth_getBlockByHash", "eth_getTransactionByHash", "eth_getCode", "eth_estimateGas", "eth_gasPrice", "sequence_getWalletContext", "sequence_getNetworks", "sequence_setDefaultNetwork"];
class SequenceSigner {
  get utils() {
    return this.provider.utils;
  }
  constructor(client2, provider2) {
    this.client = client2;
    this.provider = provider2;
    this.singleNetworkSigners = {};
    this._isSigner = true;
    this._isSequenceSigner = true;
  }
  async getAddress() {
    return this.client.getAddress();
  }
  // This method shouldn't be used directly
  // it exists to maintain compatibility with ethers.Signer
  connect(provider2) {
    if (!SequenceProvider.is(provider2)) {
      throw new Error("SequenceSigner can only be connected to a SequenceProvider");
    }
    return new SequenceSigner(this.client, provider2);
  }
  getSigner(chainId) {
    if (!chainId) {
      return this;
    }
    const useChainId2 = this.provider.toChainId(chainId);
    if (!this.singleNetworkSigners[useChainId2]) {
      this.singleNetworkSigners[useChainId2] = new SingleNetworkSequenceSigner(this.client, this.provider, useChainId2);
    }
    return this.singleNetworkSigners[useChainId2];
  }
  /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */
  useChainId(chainId) {
    return this.provider.toChainId(chainId) || this.client.getChainId();
  }
  async signMessage(message, options) {
    const {
      eip6492 = true
    } = options || {};
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    return this.client.signMessage(message, {
      eip6492,
      chainId
    });
  }
  async signTypedData(domain2, types2, message, options) {
    const {
      eip6492 = true
    } = options || {};
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    return this.client.signTypedData({
      domain: domain2,
      types: types2,
      message
    }, {
      eip6492,
      chainId
    });
  }
  getProvider(chainId) {
    return this.provider.getProvider(chainId);
  }
  async sendTransaction(transaction2, options) {
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    const resolved = await resolveArrayProperties(transaction2);
    const txHash = await this.client.sendTransaction(resolved, {
      chainId
    });
    const provider2 = this.getProvider(chainId);
    try {
      return await poll$1(async function() {
        const tx = await provider2.getTransaction(txHash);
        return tx ? provider2._wrapTransaction(tx, txHash) : void 0;
      }, {
        onceBlock: provider2
      });
    } catch (err) {
      err.transactionHash = txHash;
      throw err;
    }
  }
  async getWalletConfig(chainId) {
    const useChainId2 = this.useChainId(chainId);
    return this.client.getOnchainWalletConfig({
      chainId: useChainId2
    });
  }
  getNetworks() {
    return this.client.getNetworks();
  }
  async getBalance(blockTag, optionals) {
    const provider2 = this.getProvider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBalance(this.getAddress(), blockTag);
  }
  async estimateGas(transaction2, optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).estimateGas(transaction2);
  }
  async call(transaction2, blockTag, optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).call(transaction2, blockTag);
  }
  getChainId() {
    return Promise.resolve(this.client.getChainId());
  }
  async getGasPrice(optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).getGasPrice();
  }
  async getFeeData(optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).getFeeData();
  }
  async resolveName(name2) {
    const res = await this.provider.resolveName(name2);
    if (res === null) {
      throw new Error(`ENS name not found: ${name2}`);
    }
    return res;
  }
  _checkProvider(_operation) {
  }
  populateTransaction(_transaction) {
    throw new Error("SequenceSigner does not support populateTransaction");
  }
  checkTransaction(_transaction) {
    throw new Error("SequenceSigner does not support checkTransaction");
  }
  getTransactionCount(_blockTag) {
    throw new Error("SequenceSigner does not support getTransactionCount");
  }
  signTransaction(_transaction) {
    throw new Error("SequenceWallet does not support signTransaction, use sendTransaction instead.");
  }
  static is(cand) {
    return cand && typeof cand === "object" && cand._isSequenceSigner === true;
  }
}
class SingleNetworkSequenceSigner extends SequenceSigner {
  constructor(client2, provider2, chainId) {
    super(client2, provider2.getProvider(chainId));
    this.chainId = chainId;
    this._isSingleNetworkSequenceSigner = true;
  }
  _useChainId(chainId) {
    const provided = this.provider.toChainId(chainId);
    if (provided && provided !== this.chainId) {
      throw new Error(`This signer only supports the network ${this.chainId}, but ${provided} was requested.`);
    }
    return provided || this.provider.toChainId(this.chainId);
  }
  useChainId(chainId) {
    return this._useChainId(chainId);
  }
  getChainId() {
    return Promise.resolve(this.provider.toChainId(this.chainId));
  }
  /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */
  getProvider(chainId) {
    return super.getProvider(this._useChainId(chainId));
  }
  getSigner(chainId) {
    if (this._useChainId(chainId) !== this.chainId) {
      throw new Error(`Unreachable code`);
    }
    return this;
  }
  static is(cand) {
    return cand && typeof cand === "object" && cand._isSingleNetworkSequenceSigner === true;
  }
}
class WalletUtils {
  constructor(signer2) {
    this.signer = signer2;
    if (SingleNetworkSequenceSigner.is(signer2)) {
      throw new Error("WalletUtils does not support SingleNetworkSequenceSigner");
    }
  }
  // Sign message on a specified chain, or DefaultChain by default
  signMessage(message, chainId, eip6492) {
    return this.signer.signMessage(message, {
      chainId,
      eip6492
    });
  }
  // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default
  signTypedData(domain2, types2, message, chainId, eip6492) {
    return this.signer.signTypedData(domain2, types2, message, {
      chainId,
      eip6492
    });
  }
  // Verify signature of a digest, one of a message, typedData or other
  async isValidSignature(address, digest9, signature2, chainId) {
    return isValidSignature(address, digest9, signature2, this.signer.getProvider(chainId));
  }
  // Verify message signature
  async isValidMessageSignature(address, message, signature2, chainId) {
    const provider2 = this.signer.getProvider(chainId);
    const prefixed = prefixEIP191Message(message);
    const digest9 = encodeMessageDigest(prefixed);
    return isValidSignature(address, digest9, signature2, provider2);
  }
  // Verify typedData signature
  isValidTypedDataSignature(address, typedData, signature2, chainId) {
    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature2, chainId);
  }
  // sendTransaction()
  // sendTransactions()
  // sendETH()
  // sendToken()
  // sendCoin() -- sugar for sendToken()
  // sendCollectible() -- sugar for sendToken()
  // callContract()
  // transactionHistory()
  // getReceipt()
  // getLogs()
  // // ..
  // validateSignature()
  // recoverWalletConfig()
  // recoverAddress()
}
class SequenceProvider extends BaseProvider {
  constructor(client2, providerFor, networks2 = allNetworks) {
    super(client2.getChainId());
    this.client = client2;
    this.providerFor = providerFor;
    this.networks = networks2;
    this.singleNetworkProviders = {};
    this._isSequenceProvider = true;
    this.utils = void 0;
    this.signer = void 0;
    client2.onConnect((details) => {
      this.emit("connect", details);
    });
    client2.onDisconnect((error) => {
      this.emit("disconnect", error);
    });
    client2.onDefaultChainIdChanged((chainId) => {
      this.emit("chainChanged", chainId);
    });
    client2.onAccountsChanged((accounts) => {
      this.emit("accountsChanged", accounts);
    });
    this.signer = new SequenceSigner(this.client, this);
    this.utils = new WalletUtils(this.signer);
  }
  getSigner(chainId) {
    return this.signer.getSigner(chainId);
  }
  connect(options) {
    return this.client.connect(options);
  }
  disconnect() {
    return this.client.disconnect();
  }
  isConnected() {
    return this.client.isConnected();
  }
  getSession() {
    return this.client.getSession();
  }
  listAccounts() {
    return [this.client.getAddress()];
  }
  // @deprecated use getSigner() instead
  getAddress() {
    return this.client.getAddress();
  }
  getNetworks() {
    return this.client.getNetworks();
  }
  getChainId() {
    return this.client.getChainId();
  }
  setDefaultChainId(chainId) {
    return this.client.setDefaultChainId(this.toChainId(chainId));
  }
  isOpened() {
    return this.client.isOpened();
  }
  closeWallet() {
    return this.client.closeWallet();
  }
  getWalletContext() {
    return this.client.getWalletContext();
  }
  // @deprecated use getSigner() instead
  async getWalletConfig(chainId) {
    const useChainId2 = await this.useChainId(chainId);
    return this.client.getOnchainWalletConfig({
      chainId: useChainId2
    });
  }
  authorize(options) {
    return this.client.connect(_extends$3({}, options, {
      authorize: true
    }));
  }
  async openWallet(path, intent) {
    await this.client.openWallet(path, intent);
    return true;
  }
  toChainId(chainId) {
    if (chainId === void 0) {
      return void 0;
    }
    const resolved = findNetworkConfig(this.networks, chainId);
    if (!resolved) {
      throw new Error(`Unsupported network ${chainId}`);
    }
    return resolved.chainId;
  }
  /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */
  async useChainId(chainId) {
    return this.toChainId(chainId) || this.client.getChainId();
  }
  /**
   *  This generates a provider that ONLY works for the given chainId.
   *  the generated provider can't switch networks, and can't handle requests
   *  for other networks.
   */
  getProvider(chainId) {
    if (!chainId) {
      return this;
    }
    const useChainId2 = this.toChainId(chainId);
    if (!this.singleNetworkProviders[useChainId2]) {
      this.singleNetworkProviders[useChainId2] = new SingleNetworkSequenceProvider(this.client, this.providerFor, useChainId2);
    }
    return this.singleNetworkProviders[useChainId2];
  }
  /**
   *  This returns a subprovider, this is a regular non-sequence provider that
   *  can be used to fulfill read only requests on a given network.
   */
  async _getSubprovider(chainId) {
    const useChainId2 = await this.useChainId(chainId);
    const provider2 = this.providerFor(useChainId2);
    if (!provider2) {
      throw new Error(`Unsupported network ${useChainId2}`);
    }
    return provider2;
  }
  async perform(method, params) {
    var _provider$prepareRequ;
    if (method === "eth_chainId") {
      return hexValue(await this.useChainId());
    }
    if (method === "eth_accounts") {
      return [this.client.getAddress()];
    }
    if (method === "wallet_switchEthereumChain") {
      const args = params[0];
      const chainId = normalizeChainId$2(args);
      return this.setDefaultChainId(chainId);
    }
    if (method === "eth_sendTransaction" || method === "eth_sign" || method === "eth_signTypedData" || method === "eth_signTypedData_v4" || method === "personal_sign" || // These methods will use EIP-6492
    // but this is handled directly by the wallet
    method === "sequence_sign" || method === "sequence_signTypedData_v4") {
      return this.client.send({
        method,
        params
      }, this.getChainId());
    }
    const provider2 = await this._getSubprovider();
    const prepared = (_provider$prepareRequ = provider2.prepareRequest(method, params)) != null ? _provider$prepareRequ : [method, params];
    return provider2.send(prepared[0], prepared[1]);
  }
  send(method, params) {
    return this.perform(method, params);
  }
  request(request) {
    return this.perform(request.method, request.params);
  }
  async detectNetwork() {
    const chainId = this.client.getChainId();
    const network2 = findNetworkConfig(this.networks, chainId);
    if (!network2) {
      throw new Error(`Unknown network ${chainId}`);
    }
    return network2;
  }
  // Override most of the methods, so we add support for an optional chainId
  // argument, which is used to select the provider to use.
  //
  // NOTICE: We could use generics to avoid repeating the same code
  // but this would make the code harder to read, and it's not worth it
  // since we only have a few methods to override.
  async waitForTransaction(transactionHash, confirmations, timeout, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.waitForTransaction(transactionHash, confirmations, timeout);
  }
  async getBlockNumber(optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBlockNumber();
  }
  async getGasPrice(optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getGasPrice();
  }
  async getBalance(addressOrName, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBalance(addressOrName, blockTag);
  }
  async getTransactionCount(addressOrName, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getTransactionCount(addressOrName, blockTag);
  }
  async getCode(addressOrName, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getCode(addressOrName, blockTag);
  }
  async getStorageAt(addressOrName, position, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getStorageAt(addressOrName, position, blockTag);
  }
  async call(transaction2, blockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.call(transaction2, blockTag);
  }
  async estimateGas(transaction2, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.estimateGas(transaction2);
  }
  async getBlock(blockHashOrBlockTag, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getBlock(blockHashOrBlockTag);
  }
  async getTransaction(transactionHash, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getTransaction(transactionHash);
  }
  async getLogs(filter2, optionals) {
    const provider2 = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider2.getLogs(filter2);
  }
  // ENS methods
  async supportsENS() {
    const networks2 = await this.getNetworks();
    return networks2.some((n2) => n2.chainId === 1);
  }
  async getResolver(name2) {
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.getResolver(name2);
  }
  async resolveName(name2) {
    if (isAddress$1(await name2)) {
      return name2;
    }
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.resolveName(name2);
  }
  async lookupAddress(address) {
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.lookupAddress(address);
  }
  async getAvatar(nameOrAddress) {
    if (!await this.supportsENS()) {
      return null;
    }
    const provider2 = await this._getSubprovider(1);
    return provider2.getAvatar(nameOrAddress);
  }
}
SequenceProvider.is = (provider2) => {
  return provider2 && typeof provider2 === "object" && provider2._isSequenceProvider === true;
};
function normalizeChainId$2(chainId) {
  if (typeof chainId === "object")
    return normalizeChainId$2(chainId.chainId);
  return BigNumber.from(chainId).toNumber();
}
class SingleNetworkSequenceProvider extends SequenceProvider {
  constructor(client2, providerFor, chainId) {
    super(client2, providerFor);
    this.chainId = chainId;
    this._isSingleNetworkSequenceProvider = true;
  }
  _useChainId(chainId) {
    const provided = this.toChainId(chainId);
    if (provided && provided !== this.chainId) {
      throw new Error(`This provider only supports the network ${this.chainId}, but ${provided} was requested.`);
    }
    return provided || super.toChainId(this.chainId);
  }
  useChainId(chainId) {
    return Promise.resolve(this._useChainId(chainId));
  }
  getChainId() {
    return super.toChainId(this.chainId);
  }
  async getNetwork() {
    const networks2 = await this.client.getNetworks();
    const res = findNetworkConfig(networks2, this.chainId);
    if (!res) {
      throw new Error(`Unsupported network ${this.chainId}`);
    }
    return res;
  }
  /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */
  getProvider(chainId) {
    if (this._useChainId(chainId) !== this.chainId) {
      throw new Error(`Unreachable code`);
    }
    return this;
  }
  getSigner(chainId) {
    return super.getSigner(this._useChainId(chainId));
  }
  setDefaultChainId(_chainId) {
    throw new Error(`This provider only supports the network ${this.chainId}; use the parent provider to switch networks.`);
  }
  static is(cand) {
    return cand && typeof cand === "object" && cand._isSingleNetworkSequenceProvider === true;
  }
}
class Analytics extends Databeat2 {
}
const setupAnalytics = (projectAccessKey2, server) => {
  if (!server) {
    server = "https://nodes.sequence.app";
  }
  const noop2 = !projectAccessKey2;
  const auth2 = {};
  if (projectAccessKey2) {
    auth2.headers = {
      "X-Access-Key": projectAccessKey2
    };
  }
  return new Analytics(server, auth2, {
    noop: noop2,
    defaultEnabled: true,
    privacy: {
      userIdHash: true,
      userAgentSalt: false
    },
    initProps: () => {
      if (!isBrowser()) {
        return {};
      } else {
        return {
          origin: window.location.origin
        };
      }
    }
  });
};
var packageJson = {
  name: "@0xsequence/provider",
  version: "1.10.7",
  description: "provider sub-package for Sequence",
  repository: "https://github.com/0xsequence/sequence.js/tree/master/packages/provider",
  source: "src/index.ts",
  main: "dist/0xsequence-provider.cjs.js",
  module: "dist/0xsequence-provider.esm.js",
  author: "Horizon Blockchain Games",
  license: "Apache-2.0",
  scripts: {
    test: "pnpm test:concurrently 'pnpm test:run'",
    "test:run": "pnpm test:file tests/**/*.spec.ts",
    "test:file": "NODE_OPTIONS='--import tsx' mocha --timeout 30000",
    typecheck: "tsc --noEmit",
    "test:concurrently": "concurrently -k --success first 'pnpm start:hardhat1' 'pnpm start:hardhat2'",
    "start:hardhat1": "pnpm start:hardhat1:verbose > /dev/null 2>&1",
    "start:hardhat2": "pnpm start:hardhat2:verbose > /dev/null 2>&1",
    "start:hardhat1:verbose": "hardhat node --config hardhat1.config.js --hostname 0.0.0.0 --port 9595",
    "start:hardhat2:verbose": "hardhat node --config hardhat2.config.js --hostname 0.0.0.0 --port 8595"
  },
  dependencies: {
    "@0xsequence/abi": "workspace:*",
    "@0xsequence/account": "workspace:*",
    "@0xsequence/auth": "workspace:*",
    "@0xsequence/core": "workspace:*",
    "@0xsequence/migration": "workspace:*",
    "@0xsequence/network": "workspace:*",
    "@0xsequence/relayer": "workspace:*",
    "@0xsequence/utils": "workspace:*",
    "@0xsequence/wallet": "workspace:*",
    "@databeat/tracker": "^0.9.1",
    eventemitter2: "^6.4.5",
    "webextension-polyfill": "^0.10.0"
  },
  peerDependencies: {
    ethers: ">=5.5 < 6"
  },
  devDependencies: {
    "@types/webextension-polyfill": "^0.10.0",
    ethers: "^5.7.2",
    hardhat: "^2.20.1"
  },
  files: [
    "src",
    "dist"
  ]
};
class SequenceClientSession {
  constructor(store) {
    this.store = store;
  }
  connectedSession() {
    const session = this.getSession();
    if (session && session.accountAddress && session.walletContext && session.networks) {
      return {
        accountAddress: session.accountAddress,
        walletContext: session.walletContext,
        networks: session.networks
      };
    }
    throw new Error("Sequence session not connected");
  }
  hasSession() {
    var _this$getSession;
    return ((_this$getSession = this.getSession()) == null ? void 0 : _this$getSession.accountAddress) !== void 0;
  }
  setSession(session) {
    return this.store.setItem(SequenceClientSession.SESSION_LOCALSTORE_KEY, JSON.stringify(session));
  }
  getSession() {
    const session = this.store.getItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
    if (session) {
      return JSON.parse(session);
    }
    return void 0;
  }
  async clearSession() {
    return this.store.removeItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
  }
}
SequenceClientSession.SESSION_LOCALSTORE_KEY = "@sequence.session";
class DefaultChainIdTracker {
  constructor(store, startingChainId = 1) {
    this.store = store;
    this.startingChainId = startingChainId;
    this.callbacks = [];
    store.onItemChange(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, (value) => {
      if (value) {
        const chainId = parseInt(value);
        this.callbacks.forEach((cb2) => cb2(chainId));
      }
    });
  }
  onDefaultChainIdChanged(callback) {
    this.callbacks.push(callback);
    return () => {
      this.callbacks = this.callbacks.filter((cb2) => cb2 !== callback);
    };
  }
  setDefaultChainId(chainId) {
    if (chainId !== this.getDefaultChainId()) {
      this.store.setItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, chainId.toString());
    }
  }
  getDefaultChainId() {
    const read = this.store.getItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY);
    if (!read || read.length === 0) {
      return this.startingChainId;
    }
    return parseInt(read);
  }
}
DefaultChainIdTracker.SESSION_CHAIN_ID_KEY = "@sequence.session.defaultChainId";
class SequenceClient {
  constructor(transport, store, options) {
    var _options$defaultEIP, _this$session$getSess;
    this.session = void 0;
    this.defaultChainId = void 0;
    this.callbacks = {};
    this.transport = void 0;
    this.defaultEIP6492 = void 0;
    this.projectAccessKey = void 0;
    this.analytics = void 0;
    if (isMuxTransportTemplate(transport)) {
      this.transport = MuxMessageProvider.new(transport);
    } else if (isProviderTransport(transport)) {
      this.transport = transport;
    } else {
      throw new Error("Invalid transport");
    }
    const defaultChainId = options == null ? void 0 : options.defaultChainId;
    this.defaultEIP6492 = (_options$defaultEIP = options == null ? void 0 : options.defaultEIP6492) != null ? _options$defaultEIP : false;
    this.session = new SequenceClientSession(store);
    this.defaultChainId = new DefaultChainIdTracker(store, defaultChainId);
    this.transport.on("accountsChanged", (accounts) => {
      var _this$callbacks$accou;
      if (accounts.length > 1) {
        console.warn("SequenceClient: wallet-webapp returned more than one account");
      }
      (_this$callbacks$accou = this.callbacks.accountsChanged) == null || _this$callbacks$accou.forEach((cb2) => cb2(accounts));
    });
    this.transport.on("connect", (response) => {
      var _this$callbacks$conne;
      const chainIdHex = hexValue(this.getChainId());
      (_this$callbacks$conne = this.callbacks.connect) == null || _this$callbacks$conne.forEach((cb2) => cb2(_extends$3({}, response, {
        // Ignore the full connect response
        // use the chainId defined locally
        chainId: chainIdHex
      })));
    });
    this.transport.on("disconnect", (error, origin) => {
      var _this$callbacks$disco;
      (_this$callbacks$disco = this.callbacks.disconnect) == null || _this$callbacks$disco.forEach((cb2) => cb2(error, origin));
    });
    this.transport.on("networks", (networks2) => {
      var _this$callbacks$netwo;
      (_this$callbacks$netwo = this.callbacks.networks) == null || _this$callbacks$netwo.forEach((cb2) => cb2(networks2));
    });
    this.transport.on("walletContext", (context2) => {
      var _this$callbacks$walle;
      (_this$callbacks$walle = this.callbacks.walletContext) == null || _this$callbacks$walle.forEach((cb2) => cb2(context2));
    });
    this.transport.on("open", (info) => {
      var _this$callbacks$open;
      (_this$callbacks$open = this.callbacks.open) == null || _this$callbacks$open.forEach((cb2) => cb2(info));
    });
    this.transport.on("close", () => {
      var _this$callbacks$close;
      (_this$callbacks$close = this.callbacks.close) == null || _this$callbacks$close.forEach((cb2) => cb2());
    });
    this.transport.on("chainChanged", (chainIdHex, origin) => {
      var _this$callbacks$chain;
      (_this$callbacks$chain = this.callbacks.chainChanged) == null || _this$callbacks$chain.forEach((cb2) => cb2(chainIdHex, origin));
    });
    this.defaultChainId.onDefaultChainIdChanged((chainId) => {
      var _this$callbacks$chain2;
      const chainIdHex = hexValue(chainId);
      (_this$callbacks$chain2 = this.callbacks.chainChanged) == null || _this$callbacks$chain2.forEach((cb2) => cb2(chainIdHex));
    });
    if (options != null && options.projectAccessKey) {
      this.projectAccessKey = options.projectAccessKey;
    }
    if (this.projectAccessKey && options != null && options.analytics) {
      this.analytics = setupAnalytics(this.projectAccessKey);
    }
    if ((_this$session$getSess = this.session.getSession()) != null && _this$session$getSess.accountAddress) {
      var _this$analytics, _this$session$getSess2;
      (_this$analytics = this.analytics) == null || _this$analytics.identify((_this$session$getSess2 = this.session.getSession()) == null || (_this$session$getSess2 = _this$session$getSess2.accountAddress) == null ? void 0 : _this$session$getSess2.toLowerCase());
    }
  }
  // Callbacks
  registerCallback(eventName, callback) {
    if (!this.callbacks[eventName]) {
      this.callbacks[eventName] = [];
    }
    this.callbacks[eventName].push(callback);
    return () => {
      this.callbacks[eventName] = this.callbacks[eventName].filter((c2) => c2 !== callback);
    };
  }
  // Individual callbacks lead to more idiomatic code
  onOpen(callback) {
    return this.registerCallback("open", callback);
  }
  onClose(callback) {
    return this.registerCallback("close", callback);
  }
  onConnect(callback) {
    return this.registerCallback("connect", callback);
  }
  onDisconnect(callback) {
    return this.registerCallback("disconnect", callback);
  }
  onNetworks(callback) {
    return this.registerCallback("networks", callback);
  }
  onAccountsChanged(callback) {
    return this.registerCallback("accountsChanged", callback);
  }
  // @deprecated
  onWalletContext(callback) {
    return this.registerCallback("walletContext", callback);
  }
  onChainChanged(callback) {
    return this.registerCallback("chainChanged", callback);
  }
  onDefaultChainIdChanged(callback) {
    return this.registerCallback("chainChanged", callback);
  }
  getChainId() {
    return this.defaultChainId.getDefaultChainId();
  }
  setDefaultChainId(chainId) {
    return this.defaultChainId.setDefaultChainId(chainId);
  }
  // Proxy transport methods
  async openWallet(path, intent) {
    this.transport.openWallet(path, intent, this.getChainId());
    await this.transport.waitUntilOpened();
    return this.isOpened();
  }
  closeWallet() {
    return this.transport.closeWallet();
  }
  isOpened() {
    return this.transport.isOpened();
  }
  isConnected() {
    return this.session.hasSession();
  }
  getSession() {
    return this.session.getSession();
  }
  // Basic API
  getAddress() {
    const session = this.session.connectedSession();
    return session.accountAddress;
  }
  async connect(options) {
    if ((options == null ? void 0 : options.authorizeVersion) === void 0) {
      options.authorizeVersion = 2;
    }
    if ((options == null ? void 0 : options.refresh) === true) {
      this.disconnect();
    }
    options.projectAccessKey = this.projectAccessKey;
    if (options) {
      if (options.authorize) {
        if (!options.app) {
          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);
        }
        if (options.authorizeVersion === void 0) {
          options.authorizeVersion = 2;
        }
      }
    }
    await this.openWallet(void 0, {
      type: "connect",
      options: _extends$3({}, options, {
        networkId: this.getChainId(),
        clientVersion: packageJson.version
      })
    });
    const connectDetails = await this.transport.waitUntilConnected().catch((error) => {
      if (error instanceof Error) {
        return {
          connected: false,
          error: error.message
        };
      } else {
        return {
          connected: false,
          error: JSON.stringify(error)
        };
      }
    });
    if (connectDetails.chainId) {
      connectDetails.chainId = BigNumber.from(connectDetails.chainId).toString();
    }
    if (connectDetails.connected) {
      var _connectDetails$sessi;
      if (!connectDetails.session) {
        throw new Error("impossible state, connect response is missing session");
      }
      this.session.setSession(connectDetails.session);
      if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
        var _this$analytics2;
        (_this$analytics2 = this.analytics) == null || _this$analytics2.identify(connectDetails.session.accountAddress.toLowerCase());
      }
    }
    return connectDetails;
  }
  disconnect() {
    var _this$analytics3;
    if (this.isOpened()) {
      this.closeWallet();
    }
    (_this$analytics3 = this.analytics) == null || _this$analytics3.reset();
    return this.session.clearSession();
  }
  // Higher level API
  // Working with sendAsync is less idiomatic
  // but transport uses it instead of send, so we wrap it
  send(request, chainId) {
    request.method = this.mapSignMethod(request.method);
    return new Promise((resolve, reject) => {
      this.transport.sendAsync(request, (error, response) => {
        if (error) {
          reject(error);
        } else if (response === void 0) {
          reject(new Error(`Got undefined response for request: ${request}`));
        } else if (typeof response === "object" && response.error) {
          reject(response.error);
        } else if (typeof response === "object" && response.result) {
          resolve(response.result);
        } else {
          reject(new Error(`Got invalid response for request: ${request}`));
        }
      }, chainId || this.getChainId());
    });
  }
  async getNetworks(pull) {
    const connectedSession = this.session.connectedSession();
    if (pull) {
      connectedSession.networks = await this.send({
        method: "sequence_getNetworks"
      });
      this.session.setSession(connectedSession);
    }
    return connectedSession.networks;
  }
  // NOTICE: `legacy_sign` will get overriden by `send`
  // it is done this way to ensure that:
  //  - `send` handles `personal_sign` as a request for the default sign method
  //  - explicit `personal_sign` is not replaced by `sequence_sign` (if default is EI6492)
  signMethod(options) {
    if ((options == null ? void 0 : options.eip6492) === void 0) {
      return "personal_sign";
    }
    return options.eip6492 ? "sequence_sign" : "legacy_sign";
  }
  signTypedDataMethod(options) {
    if ((options == null ? void 0 : options.eip6492) === void 0) {
      return "eth_signTypedData_v4";
    }
    return options.eip6492 ? "sequence_signTypedData_v4" : "legacy_signTypedData_v4";
  }
  mapSignMethod(method) {
    if (method === "personal_sign") {
      if (this.defaultEIP6492) {
        return "sequence_sign";
      } else {
        return "personal_sign";
      }
    }
    if (method === "eth_signTypedData_v4") {
      if (this.defaultEIP6492) {
        return "sequence_signTypedData_v4";
      } else {
        return "eth_signTypedData_v4";
      }
    }
    if (method === "legacy_sign") {
      return "personal_sign";
    }
    if (method === "legacy_signTypedData_v4") {
      return "eth_signTypedData_v4";
    }
    return method;
  }
  async signMessage(message, options) {
    var _this$analytics4;
    const method = this.signMethod(options);
    (_this$analytics4 = this.analytics) == null || _this$analytics4.track({
      event: "SIGN_MESSAGE_REQUEST",
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    message = hexlify(messageToBytes(message));
    return this.send({
      method,
      params: [message, this.getAddress()]
    }, options == null ? void 0 : options.chainId);
  }
  async signTypedData(typedData, options) {
    var _this$analytics5;
    const method = this.signTypedDataMethod(options);
    const encoded = TypedDataEncoder.getPayload(typedData.domain, typedData.types, typedData.message);
    (_this$analytics5 = this.analytics) == null || _this$analytics5.track({
      event: "SIGN_TYPED_DATA_REQUEST",
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    return this.send({
      method,
      params: [this.getAddress(), encoded]
    }, (options == null ? void 0 : options.chainId) || typedData.domain.chainId && BigNumber.from(typedData.domain.chainId).toNumber() || this.getChainId());
  }
  async sendTransaction(tx, options) {
    var _this$analytics6;
    const sequenceTxs = Array.isArray(tx) ? tx : [tx];
    const extendedTxs = toExtended(sequenceTxs);
    (_this$analytics6 = this.analytics) == null || _this$analytics6.track({
      event: "SEND_TRANSACTION_REQUEST",
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    return this.send({
      method: "eth_sendTransaction",
      params: [extendedTxs]
    }, options == null ? void 0 : options.chainId);
  }
  async getWalletContext() {
    return this.send({
      method: "sequence_getWalletContext"
    });
  }
  async getOnchainWalletConfig(options) {
    const res = await this.send({
      method: "sequence_getWalletConfig",
      params: [(options == null ? void 0 : options.chainId) || this.getChainId()]
    }, options == null ? void 0 : options.chainId);
    return Array.isArray(res) ? res[0] : res;
  }
  // NOTICE: We are leaving out all the "regular" methods os a tipical
  // JSON RPC Provider (eth_getBlockByNumber, eth_call, etc)
  // wallet-webapp does implement them, but this client is meant to be
  // exclusively used for Sequence specific methods
}
const DefaultProviderConfig = {
  transports: {
    walletAppURL: "https://sequence.app",
    windowTransport: {
      enabled: true
    },
    proxyTransport: {
      enabled: false
    }
  },
  defaultNetwork: 1,
  analytics: true
};
let sequenceWalletProvider;
const initWallet = (projectAccessKey2, partialConfig) => {
  var _config$networks$filt, _config$networks, _findNetworkConfig;
  if (!projectAccessKey2 || typeof projectAccessKey2 !== "string") {
    throw new Error("Please pass a projectAccessKey in initWallet.");
  }
  if (sequenceWalletProvider) {
    return sequenceWalletProvider;
  }
  const config2 = _extends$3({}, DefaultProviderConfig, partialConfig, {
    transports: _extends$3({}, DefaultProviderConfig.transports, partialConfig == null ? void 0 : partialConfig.transports)
  });
  const rpcProviders = {};
  const newNetworks = (_config$networks$filt = (_config$networks = config2.networks) == null ? void 0 : _config$networks.filter((n2) => {
    n2.rpcUrl !== void 0 && n2.chainId !== void 0 && !allNetworks.find((an) => an.chainId === n2.chainId);
  })) != null ? _config$networks$filt : [];
  const combinedNetworks = allNetworks.map((n2) => {
    var _config$networks2;
    const network2 = (_config$networks2 = config2.networks) == null ? void 0 : _config$networks2.find((cn) => cn.chainId === n2.chainId);
    return network2 ? _extends$3({}, n2, network2) : n2;
  }).concat(newNetworks).map((network2) => {
    if (network2.rpcUrl.includes(projectAccessKey2)) {
      return network2;
    }
    network2.rpcUrl = network2.rpcUrl + `/${projectAccessKey2}`;
    return network2;
  });
  const providerForChainId = (chainId) => {
    if (!rpcProviders[chainId]) {
      var _combinedNetworks$fin;
      const rpcUrl = (_combinedNetworks$fin = combinedNetworks.find((n2) => n2.chainId === chainId)) == null ? void 0 : _combinedNetworks$fin.rpcUrl;
      if (!rpcUrl) {
        throw new Error(`no rpcUrl found for chainId: ${chainId}`);
      }
      const baseProvider = new JsonRpcProvider$1(rpcUrl);
      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new CachedProvider()], new JsonRpcSender(baseProvider));
      rpcProviders[chainId] = new Web3Provider(router, chainId);
    }
    return rpcProviders[chainId];
  };
  const defaultNetwork = config2.defaultNetwork ? (_findNetworkConfig = findNetworkConfig(combinedNetworks, config2.defaultNetwork)) == null ? void 0 : _findNetworkConfig.chainId : void 0;
  if (!defaultNetwork && config2.defaultNetwork) {
    throw new Error(`defaultNetwork not found for chainId: ${config2.defaultNetwork}`);
  }
  const itemStore = config2.localStorage || useBestStore();
  const client2 = new SequenceClient(config2.transports, itemStore, {
    defaultChainId: defaultNetwork,
    defaultEIP6492: config2.defaultEIP6492,
    projectAccessKey: projectAccessKey2,
    analytics: config2.analytics
  });
  sequenceWalletProvider = new SequenceProvider(client2, providerForChainId);
  return sequenceWalletProvider;
};
const unregisterWallet = () => {
  if (!sequenceWalletProvider)
    return;
  sequenceWalletProvider.client.closeWallet();
  sequenceWalletProvider.client.transport.unregister();
  sequenceWalletProvider = void 0;
};
const getWallet = () => {
  if (!sequenceWalletProvider) {
    throw new Error("Wallet has not been initialized, call sequence.initWallet(config) first.");
  }
  return sequenceWalletProvider;
};
const provider$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseInjectedTransport,
  BaseProviderTransport,
  BaseWalletTransport,
  CHANNEL_ID,
  DefaultChainIdTracker,
  DefaultProviderConfig,
  ErrSignedInRequired,
  EventType,
  ExtensionMessageHandler,
  ExtensionMessageProvider,
  InitState,
  LocalStorage,
  MemoryItemStore,
  MuxMessageProvider,
  OpenState,
  PROVIDER_OPEN_TIMEOUT,
  ProviderError,
  ProxyMessageChannel,
  ProxyMessageChannelPort,
  ProxyMessageHandler,
  ProxyMessageProvider,
  SequenceClient,
  SequenceClientSession,
  SequenceProvider,
  SequenceSigner,
  SingleNetworkSequenceProvider,
  SingleNetworkSequenceSigner,
  UnrealMessageHandler,
  UnrealMessageProvider,
  WalletRequestHandler,
  WindowMessageHandler,
  WindowMessageProvider,
  WindowSessionParams,
  getWallet,
  initWallet,
  isBrowserExtension,
  isMuxTransportTemplate,
  isProviderTransport,
  isUnityPlugin,
  isValidMessageSignature,
  isValidSignature,
  isValidTypedDataSignature,
  isWalletUpToDate,
  messageToBytes,
  nextMessageIdx,
  prefixEIP191Message,
  resolveArrayProperties,
  trimEIP191Prefix,
  unregisterWallet,
  useBestStore,
  validateTransactionRequest
}, Symbol.toStringTag, { value: "Module" }));
function _mergeNamespaces$1(n2, m2) {
  m2.forEach(function(e2) {
    e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e2[k2];
          }
        });
      }
    });
  });
  return Object.freeze(n2);
}
var abi$1 = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [abi$1$2]);
var api = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [api$1]);
var auth = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [auth$1]);
var guard = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [guard$1]);
var indexer = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [indexer$1]);
var metadata = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [metadata$1]);
var multicall$1 = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [multicall$1$1]);
var network = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [network$1]);
var provider = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [provider$1]);
var relayer = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [relayer$1]);
const transactions = index$1$2.transaction;
var transactions$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  transactions
});
var utils$1 = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null,
  isValidSignature,
  isValidMessageSignature,
  isValidTypedDataSignature,
  isWalletUpToDate
}, [utils$1$1]);
var core = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [core$1]);
var signhub = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [signhub$1]);
var sessions = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [sessions$1]);
var migration = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [migration$1]);
var account = /* @__PURE__ */ _mergeNamespaces$1({
  __proto__: null
}, [account$1]);
var sequence$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abi: abi$1,
  api,
  auth,
  guard,
  indexer,
  metadata,
  multicall: multicall$1,
  network,
  provider,
  relayer,
  transactions: transactions$1,
  utils: utils$1,
  core,
  signhub,
  sessions,
  migration,
  account,
  initWallet,
  getWallet,
  unregisterWallet,
  SequenceProvider,
  SequenceClient,
  SequenceSigner
});
function useLoadGsiScript(options = {}) {
  const { nonce, onScriptLoadSuccess, onScriptLoadError } = options;
  const [scriptLoadedSuccessfully, setScriptLoadedSuccessfully] = reactExports.useState(false);
  const onScriptLoadSuccessRef = reactExports.useRef(onScriptLoadSuccess);
  onScriptLoadSuccessRef.current = onScriptLoadSuccess;
  const onScriptLoadErrorRef = reactExports.useRef(onScriptLoadError);
  onScriptLoadErrorRef.current = onScriptLoadError;
  reactExports.useEffect(() => {
    const scriptTag = document.createElement("script");
    scriptTag.src = "https://accounts.google.com/gsi/client";
    scriptTag.async = true;
    scriptTag.defer = true;
    scriptTag.nonce = nonce;
    scriptTag.onload = () => {
      var _a2;
      setScriptLoadedSuccessfully(true);
      (_a2 = onScriptLoadSuccessRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onScriptLoadSuccessRef);
    };
    scriptTag.onerror = () => {
      var _a2;
      setScriptLoadedSuccessfully(false);
      (_a2 = onScriptLoadErrorRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(onScriptLoadErrorRef);
    };
    document.body.appendChild(scriptTag);
    return () => {
      document.body.removeChild(scriptTag);
    };
  }, [nonce]);
  return scriptLoadedSuccessfully;
}
const GoogleOAuthContext = reactExports.createContext(null);
function GoogleOAuthProvider({ clientId, nonce, onScriptLoadSuccess, onScriptLoadError, children }) {
  const scriptLoadedSuccessfully = useLoadGsiScript({
    nonce,
    onScriptLoadSuccess,
    onScriptLoadError
  });
  const contextValue = reactExports.useMemo(() => ({
    clientId,
    scriptLoadedSuccessfully
  }), [clientId, scriptLoadedSuccessfully]);
  return React.createElement(GoogleOAuthContext.Provider, { value: contextValue }, children);
}
function useGoogleOAuth() {
  const context2 = reactExports.useContext(GoogleOAuthContext);
  if (!context2) {
    throw new Error("Google OAuth components must be used within GoogleOAuthProvider");
  }
  return context2;
}
function extractClientId(credentialResponse) {
  var _a2;
  const clientId = (_a2 = credentialResponse === null || credentialResponse === void 0 ? void 0 : credentialResponse.clientId) !== null && _a2 !== void 0 ? _a2 : credentialResponse === null || credentialResponse === void 0 ? void 0 : credentialResponse.client_id;
  return clientId;
}
const containerHeightMap = { large: 40, medium: 32, small: 20 };
function GoogleLogin({ onSuccess, onError, useOneTap, promptMomentNotification, type = "standard", theme = "outline", size: size2 = "large", text: text2, shape, logo_alignment, width, locale, click_listener, containerProps, ...props }) {
  const btnContainerRef = reactExports.useRef(null);
  const { clientId, scriptLoadedSuccessfully } = useGoogleOAuth();
  const onSuccessRef = reactExports.useRef(onSuccess);
  onSuccessRef.current = onSuccess;
  const onErrorRef = reactExports.useRef(onError);
  onErrorRef.current = onError;
  const promptMomentNotificationRef = reactExports.useRef(promptMomentNotification);
  promptMomentNotificationRef.current = promptMomentNotification;
  reactExports.useEffect(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2;
    if (!scriptLoadedSuccessfully)
      return;
    (_c2 = (_b2 = (_a2 = window === null || window === void 0 ? void 0 : window.google) === null || _a2 === void 0 ? void 0 : _a2.accounts) === null || _b2 === void 0 ? void 0 : _b2.id) === null || _c2 === void 0 ? void 0 : _c2.initialize({
      client_id: clientId,
      callback: (credentialResponse) => {
        var _a3;
        if (!(credentialResponse === null || credentialResponse === void 0 ? void 0 : credentialResponse.credential)) {
          return (_a3 = onErrorRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onErrorRef);
        }
        const { credential, select_by } = credentialResponse;
        onSuccessRef.current({
          credential,
          clientId: extractClientId(credentialResponse),
          select_by
        });
      },
      ...props
    });
    (_f2 = (_e2 = (_d2 = window === null || window === void 0 ? void 0 : window.google) === null || _d2 === void 0 ? void 0 : _d2.accounts) === null || _e2 === void 0 ? void 0 : _e2.id) === null || _f2 === void 0 ? void 0 : _f2.renderButton(btnContainerRef.current, {
      type,
      theme,
      size: size2,
      text: text2,
      shape,
      logo_alignment,
      width,
      locale,
      click_listener
    });
    if (useOneTap)
      (_j2 = (_h2 = (_g2 = window === null || window === void 0 ? void 0 : window.google) === null || _g2 === void 0 ? void 0 : _g2.accounts) === null || _h2 === void 0 ? void 0 : _h2.id) === null || _j2 === void 0 ? void 0 : _j2.prompt(promptMomentNotificationRef.current);
    return () => {
      var _a3, _b3, _c3;
      if (useOneTap)
        (_c3 = (_b3 = (_a3 = window === null || window === void 0 ? void 0 : window.google) === null || _a3 === void 0 ? void 0 : _a3.accounts) === null || _b3 === void 0 ? void 0 : _b3.id) === null || _c3 === void 0 ? void 0 : _c3.cancel();
    };
  }, [
    clientId,
    scriptLoadedSuccessfully,
    useOneTap,
    type,
    theme,
    size2,
    text2,
    shape,
    logo_alignment,
    width,
    locale
  ]);
  return React.createElement("div", { ...containerProps, ref: btnContainerRef, style: { height: containerHeightMap[size2], ...containerProps === null || containerProps === void 0 ? void 0 : containerProps.style } });
}
const version$4 = "2.12.0";
const getContractAddress = (address) => address;
const getUrl = (url) => url;
const getVersion$2 = () => `viem@${version$4}`;
let BaseError$2 = class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    var _a2;
    super();
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ViemError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getVersion$2()
    });
    const details = args.cause instanceof BaseError ? args.cause.details : ((_a2 = args.cause) == null ? void 0 : _a2.message) ? args.cause.message : args.details;
    const docsPath2 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath2 ? [
        `Docs: https://viem.sh${docsPath2}${args.docsSlug ? `#${args.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return walk(this, fn);
  }
};
function walk(err, fn) {
  if (fn == null ? void 0 : fn(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn);
  return fn ? null : err;
}
class IntegerOutOfRangeError extends BaseError$2 {
  constructor({ max: max2, min: min2, signed: signed2, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed2 ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min2} to ${max2})` : `(above ${min2})`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntegerOutOfRangeError"
    });
  }
}
class InvalidBytesBooleanError extends BaseError$2 {
  constructor(bytes3) {
    super(`Bytes value "${bytes3}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidBytesBooleanError"
    });
  }
}
class InvalidHexBooleanError extends BaseError$2 {
  constructor(hex2) {
    super(`Hex value "${hex2}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidHexBooleanError"
    });
  }
}
class SizeOverflowError extends BaseError$2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeOverflowError"
    });
  }
}
class SliceOffsetOutOfBoundsError extends BaseError$2 {
  constructor({ offset: offset2, position, size: size2 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset2}" is out-of-bounds (size: ${size2}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}
class SizeExceedsPaddingSizeError extends BaseError$2 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
class InvalidBytesLengthError extends BaseError$2 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidBytesLengthError"
    });
  }
}
function pad2(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex2 = hex_.replace("0x", "");
  if (hex2.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex2.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes3, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes3;
  if (bytes3.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes3.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0; i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes3[padEnd ? i : bytes3.length - i - 1];
  }
  return paddedBytes;
}
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size$5(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function toBytes$1(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes$1(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes3 = new Uint8Array(1);
  bytes3[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes3, { size: opts.size });
    return pad2(bytes3, { size: opts.size });
  }
  return bytes3;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes$1(hex_, opts = {}) {
  let hex2 = hex_;
  if (opts.size) {
    assertSize(hex2, { size: opts.size });
    hex2 = pad2(hex2, { dir: "right", size: opts.size });
  }
  let hexString = hex2.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes3 = new Uint8Array(length);
  for (let index2 = 0, j2 = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError$2(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes3[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes3;
}
function numberToBytes(value, opts) {
  const hex2 = numberToHex(value, opts);
  return hexToBytes$1(hex2);
}
function stringToBytes(value, opts = {}) {
  const bytes3 = encoder$1.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes3, { size: opts.size });
    return pad2(bytes3, { dir: "right", size: opts.size });
  }
  return bytes3;
}
function assertSize(hexOrBytes, { size: size2 }) {
  if (size$5(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size$5(hexOrBytes),
      maxSize: size2
    });
}
function fromHex$1(hex2, toOrOpts) {
  const opts = { to: toOrOpts };
  const to = opts.to;
  if (to === "number")
    return hexToNumber$1(hex2, opts);
  if (to === "bigint")
    return hexToBigInt(hex2, opts);
  if (to === "string")
    return hexToString(hex2, opts);
  if (to === "boolean")
    return hexToBool(hex2, opts);
  return hexToBytes$1(hex2, opts);
}
function hexToBigInt(hex2, opts = {}) {
  const { signed: signed2 } = opts;
  if (opts.size)
    assertSize(hex2, { size: opts.size });
  const value = BigInt(hex2);
  if (!signed2)
    return value;
  const size2 = (hex2.length - 2) / 2;
  const max2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max2)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex2 = hex_;
  if (opts.size) {
    assertSize(hex2, { size: opts.size });
    hex2 = trim(hex2);
  }
  if (trim(hex2) === "0x00")
    return false;
  if (trim(hex2) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex2);
}
function hexToNumber$1(hex2, opts = {}) {
  return Number(hexToBigInt(hex2, opts));
}
function hexToString(hex2, opts = {}) {
  let bytes3 = hexToBytes$1(hex2);
  if (opts.size) {
    assertSize(bytes3, { size: opts.size });
    bytes3 = trim(bytes3, { dir: "right" });
  }
  return new TextDecoder().decode(bytes3);
}
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
function toHex$1(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex$1(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex2 = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad2(hex2, { size: opts.size });
  }
  return hex2;
}
function bytesToHex$1(value, opts = {}) {
  let string = "";
  for (let i = 0; i < value.length; i++) {
    string += hexes$1[value[i]];
  }
  const hex2 = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex2, { size: opts.size });
    return pad2(hex2, { dir: "right", size: opts.size });
  }
  return hex2;
}
function numberToHex(value_, opts = {}) {
  const { signed: signed2, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed2)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed2 ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex2 = `0x${(signed2 && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad2(hex2, { size: size2 });
  return hex2;
}
const encoder = /* @__PURE__ */ new TextEncoder();
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex$1(value, opts);
}
async function addChain(client2, { chain }) {
  const { id: id2, name: name2, nativeCurrency, rpcUrls, blockExplorers } = chain;
  await client2.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id2),
        chainName: name2,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  }, { retryCount: 0 });
}
function formatAbiItem$1(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
class AbiConstructorNotFoundError extends BaseError$2 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError$2 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError$2 {
  constructor({ data, params, size: size2 }) {
    super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data} (${size2} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingDataSizeTooSmallError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data;
    this.params = params;
    this.size = size2;
  }
}
class AbiDecodingZeroDataError extends BaseError$2 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.');
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$2 {
  constructor({ expectedLength, givenLength, type }) {
    super([
      `ABI encoding array length mismatch for type ${type}.`,
      `Expected length: ${expectedLength}`,
      `Given length: ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$2 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size$5(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}
class AbiEncodingLengthMismatchError extends BaseError$2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError$2 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded error signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiErrorSignatureNotFoundError"
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.signature = signature2;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError$2 {
  constructor({ docsPath: docsPath2 }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError$2 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded event signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError$2 {
  constructor(eventName, { docsPath: docsPath2 } = {}) {
    super([
      `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError$2 {
  constructor(functionName, { docsPath: docsPath2 } = {}) {
    super([
      `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError$2 {
  constructor(functionName, { docsPath: docsPath2 }) {
    super([
      `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError$2 {
  constructor(x, y2) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${x.type}\` in \`${formatAbiItem$1(x.abiItem)}\`, and`,
        `\`${y2.type}\` in \`${formatAbiItem$1(y2.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError$2 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError$2 {
  constructor({ abiItem, data, params, size: size2 }) {
    super([
      `Data size of ${size2} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data} (${size2} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogDataMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
    this.data = data;
    this.params = params;
    this.size = size2;
  }
}
class DecodeLogTopicsMismatch extends BaseError$2 {
  constructor({ abiItem, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem$1(abiItem, { includeName: true })}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "DecodeLogTopicsMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
  }
}
class InvalidAbiEncodingTypeError extends BaseError$2 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2 });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiEncodingType"
    });
  }
}
class InvalidAbiDecodingTypeError extends BaseError$2 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2 });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiDecodingType"
    });
  }
}
class InvalidArrayError extends BaseError$2 {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError$2 {
  constructor(type) {
    super([
      `"${type}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidDefinitionTypeError"
    });
  }
}
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes$2(values);
}
function concatBytes$2(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset2 = 0;
  for (const arr of values) {
    result.set(arr, offset2);
    offset2 += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}
class InvalidAddressError extends BaseError$2 {
  constructor({ address }) {
    super(`Address "${address}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAddressError"
    });
  }
}
class LruMap extends Map {
  constructor(size2) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size2;
  }
  set(key2, value) {
    super.set(key2, value);
    if (this.maxSize && this.size > this.maxSize)
      this.delete(this.keys().next().value);
    return this;
  }
}
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash$1(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l: l2 } = fromBig(lst[i], le2);
    [Ah2[i], Al[i]] = [h2, l2];
  }
  return [Ah2, Al];
}
const rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
const rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
const rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
const rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
const crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (a2) => a2 instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift2) => word << 32 - shift2 | word >>> shift2;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes$1(data);
  if (!u8a$1(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes$1(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad3 = 0;
  arrays.forEach((a2) => {
    if (!u8a$1(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad3);
    pad3 += a2.length;
  });
  return r2;
}
class Hash2 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
    return crypto$1.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round2 = 0, R2 = _1n$5, x = 1, y2 = 0; round2 < 24; round2++) {
  [x, y2] = [y2, (2 * x + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n$4;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n$5 ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n$3)
      t2 ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j2)) - _1n$5;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
const rotlH = (h2, l2, s2) => s2 > 32 ? rotlBH(h2, l2, s2) : rotlSH(h2, l2, s2);
const rotlL = (h2, l2, s2) => s2 > 32 ? rotlBL(h2, l2, s2) : rotlSL(h2, l2, s2);
function keccakP(s2, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x = 0; x < 10; x++)
      B2[x] = s2[x] ^ s2[x + 10] ^ s2[x + 20] ^ s2[x + 30] ^ s2[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x + y2] ^= Th2;
        s2[x + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift2 = SHA3_ROTL[t2];
      const Th2 = rotlH(curH, curL, shift2);
      const Tl = rotlL(curH, curL, shift2);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th2;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x = 0; x < 10; x++)
        B2[x] = s2[y2 + x];
      for (let x = 0; x < 10; x++)
        s2[y2 + x] ^= ~B2[(x + 2) % 10] & B2[(x + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round2];
    s2[1] ^= SHA3_IOTA_L[round2];
  }
  B2.fill(0);
}
class Keccak extends Hash2 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes3 = keccak_256(isHex(value, { strict: false }) ? toBytes$1(value) : value);
  if (to === "bytes")
    return bytes3;
  return toHex$1(bytes3);
}
const checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = hexAddress.split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function getAddress(address, chainId) {
  if (!isAddress(address, { strict: false }))
    throw new InvalidAddressError({ address });
  return checksumAddress(address, chainId);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
const isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress(address, options) {
  const { strict = true } = options ?? {};
  if (isAddressCache.has(address))
    return isAddressCache.get(address);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(address, result);
  return result;
}
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size$5(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size$5(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size$5(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size$5(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed2 = param.type.startsWith("int");
    return encodeNumber(value, { signed: signed2 });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size$5(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size$5(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size$5(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  if (typeof value !== "boolean")
    throw new BaseError$2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed: signed2 }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed: signed2
    })
  };
}
function encodeString(value) {
  const hexValue2 = stringToHex(value);
  const partsLength = Math.ceil(size$5(hexValue2) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex(slice(hexValue2, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(size$5(hexValue2), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index2 = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index2]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
const docsPath$4 = "/docs/contract/encodeDeployData";
function encodeDeployData(parameters) {
  const { abi: abi2, args, bytecode } = parameters;
  if (!args || args.length === 0)
    return bytecode;
  const description2 = abi2.find((x) => "type" in x && x.type === "constructor");
  if (!description2)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath$4 });
  if (!("inputs" in description2))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath$4 });
  if (!description2.inputs || description2.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath$4 });
  const data = encodeAbiParameters(description2.inputs, args);
  return concatHex([bytecode, data]);
}
function parseAccount(account2) {
  if (typeof account2 === "string")
    return { address: account2, type: "json-rpc" };
  return account2;
}
class AccountNotFoundError extends BaseError$2 {
  constructor({ docsPath: docsPath2 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join("\n"), {
      docsPath: docsPath2,
      docsSlug: "account"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountNotFoundError"
    });
  }
}
class ChainDoesNotSupportContract extends BaseError$2 {
  constructor({ blockNumber, chain, contract }) {
    super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
          `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
        ] : [
          `- The chain does not have the contract "${contract.name}" configured.`
        ]
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError$2 {
  constructor({ chain, currentChainId }) {
    super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${currentChainId}`,
        `Expected Chain ID: ${chain.id}  ${chain.name}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainMismatchError"
    });
  }
}
class ChainNotFoundError2 extends BaseError$2 {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotFoundError"
    });
  }
}
class ClientChainNotConfiguredError extends BaseError$2 {
  constructor() {
    super("No chain was provided to the Client.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ClientChainNotConfiguredError"
    });
  }
}
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError2();
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}
const etherUnits = {
  gwei: 9,
  wei: 18
};
const gweiUnits = {
  ether: -9,
  wei: 9
};
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
class ExecutionRevertedError extends BaseError$2 {
  constructor({ cause, message } = {}) {
    var _a2;
    const reason = (_a2 = message == null ? void 0 : message.replace("execution reverted: ", "")) == null ? void 0 : _a2.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError$2 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError$2 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeCapTooLow"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError$2 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooHighError"
    });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError$2 {
  constructor({ cause, nonce } = {}) {
    super([
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join("\n"), { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceTooLowError"
    });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError$2 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NonceMaxValueError"
    });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError$2 {
  constructor({ cause } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join("\n"), {
      cause,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds/
});
class IntrinsicGasTooHighError extends BaseError$2 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError$2 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError$2 {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError$2 {
  constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"), {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError$2 {
  constructor({ cause }) {
    super(`An error occurred while executing: ${cause == null ? void 0 : cause.shortMessage}`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownNodeError"
    });
  }
}
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key2, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key2, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key2]) => Math.max(acc, key2.length), 0);
  return entries.map(([key2, value]) => `  ${`${key2}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
class FeeConflictError extends BaseError$2 {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FeeConflictError"
    });
  }
}
class InvalidSerializableTransactionError extends BaseError$2 {
  constructor({ transaction: transaction2 }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(transaction2),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSerializableTransactionError"
    });
  }
}
class TransactionExecutionError extends BaseError$2 {
  constructor(cause, { account: account2, docsPath: docsPath2, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    var _a2;
    const prettyArgs = prettyPrint({
      chain: chain && `${chain == null ? void 0 : chain.name} (id: ${chain == null ? void 0 : chain.id})`,
      from: account2 == null ? void 0 : account2.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${((_a2 = chain == null ? void 0 : chain.nativeCurrency) == null ? void 0 : _a2.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionExecutionError"
    });
    this.cause = cause;
  }
}
class TransactionNotFoundError extends BaseError$2 {
  constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {
    let identifier = "Transaction";
    if (blockTag && index2 !== void 0)
      identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
    if (blockHash && index2 !== void 0)
      identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
    if (blockNumber && index2 !== void 0)
      identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
    if (hash2)
      identifier = `Transaction with hash "${hash2}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError$2 {
  constructor({ hash: hash2 }) {
    super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError$2 {
  constructor({ hash: hash2 }) {
    super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
const stringify = (value, replacer, space) => JSON.stringify(value, (key2, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key2, value2) : value2;
}, space);
class HttpRequestError extends BaseError$2 {
  constructor({ body, details, headers, status, url }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body && `Request body: ${stringify(body)}`
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}
class RpcRequestError extends BaseError$2 {
  constructor({ body, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
  }
}
class TimeoutError3 extends BaseError$2 {
  constructor({ body, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TimeoutError"
    });
  }
}
const unknownErrorCode = -1;
class RpcError extends BaseError$2 {
  constructor(cause, { code: code2, docsPath: docsPath2, metaMessages, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: metaMessages || (cause == null ? void 0 : cause.metaMessages)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = cause.name;
    this.code = cause instanceof RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      shortMessage: "An unknown RPC error occurred."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownRpcError"
    });
  }
}
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err instanceof BaseError$2 ? err.walk((e2) => e2.code === ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof BaseError$2) {
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  }
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args == null ? void 0 : args.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args == null ? void 0 : args.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args == null ? void 0 : args.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args == null ? void 0 : args.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args == null ? void 0 : args.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args == null ? void 0 : args.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args == null ? void 0 : args.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args == null ? void 0 : args.maxFeePerGas,
      maxPriorityFeePerGas: args == null ? void 0 : args.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
function getTransactionError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
function extract(value_, { format: format2 }) {
  if (!format2)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key2 of keys) {
      if (key2 in value_)
        value[key2] = value_[key2];
      if (formatted2[key2] && typeof formatted2[key2] === "object" && !Array.isArray(formatted2[key2]))
        extract_(formatted2[key2]);
    }
  }
  const formatted = format2(value_ || {});
  extract_(formatted);
  return value;
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3"
};
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.accessList !== "undefined")
    rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== "undefined")
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined") {
    if (typeof request.blobs[0] !== "string")
      rpcRequest.blobs = request.blobs.map((x) => bytesToHex$1(x));
    else
      rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== "undefined")
    rpcRequest.data = request.data;
  if (typeof request.from !== "undefined")
    rpcRequest.from = request.from;
  if (typeof request.gas !== "undefined")
    rpcRequest.gas = numberToHex(request.gas);
  if (typeof request.gasPrice !== "undefined")
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request.nonce);
  if (typeof request.to !== "undefined")
    rpcRequest.to = request.to;
  if (typeof request.type !== "undefined")
    rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== "undefined")
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
function getAction$1(client2, action, name2) {
  return (params) => {
    var _a2, _b2;
    return ((_a2 = client2[action.name]) == null ? void 0 : _a2.call(client2, params)) ?? ((_b2 = client2[name2]) == null ? void 0 : _b2.call(client2, params)) ?? action(client2, params);
  };
}
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account2 = account_ ? parseAccount(account_) : void 0;
  if (account2 && !isAddress(account2.address))
    throw new InvalidAddressError({ address: account2.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
async function getChainId$1(client2) {
  const chainIdHex = await client2.request({
    method: "eth_chainId"
  });
  return hexToNumber$1(chainIdHex);
}
class BaseFeeScalarError extends BaseError$2 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError$2 {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError$2 {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
}
class BlockNotFoundError extends BaseError$2 {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function formatTransaction(transaction2) {
  const transaction_ = {
    ...transaction2,
    blockHash: transaction2.blockHash ? transaction2.blockHash : null,
    blockNumber: transaction2.blockNumber ? BigInt(transaction2.blockNumber) : null,
    chainId: transaction2.chainId ? hexToNumber$1(transaction2.chainId) : void 0,
    gas: transaction2.gas ? BigInt(transaction2.gas) : void 0,
    gasPrice: transaction2.gasPrice ? BigInt(transaction2.gasPrice) : void 0,
    maxFeePerBlobGas: transaction2.maxFeePerBlobGas ? BigInt(transaction2.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction2.maxFeePerGas ? BigInt(transaction2.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction2.maxPriorityFeePerGas ? BigInt(transaction2.maxPriorityFeePerGas) : void 0,
    nonce: transaction2.nonce ? hexToNumber$1(transaction2.nonce) : void 0,
    to: transaction2.to ? transaction2.to : null,
    transactionIndex: transaction2.transactionIndex ? Number(transaction2.transactionIndex) : null,
    type: transaction2.type ? transactionType[transaction2.type] : void 0,
    typeHex: transaction2.type ? transaction2.type : void 0,
    value: transaction2.value ? BigInt(transaction2.value) : void 0,
    v: transaction2.v ? BigInt(transaction2.v) : void 0
  };
  transaction_.yParity = (() => {
    if (transaction2.yParity)
      return Number(transaction2.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
function formatBlock(block) {
  var _a2;
  const transactions2 = (_a2 = block.transactions) == null ? void 0 : _a2.map((transaction2) => {
    if (typeof transaction2 === "string")
      return transaction2;
    return formatTransaction(transaction2);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions: transactions2,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
async function getBlock(client2, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  var _a2, _b2, _c2;
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client2.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block = await client2.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.block) == null ? void 0 : _c2.format) || formatBlock;
  return format2(block);
}
async function getGasPrice(client2) {
  const gasPrice = await client2.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}
async function estimateMaxPriorityFeePerGas(client2, args) {
  return internal_estimateMaxPriorityFeePerGas(client2, args);
}
async function internal_estimateMaxPriorityFeePerGas(client2, args) {
  var _a2, _b2, _c2;
  const { block: block_, chain = client2.chain, request } = args || {};
  if (typeof ((_a2 = chain == null ? void 0 : chain.fees) == null ? void 0 : _a2.defaultPriorityFee) === "function") {
    const block = block_ || await getAction$1(client2, getBlock, "getBlock")({});
    return chain.fees.defaultPriorityFee({
      block,
      client: client2,
      request
    });
  }
  if (typeof ((_b2 = chain == null ? void 0 : chain.fees) == null ? void 0 : _b2.defaultPriorityFee) !== "undefined")
    return (_c2 = chain == null ? void 0 : chain.fees) == null ? void 0 : _c2.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client2.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction$1(client2, getBlock, "getBlock")({}),
      getAction$1(client2, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}
async function estimateFeesPerGas(client2, args) {
  return internal_estimateFeesPerGas(client2, args);
}
async function internal_estimateFeesPerGas(client2, args) {
  var _a2, _b2;
  const { block: block_, chain = client2.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    var _a3, _b3;
    if (typeof ((_a3 = chain == null ? void 0 : chain.fees) == null ? void 0 : _a3.baseFeeMultiplier) === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client: client2,
        request
      });
    return ((_b3 = chain == null ? void 0 : chain.fees) == null ? void 0 : _b3.baseFeeMultiplier) ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = ((_a2 = baseFeeMultiplier.toString().split(".")[1]) == null ? void 0 : _a2.length) ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base2) => base2 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction$1(client2, getBlock, "getBlock")({});
  if (typeof ((_b2 = chain == null ? void 0 : chain.fees) == null ? void 0 : _b2.estimateFeesPerGas) === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client: client2,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof (request == null ? void 0 : request.maxPriorityFeePerGas) === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client2, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = (request == null ? void 0 : request.maxFeePerGas) ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = (request == null ? void 0 : request.gasPrice) ?? multiply(await getAction$1(client2, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}
class EstimateGasExecutionError extends BaseError$2 {
  constructor(cause, { account: account2, docsPath: docsPath2, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    var _a2;
    const prettyArgs = prettyPrint({
      from: account2 == null ? void 0 : account2.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${((_a2 = chain == null ? void 0 : chain.nativeCurrency) == null ? void 0 : _a2.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
}
function getEstimateGasError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
class AccountStateConflictError extends BaseError$2 {
  constructor({ address }) {
    super(`State for account "${address}" is set multiple times.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountStateConflictError"
    });
  }
}
class StateAssignmentConflictError extends BaseError$2 {
  constructor() {
    super("state and stateDiff are set on the same account.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "StateAssignmentConflictError"
    });
  }
}
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}
`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state }) => {
    let val = `${pretty}    ${address}:
`;
    if (state.nonce)
      val += `      nonce: ${state.nonce}
`;
    if (state.balance)
      val += `      balance: ${state.balance}
`;
    if (state.code)
      val += `      code: ${state.code}
`;
    if (state.state) {
      val += "      state:\n";
      val += prettyStateMapping(state.state);
    }
    if (state.stateDiff) {
      val += "      stateDiff:\n";
      val += prettyStateMapping(state.stateDiff);
    }
    return val;
  }, "  State Override:\n").slice(0, -1);
}
function serializeStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0)
    return void 0;
  return stateMapping.reduce((acc, { slot, value }) => {
    if (slot.length !== 66)
      throw new InvalidBytesLengthError({
        size: slot.length,
        targetSize: 66,
        type: "hex"
      });
    if (value.length !== 66)
      throw new InvalidBytesLengthError({
        size: value.length,
        targetSize: 66,
        type: "hex"
      });
    acc[slot] = value;
    return acc;
  }, {});
}
function serializeAccountStateOverride(parameters) {
  const { balance, nonce, state, stateDiff, code: code2 } = parameters;
  const rpcAccountStateOverride = {};
  if (code2 !== void 0)
    rpcAccountStateOverride.code = code2;
  if (balance !== void 0)
    rpcAccountStateOverride.balance = numberToHex(balance);
  if (nonce !== void 0)
    rpcAccountStateOverride.nonce = numberToHex(nonce);
  if (state !== void 0)
    rpcAccountStateOverride.state = serializeStateMapping(state);
  if (stateDiff !== void 0) {
    if (rpcAccountStateOverride.state)
      throw new StateAssignmentConflictError();
    rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
  if (!parameters)
    return void 0;
  const rpcStateOverride = {};
  for (const { address, ...accountState } of parameters) {
    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address });
    if (rpcStateOverride[address])
      throw new AccountStateConflictError({ address });
    rpcStateOverride[address] = serializeAccountStateOverride(accountState);
  }
  return rpcStateOverride;
}
async function estimateGas(client2, args) {
  var _a2, _b2, _c2;
  const account_ = args.account ?? client2.account;
  const account2 = account_ ? parseAccount(account_) : void 0;
  try {
    const { accessList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = await prepareTransactionRequest(client2, {
      ...args,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (account2 == null ? void 0 : account2.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    });
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    assertRequest(args);
    const chainFormat = (_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.transactionRequest) == null ? void 0 : _c2.format;
    const format2 = chainFormat || formatTransactionRequest;
    const request = format2({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account2 == null ? void 0 : account2.address,
      accessList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client2.request({
      method: "eth_estimateGas",
      params: rpcStateOverride ? [request, block ?? "latest", rpcStateOverride] : block ? [request, block] : [request]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account: account2,
      chain: client2.chain
    });
  }
}
async function getTransactionCount(client2, { address, blockTag = "latest", blockNumber }) {
  const count2 = await client2.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber$1(count2);
}
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes$1(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x) => bytesToHex$1(x));
}
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes$1(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes$1(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x) => bytesToHex$1(x));
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh2, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
class SHA2 extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA2562 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA2562());
function sha256(value, to_) {
  const bytes3 = sha256$1(isHex(value, { strict: false }) ? toBytes$1(value) : value);
  return bytes3;
}
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version2 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha256(commitment);
  versionedHash.set([version2], 0);
  return to === "bytes" ? versionedHash : bytesToHex$1(versionedHash);
}
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version2 } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version2
    }));
  }
  return hashes;
}
const blobsPerTransaction = 6;
const bytesPerFieldElement = 32;
const fieldElementsPerBlob = 4096;
const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;
class BlobSizeTooLargeError extends BaseError$2 {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlobSizeTooLargeError"
    });
  }
}
class EmptyBlobError extends BaseError$2 {
  constructor() {
    super("Blob data must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EmptyBlobError"
    });
  }
}
class NegativeOffsetError extends BaseError$2 {
  constructor({ offset: offset2 }) {
    super(`Offset \`${offset2}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError$2 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PositionOutOfBoundsError"
    });
  }
}
class RecursiveReadLimitExceededError extends BaseError$2 {
  constructor({ count: count2, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count2}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RecursiveReadLimitExceededError"
    });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset2) {
    if (offset2 < 0)
      throw new NegativeOffsetError({ offset: offset2 });
    const position = this.position - offset2;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset2) {
    if (offset2 < 0)
      throw new NegativeOffsetError({ offset: offset2 });
    const position = this.position + offset2;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes3) {
    this.assertPosition(this.position + bytes3.length - 1);
    this.bytes.set(bytes3, this.position);
    this.position += bytes3.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size2) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size2 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count2 = this.getReadCount();
    this.positionReadCount.set(this.position, count2 + 1);
    if (count2 > 0)
      this.recursiveReadCount++;
  }
};
function createCursor(bytes3, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes3;
  cursor.dataView = new DataView(bytes3.buffer, bytes3.byteOffset, bytes3.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes$1(parameters.data) : parameters.data;
  const size_ = size$5(data);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes3 = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes3);
      if (bytes3.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex$1(x.bytes));
}
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}
function getTransactionType(transaction2) {
  if (transaction2.type)
    return transaction2.type;
  if (typeof transaction2.blobs !== "undefined" || typeof transaction2.blobVersionedHashes !== "undefined" || typeof transaction2.maxFeePerBlobGas !== "undefined" || typeof transaction2.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction2.maxFeePerGas !== "undefined" || typeof transaction2.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction2.gasPrice !== "undefined") {
    if (typeof transaction2.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction: transaction2 });
}
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(client2, args) {
  const { account: account_ = client2.account, blobs, chain, chainId, gas, kzg, nonce, parameters = defaultParameters, type } = args;
  const account2 = account_ ? parseAccount(account_) : void 0;
  const request = { ...args, ...account2 ? { from: account2 == null ? void 0 : account2.address } : {} };
  let block;
  async function getBlock$1() {
    if (block)
      return block;
    block = await getAction$1(client2, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId")) {
    if (chain)
      request.chainId = chain.id;
    else if (typeof chainId !== "undefined")
      request.chainId = chainId;
    else
      request.chainId = await getAction$1(client2, getChainId$1, "getChainId")({});
  }
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account2)
    request.nonce = await getAction$1(client2, getTransactionCount, "getTransactionCount")({
      address: account2.address,
      blockTag: "pending"
    });
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      const block2 = await getBlock$1();
      request.type = typeof (block2 == null ? void 0 : block2.baseFeePerGas) === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock$1();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client2, {
          block: block2,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError();
      const block2 = await getBlock$1();
      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client2, {
        block: block2,
        chain,
        request,
        type: "legacy"
      });
      request.gasPrice = gasPrice_;
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction$1(client2, estimateGas, "estimateGas")({
      ...request,
      account: account2 ? { address: account2.address, type: "json-rpc" } : void 0
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}
async function sendRawTransaction(client2, { serializedTransaction }) {
  return client2.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}
async function sendTransaction$1(client2, parameters) {
  var _a2, _b2, _c2, _d2;
  const { account: account_ = client2.account, chain = client2.chain, accessList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account2 = parseAccount(account_);
  try {
    assertRequest(parameters);
    let chainId;
    if (chain !== null) {
      chainId = await getAction$1(client2, getChainId$1, "getChainId")({});
      assertCurrentChain({
        currentChainId: chainId,
        chain
      });
    }
    if (account2.type === "local") {
      const request2 = await getAction$1(client2, prepareTransactionRequest, "prepareTransactionRequest")({
        account: account2,
        accessList,
        blobs,
        chain,
        chainId,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        parameters: [...defaultParameters, "sidecars"],
        to,
        value,
        ...rest
      });
      const serializer = (_a2 = chain == null ? void 0 : chain.serializers) == null ? void 0 : _a2.transaction;
      const serializedTransaction = await account2.signTransaction(request2, {
        serializer
      });
      return await getAction$1(client2, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    const chainFormat = (_d2 = (_c2 = (_b2 = client2.chain) == null ? void 0 : _b2.formatters) == null ? void 0 : _c2.transactionRequest) == null ? void 0 : _d2.format;
    const format2 = chainFormat || formatTransactionRequest;
    const request = format2({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      accessList,
      blobs,
      data,
      from: account2.address,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client2.request({
      method: "eth_sendTransaction",
      params: [request]
    }, { retryCount: 0 });
  } catch (err) {
    throw getTransactionError(err, {
      ...parameters,
      account: account2,
      chain: parameters.chain || void 0
    });
  }
}
function deployContract(walletClient, parameters) {
  const { abi: abi2, args, bytecode, ...request } = parameters;
  const calldata = encodeDeployData({ abi: abi2, args, bytecode });
  return sendTransaction$1(walletClient, {
    ...request,
    data: calldata
  });
}
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
];
const universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
];
const universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
];
const textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
];
const addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
];
const universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
function bytesToBigInt(bytes3, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes3, { size: opts.size });
  const hex2 = bytesToHex$1(bytes3, opts);
  return hexToBigInt(hex2, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes3 = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes3, { size: opts.size });
    bytes3 = trim(bytes3);
  }
  if (bytes3.length > 1 || bytes3[0] > 1)
    throw new InvalidBytesBooleanError(bytes3);
  return Boolean(bytes3[0]);
}
function bytesToNumber(bytes3, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes3, { size: opts.size });
  const hex2 = bytesToHex$1(bytes3, opts);
  return hexToNumber$1(hex2, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes3 = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes3, { size: opts.size });
    bytes3 = trim(bytes3, { dir: "right" });
  }
  return new TextDecoder().decode(bytes3);
}
function decodeAbiParameters(params, data) {
  const bytes3 = typeof data === "string" ? hexToBytes$1(data) : data;
  const cursor = createCursor(bytes3);
  if (size$5(bytes3) === 0 && params.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$5(data) && size$5(data) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof data === "string" ? data : bytesToHex$1(data),
      params,
      size: size$5(data)
    });
  let consumed = 0;
  const values = [];
  for (let i = 0; i < params.length; ++i) {
    const param = params[i];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, param, {
      staticPosition: 0
    });
    consumed += consumed_;
    values.push(data2);
  }
  return values;
}
function decodeParameter(cursor, param, { staticPosition }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(cursor, { ...param, type }, { length, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, { staticPosition });
  if (param.type === "address")
    return decodeAddress(cursor);
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const sizeOfLength = 32;
const sizeOfOffset = 32;
function decodeAddress(cursor) {
  const value = cursor.readBytes(32);
  return [checksumAddress(bytesToHex$1(sliceBytes(value, -20))), 32];
}
function decodeArray(cursor, param, { length, staticPosition }) {
  if (!length) {
    const offset2 = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset2;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value2 = [];
    for (let i = 0; i < length2; ++i) {
      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(param)) {
    const offset2 = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset2;
    const value2 = [];
    for (let i = 0; i < length; ++i) {
      cursor.setPosition(start + i * 32);
      const [data] = decodeParameter(cursor, param, {
        staticPosition: start
      });
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let i = 0; i < length; ++i) {
    const [data, consumed_] = decodeParameter(cursor, param, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data);
  }
  return [value, consumed];
}
function decodeBool(cursor) {
  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
  const [_, size2] = param.type.split("bytes");
  if (!size2) {
    const offset2 = bytesToNumber(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset2);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [bytesToHex$1(data), 32];
  }
  const value = bytesToHex$1(cursor.readBytes(Number.parseInt(size2), 32));
  return [value, 32];
}
function decodeNumber(cursor, param) {
  const signed2 = param.type.startsWith("int");
  const size2 = Number.parseInt(param.type.split("int")[1] || "256");
  const value = cursor.readBytes(32);
  return [
    size2 > 48 ? bytesToBigInt(value, { signed: signed2 }) : bytesToNumber(value, { signed: signed2 }),
    32
  ];
}
function decodeTuple(cursor, param, { staticPosition }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name: name2 }) => !name2);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset2 = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset2;
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition: start
      });
      consumed += consumed_;
      value[hasUnnamedChild ? i : component == null ? void 0 : component.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let i = 0; i < param.components.length; ++i) {
    const component = param.components[i];
    const [data, consumed_] = decodeParameter(cursor, component, {
      staticPosition
    });
    value[hasUnnamedChild ? i : component == null ? void 0 : component.name] = data;
    consumed += consumed_;
  }
  return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset2 = bytesToNumber(cursor.readBytes(32));
  const start = staticPosition + offset2;
  cursor.setPosition(start);
  const length = bytesToNumber(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value = bytesToString(trim(data));
  cursor.setPosition(staticPosition + 32);
  return [value, 32];
}
function hasDynamicChild(param) {
  var _a2;
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return (_a2 = param.components) == null ? void 0 : _a2.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
const hash = (value) => keccak256(toBytes$1(value));
function hashSignature(sig) {
  return hash(sig);
}
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match == null ? void 0 : match.groups;
}
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let i = 0; i < length; i++) {
      const component = abiParameter.components[i];
      type += formatAbiParameter(component);
      if (i < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${(result == null ? void 0 : result.array) ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0; i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  else if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  else if (abiItem.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
function normalizeSignature(signature2) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0; i < signature2.length; i++) {
    const char = signature2[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature2[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError$2("Unable to normalize signature.");
  return result;
}
const toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem(def);
  })();
  return normalizeSignature(def_);
};
function toSignatureHash(fn) {
  return hashSignature(toSignature(fn));
}
const toEventSelector = toSignatureHash;
const toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
function getAbiItem(parameters) {
  const { abi: abi2, args = [], name: name2 } = parameters;
  const isSelector = isHex(name2, { strict: false });
  const abiItems = abi2.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name2;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name2;
      return false;
    }
    return "name" in abiItem && abiItem.name === name2;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = void 0;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgOfType(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return isAddress(args[parameterIndex], { strict: false });
      if (types2.includes("address") && types2.includes("bytes"))
        return isAddress(args[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}
const docsPath$3 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(parameters) {
  const { abi: abi2, args, functionName, data } = parameters;
  let abiItem = abi2[0];
  if (functionName) {
    const item2 = getAbiItem({ abi: abi2, args, name: functionName });
    if (!item2)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$3 });
    abiItem = item2;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$3 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$3 });
  const values = decodeAbiParameters(abiItem.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return void 0;
}
const docsPath$2 = "/docs/contract/encodeFunctionData";
function prepareEncodeFunctionData(parameters) {
  const { abi: abi2, args, functionName } = parameters;
  let abiItem = abi2[0];
  if (functionName) {
    const item2 = getAbiItem({
      abi: abi2,
      args,
      name: functionName
    });
    if (!item2)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$2 });
    abiItem = item2;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$2 });
  return {
    abi: [abiItem],
    functionName: toFunctionSelector(formatAbiItem$1(abiItem))
  };
}
function encodeFunctionData(parameters) {
  const { args } = parameters;
  const { abi: abi2, functionName } = (() => {
    var _a2;
    if (parameters.abi.length === 1 && ((_a2 = parameters.functionName) == null ? void 0 : _a2.startsWith("0x")))
      return parameters;
    return prepareEncodeFunctionData(parameters);
  })();
  const abiItem = abi2[0];
  const signature2 = functionName;
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
  return concatHex([signature2, data ?? "0x"]);
}
function getChainContractAddress({ blockNumber, chain, contract: name2 }) {
  var _a2;
  const contract = (_a2 = chain == null ? void 0 : chain.contracts) == null ? void 0 : _a2[name2];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name: name2 }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name: name2,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
const solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
};
const solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function decodeErrorResult(parameters) {
  const { abi: abi2, data } = parameters;
  const signature2 = slice(data, 0, 4);
  if (signature2 === "0x")
    throw new AbiDecodingZeroDataError();
  const abi_ = [...abi2 || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x) => x.type === "error" && signature2 === toFunctionSelector(formatAbiItem$1(x)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,
    errorName: abiItem.name
  };
}
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input2, i) => `${includeName && input2.name ? `${input2.name}: ` : ""}${typeof args[i] === "object" ? stringify(args[i]) : args[i]}`).join(", ")})`;
}
class CallExecutionError extends BaseError$2 {
  constructor(cause, { account: account_, docsPath: docsPath2, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
    var _a2;
    const account2 = account_ ? parseAccount(account_) : void 0;
    let prettyArgs = prettyPrint({
      from: account2 == null ? void 0 : account2.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${((_a2 = chain == null ? void 0 : chain.nativeCurrency) == null ? void 0 : _a2.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    if (stateOverride) {
      prettyArgs += `
${prettyStateOverride(stateOverride)}`;
    }
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CallExecutionError"
    });
    this.cause = cause;
  }
}
class ContractFunctionExecutionError extends BaseError$2 {
  constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath2, functionName, sender }) {
    const abiItem = getAbiItem({ abi: abi2, args, name: functionName });
    const formattedArgs = abiItem ? formatAbiItemWithArgs({
      abiItem,
      args,
      includeFunctionName: false,
      includeName: false
    }) : void 0;
    const functionWithParams = abiItem ? formatAbiItem$1(abiItem, { includeName: true }) : void 0;
    const prettyArgs = prettyPrint({
      address: contractAddress && getContractAddress(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array((functionName == null ? void 0 : functionName.length) ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Contract Call:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "abi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "args", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "formattedArgs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "functionName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sender", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionExecutionError"
    });
    this.abi = abi2;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
}
class ContractFunctionRevertedError extends BaseError$2 {
  constructor({ abi: abi2, data, functionName, message }) {
    let cause;
    let decodedData = void 0;
    let metaMessages;
    let reason;
    if (data && data !== "0x") {
      try {
        decodedData = decodeErrorResult({ abi: abi2, data });
        const { abiItem, errorName, args: errorArgs } = decodedData;
        if (errorName === "Error") {
          reason = errorArgs[0];
        } else if (errorName === "Panic") {
          const [firstArg] = errorArgs;
          reason = panicReasons[firstArg];
        } else {
          const errorWithParams = abiItem ? formatAbiItem$1(abiItem, { includeName: true }) : void 0;
          const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
            abiItem,
            args: errorArgs,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : "",
            formattedArgs && formattedArgs !== "()" ? `       ${[...Array((errorName == null ? void 0 : errorName.length) ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
          ];
        }
      } catch (err) {
        cause = err;
      }
    } else if (message)
      reason = message;
    let signature2;
    if (cause instanceof AbiErrorSignatureNotFoundError) {
      signature2 = cause.signature;
      metaMessages = [
        `Unable to decode signature "${signature2}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ];
    }
    super(reason && reason !== "execution reverted" || signature2 ? [
      `The contract function "${functionName}" reverted with the following ${signature2 ? "signature" : "reason"}:`,
      reason || signature2
    ].join("\n") : `The contract function "${functionName}" reverted.`, {
      cause,
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reason", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = decodedData;
    this.reason = reason;
    this.signature = signature2;
  }
}
class ContractFunctionZeroDataError extends BaseError$2 {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ContractFunctionZeroDataError"
    });
  }
}
class RawContractError extends BaseError$2 {
  constructor({ data, message }) {
    super(message || "");
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RawContractError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data;
  }
}
function isNullUniversalResolverError(err, callType) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  if (!(err instanceof BaseError$2))
    return false;
  const cause = err.walk((e2) => e2 instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (((_a2 = cause.data) == null ? void 0 : _a2.errorName) === "ResolverNotFound")
    return true;
  if (((_b2 = cause.data) == null ? void 0 : _b2.errorName) === "ResolverWildcardNotSupported")
    return true;
  if (((_c2 = cause.data) == null ? void 0 : _c2.errorName) === "ResolverNotContract")
    return true;
  if (((_d2 = cause.data) == null ? void 0 : _d2.errorName) === "ResolverError")
    return true;
  if (((_e2 = cause.data) == null ? void 0 : _e2.errorName) === "HttpError")
    return true;
  if ((_f2 = cause.reason) == null ? void 0 : _f2.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}
function namehash(name2) {
  let result = new Uint8Array(32).fill(0);
  if (!name2)
    return bytesToHex$1(result);
  const labels = name2.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes$1(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex$1(result);
}
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex$1(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes3 = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset2 = 0;
  const list2 = value.split(".");
  for (let i = 0; i < list2.length; i++) {
    let encoded = stringToBytes(list2[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list2[i])));
    bytes3[offset2] = encoded.length;
    bytes3.set(encoded, offset2 + 1);
    offset2 += encoded.length + 1;
  }
  if (bytes3.byteLength !== offset2 + 1)
    return bytes3.slice(0, offset2 + 1);
  return bytes3;
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi: abi2, address, args, docsPath: docsPath2, functionName, sender }) {
  const { code: code2, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError$2 ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code2) && (data || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi: abi2,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi: abi2,
    args,
    contractAddress: address,
    docsPath: docsPath2,
    functionName,
    sender
  });
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i = links.length - 1; i >= 0; i--) {
          const link2 = links[i];
          if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      if (cspNonce) {
        link.setAttribute("nonce", cspNonce);
      }
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    }));
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const aggregate3Signature = "0x82ad56cb";
function getCallError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn, id: id2, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler2 = getScheduler();
    flush();
    const args = scheduler2.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data) => {
      var _a2;
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (let i = 0; i < scheduler2.length; i++) {
        const { pendingPromise } = scheduler2[i];
        (_a2 = pendingPromise.resolve) == null ? void 0 : _a2.call(pendingPromise, [data[i], data]);
      }
    }).catch((err) => {
      var _a2;
      for (let i = 0; i < scheduler2.length; i++) {
        const { pendingPromise } = scheduler2[i];
        (_a2 = pendingPromise.reject) == null ? void 0 : _a2.call(pendingPromise, err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id2);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id2) || [];
  const setScheduler = (item2) => schedulerCache.set(id2, [...getScheduler(), item2]);
  return {
    flush,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve, reject) => {
        pendingPromise.resolve = resolve;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch == null ? void 0 : shouldSplitBatch([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
async function call(client2, args) {
  var _a2, _b2, _c2, _d2;
  const { account: account_ = client2.account, batch = Boolean((_a2 = client2.batch) == null ? void 0 : _a2.multicall), blockNumber, blockTag = "latest", accessList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
  const account2 = account_ ? parseAccount(account_) : void 0;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const chainFormat = (_d2 = (_c2 = (_b2 = client2.chain) == null ? void 0 : _b2.formatters) == null ? void 0 : _c2.transactionRequest) == null ? void 0 : _d2.format;
    const format2 = chainFormat || formatTransactionRequest;
    const request = format2({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account2 == null ? void 0 : account2.address,
      accessList,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {
      try {
        return await scheduleMulticall(client2, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client2.request({
      method: "eth_call",
      params: rpcStateOverride ? [
        request,
        block,
        rpcStateOverride
      ] : [request, block]
    });
    if (response === "0x")
      return { data: void 0 };
    return { data: response };
  } catch (err) {
    const data2 = getRevertErrorData(err);
    const { offchainLookup, offchainLookupSignature } = await __vitePreload(() => import("./ccip-CPzQpqt_.js"), true ? [] : void 0, import.meta.url);
    if (client2.ccipRead !== false && (data2 == null ? void 0 : data2.slice(0, 10)) === offchainLookupSignature && to)
      return { data: await offchainLookup(client2, { data: data2, to }) };
    throw getCallError(err, {
      ...args,
      account: account2,
      chain: client2.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data, to, ...request_ } = request;
  if (!data)
    return false;
  if (data.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client2, args) {
  var _a2;
  const { batchSize = 1024, wait: wait2 = 0 } = typeof ((_a2 = client2.batch) == null ? void 0 : _a2.multicall) === "object" ? client2.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new ClientChainNotConfiguredError();
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client2.uid}.${block}`,
    wait: wait2,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data2 }) => size3 + (data2.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data2 = await client2.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data2 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: void 0 };
  return { data: returnData };
}
function getRevertErrorData(err) {
  var _a2;
  if (!(err instanceof BaseError$2))
    return void 0;
  const error = err.walk();
  return typeof (error == null ? void 0 : error.data) === "object" ? (_a2 = error.data) == null ? void 0 : _a2.data : error.data;
}
async function readContract(client2, parameters) {
  const { abi: abi2, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    const { data } = await getAction$1(client2, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi: abi2,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}
async function getEnsAddress(client2, { blockNumber, blockTag, coinType, name: name2, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name2), BigInt(coinType)] } : { args: [namehash(name2)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex$1(packetToBytes(name2)), functionData],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name2), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError$2 {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError$2 {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError$2 {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUriResolutionError"
    });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError$2 {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType == null ? void 0 : contentType.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img2 = new Image();
      img2.onload = () => {
        resolve(true);
      };
      img2.onerror = () => {
        resolve(false);
      };
      img2.src = uri;
    });
  }
}
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = (networkRegexMatch == null ? void 0 : networkRegexMatch.groups) || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS2 = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS2) {
    let replacedUri = uri;
    if (gatewayUrls == null ? void 0 : gatewayUrls.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls == null ? void 0 : gatewayUrls.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS2) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client2, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
async function parseAvatarRecord(client2, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client2, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client2, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client2, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? (
      // if it is encoded, decode it
      atob(resolvedNftUri.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      resolvedNftUri
    );
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}
async function getEnsText(client2, { blockNumber, blockTag, name: name2, key: key2, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex$1(packetToBytes(name2)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name2), key2]
        })
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
async function getEnsAvatar(client2, { blockNumber, blockTag, assetGatewayUrls, name: name2, gatewayUrls, strict, universalResolverAddress }) {
  const record = await getAction$1(client2, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name: name2,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client2, {
      record,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}
async function getEnsName(client2, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex$1(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract, "readContract");
    const [name2, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name2;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}
async function getEnsResolver(client2, { blockNumber, blockTag, name: name2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction$1(client2, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex$1(packetToBytes(name2))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}
function createFilterRequestScope(client2, { method }) {
  var _a2, _b2;
  const requestMap = {};
  if (client2.transport.type === "fallback")
    (_b2 = (_a2 = client2.transport).onResponse) == null ? void 0 : _b2.call(_a2, ({ method: method_, response: id2, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id2] = transport.request;
    });
  return (id2) => requestMap[id2] || client2.request;
}
async function createBlockFilter(client2) {
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newBlockFilter"
  });
  const id2 = await client2.request({
    method: "eth_newBlockFilter"
  });
  return { id: id2, request: getRequest(id2), type: "block" };
}
class FilterTypeNotSupportedError extends BaseError$2 {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
}
const docsPath$1 = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  var _a2;
  const { abi: abi2, eventName, args } = parameters;
  let abiItem = abi2[0];
  if (eventName) {
    const item2 = getAbiItem({ abi: abi2, name: eventName });
    if (!item2)
      throw new AbiEventNotFoundError(eventName, { docsPath: docsPath$1 });
    abiItem = item2;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath: docsPath$1 });
  const definition = formatAbiItem$1(abiItem);
  const signature2 = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = (_a2 = abiItem.inputs) == null ? void 0 : _a2.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x) => args[x.name])) ?? [] : [];
    if (args_.length > 0) {
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j2) => encodeArg({ param, value: args_[i][j2] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null)) ?? [];
    }
  }
  return [signature2, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes$1(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}
async function createContractEventFilter(client2, parameters) {
  const { address, abi: abi2, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi: abi2,
    args,
    eventName
  }) : void 0;
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi2,
    args,
    eventName,
    id: id2,
    request: getRequest(id2),
    strict: Boolean(strict),
    type: "event"
  };
}
async function createEventFilter(client2, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id2 = await client2.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id: id2,
    request: getRequest(id2),
    strict: Boolean(strict),
    toBlock,
    type: "event"
  };
}
async function createPendingTransactionFilter(client2) {
  const getRequest = createFilterRequestScope(client2, {
    method: "eth_newPendingTransactionFilter"
  });
  const id2 = await client2.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id2, request: getRequest(id2), type: "transaction" };
}
async function estimateContractGas(client2, parameters) {
  const { abi: abi2, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  try {
    const gas = await getAction$1(client2, estimateGas, "estimateGas")({
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account2 = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account2 == null ? void 0 : account2.address
    });
  }
}
async function getBalance(client2, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client2.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}
async function getBlobBaseFee(client2) {
  const baseFee = await client2.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}
const promiseCache = /* @__PURE__ */ new Map();
const responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data) => cache.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: /* @__PURE__ */ new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}
const cacheKey = (id2) => `blockNumber.${id2}`;
async function getBlockNumber(client2, { cacheTime = client2.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client2.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client2.uid), cacheTime });
  return BigInt(blockNumberHex);
}
async function getBlockTransactionCount(client2, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count2;
  if (blockHash) {
    count2 = await client2.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count2 = await client2.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber$1(count2);
}
async function getBytecode(client2, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex2 = await client2.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  });
  if (hex2 === "0x")
    return void 0;
  return hex2;
}
const docsPath = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi: abi2, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature2, ...argTopics] = topics;
  if (!signature2)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath });
  const abiItem = abi2.find((x) => x.type === "event" && signature2 === toEventSelector(formatAbiItem$1(x)));
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature2, { docsPath });
  const { name: name2, inputs } = abiItem;
  const isUnnamed = inputs == null ? void 0 : inputs.some((x) => !("name" in x && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size$5(data)
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name2,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}
function parseEventLogs({ abi: abi2, eventName, logs, strict = true }) {
  return logs.map((log) => {
    var _a2;
    try {
      const event = decodeEventLog({
        ...log,
        abi: abi2,
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      return { ...event, ...log };
    } catch (err) {
      let eventName2;
      let isUnnamed;
      if (err instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err.abiItem.name;
        isUnnamed = (_a2 = err.abiItem.inputs) == null ? void 0 : _a2.some((x) => !("name" in x && x.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
async function getLogs(client2, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client2.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    logs: formattedLogs,
    strict
  });
}
async function getContractEvents(client2, parameters) {
  const { abi: abi2, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi: abi2, name: eventName }) : void 0;
  const events = !event ? abi2.filter((x) => x.type === "event") : void 0;
  return getAction$1(client2, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}
function formatFeeHistory(feeHistory) {
  var _a2;
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: (_a2 = feeHistory.reward) == null ? void 0 : _a2.map((reward) => reward.map((value) => BigInt(value)))
  };
}
async function getFeeHistory(client2, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client2.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory(feeHistory);
}
async function getFilterChanges(_client3, { filter: filter2 }) {
  const strict = "strict" in filter2 && filter2.strict;
  const logs = await filter2.request({
    method: "eth_getFilterChanges",
    params: [filter2.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter2) || !filter2.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter2.abi,
    logs: formattedLogs,
    strict
  });
}
async function getFilterLogs(_client3, { filter: filter2 }) {
  const strict = filter2.strict ?? false;
  const logs = await filter2.request({
    method: "eth_getFilterLogs",
    params: [filter2.id]
  });
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!filter2.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter2.abi,
    logs: formattedLogs,
    strict
  });
}
async function getStorageAt(client2, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client2.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}
async function getTransaction(client2, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  var _a2, _b2, _c2;
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction2 = null;
  if (hash2) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    });
  } else if (blockHash) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction2 = await client2.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    });
  }
  if (!transaction2)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.transaction) == null ? void 0 : _c2.format) || formatTransaction;
  return format2(transaction2);
}
async function getTransactionConfirmations(client2, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction2] = await Promise.all([
    getAction$1(client2, getBlockNumber, "getBlockNumber")({}),
    hash2 ? getAction$1(client2, getTransaction, "getBlockNumber")({ hash: hash2 }) : void 0
  ]);
  const transactionBlockNumber = (transactionReceipt == null ? void 0 : transactionReceipt.blockNumber) || (transaction2 == null ? void 0 : transaction2.blockNumber);
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber$1(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
async function getTransactionReceipt$1(client2, { hash: hash2 }) {
  var _a2, _b2, _c2;
  const receipt = await client2.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.transactionReceipt) == null ? void 0 : _c2.format) || formatTransactionReceipt;
  return format2(receipt);
}
async function multicall(client2, parameters) {
  var _a2;
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof ((_a2 = client2.batch) == null ? void 0 : _a2.multicall) === "object" && client2.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client2.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client2.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0; i < contracts.length; i++) {
    const { abi: abi2, address, args, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({ abi: abi2, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (
        // Check if batching is enabled.
        batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
        currentChunkSize > batchSize && // Check if the current chunk is not already empty.
        chunkedCalls[currentChunk].length > 0
      ) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction$1(client2, readContract, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results2 = [];
  for (let i = 0; i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j2 = 0; j2 < chunkedCalls[i].length; j2++) {
        results2.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j2 = 0; j2 < aggregate3Result.length; j2++) {
      const { returnData, success } = aggregate3Result[j2];
      const { callData } = chunkedCalls[i][j2];
      const { abi: abi2, address, functionName, args } = contracts[results2.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi2,
          args,
          data: returnData,
          functionName
        });
        results2.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi: abi2,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results2.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results2.length !== contracts.length)
    throw new BaseError$2("multicall results mismatch");
  return results2;
}
const listenersCache = /* @__PURE__ */ new Map();
const cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb2) => cb2.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key2 in callbacks) {
    emit[key2] = (...args) => {
      var _a2, _b2;
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        (_b2 = (_a2 = listener.fns)[key2]) == null ? void 0 : _b2.call(_a2, ...args);
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
async function wait(time2) {
  return new Promise((res) => setTimeout(res, time2));
}
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = void 0;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await (initialWaitTime == null ? void 0 : initialWaitTime(data)) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}
function watchBlocks(client2, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client2.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      var _a2;
      try {
        const block = await getAction$1(client2, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number && (prevBlock == null ? void 0 : prevBlock.number)) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = (prevBlock == null ? void 0 : prevBlock.number) + 1n; i < block.number; i++) {
              const block2 = await getAction$1(client2, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (
          // If no previous block exists, emit.
          !(prevBlock == null ? void 0 : prevBlock.number) || // If the block tag is "pending" with no block number, emit.
          blockTag === "pending" && !(block == null ? void 0 : block.number) || // If the next block number is greater than the previous block number, emit.
          // We don't want to emit blocks in the past.
          block.number && block.number > prevBlock.number
        ) {
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err) {
        (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const transport = (() => {
          if (client2.transport.type === "fallback") {
            const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client2.transport;
            return transport2.value;
          }
          return client2.transport;
        })();
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            var _a2, _b2, _c2;
            if (!active)
              return;
            const format2 = ((_c2 = (_b2 = (_a2 = client2.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b2.block) == null ? void 0 : _c2.format) || formatBlock;
            const block = format2(data.result);
            onBlock(block, prevBlock);
            prevBlock = block;
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError == null ? void 0 : onError(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}
function watchBlockNumber(client2, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      var _a2;
      try {
        const blockNumber = await getAction$1(client2, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client2.transport.type === "fallback") {
              const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client2.transport;
              return transport2.value;
            }
            return client2.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              var _a2;
              if (!active)
                return;
              const blockNumber = hexToBigInt((_a2 = data.result) == null ? void 0 : _a2.number);
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              var _a2;
              (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError == null ? void 0 : onError(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
async function uninstallFilter(_client3, { filter: filter2 }) {
  return filter2.request({
    method: "eth_uninstallFilter",
    params: [filter2.id]
  });
}
function watchEvent(client2, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client2.uid,
      event,
      pollingInterval,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        var _a2;
        if (!initialized) {
          try {
            filter2 = await getAction$1(client2, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction$1(client2, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction$1(client2, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction$1(client2, getLogs, "getLogs")({
                address,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError)
            initialized = false;
          (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$1(client2, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const transport = (() => {
          if (client2.transport.type === "fallback") {
            const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client2.transport;
            return transport2.value;
          }
          return client2.transport;
        })();
        const events_ = events ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          topics = [
            events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }))
          ];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            var _a2;
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_ ?? [],
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, { args: args2, eventName });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = (_a2 = err.abiItem.inputs) == null ? void 0 : _a2.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError == null ? void 0 : onError(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
function watchPendingTransactions(client2, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client2.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client2.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter2;
      const unwatch = poll(async () => {
        var _a2;
        try {
          if (!filter2) {
            try {
              filter2 = await getAction$1(client2, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction$1(client2, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit.onTransactions([hash2]);
        } catch (err) {
          (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$1(client2, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client2.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction2 = data.result;
            onTransactions([transaction2]);
          },
          onError(error) {
            onError == null ? void 0 : onError(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError == null ? void 0 : onError(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}
async function getAddresses(client2) {
  var _a2;
  if (((_a2 = client2.account) == null ? void 0 : _a2.type) === "local")
    return [client2.account.address];
  const addresses = await client2.request({ method: "eth_accounts" });
  return addresses.map((address) => checksumAddress(address));
}
async function getPermissions(client2) {
  const permissions = await client2.request({ method: "wallet_getPermissions" });
  return permissions;
}
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count: count2 = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count: count2, error }) : delay_;
        if (delay2)
          await wait(delay2);
        attemptRetry({ count: count2 + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count2 < retryCount && await shouldRetry2({ count: count2, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { retryDelay = 150, retryCount = 3 } = {
      ...options,
      ...overrideOptions
    };
    return withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err);
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err);
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case 5e3:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError$2)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count: count2, error }) => {
        var _a2;
        if (error && error instanceof HttpRequestError) {
          const retryAfter = (_a2 = error == null ? void 0 : error.headers) == null ? void 0 : _a2.get("Retry-After");
          if (retryAfter == null ? void 0 : retryAfter.match(/\d/))
            return Number.parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count2) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}
function isAddressEqual(a2, b2) {
  if (!isAddress(a2, { strict: false }))
    throw new InvalidAddressError({ address: a2 });
  if (!isAddress(b2, { strict: false }))
    throw new InvalidAddressError({ address: b2 });
  return a2.toLowerCase() === b2.toLowerCase();
}
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: (controller == null ? void 0 : controller.signal) || null }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      var _a2;
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init3 = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              ...headers,
              "Content-Type": "application/json"
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init3);
          if (onRequest)
            await onRequest(request);
          const response2 = await fetch(url, init3);
          return response2;
        }, {
          errorInstance: new TimeoutError3({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if ((_a2 = response.headers.get("Content-Type")) == null ? void 0 : _a2.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          data = JSON.parse(data || "{}");
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError3)
          throw err;
        throw new HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
  };
}
function webSocket(socketClient, { body, onError, onResponse }) {
  socketClient.request({
    body,
    onError,
    onResponse
  });
  return socketClient;
}
async function webSocketAsync(socketClient, { body, timeout = 1e4 }) {
  return socketClient.requestAsync({
    body,
    timeout
  });
}
const rpc = {
  /**
   * @deprecated use `getHttpRpcClient` instead.
   *
   * ```diff
   * -import { rpc } from 'viem/utils'
   * +import { getHttpRpcClient } from 'viem/utils'
   *
   * -rpc.http(url, params)
   * +const httpClient = getHttpRpcClient(url)
   * +httpClient.request(params)
   * ```
   */
  http(url, params) {
    return getHttpRpcClient(url).request(params);
  },
  /**
   * @deprecated use `getWebSocketRpcClient` instead.
   *
   * ```diff
   * -import { rpc } from 'viem/utils'
   * +import { getWebSocketRpcClient } from 'viem/utils'
   *
   * -rpc.webSocket(url, params)
   * +const webSocketClient = getWebSocketRpcClient(url)
   * +webSocketClient.request(params)
   * ```
   */
  webSocket,
  /**
   * @deprecated use `getWebSocketRpcClient` instead.
   *
   * ```diff
   * -import { rpc } from 'viem/utils'
   * +import { getWebSocketRpcClient } from 'viem/utils'
   *
   * -const response = await rpc.webSocketAsync(url, params)
   * +const webSocketClient = getWebSocketRpcClient(url)
   * +const response = await webSocketClient.requestAsync(params)
   * ```
   */
  webSocketAsync
};
function hashTypedData(parameters) {
  const { domain: domain2 = {}, message, primaryType } = parameters;
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain: domain2 }),
    ...parameters.types
  };
  validateTypedData({
    domain: domain2,
    message,
    primaryType,
    types: types2
  });
  const parts = ["0x1901"];
  if (domain2)
    parts.push(hashDomain({
      domain: domain2,
      types: types2
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types: types2
    }));
  return keccak256(concat(parts));
}
function hashDomain({ domain: domain2, types: types2 }) {
  return hashStruct({
    data: domain2,
    primaryType: "EIP712Domain",
    types: types2
  });
}
function hashStruct({ data, primaryType, types: types2 }) {
  const encoded = encodeData({
    data,
    primaryType,
    types: types2
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types: types2 }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types: types2 })];
  for (const field of types2[primaryType]) {
    const [type, value] = encodeField({
      types: types2,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types: types2 }) {
  const encodedHashType = toHex$1(encodeType({ primaryType, types: types2 }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types: types2 }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types: types2 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types2[type].map(({ name: name2, type: t2 }) => `${t2} ${name2}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types: types2 }, results2 = /* @__PURE__ */ new Set()) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match == null ? void 0 : match[0];
  if (results2.has(primaryType) || types2[primaryType] === void 0) {
    return results2;
  }
  results2.add(primaryType);
  for (const field of types2[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types: types2 }, results2);
  }
  return results2;
}
function encodeField({ types: types2, name: name2, type, value }) {
  if (types2[type] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types: types2 }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex$1(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item2) => encodeField({
      name: name2,
      type: parsedType,
      types: types2,
      value: item2
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v3]) => v3)))
    ];
  }
  return [{ type }, value];
}
function validateTypedData(parameters) {
  const { domain: domain2, message, primaryType, types: types2 } = parameters;
  const validateData = (struct, data) => {
    for (const param of struct) {
      const { name: name2, type } = param;
      const value = data[name2];
      const integerMatch = type.match(integerRegex);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base2, size_] = integerMatch;
        numberToHex(value, {
          signed: base2 === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size$5(value) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size$5(value)
          });
      }
      const struct2 = types2[type];
      if (struct2)
        validateData(struct2, value);
    }
  };
  if (types2.EIP712Domain && domain2)
    validateData(types2.EIP712Domain, domain2);
  if (primaryType !== "EIP712Domain") {
    const type = types2[primaryType];
    validateData(type, message);
  }
}
function getTypesForEIP712Domain({ domain: domain2 }) {
  return [
    typeof (domain2 == null ? void 0 : domain2.name) === "string" && { name: "name", type: "string" },
    (domain2 == null ? void 0 : domain2.version) && { name: "version", type: "string" },
    typeof (domain2 == null ? void 0 : domain2.chainId) === "number" && {
      name: "chainId",
      type: "uint256"
    },
    (domain2 == null ? void 0 : domain2.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain2 == null ? void 0 : domain2.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const presignMessagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return stringToBytes(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return toBytes$1(message.raw);
  })();
  const prefixBytes = stringToBytes(`${presignMessagePrefix}${messageBytes.length}`);
  return keccak256(concat([prefixBytes, messageBytes]), to_);
}
function parseUnits(value, decimals) {
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : void 0,
    nonce: proof.nonce ? hexToNumber$1(proof.nonce) : void 0,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
  };
}
async function getProof(client2, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof = await client2.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}
async function waitForTransactionReceipt(client2, {
  confirmations = 1,
  hash: hash2,
  onReplaced,
  pollingInterval = client2.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count: count2 }) => ~~(1 << count2) * 200,
  // exponential backoff
  timeout
}) {
  const observerId = stringify(["waitForTransactionReceipt", client2.uid, hash2]);
  let count2 = 0;
  let transaction2;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
      const _unwatch = getAction$1(client2, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          let blockNumber = blockNumber_;
          if (retrying)
            return;
          if (count2 > retryCount)
            done(() => emit.reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })));
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit.resolve(receipt));
              return;
            }
            if (!transaction2) {
              retrying = true;
              await withRetry(async () => {
                transaction2 = await getAction$1(client2, getTransaction, "getTransaction")({ hash: hash2 });
                if (transaction2.blockNumber)
                  blockNumber = transaction2.blockNumber;
              }, {
                delay: retryDelay,
                retryCount
              });
              retrying = false;
            }
            receipt = await getAction$1(client2, getTransactionReceipt$1, "getTransactionReceipt")({ hash: hash2 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
          } catch (err) {
            if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
              if (!transaction2) {
                retrying = false;
                return;
              }
              try {
                replacedTransaction = transaction2;
                retrying = true;
                const block = await withRetry(() => getAction$1(client2, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: retryDelay,
                  retryCount,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction$1(client2, getTransactionReceipt$1, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  var _a2;
                  (_a2 = emit.onReplaced) == null ? void 0 : _a2.call(emit, {
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit.reject(err_));
              }
            } else {
              done(() => emit.reject(err));
            }
          } finally {
            count2++;
          }
        }
      });
    });
  });
}
async function requestAddresses(client2) {
  const addresses = await client2.request({ method: "eth_requestAccounts" }, { retryCount: 0 });
  return addresses.map((address) => getAddress(address));
}
async function requestPermissions(client2, permissions) {
  return client2.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  }, { retryCount: 0 });
}
async function signTransaction(client2, parameters) {
  var _a2, _b2, _c2, _d2;
  const { account: account_ = client2.account, chain = client2.chain, ...transaction2 } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account2 = parseAccount(account_);
  assertRequest({
    account: account2,
    ...parameters
  });
  const chainId = await getAction$1(client2, getChainId$1, "getChainId")({});
  if (chain !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain
    });
  const formatters = (chain == null ? void 0 : chain.formatters) || ((_a2 = client2.chain) == null ? void 0 : _a2.formatters);
  const format2 = ((_b2 = formatters == null ? void 0 : formatters.transactionRequest) == null ? void 0 : _b2.format) || formatTransactionRequest;
  if (account2.type === "local") {
    return account2.signTransaction({
      ...transaction2,
      chainId
    }, { serializer: (_d2 = (_c2 = client2.chain) == null ? void 0 : _c2.serializers) == null ? void 0 : _d2.transaction });
  }
  return await client2.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format2(transaction2),
        chainId: numberToHex(chainId),
        from: account2.address
      }
    ]
  }, { retryCount: 0 });
}
async function signMessage$1(client2, { account: account_ = client2.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account2 = parseAccount(account_);
  if (account2.type === "local")
    return account2.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex$1(message.raw);
    return message.raw;
  })();
  return client2.request({
    method: "personal_sign",
    params: [message_, account2.address]
  }, { retryCount: 0 });
}
async function signTypedData(client2, parameters) {
  const { account: account_ = client2.account, domain: domain2, message, primaryType } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account2 = parseAccount(account_);
  const types2 = {
    EIP712Domain: getTypesForEIP712Domain({ domain: domain2 }),
    ...parameters.types
  };
  validateTypedData({ domain: domain2, message, primaryType, types: types2 });
  if (account2.type === "local")
    return account2.signTypedData({ domain: domain2, message, primaryType, types: types2 });
  const typedData = stringify({ domain: domain2 ?? {}, message, primaryType, types: types2 }, (_, value) => isHex(value) ? value.toLowerCase() : value);
  return client2.request({
    method: "eth_signTypedData_v4",
    params: [account2.address, typedData]
  }, { retryCount: 0 });
}
async function simulateContract$1(client2, parameters) {
  const { abi: abi2, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account2 = callRequest.account ? parseAccount(callRequest.account) : client2.account;
  const calldata = encodeFunctionData({ abi: abi2, args, functionName });
  try {
    const { data } = await getAction$1(client2, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account: account2
    });
    const result = decodeFunctionResult({
      abi: abi2,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi2.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account: account2
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi: abi2,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account2 == null ? void 0 : account2.address
    });
  }
}
async function switchChain$1(client2, { id: id2 }) {
  await client2.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id2)
      }
    ]
  }, { retryCount: 0 });
}
const universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a2) => a2 instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes3) {
  if (!u8a(bytes3))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex2 += hexes[bytes3[i]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len = hex2.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j2 = i * 2;
    const hexByte = hex2.slice(j2, j2 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  if (!u8a(bytes3))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e2}`);
    }
  } else if (u8a(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad3 = 0;
  arrays.forEach((a2) => {
    if (!u8a(a2))
      throw new Error("Uint8Array expected");
    r2.set(a2, pad3);
    pad3 += a2.length;
  });
  return r2;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$3; n2 >>= _1n$4, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$4;
}
const bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
};
const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v3 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v3.fill(1);
    k2.fill(0);
    i = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v3, ...b2);
  const reseed2 = (seed = u8n()) => {
    k2 = h2(u8fr([0]), seed);
    v3 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr([1]), seed);
    v3 = h2();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v3 = h2();
      const sl2 = v3.slice();
      out.push(sl2);
      len += v3.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed2(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed2();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
function isBytesEqual(a_, b_) {
  const a2 = isHex(a_) ? toBytes$1(a_) : a_;
  const b2 = isHex(b_) ? toBytes$1(b_) : b_;
  return equalBytes(a2, b2);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a2, b2) {
  const result = a2 % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod(number2, modulo);
  let b2 = modulo;
  let x = _0n$2, u2 = _1n$3;
  while (a2 !== _0n$2) {
    const q2 = b2 / a2;
    const r2 = b2 % a2;
    const m2 = x - u2 * q2;
    b2 = a2, a2 = r2, x = u2, u2 = m2;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n$3) / _2n$1;
  let Q2, S2, Z2;
  for (Q2 = P2 - _1n$3, S2 = 0; Q2 % _2n$1 === _0n$2; Q2 /= _2n$1, S2++)
    ;
  for (Z2 = _2n$1; Z2 < P2 && pow(Z2, legendreC, P2) !== P2 - _1n$3; Z2++)
    ;
  if (S2 === 1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  const Q1div2 = (Q2 + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z2), Q2);
    let x = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b2); m2 < r2; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g2, _1n$3 << BigInt(r2 - m2 - 1));
      g2 = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b2 = Fp2.mul(b2, g2);
      r2 = m2;
    }
    return x;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n$1) {
    const p1div4 = (P2 + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root2 = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$1);
      const v3 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v3);
      const i = Fp2.mul(Fp2.mul(nv, _2n$1), v3);
      const root2 = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root2), n2))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  return tonelliShanks(P2);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p2 = f2.ONE;
  let d2 = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p2 = f2.mul(p2, d2);
    d2 = f2.sqr(d2);
    power >>= _1n$3;
  }
  return p2;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE2 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key2, fieldOrder, isLE2 = false) {
  const len = key2.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key2) : bytesToNumberLE(key2);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c2, bits) {
  const constTimeNegate = (condition, item2) => {
    const neg3 = item2.negate();
    return condition ? neg3 : item2;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p2 = c2.ZERO;
      let d2 = elm;
      while (n2 > _0n$1) {
        if (n2 & _1n$2)
          p2 = p2.add(d2);
        d2 = d2.double();
        n2 >>= _1n$2;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base2 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p2;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p2);
          points.push(base2);
        }
        p2 = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n2) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f2 = c2.BASE;
      const mask = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset2 = window2 * windowSize;
        let wbits = Number(n2 & mask);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$2;
        }
        const offset1 = offset2;
        const offset22 = offset2 + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset22]));
        }
      }
      return { p: p2, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n2, transform) {
      const W2 = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E2 } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l2 = data.length;
    if (l2 < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r2, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r2, s: s2 };
  },
  hexFromSig(sig) {
    const slice2 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h2 = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s2 = slice2(h2(sig.s));
    const r2 = slice2(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r2.length / 2;
    const sl2 = h2(shl);
    const rl2 = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s2}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point3, _isCompressed) => {
    const a2 = point3.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y: y2 };
  });
  function weierstrassEquation(x) {
    const { a: a2, b: b2 } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a2)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key2) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key2 !== "bigint") {
      if (key2 instanceof Uint8Array)
        key2 = bytesToHex(key2);
      if (typeof key2 !== "string" || !lengths.includes(key2.length))
        throw new Error("Invalid key");
      key2 = key2.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key2 === "bigint" ? key2 : bytesToNumberBE(ensureBytes("private key", key2, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key2}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px2, py, pz) {
      this.px = px2;
      this.py = py;
      this.pz = pz;
      if (px2 == null || !Fp2.isValid(px2))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x, y: y2 } = p2 || {};
      if (!p2 || !Fp2.isValid(x) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y2))
        return Point2.ZERO;
      return new Point2(x, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i) => p2.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P2 = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y: y2 } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i) => p2.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I2 = Point2.ZERO;
      if (n2 === _0n)
        return I2;
      assertGE(n2);
      if (n2 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I2;
      let k2p = I2;
      let d2 = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d2);
        if (k2 & _1n$1)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point3, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point3 = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(n2);
        point3 = p2;
        fake = f2;
      }
      return Point2.normalizeZ([point3, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G2 = Point2.BASE;
      const mul3 = (P2, a3) => a3 === _0n || a3 === _1n$1 || !P2.equals(G2) ? P2.multiplyUnsafe(a3) : P2.multiply(a3);
      const sum = mul3(this, a2).add(mul3(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y2, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a2) {
    return mod(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point3, isCompressed) {
      const a2 = point3.toAffine();
      const x = Fp2.toBytes(a2.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point3.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y3 = Fp2.sqrt(y2);
        const isYOdd = (y3 & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y: y2 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r2, s2, recovery) {
      this.r = r2;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l2 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l2 * 2);
      return new Signature2(slcNum(hex2, 0, l2), slcNum(hex2, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r2, s: s2 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature2(r2, s2);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q2 = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point3 = Point2.BASE) {
      point3._setWindowSize(windowSize);
      point3.multiply(BigInt(3));
      return point3;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item2) {
    const arr = item2 instanceof Uint8Array;
    const str = typeof item2 === "string";
    const len = (arr || str) && item2.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item2 instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point2.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null) {
      const e2 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik2 = invN(k2);
      const q2 = Point2.BASE.multiply(k2).toAffine();
      const r2 = modN(q2.x);
      if (r2 === _0n)
        return;
      const s2 = modN(ik2 * modN(m2 + r2 * d2));
      if (s2 === _0n)
        return;
      let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n$1);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign3(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify3(signature2, msgHash, publicKey, opts = defaultVerOpts) {
    var _a2;
    const sg2 = signature2;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P2;
    try {
      if (typeof sg2 === "string" || sg2 instanceof Uint8Array) {
        try {
          _sig = Signature2.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature2.fromCompact(sg2);
        }
      } else if (typeof sg2 === "object" && typeof sg2.r === "bigint" && typeof sg2.s === "bigint") {
        const { r: r3, s: s3 } = sg2;
        _sig = new Signature2(r3, s3);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s2);
    const u1 = modN(h2 * is);
    const u2 = modN(r2 * is);
    const R2 = (_a2 = Point2.BASE.multiplyAndAddUnsafe(P2, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R2)
      return false;
    const v3 = modN(R2.x);
    return v3 === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign3,
    verify: verify3,
    ProjectivePoint: Point2,
    Signature: Signature2,
    utils: utils2
  };
}
class HMAC extends Hash2 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash$1(hash2);
    const key2 = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key2.length > blockLen ? hash2.create().update(key2).digest() : key2);
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash2.create();
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54 ^ 92;
    this.oHash.update(pad3);
    pad3.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac$1 = (hash2, key2, message) => new HMAC(hash2, key2).update(message).digest();
hmac$1.create = (hash2, key2) => new HMAC(hash2, key2);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key2, ...msgs) => hmac$1(hash2, key2, concatBytes$1(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a2, b2) => (a2 + b2 / _2n) / b2;
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root2 = pow2(t2, _2n, P2);
  if (!Fp.eql(Fp.sqr(root2), y2))
    throw new Error("Cannot find square root");
  return root2;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k2, n2);
      const c2 = divNearest(-b1 * k2, n2);
      let k1 = mod(k2 - c1 * a1 - c2 * a2, n2);
      let k22 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k22 = n2 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
function serializeSignature({ r: r2, s: s2, v: v3, yParity }) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v3 && (v3 === 27n || v3 === 28n || v3 >= 35n))
      return v3 % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  return `0x${new secp256k1.Signature(hexToBigInt(r2), hexToBigInt(s2)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
}
async function verifyHash(client2, { address, hash: hash2, signature: signature2, ...callRequest }) {
  const signatureHex = (() => {
    if (isHex(signature2))
      return signature2;
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2)
      return serializeSignature(signature2);
    return bytesToHex$1(signature2);
  })();
  try {
    const { data } = await getAction$1(client2, call, "call")({
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash2, signatureHex],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...callRequest
    });
    return isBytesEqual(data ?? "0x0", "0x1");
  } catch (error) {
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}
async function verifyMessage(client2, { address, message, signature: signature2, ...callRequest }) {
  const hash2 = hashMessage(message);
  return verifyHash(client2, {
    address,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
async function verifyTypedData(client2, parameters) {
  const { address, signature: signature2, message, primaryType, types: types2, domain: domain2, ...callRequest } = parameters;
  const hash2 = hashTypedData({ message, primaryType, types: types2, domain: domain2 });
  return verifyHash(client2, {
    address,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
async function watchAsset(client2, params) {
  const added = await client2.request({
    method: "wallet_watchAsset",
    params
  }, { retryCount: 0 });
  return added;
}
function watchContractEvent(client2, parameters) {
  const { abi: abi2, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client2.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client2.transport.type === "webSocket")
      return false;
    if (client2.transport.type === "fallback" && client2.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client2.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        var _a2;
        if (!initialized) {
          try {
            filter2 = await getAction$1(client2, createContractEventFilter, "createContractEventFilter")({
              abi: abi2,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getAction$1(client2, getFilterChanges, "getFilterChanges")({ filter: filter2 });
          } else {
            const blockNumber = await getAction$1(client2, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction$1(client2, getContractEvents, "getContractEvents")({
                abi: abi2,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter2 && err instanceof InvalidInputRpcError)
            initialized = false;
          (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await getAction$1(client2, uninstallFilter, "uninstallFilter")({ filter: filter2 });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client2.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      (async () => {
        try {
          const transport = (() => {
            if (client2.transport.type === "fallback") {
              const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client2.transport;
              return transport2.value;
            }
            return client2.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi: abi2,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              var _a2;
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi: abi2,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (err) {
                let eventName2;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err.abiItem.name;
                  isUnnamed = (_a2 = err.abiItem.inputs) == null ? void 0 : _a2.some((x) => !("name" in x && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              var _a2;
              (_a2 = emit.onError) == null ? void 0 : _a2.call(emit, error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError == null ? void 0 : onError(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
async function writeContract$1(client2, parameters) {
  const { abi: abi2, address, args, dataSuffix, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi: abi2,
    args,
    functionName
  });
  return getAction$1(client2, sendTransaction$1, "sendTransaction")({
    data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address,
    ...request
  });
}
function requestProviders(listener) {
  const handler = (event) => listener(event.detail);
  window.addEventListener("eip6963:announceProvider", handler);
  window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
  return () => window.removeEventListener("eip6963:announceProvider", handler);
}
function createStore$1() {
  const listeners = /* @__PURE__ */ new Set();
  let providerDetails = [];
  const request = () => requestProviders((providerDetail) => {
    if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
      return;
    providerDetails = [...providerDetails, providerDetail];
    listeners.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
  });
  let unwatch = request();
  return {
    _listeners() {
      return listeners;
    },
    clear() {
      listeners.forEach((listener) => listener([], { removed: [...providerDetails] }));
      providerDetails = [];
    },
    destroy() {
      this.clear();
      listeners.clear();
      unwatch();
    },
    findProvider({ rdns }) {
      return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
    },
    getProviders() {
      return providerDetails;
    },
    reset() {
      this.clear();
      unwatch();
      unwatch = request();
    },
    subscribe(listener, { emitImmediately } = {}) {
      listeners.add(listener);
      if (emitImmediately)
        listener(providerDetails, { added: providerDetails });
      return () => listeners.delete(listener);
    }
  };
}
const size$4 = 256;
let index$2 = size$4;
let buffer$1;
function uid$1(length = 11) {
  if (!buffer$1 || index$2 + length > size$4 * 2) {
    buffer$1 = "";
    index$2 = 0;
    for (let i = 0; i < size$4; i++) {
      buffer$1 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$1.substring(index$2, index$2++ + length);
}
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, ccipRead, key: key2 = "base", name: name2 = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain = parameters.chain;
  const account2 = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config2, ...value };
  const client2 = {
    account: account2,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key: key2,
    name: name2,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid$1()
  };
  function extend(base2) {
    return (extendFn) => {
      const extended = extendFn(base2);
      for (const key3 in client2)
        delete extended[key3];
      const combined = { ...base2, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client2, { extend: extend(client2) });
}
function createTransport({ key: key2, name: name2, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  return {
    config: { key: key2, name: name2, request, retryCount, retryDelay, timeout, type },
    request: buildRequest(request, { retryCount, retryDelay }),
    value
  };
}
function custom(provider2, config2 = {}) {
  const { key: key2 = "custom", name: name2 = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key: key2,
    name: name2,
    request: provider2.request.bind(provider2),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
class UrlRequiredError extends BaseError$2 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}
function http(url, config2 = {}) {
  const { batch, fetchOptions, key: key2 = "http", name: name2 = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = chain == null ? void 0 : chain.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key: key2,
      name: name2,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a2, b2) => a2.id - b2.id
        });
        const fn = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
function parseSiweMessage(message) {
  var _a2, _b2, _c2;
  const { scheme, statement, ...prefix } = ((_a2 = message.match(prefixRegex)) == null ? void 0 : _a2.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b2 = message.match(suffixRegex)) == null ? void 0 : _b2.groups) ?? {};
  const resources = (_c2 = message.split("Resources:")[1]) == null ? void 0 : _c2.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
const prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
const suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function validateSiweMessage(parameters) {
  const { address, domain: domain2, message, nonce, scheme, time: time2 = /* @__PURE__ */ new Date() } = parameters;
  if (domain2 && message.domain !== domain2)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time2 >= message.expirationTime)
    return false;
  if (message.notBefore && time2 < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isAddressEqual(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}
async function verifySiweMessage(client2, parameters) {
  const { address, domain: domain2, message, nonce, scheme, signature: signature2, time: time2 = /* @__PURE__ */ new Date(), ...callRequest } = parameters;
  const parsed = parseSiweMessage(message);
  if (!parsed.address)
    return false;
  const isValid2 = validateSiweMessage({
    address,
    domain: domain2,
    message: parsed,
    nonce,
    scheme,
    time: time2
  });
  if (!isValid2)
    return false;
  const hash2 = hashMessage(message);
  return verifyHash(client2, {
    address: parsed.address,
    hash: hash2,
    signature: signature2,
    ...callRequest
  });
}
function publicActions(client2) {
  return {
    call: (args) => call(client2, args),
    createBlockFilter: () => createBlockFilter(client2),
    createContractEventFilter: (args) => createContractEventFilter(client2, args),
    createEventFilter: (args) => createEventFilter(client2, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client2),
    estimateContractGas: (args) => estimateContractGas(client2, args),
    estimateGas: (args) => estimateGas(client2, args),
    getBalance: (args) => getBalance(client2, args),
    getBlobBaseFee: () => getBlobBaseFee(client2),
    getBlock: (args) => getBlock(client2, args),
    getBlockNumber: (args) => getBlockNumber(client2, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client2, args),
    getBytecode: (args) => getBytecode(client2, args),
    getChainId: () => getChainId$1(client2),
    getContractEvents: (args) => getContractEvents(client2, args),
    getEnsAddress: (args) => getEnsAddress(client2, args),
    getEnsAvatar: (args) => getEnsAvatar(client2, args),
    getEnsName: (args) => getEnsName(client2, args),
    getEnsResolver: (args) => getEnsResolver(client2, args),
    getEnsText: (args) => getEnsText(client2, args),
    getFeeHistory: (args) => getFeeHistory(client2, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client2, args),
    getFilterChanges: (args) => getFilterChanges(client2, args),
    getFilterLogs: (args) => getFilterLogs(client2, args),
    getGasPrice: () => getGasPrice(client2),
    getLogs: (args) => getLogs(client2, args),
    getProof: (args) => getProof(client2, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client2, args),
    getStorageAt: (args) => getStorageAt(client2, args),
    getTransaction: (args) => getTransaction(client2, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client2, args),
    getTransactionCount: (args) => getTransactionCount(client2, args),
    getTransactionReceipt: (args) => getTransactionReceipt$1(client2, args),
    multicall: (args) => multicall(client2, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client2, args),
    readContract: (args) => readContract(client2, args),
    sendRawTransaction: (args) => sendRawTransaction(client2, args),
    simulateContract: (args) => simulateContract$1(client2, args),
    verifyMessage: (args) => verifyMessage(client2, args),
    verifySiweMessage: (args) => verifySiweMessage(client2, args),
    verifyTypedData: (args) => verifyTypedData(client2, args),
    uninstallFilter: (args) => uninstallFilter(client2, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client2, args),
    watchBlocks: (args) => watchBlocks(client2, args),
    watchBlockNumber: (args) => watchBlockNumber(client2, args),
    watchContractEvent: (args) => watchContractEvent(client2, args),
    watchEvent: (args) => watchEvent(client2, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client2, args)
  };
}
function walletActions(client2) {
  return {
    addChain: (args) => addChain(client2, args),
    deployContract: (args) => deployContract(client2, args),
    getAddresses: () => getAddresses(client2),
    getChainId: () => getChainId$1(client2),
    getPermissions: () => getPermissions(client2),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client2, args),
    requestAddresses: () => requestAddresses(client2),
    requestPermissions: (args) => requestPermissions(client2, args),
    sendRawTransaction: (args) => sendRawTransaction(client2, args),
    sendTransaction: (args) => sendTransaction$1(client2, args),
    signMessage: (args) => signMessage$1(client2, args),
    signTransaction: (args) => signTransaction(client2, args),
    signTypedData: (args) => signTypedData(client2, args),
    switchChain: (args) => switchChain$1(client2, args),
    watchAsset: (args) => watchAsset(client2, args),
    writeContract: (args) => writeContract$1(client2, args)
  };
}
const zeroAddress = "0x0000000000000000000000000000000000000000";
var define_import_meta_env_default$1 = { BASE_URL: "./", MODE: "production", DEV: false, PROD: true, SSR: false };
const subscribeWithSelectorImpl = (fn) => (set, get2, api2) => {
  const origSubscribe = api2.subscribe;
  api2.subscribe = (selector2, optListener, options) => {
    let listener = selector2;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector2(api2.getState());
      listener = (state) => {
        const nextSlice = selector2(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get2, api2);
  return initialState;
};
const subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name2) => {
      var _a2;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0);
      };
      const str = (_a2 = storage.getItem(name2)) != null ? _a2 : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name2, newValue) => storage.setItem(
      name2,
      JSON.stringify(newValue, void 0)
    ),
    removeItem: (name2) => storage.removeItem(name2)
  };
  return persistStorage;
}
const toThenable = (fn) => (input2) => {
  try {
    const result = fn(input2);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const oldImpl = (config2, baseOptions) => (set, get2, api2) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e2) {
  }
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get2,
      api2
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get2() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e2) => {
      errorInSync = e2;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api2.setState;
  api2.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get2,
    api2
  );
  let stateFromStorage;
  const hydrate2 = () => {
    var _a2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => cb2(get2()));
    const postRehydrationCallback = ((_a2 = options.onRehydrateStorage) == null ? void 0 : _a2.call(options, get2())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get2()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api2.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  hydrate2();
  return stateFromStorage || configResult;
};
const newImpl = (config2, baseOptions) => (set, get2, api2) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get2,
      api2
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get2() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api2.setState;
  api2.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get2,
    api2
  );
  let stateFromStorage;
  const hydrate2 = () => {
    var _a2, _b2;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => {
      var _a22;
      return cb2((_a22 = get2()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b2 = options.onRehydrateStorage) == null ? void 0 : _b2.call(options, (_a2 = get2()) != null ? _a2 : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a22;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get2()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get2();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api2.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate2();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config2, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if ((define_import_meta_env_default$1 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config2, baseOptions);
  }
  return newImpl(config2, baseOptions);
};
const persist = persistImpl;
var define_import_meta_env_default = { BASE_URL: "./", MODE: "production", DEV: false, PROD: true, SSR: false };
const createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((define_import_meta_env_default ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api2 = { setState, getState: getState2, subscribe, destroy };
  state = createState2(setState, getState2, api2);
  return api2;
};
const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
var eventemitter3 = { exports: {} };
(function(module2) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context2, once) {
    this.fn = fn;
    this.context = context2;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context2, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names2 = [], events, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events = this._events) {
      if (has.call(events, name2))
        names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j2;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context2) {
    return addListener(this, event, fn, context2, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context2) {
    return addListener(this, event, fn, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports);
class Emitter {
  constructor(uid2) {
    Object.defineProperty(this, "uid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: uid2
    });
    Object.defineProperty(this, "_emitter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new EventEmitter()
    });
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, ...params) {
    const data = params[0];
    this._emitter.emit(eventName, { uid: this.uid, ...data });
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
}
function createEmitter(uid2) {
  return new Emitter(uid2);
}
function deserialize(value, reviver) {
  return JSON.parse(value, (key2, value_) => {
    let value2 = value_;
    if ((value2 == null ? void 0 : value2.__type) === "bigint")
      value2 = BigInt(value2.value);
    if ((value2 == null ? void 0 : value2.__type) === "Map")
      value2 = new Map(value2.value);
    return (reviver == null ? void 0 : reviver(key2, value2)) ?? value2;
  });
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length } = array;
  for (let index2 = 0; index2 < length; ++index2) {
    if (array[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace(key2, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key2;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key2, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key2;
      }
    }
    return hasReplacer ? replacer.call(this, key2, value) : value;
  };
}
function serialize(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer((key2, value_) => {
    let value2 = value_;
    if (typeof value2 === "bigint")
      value2 = { __type: "bigint", value: value_.toString() };
    if (value2 instanceof Map)
      value2 = { __type: "Map", value: Array.from(value_.entries()) };
    return (replacer == null ? void 0 : replacer(key2, value2)) ?? value2;
  }, circularReplacer), indent ?? void 0);
}
function createStorage(parameters) {
  const { deserialize: deserialize$1 = deserialize, key: prefix = "wagmi", serialize: serialize$12 = serialize, storage = noopStorage } = parameters;
  function unwrap2(value) {
    if (value instanceof Promise)
      return value.then((x) => x).catch(() => null);
    return value;
  }
  return {
    ...storage,
    key: prefix,
    async getItem(key2, defaultValue) {
      const value = storage.getItem(`${prefix}.${key2}`);
      const unwrapped = await unwrap2(value);
      if (unwrapped)
        return deserialize$1(unwrapped) ?? null;
      return defaultValue ?? null;
    },
    async setItem(key2, value) {
      const storageKey2 = `${prefix}.${key2}`;
      if (value === null)
        await unwrap2(storage.removeItem(storageKey2));
      else
        await unwrap2(storage.setItem(storageKey2, serialize$12(value)));
    },
    async removeItem(key2) {
      await unwrap2(storage.removeItem(`${prefix}.${key2}`));
    }
  };
}
const noopStorage = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
};
function createConnector(createConnectorFn) {
  return createConnectorFn;
}
const version$3 = "2.10.3";
const getVersion$1 = () => `@wagmi/core@${version$3}`;
var __classPrivateFieldGet$1 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _BaseError_instances, _BaseError_walk;
let BaseError$1 = class BaseError2 extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return getVersion$1();
  }
  constructor(shortMessage, options = {}) {
    var _a2;
    super();
    _BaseError_instances.add(this);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiCoreError"
    });
    const details = options.cause instanceof BaseError2 ? options.cause.details : ((_a2 = options.cause) == null ? void 0 : _a2.message) ? options.cause.message : options.details;
    const docsPath2 = options.cause instanceof BaseError2 ? options.cause.docsPath || options.docsPath : options.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...options.metaMessages ? [...options.metaMessages, ""] : [],
      ...docsPath2 ? [
        `Docs: ${this.docsBaseUrl}${docsPath2}.html${options.docsSlug ? `#${options.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (options.cause)
      this.cause = options.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = options.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return __classPrivateFieldGet$1(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn);
  }
};
_BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function _BaseError_walk2(err, fn) {
  if (fn == null ? void 0 : fn(err))
    return err;
  if (err.cause)
    return __classPrivateFieldGet$1(this, _BaseError_instances, "m", _BaseError_walk2).call(this, err.cause, fn);
  return err;
};
class ChainNotConfiguredError extends BaseError$1 {
  constructor() {
    super("Chain not configured.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotConfiguredError"
    });
  }
}
class ConnectorAlreadyConnectedError extends BaseError$1 {
  constructor() {
    super("Connector already connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAlreadyConnectedError"
    });
  }
}
class ConnectorNotConnectedError extends BaseError$1 {
  constructor() {
    super("Connector not connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorNotConnectedError"
    });
  }
}
class ConnectorAccountNotFoundError extends BaseError$1 {
  constructor({ address, connector }) {
    super(`Account "${address}" not found for connector "${connector.name}".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAccountNotFoundError"
    });
  }
}
class ProviderNotFoundError extends BaseError$1 {
  constructor() {
    super("Provider not found.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderNotFoundError"
    });
  }
}
class SwitchChainNotSupportedError extends BaseError$1 {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainNotSupportedError"
    });
  }
}
const supportsSimulationIdRegex = /(rabby|trustwallet)/;
const targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (window2 == null ? void 0 : window2.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(window2) {
      return findProvider(window2, (provider2) => {
        if (!provider2.isMetaMask)
          return false;
        if (provider2.isBraveWallet && !provider2._events && !provider2._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider2[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      var _a2, _b2;
      if ((_a2 = window2 == null ? void 0 : window2.phantom) == null ? void 0 : _a2.ethereum)
        return (_b2 = window2.phantom) == null ? void 0 : _b2.ethereum;
      return findProvider(window2, "isPhantom");
    }
  }
};
injected.type = "injected";
function injected(parameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      provider(window2) {
        return window2 == null ? void 0 : window2.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect2;
  let disconnect2;
  return createConnector((config2) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    get supportsSimulation() {
      return supportsSimulationIdRegex.test(this.id.toLowerCase());
    },
    type: injected.type,
    async setup() {
      const provider2 = await this.getProvider();
      if (provider2 && parameters.target) {
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider2.on("connect", connect2);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      var _a2, _b2, _c2, _d2, _e2, _f2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      let accounts = [];
      if (isReconnecting2)
        accounts = await this.getAccounts().catch(() => []);
      else if (shimDisconnect) {
        try {
          const permissions = await provider2.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts = (_d2 = (_c2 = (_b2 = (_a2 = permissions[0]) == null ? void 0 : _a2.caveats) == null ? void 0 : _b2[0]) == null ? void 0 : _c2.value) == null ? void 0 : _d2.map((x) => getAddress(x));
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!(accounts == null ? void 0 : accounts.length) && !isReconnecting2) {
          const requestedAccounts = await provider2.request({
            method: "eth_requestAccounts"
          });
          accounts = requestedAccounts.map((x) => getAddress(x));
        }
        if (connect2) {
          provider2.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        if (shimDisconnect)
          await ((_e2 = config2.storage) == null ? void 0 : _e2.removeItem(`${this.id}.disconnected`));
        if (!parameters.target)
          await ((_f2 = config2.storage) == null ? void 0 : _f2.setItem("injected.connected", true));
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a2, _b2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
      try {
        await provider2.request({
          // `'wallet_revokePermissions'` added in `viem@2.10.3`
          method: "wallet_revokePermissions",
          params: [{ eth_accounts: {} }]
        });
      } catch {
      }
      if (shimDisconnect) {
        await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem(`${this.id}.disconnected`, true));
      }
      if (!parameters.target)
        await ((_b2 = config2.storage) == null ? void 0 : _b2.removeItem("injected.connected"));
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const accounts = await provider2.request({ method: "eth_accounts" });
      return accounts.map((x) => getAddress(x));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const hexChainId = await provider2.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider2;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider2 = target.provider(window);
      else if (typeof target.provider === "string")
        provider2 = findProvider(window, target.provider);
      else
        provider2 = target.provider;
      if (provider2 && !provider2.removeListener) {
        if ("off" in provider2 && typeof provider2.off === "function")
          provider2.removeListener = provider2.off;
        else
          provider2.removeListener = () => {
          };
      }
      return provider2;
    },
    async isAuthorized() {
      var _a2, _b2;
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(`${this.id}.disconnected`));
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem("injected.connected"));
          if (!connected)
            return false;
        }
        const provider2 = await this.getProvider();
        if (!provider2) {
          if (unstable_shimAsyncInject !== void 0 && unstable_shimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider3 = await this.getProvider();
              return !!provider3;
            };
            const timeout = typeof unstable_shimAsyncInject === "number" ? unstable_shimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise((resolve) => window.addEventListener("ethereum#initialized", () => resolve(handleEthereum()), { once: true }))
              ] : [],
              new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout))
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError();
        }
        const accounts = await withRetry(() => withTimeout(() => this.getAccounts(), {
          timeout: 100
        }));
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2, _d2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          provider2.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config2.emitter.emit("change", { chainId });
          }),
          new Promise((resolve) => config2.emitter.once("change", ({ chainId: currentChainId }) => {
            if (currentChainId === chainId)
              resolve();
          }))
        ]);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b2 = (_a2 = error == null ? void 0 : error.data) == null ? void 0 : _a2.originalError) == null ? void 0 : _b2.code) === 4902) {
          try {
            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x) => x.url)
              ];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            const currentChainId = await this.getChainId();
            if (currentChainId !== chainId)
              throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts) {
      var _a2;
      if (accounts.length === 0)
        this.onDisconnect();
      else if (config2.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await ((_a2 = config2.storage) == null ? void 0 : _a2.removeItem(`${this.id}.disconnected`));
      } else
        config2.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config2.emitter.emit("connect", { accounts, chainId });
      const provider2 = await this.getProvider();
      if (provider2) {
        if (connect2) {
          provider2.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
      }
    },
    async onDisconnect(error) {
      const provider2 = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider2 && !!(await this.getAccounts()).length)
          return;
      }
      config2.emitter.emit("disconnect");
      if (provider2) {
        if (chainChanged) {
          provider2.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider2.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider2.on("connect", connect2);
        }
      }
    }
  }));
}
function findProvider(window2, select) {
  function isProvider(provider2) {
    if (typeof select === "function")
      return select(provider2);
    if (typeof select === "string")
      return provider2[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum == null ? void 0 : ethereum.providers)
    return ethereum.providers.find((provider2) => isProvider(provider2));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}
const size$3 = 256;
let index$1 = size$3;
let buffer;
function uid(length = 11) {
  if (!buffer || index$1 + length > size$3 * 2) {
    buffer = "";
    index$1 = 0;
    for (let i = 0; i < size$3; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index$1, index$1++ + length);
}
function createConfig(parameters) {
  const { multiInjectedProviderDiscovery = true, storage = createStorage({
    storage: typeof window !== "undefined" && window.localStorage ? window.localStorage : noopStorage
  }), syncConnectedChain = true, ssr, ...rest } = parameters;
  const mipd = typeof window !== "undefined" && multiInjectedProviderDiscovery ? createStore$1() : void 0;
  const chains2 = createStore(() => rest.chains);
  const connectors = createStore(() => [
    ...rest.connectors ?? [],
    ...!ssr ? (mipd == null ? void 0 : mipd.getProviders().map(providerDetailToConnector)) ?? [] : []
  ].map(setup));
  function setup(connectorFn) {
    var _a2;
    const emitter = createEmitter(uid());
    const connector = {
      ...connectorFn({ emitter, chains: chains2.getState(), storage }),
      emitter,
      uid: emitter.uid
    };
    emitter.on("connect", connect2);
    (_a2 = connector.setup) == null ? void 0 : _a2.call(connector);
    return connector;
  }
  function providerDetailToConnector(providerDetail) {
    const { info } = providerDetail;
    const provider2 = providerDetail.provider;
    return injected({ target: { ...info, id: info.rdns, provider: provider2 } });
  }
  const clients = /* @__PURE__ */ new Map();
  function getClient2(config2 = {}) {
    const chainId = config2.chainId ?? store.getState().chainId;
    const chain = chains2.getState().find((x) => x.id === chainId);
    if (config2.chainId && !chain)
      throw new ChainNotConfiguredError();
    {
      const client3 = clients.get(store.getState().chainId);
      if (client3 && !chain)
        return client3;
      else if (!chain)
        throw new ChainNotConfiguredError();
    }
    {
      const client3 = clients.get(chainId);
      if (client3)
        return client3;
    }
    let client2;
    if (rest.client)
      client2 = rest.client({ chain });
    else {
      const chainId2 = chain.id;
      const chainIds = chains2.getState().map((x) => x.id);
      const properties = {};
      const entries = Object.entries(rest);
      for (const [key2, value] of entries) {
        if (key2 === "chains" || key2 === "client" || key2 === "connectors" || key2 === "transports")
          continue;
        else {
          if (typeof value === "object") {
            if (chainId2 in value)
              properties[key2] = value[chainId2];
            else {
              const hasChainSpecificValue = chainIds.some((x) => x in value);
              if (hasChainSpecificValue)
                continue;
              properties[key2] = value;
            }
          } else
            properties[key2] = value;
        }
      }
      client2 = createClient({
        ...properties,
        chain,
        batch: properties.batch ?? { multicall: true },
        transport: (parameters2) => rest.transports[chainId2]({ ...parameters2, connectors })
      });
    }
    clients.set(chainId, client2);
    return client2;
  }
  function getInitialState() {
    return {
      chainId: chains2.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: null,
      status: "disconnected"
    };
  }
  let currentVersion;
  const prefix = "0.0.0-canary-";
  if (version$3.startsWith(prefix))
    currentVersion = parseInt(version$3.replace(prefix, ""));
  else
    currentVersion = parseInt(version$3.split(".")[0] ?? "0");
  const store = createStore(subscribeWithSelector(
    // only use persist middleware if storage exists
    storage ? persist(getInitialState, {
      migrate(persistedState, version2) {
        if (version2 === currentVersion)
          return persistedState;
        const initialState = getInitialState();
        const chainId = persistedState && typeof persistedState === "object" && "chainId" in persistedState && typeof persistedState.chainId === "number" ? persistedState.chainId : initialState.chainId;
        return { ...initialState, chainId };
      },
      name: "store",
      partialize(state) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(state.connections.entries()).map(([key2, connection]) => {
              const { id: id2, name: name2, type, uid: uid2 } = connection.connector;
              const connector = { id: id2, name: name2, type, uid: uid2 };
              return [key2, { ...connection, connector }];
            })
          },
          chainId: state.chainId,
          current: state.current
        };
      },
      skipHydration: ssr,
      storage,
      version: currentVersion
    }) : getInitialState
  ));
  if (syncConnectedChain)
    store.subscribe(({ connections, current }) => {
      var _a2;
      return current ? (_a2 = connections.get(current)) == null ? void 0 : _a2.chainId : void 0;
    }, (chainId) => {
      const isChainConfigured = chains2.getState().some((x) => x.id === chainId);
      if (!isChainConfigured)
        return;
      return store.setState((x) => ({
        ...x,
        chainId: chainId ?? x.chainId
      }));
    });
  mipd == null ? void 0 : mipd.subscribe((providerDetails) => {
    const currentConnectorIds = /* @__PURE__ */ new Map();
    for (const connector of connectors.getState()) {
      currentConnectorIds.set(connector.id, true);
    }
    const newConnectors = [];
    for (const providerDetail of providerDetails) {
      const connector = setup(providerDetailToConnector(providerDetail));
      if (currentConnectorIds.has(connector.id))
        continue;
      newConnectors.push(connector);
    }
    if (storage && !store.persist.hasHydrated())
      return;
    connectors.setState((x) => [...x, ...newConnectors], true);
  });
  function change(data) {
    store.setState((x) => {
      const connection = x.connections.get(data.uid);
      if (!connection)
        return x;
      return {
        ...x,
        connections: new Map(x.connections).set(data.uid, {
          accounts: data.accounts ?? connection.accounts,
          chainId: data.chainId ?? connection.chainId,
          connector: connection.connector
        })
      };
    });
  }
  function connect2(data) {
    if (store.getState().status === "connecting" || store.getState().status === "reconnecting")
      return;
    store.setState((x) => {
      const connector = connectors.getState().find((x2) => x2.uid === data.uid);
      if (!connector)
        return x;
      if (connector.emitter.listenerCount("connect"))
        connector.emitter.off("connect", change);
      if (!connector.emitter.listenerCount("change"))
        connector.emitter.on("change", change);
      if (!connector.emitter.listenerCount("disconnect"))
        connector.emitter.on("disconnect", disconnect2);
      return {
        ...x,
        connections: new Map(x.connections).set(data.uid, {
          accounts: data.accounts,
          chainId: data.chainId,
          connector
        }),
        current: data.uid,
        status: "connected"
      };
    });
  }
  function disconnect2(data) {
    store.setState((x) => {
      const connection = x.connections.get(data.uid);
      if (connection) {
        const connector = connection.connector;
        if (connector.emitter.listenerCount("change"))
          connection.connector.emitter.off("change", change);
        if (connector.emitter.listenerCount("disconnect"))
          connection.connector.emitter.off("disconnect", disconnect2);
        if (!connector.emitter.listenerCount("connect"))
          connection.connector.emitter.on("connect", connect2);
      }
      x.connections.delete(data.uid);
      if (x.connections.size === 0)
        return {
          ...x,
          connections: /* @__PURE__ */ new Map(),
          current: null,
          status: "disconnected"
        };
      const nextConnection = x.connections.values().next().value;
      return {
        ...x,
        connections: new Map(x.connections),
        current: nextConnection.connector.uid
      };
    });
  }
  return {
    get chains() {
      return chains2.getState();
    },
    get connectors() {
      return connectors.getState();
    },
    storage,
    getClient: getClient2,
    get state() {
      return store.getState();
    },
    setState(value) {
      let newState;
      if (typeof value === "function")
        newState = value(store.getState());
      else
        newState = value;
      const initialState = getInitialState();
      if (typeof newState !== "object")
        newState = initialState;
      const isCorrupt = Object.keys(initialState).some((x) => !(x in newState));
      if (isCorrupt)
        newState = initialState;
      store.setState(newState, true);
    },
    subscribe(selector2, listener, options) {
      return store.subscribe(selector2, listener, options ? { ...options, fireImmediately: options.emitImmediately } : void 0);
    },
    _internal: {
      mipd,
      store,
      ssr: Boolean(ssr),
      syncConnectedChain,
      transports: rest.transports,
      chains: {
        setState(value) {
          const nextChains = typeof value === "function" ? value(chains2.getState()) : value;
          if (nextChains.length === 0)
            return;
          return chains2.setState(nextChains, true);
        },
        subscribe(listener) {
          return chains2.subscribe(listener);
        }
      },
      connectors: {
        providerDetailToConnector,
        setup,
        setState(value) {
          return connectors.setState(typeof value === "function" ? value(connectors.getState()) : value, true);
        },
        subscribe(listener) {
          return connectors.subscribe(listener);
        }
      },
      events: { change, connect: connect2, disconnect: disconnect2 }
    }
  };
}
function getAction(client2, actionFn, name2) {
  const action_implicit = client2[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client2[name2];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client2, params);
}
async function connect(config2, parameters) {
  var _a2;
  let connector;
  if (typeof parameters.connector === "function") {
    connector = config2._internal.connectors.setup(parameters.connector);
  } else
    connector = parameters.connector;
  if (connector.uid === config2.state.current)
    throw new ConnectorAlreadyConnectedError();
  try {
    config2.setState((x) => ({ ...x, status: "connecting" }));
    connector.emitter.emit("message", { type: "connecting" });
    const data = await connector.connect({ chainId: parameters.chainId });
    const accounts = data.accounts;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem("recentConnectorId", connector.id));
    config2.setState((x) => ({
      ...x,
      connections: new Map(x.connections).set(connector.uid, {
        accounts,
        chainId: data.chainId,
        connector
      }),
      current: connector.uid,
      status: "connected"
    }));
    return { accounts, chainId: data.chainId };
  } catch (error) {
    config2.setState((x) => ({
      ...x,
      // Keep existing connector connected in case of error
      status: x.current ? "connected" : "disconnected"
    }));
    throw error;
  }
}
async function disconnect(config2, parameters = {}) {
  var _a2, _b2;
  let connector;
  if (parameters.connector)
    connector = parameters.connector;
  else {
    const { connections: connections2, current } = config2.state;
    const connection = connections2.get(current);
    connector = connection == null ? void 0 : connection.connector;
  }
  const connections = config2.state.connections;
  if (connector) {
    await connector.disconnect();
    connector.emitter.off("change", config2._internal.events.change);
    connector.emitter.off("disconnect", config2._internal.events.disconnect);
    connector.emitter.on("connect", config2._internal.events.connect);
    connections.delete(connector.uid);
  }
  config2.setState((x) => {
    if (connections.size === 0)
      return {
        ...x,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      };
    const nextConnection = connections.values().next().value;
    return {
      ...x,
      connections: new Map(connections),
      current: nextConnection.connector.uid
    };
  });
  {
    const current = config2.state.current;
    if (!current)
      return;
    const connector2 = (_a2 = config2.state.connections.get(current)) == null ? void 0 : _a2.connector;
    if (!connector2)
      return;
    await ((_b2 = config2.storage) == null ? void 0 : _b2.setItem("recentConnectorId", connector2.id));
  }
}
async function getConnectorClient(config2, parameters = {}) {
  let connection;
  if (parameters.connector) {
    const { connector: connector2 } = parameters;
    const [accounts, chainId2] = await Promise.all([
      connector2.getAccounts(),
      connector2.getChainId()
    ]);
    connection = {
      accounts,
      chainId: chainId2,
      connector: connector2
    };
  } else
    connection = config2.state.connections.get(config2.state.current);
  if (!connection)
    throw new ConnectorNotConnectedError();
  const chainId = parameters.chainId ?? connection.chainId;
  const connector = connection.connector;
  if (connector.getClient)
    return connector.getClient({ chainId });
  const account2 = parseAccount(parameters.account ?? connection.accounts[0]);
  account2.address = getAddress(account2.address);
  const chain = config2.chains.find((chain2) => chain2.id === chainId);
  const provider2 = await connection.connector.getProvider({ chainId });
  if (parameters.account && !connection.accounts.some((x) => x.toLowerCase() === account2.address.toLowerCase()))
    throw new ConnectorAccountNotFoundError({
      address: account2.address,
      connector
    });
  return createClient({
    account: account2,
    chain,
    name: "Connector Client",
    transport: (opts) => custom(provider2)({ ...opts, retryCount: 0 })
  });
}
function getAccount(config2) {
  const uid2 = config2.state.current;
  const connection = config2.state.connections.get(uid2);
  const addresses = connection == null ? void 0 : connection.accounts;
  const address = addresses == null ? void 0 : addresses[0];
  const chain = config2.chains.find((chain2) => chain2.id === (connection == null ? void 0 : connection.chainId));
  const status = config2.state.status;
  switch (status) {
    case "connected":
      return {
        address,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: !!address,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address,
        addresses,
        chain,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function getChainId(config2) {
  return config2.state.chainId;
}
function deepEqual$1(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    let length;
    let i;
    if (Array.isArray(a2) && Array.isArray(b2)) {
      length = a2.length;
      if (length !== b2.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!deepEqual$1(a2[i], b2[i]))
          return false;
      return true;
    }
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    const keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      const key2 = keys[i];
      if (key2 && !deepEqual$1(a2[key2], b2[key2]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
let previousChains = [];
function getChains(config2) {
  const chains2 = config2.chains;
  if (deepEqual$1(previousChains, chains2))
    return previousChains;
  previousChains = chains2;
  return chains2;
}
function getClient(config2, parameters = {}) {
  let client2 = void 0;
  try {
    client2 = config2.getClient(parameters);
  } catch {
  }
  return client2;
}
let previousConnections = [];
function getConnections(config2) {
  const connections = [...config2.state.connections.values()];
  if (config2.state.status === "reconnecting")
    return previousConnections;
  if (deepEqual$1(previousConnections, connections))
    return previousConnections;
  previousConnections = connections;
  return connections;
}
let previousConnectors = [];
function getConnectors(config2) {
  const connectors = config2.connectors;
  if (deepEqual$1(previousConnectors, connectors))
    return previousConnectors;
  previousConnectors = connectors;
  return connectors;
}
function getPublicClient(config2, parameters = {}) {
  const client2 = getClient(config2, parameters);
  return client2 == null ? void 0 : client2.extend(publicActions);
}
async function getWalletClient(config2, parameters = {}) {
  const client2 = await getConnectorClient(config2, parameters);
  client2.extend(walletActions);
  return client2.extend(walletActions);
}
let isReconnecting = false;
async function reconnect(config2, parameters = {}) {
  var _a2, _b2;
  if (isReconnecting)
    return [];
  isReconnecting = true;
  config2.setState((x) => ({
    ...x,
    status: x.current ? "reconnecting" : "connecting"
  }));
  const connectors = [];
  if ((_a2 = parameters.connectors) == null ? void 0 : _a2.length) {
    for (const connector_ of parameters.connectors) {
      let connector;
      if (typeof connector_ === "function")
        connector = config2._internal.connectors.setup(connector_);
      else
        connector = connector_;
      connectors.push(connector);
    }
  } else
    connectors.push(...config2.connectors);
  let recentConnectorId;
  try {
    recentConnectorId = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem("recentConnectorId"));
  } catch {
  }
  const scores = {};
  for (const [, connection] of config2.state.connections) {
    scores[connection.connector.id] = 1;
  }
  if (recentConnectorId)
    scores[recentConnectorId] = 0;
  const sorted = Object.keys(scores).length > 0 ? (
    // .toSorted()
    [...connectors].sort((a2, b2) => (scores[a2.id] ?? 10) - (scores[b2.id] ?? 10))
  ) : connectors;
  let connected = false;
  const connections = [];
  const providers = [];
  for (const connector of sorted) {
    const provider_ = await connector.getProvider().catch(() => void 0);
    if (!provider_)
      continue;
    if (providers.some((provider2) => provider2 === provider_))
      continue;
    const isAuthorized = await connector.isAuthorized();
    if (!isAuthorized)
      continue;
    const data = await connector.connect({ isReconnecting: true }).catch(() => null);
    if (!data)
      continue;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    config2.setState((x) => {
      const connections2 = new Map(connected ? x.connections : /* @__PURE__ */ new Map()).set(connector.uid, { accounts: data.accounts, chainId: data.chainId, connector });
      return {
        ...x,
        current: connected ? x.current : connector.uid,
        connections: connections2
      };
    });
    connections.push({
      accounts: data.accounts,
      chainId: data.chainId,
      connector
    });
    providers.push(provider_);
    connected = true;
  }
  if (config2.state.status === "reconnecting" || config2.state.status === "connecting") {
    if (!connected)
      config2.setState((x) => ({
        ...x,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      }));
    else
      config2.setState((x) => ({ ...x, status: "connected" }));
  }
  isReconnecting = false;
  return connections;
}
async function sendTransaction(config2, parameters) {
  const { account: account2, chainId, connector, gas: gas_, ...rest } = parameters;
  let client2;
  if (typeof account2 === "object" && account2.type === "local")
    client2 = config2.getClient({ chainId });
  else
    client2 = await getConnectorClient(config2, { account: account2, chainId, connector });
  const { connector: activeConnector } = getAccount(config2);
  const gas = await (async () => {
    var _a2;
    if (!("data" in parameters) || !parameters.data)
      return void 0;
    if ((_a2 = connector ?? activeConnector) == null ? void 0 : _a2.supportsSimulation)
      return void 0;
    if (gas_ === null)
      return void 0;
    if (gas_ === void 0) {
      const action2 = getAction(client2, estimateGas, "estimateGas");
      return action2({
        ...rest,
        account: account2,
        chain: chainId ? { id: chainId } : null
      });
    }
    return gas_;
  })();
  const action = getAction(client2, sendTransaction$1, "sendTransaction");
  const hash2 = await action({
    ...rest,
    ...account2 ? { account: account2 } : {},
    gas,
    chain: chainId ? { id: chainId } : null
  });
  return hash2;
}
async function simulateContract(config2, parameters) {
  const { abi: abi2, chainId, connector, ...rest } = parameters;
  let account2;
  if (parameters.account)
    account2 = parameters.account;
  else {
    const connectorClient = await getConnectorClient(config2, {
      chainId,
      connector
    });
    account2 = connectorClient.account;
  }
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, simulateContract$1, "simulateContract");
  const { result, request } = await action({ ...rest, abi: abi2, account: account2 });
  return {
    chainId: client2.chain.id,
    result,
    request: { __mode: "prepared", ...request, chainId }
  };
}
async function switchChain(config2, parameters) {
  var _a2;
  const { addEthereumChainParameter, chainId } = parameters;
  const connection = config2.state.connections.get(((_a2 = parameters.connector) == null ? void 0 : _a2.uid) ?? config2.state.current);
  if (connection) {
    const connector = connection.connector;
    if (!connector.switchChain)
      throw new SwitchChainNotSupportedError({ connector });
    const chain2 = await connector.switchChain({
      addEthereumChainParameter,
      chainId
    });
    return chain2;
  }
  const chain = config2.chains.find((x) => x.id === chainId);
  if (!chain)
    throw new ChainNotConfiguredError();
  config2.setState((x) => ({ ...x, chainId }));
  return chain;
}
function watchAccount(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getAccount(config2), onChange, {
    equalityFn(a2, b2) {
      const { connector: aConnector, ...aRest } = a2;
      const { connector: bConnector, ...bRest } = b2;
      return deepEqual$1(aRest, bRest) && // check connector separately
      (aConnector == null ? void 0 : aConnector.id) === (bConnector == null ? void 0 : bConnector.id) && (aConnector == null ? void 0 : aConnector.uid) === (bConnector == null ? void 0 : bConnector.uid);
    }
  });
}
function watchChainId(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe((state) => state.chainId, onChange);
}
function watchConnections(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getConnections(config2), onChange, {
    equalityFn: deepEqual$1
  });
}
function watchConnectors(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.connectors.subscribe((connectors, prevConnectors) => {
    onChange(Object.values(connectors), prevConnectors);
  });
}
function watchPublicClient(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getPublicClient(config2), onChange, {
    equalityFn(a2, b2) {
      return (a2 == null ? void 0 : a2.uid) === (b2 == null ? void 0 : b2.uid);
    }
  });
}
async function writeContract(config2, parameters) {
  const { account: account2, chainId, connector, __mode, ...rest } = parameters;
  let client2;
  if (typeof account2 === "object" && account2.type === "local")
    client2 = config2.getClient({ chainId });
  else
    client2 = await getConnectorClient(config2, { account: account2, chainId, connector });
  const { connector: activeConnector } = getAccount(config2);
  let request;
  if (__mode === "prepared" || (activeConnector == null ? void 0 : activeConnector.supportsSimulation))
    request = rest;
  else {
    const { request: simulateRequest } = await simulateContract(config2, {
      ...rest,
      account: account2,
      chainId
    });
    request = simulateRequest;
  }
  const action = getAction(client2, writeContract$1, "writeContract");
  const hash2 = await action({
    ...request,
    ...account2 ? { account: account2 } : {},
    chain: chainId ? { id: chainId } : null
  });
  return hash2;
}
mock$1.type = "mock";
function mock$1(parameters) {
  const transactionCache = /* @__PURE__ */ new Map();
  const features = parameters.features ?? {};
  let connected = false;
  let connectedChainId;
  return createConnector((config2) => ({
    id: "mock",
    name: "Mock Connector",
    type: mock$1.type,
    async setup() {
      connectedChainId = config2.chains[0].id;
    },
    async connect({ chainId } = {}) {
      if (features.connectError) {
        if (typeof features.connectError === "boolean")
          throw new UserRejectedRequestError(new Error("Failed to connect."));
        throw features.connectError;
      }
      const provider2 = await this.getProvider();
      const accounts = await provider2.request({
        method: "eth_requestAccounts"
      });
      let currentChainId = await this.getChainId();
      if (chainId && currentChainId !== chainId) {
        const chain = await this.switchChain({ chainId });
        currentChainId = chain.id;
      }
      connected = true;
      return {
        accounts: accounts.map((x) => getAddress(x)),
        chainId: currentChainId
      };
    },
    async disconnect() {
      connected = false;
    },
    async getAccounts() {
      if (!connected)
        throw new ConnectorNotConnectedError();
      const provider2 = await this.getProvider();
      const accounts = await provider2.request({ method: "eth_accounts" });
      return accounts.map((x) => getAddress(x));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const hexChainId = await provider2.request({ method: "eth_chainId" });
      return fromHex$1(hexChainId, "number");
    },
    async isAuthorized() {
      if (!features.reconnect)
        return false;
      if (!connected)
        return false;
      const accounts = await this.getAccounts();
      return !!accounts.length;
    },
    async switchChain({ chainId }) {
      const provider2 = await this.getProvider();
      const chain = config2.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      await provider2.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: numberToHex(chainId) }]
      });
      return chain;
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config2.emitter.emit("disconnect");
      connected = false;
    },
    async getProvider({ chainId } = {}) {
      const chain = config2.chains.find((x) => x.id === chainId) ?? config2.chains[0];
      const url = chain.rpcUrls.default.http[0];
      const request = async ({ method, params }) => {
        if (method === "eth_chainId")
          return numberToHex(connectedChainId);
        if (method === "eth_requestAccounts")
          return parameters.accounts;
        if (method === "eth_signTypedData_v4") {
          if (features.signTypedDataError) {
            if (typeof features.signTypedDataError === "boolean")
              throw new UserRejectedRequestError(new Error("Failed to sign typed data."));
            throw features.signTypedDataError;
          }
        }
        if (method === "wallet_switchEthereumChain") {
          if (features.switchChainError) {
            if (typeof features.switchChainError === "boolean")
              throw new UserRejectedRequestError(new Error("Failed to switch chain."));
            throw features.switchChainError;
          }
          connectedChainId = fromHex$1(params[0].chainId, "number");
          this.onChainChanged(connectedChainId.toString());
          return;
        }
        if (method === "wallet_getCapabilities")
          return {
            "0x2105": {
              paymasterService: {
                supported: params[0] === "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
              },
              sessionKeys: {
                supported: true
              }
            },
            "0x14A34": {
              paymasterService: {
                supported: params[0] === "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
              }
            }
          };
        if (method === "wallet_sendCalls") {
          const hashes = [];
          const calls = params[0].calls;
          for (const call2 of calls) {
            const { result: result2, error: error2 } = await rpc.http(url, {
              body: {
                method: "eth_sendTransaction",
                params: [call2]
              }
            });
            if (error2)
              throw new RpcRequestError({
                body: { method, params },
                error: error2,
                url
              });
            hashes.push(result2);
          }
          const id2 = keccak256(stringToHex(JSON.stringify(calls)));
          transactionCache.set(id2, hashes);
          return id2;
        }
        if (method === "wallet_getCallsStatus") {
          const hashes = transactionCache.get(params[0]);
          if (!hashes)
            return null;
          const receipts = await Promise.all(hashes.map(async (hash2) => {
            const { result: result2, error: error2 } = await rpc.http(url, {
              body: {
                method: "eth_getTransactionReceipt",
                params: [hash2],
                id: 0
              }
            });
            if (error2)
              throw new RpcRequestError({
                body: { method, params },
                error: error2,
                url
              });
            if (!result2)
              return null;
            return {
              blockHash: result2.blockHash,
              blockNumber: result2.blockNumber,
              gasUsed: result2.gasUsed,
              logs: result2.logs,
              status: result2.status,
              transactionHash: result2.transactionHash
            };
          }));
          if (receipts.some((x) => !x))
            return { status: "PENDING", receipts: [] };
          return { status: "CONFIRMED", receipts };
        }
        if (method === "wallet_showCallsStatus")
          return;
        if (method === "personal_sign") {
          if (features.signMessageError) {
            if (typeof features.signMessageError === "boolean")
              throw new UserRejectedRequestError(new Error("Failed to sign message."));
            throw features.signMessageError;
          }
          method = "eth_sign";
          params = [params[1], params[0]];
        }
        const body = { method, params };
        const { error, result } = await rpc.http(url, { body });
        if (error)
          throw new RpcRequestError({ body, error, url });
        return result;
      };
      return custom({ request })({ retryCount: 0 });
    }
  }));
}
function hydrate(config2, parameters) {
  const { initialState, reconnectOnMount } = parameters;
  if (initialState && !config2._internal.store.persist.hasHydrated())
    config2.setState({
      ...initialState,
      connections: reconnectOnMount ? initialState.connections : /* @__PURE__ */ new Map(),
      status: reconnectOnMount ? "reconnecting" : "disconnected"
    });
  return {
    async onMount() {
      var _a2;
      if (config2._internal.ssr) {
        await config2._internal.store.persist.rehydrate();
        const mipdConnectors = (_a2 = config2._internal.mipd) == null ? void 0 : _a2.getProviders().map(config2._internal.connectors.providerDetailToConnector).map(config2._internal.connectors.setup);
        config2._internal.connectors.setState((connectors) => [
          ...connectors,
          ...mipdConnectors ?? []
        ]);
      }
      if (reconnectOnMount)
        reconnect(config2);
      else if (config2.storage)
        config2.setState((x) => ({
          ...x,
          connections: /* @__PURE__ */ new Map()
        }));
    }
  };
}
function Hydrate(parameters) {
  const { children, config: config2, initialState, reconnectOnMount = true } = parameters;
  const { onMount } = hydrate(config2, {
    initialState,
    reconnectOnMount
  });
  if (!config2._internal.ssr)
    onMount();
  const active = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (!active.current)
      return;
    if (!config2._internal.ssr)
      return;
    onMount();
    return () => {
      active.current = false;
    };
  }, []);
  return children;
}
const WagmiContext = reactExports.createContext(void 0);
function WagmiProvider(parameters) {
  const { children, config: config2 } = parameters;
  const props = { value: config2 };
  return reactExports.createElement(Hydrate, parameters, reactExports.createElement(WagmiContext.Provider, props, children));
}
const version$2 = "2.9.5";
const getVersion = () => `wagmi@${version$2}`;
class BaseError3 extends BaseError$1 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return getVersion();
  }
}
class WagmiProviderNotFoundError extends BaseError3 {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiProviderNotFoundError"
    });
  }
}
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$1() {
  return void 0;
}
function functionalUpdate(updater, input2) {
  return typeof updater === "function" ? updater(input2) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn2 = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn2(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject$2(val) ? Object.keys(val).sort().reduce((result, key2) => {
      result[key2] = val[key2];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key2) => !partialMatchKey(a2[key2], b2[key2]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (array || isPlainObject$2(a2) && isPlainObject$2(b2)) {
    const aItems = array ? a2 : Object.keys(a2);
    const aSize = aItems.length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key2 = array ? i : bItems[i];
      if ((!array && aItems.includes(key2) || array) && a2[key2] === void 0 && b2[key2] === void 0) {
        copy2[key2] = void 0;
        equalItems++;
      } else {
        copy2[key2] = replaceEqualDeep(a2[key2], b2[key2]);
        if (copy2[key2] === a2[key2] && a2[key2] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (!b2 || Object.keys(a2).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key2 in a2) {
    if (a2[key2] !== b2[key2]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$2(o2) {
  if (!hasObjectPrototype$1(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype$1(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o2) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype$1(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item2, max2 = 0) {
  const newItems = [...items, item2];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item2, max2 = 0) {
  const newItems = [item2, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused, void 0);
    __privateAdd(this, _cleanup, void 0);
    __privateAdd(this, _setup, void 0);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup, setup);
    (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a2;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();
var OnlineManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2, void 0);
    __privateAdd(this, _setup2, void 0);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup2, setup);
    (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    var _a2;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a2 = config2.abort) == null ? void 0 : _a2.call(config2);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onSuccess) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onError) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a2;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a2 = config2.onPause) == null ? void 0 : _a2.call(config2);
    }).then(() => {
      var _a2;
      continueFn = void 0;
      if (!isResolved) {
        (_a2 = config2.onContinue) == null ? void 0 : _a2.call(config2);
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a2;
      if (isResolved) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry2 = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry2) {
        reject(error);
        return;
      }
      failureCount++;
      (_a2 = config2.onFail) == null ? void 0 : _a2.call(config2, failureCount, error);
      sleep(delay2).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return promise;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return promise;
    }
  };
}
function createNotifyManager() {
  let queue2 = [];
  let transactions2 = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb2) => setTimeout(cb2, 0);
  const setScheduler = (fn) => {
    scheduleFn = fn;
  };
  const batch = (callback) => {
    let result;
    transactions2++;
    try {
      result = callback();
    } finally {
      transactions2--;
      if (!transactions2) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions2) {
      queue2.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue2;
    queue2 = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn) => {
    notifyFn = fn;
  };
  const setBatchNotifyFunction = (fn) => {
    batchNotifyFn = fn;
  };
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction,
    setScheduler
  };
}
var notifyManager = createNotifyManager();
var Removable = (_c = class {
  constructor() {
    __privateAdd(this, _gcTimeout, void 0);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _c);
var Query = (_d = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _dispatch);
    __privateAdd(this, _initialState, void 0);
    __privateAdd(this, _revertState, void 0);
    __privateAdd(this, _cache, void 0);
    __privateAdd(this, _retryer, void 0);
    __privateAdd(this, _defaultOptions, void 0);
    __privateAdd(this, _abortSignalConsumed, void 0);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _cache, config2.cache);
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, config2.state || getDefaultState$1(this.options));
    this.state = __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _dispatch, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a2, _b2;
    const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
    return promise ? promise.then(noop$1).catch(noop$1) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a2;
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  onOnline() {
    var _a2;
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a2, _b2, _c2;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      meta: this.meta
    };
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    addSignalProperty(queryFnContext);
    const fetchFn = () => {
      if (!this.options.queryFn || this.options.queryFn === skipToken) {
        return Promise.reject(
          new Error(`Missing queryFn: '${this.options.queryHash}'`)
        );
      }
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          this.options.queryFn,
          queryFnContext,
          this
        );
      }
      return this.options.queryFn(
        queryFnContext
      );
    };
    const context2 = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context2);
    (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(
      context2,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context2.fetchOptions) == null ? void 0 : _b2.meta)) {
      __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context2.fetchOptions) == null ? void 0 : _c2.meta });
    }
    const onError = (error) => {
      var _a3, _b3, _c3, _d2;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
          _a3,
          error,
          this
        );
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          this.state.data,
          error,
          this
        );
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    __privateSet(this, _retryer, createRetryer({
      fn: context2.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _a3, _b3, _c3, _d2;
        if (data === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        this.setData(data);
        (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data, this);
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          data,
          this.state.error,
          this
        );
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context2.options.retry,
      retryDelay: context2.options.retryDelay,
      networkMode: context2.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _dispatch = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _d);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryCache = (_e = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries, void 0);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client2, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _e);
var Mutation = (_f = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _dispatch2);
    __privateAdd(this, _observers, void 0);
    __privateAdd(this, _mutationCache, void 0);
    __privateAdd(this, _retryer2, void 0);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x) => x !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a2;
    return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
          _a2,
          variables,
          this
        ));
        const context2 = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
        if (context2 !== this.state.context) {
          __privateMethod(this, _dispatch2, dispatch_fn2).call(this, {
            type: "pending",
            context: context2,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
        _e2,
        data,
        variables,
        this.state.context,
        this
      ));
      await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data, variables, this.state.context));
      await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
        _i2,
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l = (_k = this.options).onSettled) == null ? void 0 : _l.call(_k, data, null, variables, this.state.context));
      __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_n = (_m = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t = (_s = this.options).onSettled) == null ? void 0 : _t.call(
          _s,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _dispatch2, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _dispatch2 = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations, void 0);
    __privateAdd(this, _mutationId, void 0);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client2, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client2.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    var _a2;
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = (_a2 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a2.filter((x) => x !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    var _a2;
    const firstPendingMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    var _a2;
    const foundMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
    return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$1))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  var _a2;
  return ((_a2 = mutation.options.scope) == null ? void 0 : _a2.id) ?? String(mutation.mutationId);
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context2, query) => {
      const fetchFn = async () => {
        var _a2, _b2, _c2, _d2, _e2;
        const options = context2.options;
        const direction = (_c2 = (_b2 = (_a2 = context2.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
        const oldPages = ((_d2 = context2.state.data) == null ? void 0 : _d2.pages) || [];
        const oldPageParams = ((_e2 = context2.state.data) == null ? void 0 : _e2.pageParams) || [];
        const empty = { pages: [], pageParams: [] };
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context2.signal.aborted) {
                cancelled = true;
              } else {
                context2.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context2.signal;
            }
          });
        };
        const queryFn = context2.options.queryFn && context2.options.queryFn !== skipToken ? context2.options.queryFn : () => {
          return Promise.reject(
            new Error(`Missing queryFn: '${context2.options.queryHash}'`)
          );
        };
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context2.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context2.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context2.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        let result;
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          result = await fetchPage(
            empty,
            oldPageParams[0] ?? options.initialPageParam
          );
          const remainingPages = pages ?? oldPages.length;
          for (let i = 1; i < remainingPages; i++) {
            const param = getNextPageParam(options, result);
            result = await fetchPage(result, param);
          }
        }
        return result;
      };
      if (context2.options.persister) {
        context2.fetchFn = () => {
          var _a2, _b2;
          return (_b2 = (_a2 = context2.options).persister) == null ? void 0 : _b2.call(
            _a2,
            fetchFn,
            {
              queryKey: context2.queryKey,
              meta: context2.options.meta,
              signal: context2.signal
            },
            query
          );
        };
      } else {
        context2.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  );
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a2;
  return (_a2 = options.getPreviousPageParam) == null ? void 0 : _a2.call(
    options,
    pages[0],
    pages,
    pageParams[0],
    pageParams
  );
}
function hasNextPage(options, data) {
  if (!data)
    return false;
  return getNextPageParam(options, data) != null;
}
function hasPreviousPage(options, data) {
  if (!data || !options.getPreviousPageParam)
    return false;
  return getPreviousPageParam(options, data) != null;
}
var QueryClient = (_h = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache, void 0);
    __privateAdd(this, _mutationCache2, void 0);
    __privateAdd(this, _defaultOptions2, void 0);
    __privateAdd(this, _queryDefaults, void 0);
    __privateAdd(this, _mutationDefaults, void 0);
    __privateAdd(this, _mountCount, void 0);
    __privateAdd(this, _unsubscribeFocus, void 0);
    __privateAdd(this, _unsubscribeOnline, void 0);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a2, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    if (cachedData === void 0)
      return this.fetchQuery(options);
    else {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      if (options.revalidateIfStale && query.isStaleByTime(defaultedOptions.staleTime)) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$1).catch(noop$1);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: filters.refetchType ?? filters.type ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    const fetchOptions = {
      ...options,
      cancelRefetch: (options == null ? void 0 : options.cancelRefetch) ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$1);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$1);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$1).catch(noop$1);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$1).catch(noop$1);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults2 = [...__privateGet(this, _queryDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
var QueryObserver = (_i = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _executeFetch);
    __privateAdd(this, _updateStaleTimeout);
    __privateAdd(this, _computeRefetchInterval);
    __privateAdd(this, _updateRefetchInterval);
    __privateAdd(this, _updateTimers);
    __privateAdd(this, _clearStaleTimeout);
    __privateAdd(this, _clearRefetchInterval);
    __privateAdd(this, _updateQuery);
    __privateAdd(this, _notify);
    __privateAdd(this, _client, void 0);
    __privateAdd(this, _currentQuery, void 0);
    __privateAdd(this, _currentQueryInitialState, void 0);
    __privateAdd(this, _currentResult, void 0);
    __privateAdd(this, _currentResultState, void 0);
    __privateAdd(this, _currentResultOptions, void 0);
    __privateAdd(this, _selectError, void 0);
    __privateAdd(this, _selectFn, void 0);
    __privateAdd(this, _selectResult, void 0);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData, void 0);
    __privateAdd(this, _staleTimeoutId, void 0);
    __privateAdd(this, _refetchIntervalId, void 0);
    __privateAdd(this, _currentRefetchInterval, void 0);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client, client2);
    __privateSet(this, _selectError, null);
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _executeFetch, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _updateTimers, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _clearStaleTimeout, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _clearRefetchInterval, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    __privateMethod(this, _updateQuery, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _executeFetch, executeFetch_fn).call(this);
    }
    this.updateResult(notifyOptions);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      __privateMethod(this, _updateStaleTimeout, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _computeRefetchInterval, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _updateRefetchInterval, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key2) => {
      Object.defineProperty(trackedResult, key2, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key2);
          onPropTracked == null ? void 0 : onPropTracked(key2);
          return result[key2];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key2) {
    __privateGet(this, _trackedProps).add(key2);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _executeFetch, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a2;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data = options.select(newState.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          __privateSet(this, _selectResult, data);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    } else {
      data = newState.data;
    }
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a2.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key2) => {
        const typedKey = key2;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    __privateMethod(this, _notify, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _updateTimers, updateTimers_fn).call(this);
    }
  }
}, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _executeFetch = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _updateQuery, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop$1);
  }
  return promise;
}, _updateStaleTimeout = new WeakSet(), updateStaleTimeout_fn = function() {
  __privateMethod(this, _clearStaleTimeout, clearStaleTimeout_fn).call(this);
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(this.options.staleTime)) {
    return;
  }
  const time2 = timeUntilStale(
    __privateGet(this, _currentResult).dataUpdatedAt,
    this.options.staleTime
  );
  const timeout = time2 + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, _computeRefetchInterval = new WeakSet(), computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, _updateRefetchInterval = new WeakSet(), updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _clearRefetchInterval, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || this.options.enabled === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _executeFetch, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, _updateTimers = new WeakSet(), updateTimers_fn = function() {
  __privateMethod(this, _updateStaleTimeout, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _updateRefetchInterval, updateRefetchInterval_fn).call(this, __privateMethod(this, _computeRefetchInterval, computeRefetchInterval_fn).call(this));
}, _clearStaleTimeout = new WeakSet(), clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, _clearRefetchInterval = new WeakSet(), clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, _updateQuery = new WeakSet(), updateQuery_fn = function() {
  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, _notify = new WeakSet(), notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _i);
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return options.enabled !== false && query.isStaleByTime(options.staleTime);
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
var InfiniteQueryObserver = class extends QueryObserver {
  constructor(client2, options) {
    super(client2, options);
  }
  bindMethods() {
    super.bindMethods();
    this.fetchNextPage = this.fetchNextPage.bind(this);
    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(options, notifyOptions) {
    super.setOptions(
      {
        ...options,
        behavior: infiniteQueryBehavior()
      },
      notifyOptions
    );
  }
  getOptimisticResult(options) {
    options.behavior = infiniteQueryBehavior();
    return super.getOptimisticResult(options);
  }
  fetchNextPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(query, options) {
    var _a2, _b2;
    const { state } = query;
    const parentResult = super.createResult(query, options);
    const { isFetching, isRefetching, isError, isRefetchError } = parentResult;
    const fetchDirection = (_b2 = (_a2 = state.fetchMeta) == null ? void 0 : _a2.fetchMore) == null ? void 0 : _b2.direction;
    const isFetchNextPageError = isError && fetchDirection === "forward";
    const isFetchingNextPage = isFetching && fetchDirection === "forward";
    const isFetchPreviousPageError = isError && fetchDirection === "backward";
    const isFetchingPreviousPage = isFetching && fetchDirection === "backward";
    const result = {
      ...parentResult,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hasNextPage(options, state.data),
      hasPreviousPage: hasPreviousPage(options, state.data),
      isFetchNextPageError,
      isFetchingNextPage,
      isFetchPreviousPageError,
      isFetchingPreviousPage,
      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,
      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
    };
    return result;
  }
};
var MutationObserver$1 = (_j = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _updateResult);
    __privateAdd(this, _notify2);
    __privateAdd(this, _client2, void 0);
    __privateAdd(this, _currentResult2, void 0);
    __privateAdd(this, _currentMutation, void 0);
    __privateAdd(this, _mutateOptions, void 0);
    __privateSet(this, _client2, client2);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _updateResult, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a2;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client2).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _updateResult, updateResult_fn).call(this);
    __privateMethod(this, _notify2, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a2;
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _updateResult, updateResult_fn).call(this);
    __privateMethod(this, _notify2, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a2;
    __privateSet(this, _mutateOptions, options);
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client2).getMutationCache().build(__privateGet(this, _client2), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client2 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _updateResult = new WeakSet(), updateResult_fn = function() {
  var _a2;
  const state = ((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state) ?? getDefaultState();
  __privateSet(this, _currentResult2, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, _notify2 = new WeakSet(), notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context2 = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b2 = (_a2 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b2.call(_a2, action.data, variables, context2);
        (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context2);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f2 = (_e2 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e2, action.error, variables, context2);
        (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
          _g2,
          void 0,
          action.error,
          variables,
          context2
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _j);
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client2 = reactExports.useContext(QueryClientContext);
  if (!client2) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client2;
};
var QueryClientProvider = ({
  client: client2,
  children
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(QueryClientContext.Provider, { value: client2, children });
};
var IsRestoringContext = reactExports.createContext(false);
var useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue());
var useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop() {
}
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);
};
var ensureStaleTime = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
};
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});
function useBaseQuery(options, Observer, queryClient2) {
  const client2 = useQueryClient();
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client2.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureStaleTime(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(
    () => new Observer(
      client2,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
        observer.updateResult();
        return unsubscribe;
      },
      [observer, isRestoring]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client2.getQueryCache().get(defaultedOptions.queryHash)
  })) {
    throw result.error;
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery$1(options, queryClient2) {
  return useBaseQuery(options, QueryObserver);
}
function useMutation(options, queryClient2) {
  const client2 = useQueryClient();
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client2,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
function useInfiniteQuery(options, queryClient2) {
  return useBaseQuery(
    options,
    InfiniteQueryObserver
  );
}
function watchChains(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.chains.subscribe((chains2, prevChains) => {
    onChange(chains2, prevChains);
  });
}
function useConfig(parameters = {}) {
  const config2 = parameters.config ?? reactExports.useContext(WagmiContext);
  if (!config2)
    throw new WagmiProviderNotFoundError();
  return config2;
}
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$1 = reactExports;
function h$2(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$1 = "function" === typeof Object.is ? Object.is : h$2, l$1 = e$1.useState, m$1 = e$1.useEffect, n$2 = e$1.useLayoutEffect, p$2 = e$1.useDebugValue;
function q$2(a2, b2) {
  var d2 = b2(), f2 = l$1({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$2(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$3(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$1(function() {
    r$3(c2) && g2({ inst: c2 });
    return a2(function() {
      r$3(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$2(d2);
  return d2;
}
function r$3(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$1(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$2(a2, b2) {
  return b2();
}
var u$2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$2 : q$2;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$1.useSyncExternalStore ? e$1.useSyncExternalStore : u$2;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$1 = reactExports, n$1 = shimExports;
function p$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$1 = "function" === typeof Object.is ? Object.is : p$1, r$2 = n$1.useSyncExternalStore, t$1 = h$1.useRef, u$1 = h$1.useEffect, v$1 = h$1.useMemo, w = h$1.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$1(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$1(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$1(d3, a4))
        return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$2(a2, c2[0], c2[1]);
  u$1(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
const isPlainObject$1 = (obj) => typeof obj === "object" && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe, getSnapshot, getServerSnapshot = getSnapshot, isEqual = deepEqual$1) {
  const trackedKeys = reactExports.useRef([]);
  const result = withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, (x) => x, (a2, b2) => {
    if (isPlainObject$1(a2) && isPlainObject$1(b2) && trackedKeys.current.length) {
      for (const key2 of trackedKeys.current) {
        const equal = isEqual(a2[key2], b2[key2]);
        if (!equal)
          return false;
      }
      return true;
    }
    return isEqual(a2, b2);
  });
  if (isPlainObject$1(result)) {
    const trackedResult = { ...result };
    Object.defineProperties(trackedResult, Object.entries(trackedResult).reduce((res, [key2, value]) => {
      return {
        ...res,
        [key2]: {
          configurable: false,
          enumerable: true,
          get: () => {
            if (!trackedKeys.current.includes(key2)) {
              trackedKeys.current.push(key2);
            }
            return value;
          }
        }
      };
    }, {}));
    return trackedResult;
  }
  return result;
}
function useAccount(parameters = {}) {
  const config2 = useConfig(parameters);
  return useSyncExternalStoreWithTracked((onChange) => watchAccount(config2, { onChange }), () => getAccount(config2));
}
function hashFn(queryKey) {
  return JSON.stringify(queryKey, (_, value) => {
    if (isPlainObject(value))
      return Object.keys(value).sort().reduce((result, key2) => {
        result[key2] = value[key2];
        return result;
      }, {});
    if (typeof value === "bigint")
      return value.toString();
    return value;
  });
}
function isPlainObject(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (typeof ctor === "undefined")
    return true;
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot))
    return false;
  if (!prot.hasOwnProperty("isPrototypeOf"))
    return false;
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function filterQueryOptions(options) {
  const {
    // import('@tanstack/query-core').QueryOptions
    // biome-ignore lint/correctness/noUnusedVariables: remove properties
    _defaulted,
    behavior,
    gcTime,
    initialData,
    initialDataUpdatedAt,
    maxPages,
    meta,
    networkMode,
    queryFn,
    queryHash,
    queryKey,
    queryKeyHashFn,
    retry,
    retryDelay,
    structuralSharing,
    // import('@tanstack/query-core').InfiniteQueryObserverOptions
    // biome-ignore lint/correctness/noUnusedVariables: remove properties
    getPreviousPageParam: getPreviousPageParam2,
    getNextPageParam: getNextPageParam2,
    initialPageParam,
    // import('@tanstack/react-query').UseQueryOptions
    // biome-ignore lint/correctness/noUnusedVariables: remove properties
    _optimisticResults,
    enabled,
    notifyOnChangeProps,
    placeholderData,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retryOnMount,
    select,
    staleTime,
    suspense,
    throwOnError,
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // wagmi
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // biome-ignore lint/correctness/noUnusedVariables: remove properties
    config: config2,
    connector,
    query,
    ...rest
  } = options;
  return rest;
}
function connectMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return connect(config2, variables);
    },
    mutationKey: ["connect"]
  };
}
function disconnectMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return disconnect(config2, variables);
    },
    mutationKey: ["disconnect"]
  };
}
function getWalletClientQueryOptions(config2, options = {}) {
  return {
    gcTime: 0,
    async queryFn({ queryKey }) {
      const { connector } = options;
      const { connectorUid: _, scopeKey: _s, ...parameters } = queryKey[1];
      return getWalletClient(config2, { ...parameters, connector });
    },
    queryKey: getWalletClientQueryKey(options)
  };
}
function getWalletClientQueryKey(options = {}) {
  const { connector, ...parameters } = options;
  return [
    "walletClient",
    { ...filterQueryOptions(parameters), connectorUid: connector == null ? void 0 : connector.uid }
  ];
}
function sendTransactionMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return sendTransaction(config2, variables);
    },
    mutationKey: ["sendTransaction"]
  };
}
function switchChainMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return switchChain(config2, variables);
    },
    mutationKey: ["switchChain"]
  };
}
function writeContractMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return writeContract(config2, variables);
    },
    mutationKey: ["writeContract"]
  };
}
function useQuery(parameters) {
  const result = useQuery$1({
    ...parameters,
    queryKeyHashFn: hashFn
    // for bigint support
  });
  result.queryKey = parameters.queryKey;
  return result;
}
function useChainId(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchChainId(config2, { onChange }), () => getChainId(config2), () => getChainId(config2));
}
function useChains(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchChains(config2, { onChange }), () => getChains(config2), () => getChains(config2));
}
function useConnectors(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchConnectors(config2, { onChange }), () => getConnectors(config2), () => getConnectors(config2));
}
function useConnect(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = connectMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  reactExports.useEffect(() => {
    return config2.subscribe(({ status }) => status, (status, previousStatus) => {
      if (previousStatus === "connected" && status === "disconnected")
        result.reset();
    });
  }, [config2, result]);
  return {
    ...result,
    connect: mutate,
    connectAsync: mutateAsync,
    connectors: useConnectors({ config: config2 })
  };
}
function useConnections(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchConnections(config2, { onChange }), () => getConnections(config2), () => getConnections(config2));
}
function useDisconnect(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = disconnectMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    connectors: useConnections({ config: config2 }).map((connection) => connection.connector),
    disconnect: mutate,
    disconnectAsync: mutateAsync
  };
}
function usePublicClient(parameters = {}) {
  const config2 = useConfig(parameters);
  return withSelectorExports.useSyncExternalStoreWithSelector((onChange) => watchPublicClient(config2, { onChange }), () => getPublicClient(config2, parameters), () => getPublicClient(config2, parameters), (x) => x, (a2, b2) => (a2 == null ? void 0 : a2.uid) === (b2 == null ? void 0 : b2.uid));
}
function useSendTransaction(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = sendTransactionMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    sendTransaction: mutate,
    sendTransactionAsync: mutateAsync
  };
}
function useSwitchChain(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = switchChainMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    chains: useChains({ config: config2 }),
    switchChain: mutate,
    switchChainAsync: mutateAsync
  };
}
function useWalletClient(parameters = {}) {
  const { query = {}, ...rest } = parameters;
  const config2 = useConfig(rest);
  const queryClient2 = useQueryClient();
  const { address, connector, status } = useAccount({ config: config2 });
  const chainId = useChainId({ config: config2 });
  const { queryKey, ...options } = getWalletClientQueryOptions(config2, {
    ...parameters,
    chainId: parameters.chainId ?? chainId,
    connector: parameters.connector ?? connector
  });
  const enabled = Boolean(status !== "disconnected" && (query.enabled ?? true));
  const addressRef = reactExports.useRef(address);
  reactExports.useEffect(() => {
    const previousAddress = addressRef.current;
    if (!address && previousAddress) {
      queryClient2.removeQueries({ queryKey });
      addressRef.current = void 0;
    } else if (address !== previousAddress) {
      queryClient2.invalidateQueries({ queryKey });
      addressRef.current = address;
    }
  }, [address, queryClient2]);
  return useQuery({
    ...query,
    ...options,
    queryKey,
    enabled,
    staleTime: Infinity
  });
}
function useWriteContract(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = writeContractMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    writeContract: mutate,
    writeContractAsync: mutateAsync
  };
}
var LocalStorageKey;
(function(LocalStorageKey2) {
  LocalStorageKey2["Settings"] = "@kit.settings";
  LocalStorageKey2["Theme"] = "@kit.theme";
  LocalStorageKey2["EthAuthProof"] = "@kit.ethAuthProof";
  LocalStorageKey2["EthAuthSettings"] = "@kit.ethAuthSettings";
  LocalStorageKey2["WaasGoogleClientID"] = "@kit.waasGoogleClientId";
  LocalStorageKey2["WaasGoogleIdToken"] = "@kit.waasGoogleIdToken";
  LocalStorageKey2["WaasAppleClientID"] = "@kit.waasAppleClientId";
  LocalStorageKey2["WaasAppleRedirectURI"] = "@kit.waasAppleRedirectURI";
  LocalStorageKey2["WaasAppleIdToken"] = "@kit.waasAppleIdToken";
  LocalStorageKey2["WaasActiveLoginType"] = "@kit.waasActiveLoginType";
  LocalStorageKey2["WaasEmailIdToken"] = "@kit.waasEmailIdToken";
  LocalStorageKey2["WaasSignInEmail"] = "@kit.waasSignInEmail";
})(LocalStorageKey || (LocalStorageKey = {}));
const DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7;
const createGenericContext$2 = () => {
  const genericContext = reactExports.createContext(void 0);
  const useGenericContext = () => {
    const contextIsDefined = reactExports.useContext(genericContext);
    if (!contextIsDefined) {
      throw new Error("useGenericContext must be used within a Provider");
    }
    return contextIsDefined;
  };
  return [useGenericContext, genericContext.Provider];
};
const [useAnalyticsContext, AnalyticsContextProvider] = createGenericContext$2();
const [useConnectModalContext, ConnectModalContextProvider] = createGenericContext$2();
const [useKitConfig, KitConfigContextProvider] = createGenericContext$2();
const [useThemeContext, ThemeContextProvider] = createGenericContext$2();
const [useWalletConfigContext, WalletConfigContextProvider] = createGenericContext$2();
const useStorage = () => {
  const config2 = useConfig();
  if (!config2.storage) {
    return null;
  }
  return config2.storage;
};
const useStorageItem = (key2) => {
  const storage = useStorage();
  return useQuery$1({
    queryKey: ["storage", key2],
    queryFn: async () => {
      return storage == null ? void 0 : storage.getItem(key2);
    },
    retry: true,
    enabled: !!storage
  });
};
class Deferred {
  constructor() {
    __publicField(this, "_resolve", () => {
    });
    __publicField(this, "_reject", () => {
    });
    __publicField(this, "_promise", new Promise((resolve, reject) => {
      this._reject = reject;
      this._resolve = resolve;
    }));
  }
  get promise() {
    return this._promise;
  }
  resolve(value) {
    this._resolve(value);
  }
  reject(value) {
    this._reject(value);
  }
}
let _pendingConfirmation;
function useWaasConfirmationHandler(waasConnector) {
  const [pendingRequestConfirmation, setPendingRequestConfirmation] = reactExports.useState();
  function confirmPendingRequest(id2) {
    _pendingConfirmation == null ? void 0 : _pendingConfirmation.resolve({ id: id2, confirmed: true });
    setPendingRequestConfirmation(void 0);
    _pendingConfirmation = void 0;
  }
  function rejectPendingRequest(id2) {
    _pendingConfirmation == null ? void 0 : _pendingConfirmation.resolve({ id: id2, confirmed: false });
    setPendingRequestConfirmation(void 0);
    _pendingConfirmation = void 0;
  }
  reactExports.useEffect(() => {
    async function setup() {
      if (!waasConnector) {
        return;
      }
      const waasProvider = waasConnector.sequenceWaasProvider;
      if (!waasProvider) {
        return;
      }
      waasProvider.requestConfirmationHandler = {
        confirmSignTransactionRequest(id2, txs, chainId) {
          const pending = new Deferred();
          setPendingRequestConfirmation({ id: id2, type: "signTransaction", txs: Array.isArray(txs) ? txs : [txs], chainId });
          _pendingConfirmation = pending;
          return pending.promise;
        },
        confirmSignMessageRequest(id2, message, chainId) {
          const pending = new Deferred();
          setPendingRequestConfirmation({ id: id2, type: "signMessage", message, chainId });
          _pendingConfirmation = pending;
          return pending.promise;
        }
      };
    }
    setup();
  });
  return [pendingRequestConfirmation, confirmPendingRequest, rejectPendingRequest];
}
function canonicalize(obj) {
  var buffer2 = "";
  serialize2(obj);
  return buffer2;
  function serialize2(object) {
    if (object === null || typeof object !== "object" || object.toJSON != null) {
      buffer2 += JSON.stringify(object);
    } else if (Array.isArray(object)) {
      buffer2 += "[";
      var next_1 = false;
      object.forEach(function(element) {
        if (next_1) {
          buffer2 += ",";
        }
        next_1 = true;
        if (element === void 0) {
          element = null;
        }
        serialize2(element);
      });
      buffer2 += "]";
    } else {
      buffer2 += "{";
      var vKeys = Object.keys(object).filter(function(k2) {
        return object[k2] !== void 0;
      }).sort();
      vKeys.forEach(function(property, index2) {
        return addProp(object, property, index2);
      });
      buffer2 += "}";
    }
  }
  function addProp(object, property, index2) {
    if (index2 > 0) {
      buffer2 += ",";
    }
    buffer2 += JSON.stringify(property);
    buffer2 += ":";
    serialize2(object[property]);
  }
}
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
  let httpHandler = runtimeConfig.httpHandler;
  return {
    setHttpHandler(handler) {
      httpHandler = handler;
    },
    httpHandler() {
      return httpHandler;
    },
    updateHttpClientConfig(key2, value) {
      httpHandler.updateHttpClientConfig(key2, value);
    },
    httpHandlerConfigs() {
      return httpHandler.httpHandlerConfigs();
    }
  };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
  return {
    httpHandler: httpHandlerExtensionConfiguration.httpHandler()
  };
};
var HttpAuthLocation;
(function(HttpAuthLocation2) {
  HttpAuthLocation2["HEADER"] = "header";
  HttpAuthLocation2["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));
var HttpApiKeyAuthLocation;
(function(HttpApiKeyAuthLocation2) {
  HttpApiKeyAuthLocation2["HEADER"] = "header";
  HttpApiKeyAuthLocation2["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
var EndpointURLScheme;
(function(EndpointURLScheme2) {
  EndpointURLScheme2["HTTP"] = "http";
  EndpointURLScheme2["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));
var AlgorithmId;
(function(AlgorithmId2) {
  AlgorithmId2["MD5"] = "md5";
  AlgorithmId2["CRC32"] = "crc32";
  AlgorithmId2["CRC32C"] = "crc32c";
  AlgorithmId2["SHA1"] = "sha1";
  AlgorithmId2["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
var FieldPosition;
(function(FieldPosition2) {
  FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
  FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));
const SMITHY_CONTEXT_KEY = "__smithy_context";
var IniSectionType;
(function(IniSectionType2) {
  IniSectionType2["PROFILE"] = "profile";
  IniSectionType2["SSO_SESSION"] = "sso-session";
  IniSectionType2["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));
var RequestHandlerProtocol;
(function(RequestHandlerProtocol2) {
  RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
class HttpRequest {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static isInstance(request) {
    if (!request)
      return false;
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    const cloned = new HttpRequest({
      ...this,
      headers: { ...this.headers }
    });
    if (cloned.query)
      cloned.query = cloneQuery$1(cloned.query);
    return cloned;
  }
}
function cloneQuery$1(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}
class HttpResponse {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
}
function resolveHostHeaderConfig(input2) {
  return input2;
}
const hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
    delete request.headers["host"];
    request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
  } else if (!request.headers["host"]) {
    let host = request.hostname;
    if (request.port != null)
      host += `:${request.port}`;
    request.headers["host"] = host;
  }
  return next(args);
};
const hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
const getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});
const loggerMiddleware = () => (next, context2) => async (args) => {
  var _a2, _b2;
  try {
    const response = await next(args);
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context2;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context2.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context2.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    (_a2 = logger2 == null ? void 0 : logger2.info) == null ? void 0 : _a2.call(logger2, {
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context2;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context2.inputFilterSensitiveLog;
    (_b2 = logger2 == null ? void 0 : logger2.error) == null ? void 0 : _b2.call(logger2, {
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
};
const loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
const getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});
var define_process_env_default = {};
const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = define_process_env_default[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = define_process_env_default[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request
  });
};
const addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
const getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});
function resolveUserAgentConfig(input2) {
  return {
    ...input2,
    customUserAgent: typeof input2.customUserAgent === "string" ? [[input2.customUserAgent]] : input2.customUserAgent
  };
}
const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};
const customEndpointFunctions = {};
const debugId = "endpoints";
function toDebugString(input2) {
  if (typeof input2 !== "object" || input2 == null) {
    return input2;
  }
  if ("ref" in input2) {
    return `$${toDebugString(input2.ref)}`;
  }
  if ("fn" in input2) {
    return `${input2.fn}(${(input2.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input2, null, 2);
}
class EndpointError extends Error {
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
}
const booleanEquals = (value1, value2) => value1 === value2;
const getAttrPathList = (path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};
const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index2) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index2}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index2)];
  }
  return acc[index2];
}, value);
const isSet = (value) => value != null;
const not = (value) => !value;
const DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
};
const parseURL = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url.search = Object.entries(query).map(([k2, v3]) => `${k2}=${v3}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search: search2 } = whatwgURL;
  if (search2) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};
const stringEquals = (value1, value2) => value1 === value2;
const substring = (input2, start, stop, reverse) => {
  if (start >= stop || input2.length < stop) {
    return null;
  }
  if (!reverse) {
    return input2.substring(start, stop);
  }
  return input2.substring(input2.length - stop, input2.length - start);
};
const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`);
const endpointFunctions = {
  booleanEquals,
  getAttr,
  isSet,
  isValidHostLabel,
  not,
  parseURL,
  stringEquals,
  substring,
  uriEncode
};
const evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};
const getReferenceValue = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};
const evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
const callFunction = ({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  const fnSegments = fn.split(".");
  if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
    return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
  }
  return endpointFunctions[fn](...evaluatedArgs);
};
const evaluateCondition = ({ assign, ...fnArgs }, options) => {
  var _a2, _b2;
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};
const evaluateConditions = (conditions = [], options) => {
  var _a2, _b2;
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};
const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});
const getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
};
const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});
const getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};
const evaluateEndpointRule = (endpointRule, options) => {
  var _a2, _b2;
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};
const evaluateErrorRule = (errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};
const evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};
const evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
};
const resolveEndpoint = (ruleSetObject, options) => {
  var _a2, _b2, _c2, _d2, _e2;
  const { endpointParams, logger: logger2 } = options;
  const { parameters, rules } = ruleSetObject;
  (_b2 = (_a2 = options.logger) == null ? void 0 : _a2.debug) == null ? void 0 : _b2.call(_a2, `${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v3]) => v3.default != null).map(([k2, v3]) => [k2, v3.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v3]) => v3.required).map(([k2]) => k2);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
  if ((_c2 = options.endpointParams) == null ? void 0 : _c2.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint.url.protocol = protocol;
      endpoint.url.port = port;
    } catch (e2) {
    }
  }
  (_e2 = (_d2 = options.logger) == null ? void 0 : _d2.debug) == null ? void 0 : _e2.call(_d2, `${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
  return endpoint;
};
const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value)) {
    return false;
  }
  return true;
};
const parseArn = (value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition2, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition2 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition2,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
};
const partitions = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
];
const version$1 = "1.1";
const partitionsInfo = {
  partitions,
  version: version$1
};
let selectedPartitionsInfo = partitionsInfo;
const partition = (value) => {
  const { partitions: partitions2 } = selectedPartitionsInfo;
  for (const partition2 of partitions2) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions2) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions2.find((partition2) => partition2.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
};
const awsEndpointFunctions = {
  isVirtualHostableS3Bucket,
  parseArn,
  partition
};
customEndpointFunctions.aws = awsEndpointFunctions;
const USER_AGENT = "user-agent";
const X_AMZ_USER_AGENT = "x-amz-user-agent";
const SPACE$1 = " ";
const UA_NAME_SEPARATOR = "/";
const UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
const UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
const UA_ESCAPE_CHAR = "-";
const userAgentMiddleware = (options) => (next, context2) => async (args) => {
  var _a2, _b2;
  const { request } = args;
  if (!HttpRequest.isInstance(request))
    return next(args);
  const { headers } = request;
  const userAgent = ((_a2 = context2 == null ? void 0 : context2.userAgent) == null ? void 0 : _a2.map(escapeUserAgent)) || [];
  const defaultUserAgent2 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  const customUserAgent = ((_b2 = options == null ? void 0 : options.customUserAgent) == null ? void 0 : _b2.map(escapeUserAgent)) || [];
  const sdkUserAgentValue = [].concat([...defaultUserAgent2, ...userAgent, ...customUserAgent]).join(SPACE$1);
  const normalUAValue = [
    ...defaultUserAgent2.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE$1);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request
  });
};
const escapeUserAgent = (userAgentPair) => {
  var _a2;
  const name2 = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version2 = (_a2 = userAgentPair[1]) == null ? void 0 : _a2.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name2.indexOf(UA_NAME_SEPARATOR);
  const prefix = name2.substring(0, prefixSeparatorIndex);
  let uaName = name2.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version2].filter((item2) => item2 && item2.length > 0).reduce((acc, item2, index2) => {
    switch (index2) {
      case 0:
        return item2;
      case 1:
        return `${acc}/${item2}`;
      default:
        return `${acc}#${item2}`;
    }
  }, "");
};
const getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
const getUserAgentPlugin = (config2) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config2), getUserAgentMiddlewareOptions);
  }
});
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));
const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
const DEFAULT_USE_FIPS_ENDPOINT = false;
const getSmithyContext = (context2) => context2[SMITHY_CONTEXT_KEY] || (context2[SMITHY_CONTEXT_KEY] = {});
const normalizeProvider$1 = (input2) => {
  if (typeof input2 === "function")
    return input2;
  const promisified = Promise.resolve(input2);
  return () => promisified;
};
const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
const getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
const resolveRegionConfig = (input2) => {
  const { region, useFipsEndpoint } = input2;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input2,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};
function convertHttpAuthSchemesToMap(httpAuthSchemes) {
  const map = /* @__PURE__ */ new Map();
  for (const scheme of httpAuthSchemes) {
    map.set(scheme.schemeId, scheme);
  }
  return map;
}
const httpAuthSchemeMiddleware = (config2, mwOptions) => (next, context2) => async (args) => {
  var _a2;
  const options = config2.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config2, context2, args.input));
  const authSchemes = convertHttpAuthSchemesToMap(config2.httpAuthSchemes);
  const smithyContext = getSmithyContext(context2);
  const failureReasons = [];
  for (const option of options) {
    const scheme = authSchemes.get(option.schemeId);
    if (!scheme) {
      failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
      continue;
    }
    const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config2));
    if (!identityProvider) {
      failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
      continue;
    }
    const { identityProperties = {}, signingProperties = {} } = ((_a2 = option.propertiesExtractor) == null ? void 0 : _a2.call(option, config2, context2)) || {};
    option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
    option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
    smithyContext.selectedHttpAuthScheme = {
      httpAuthOption: option,
      identity: await identityProvider(option.identityProperties),
      signer: scheme.signer
    };
    break;
  }
  if (!smithyContext.selectedHttpAuthScheme) {
    throw new Error(failureReasons.join("\n"));
  }
  return next(args);
};
const resolveParamsForS3 = async (endpointParams) => {
  const bucket = (endpointParams == null ? void 0 : endpointParams.Bucket) || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
  const [arn, partition2, service, , , bucket] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = Boolean(isArn && partition2 && service && bucket);
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return isValidArn;
};
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config2) => {
  const configProvider = async () => {
    const configValue = config2[configKey] ?? config2[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
    return async () => {
      const credentials = typeof config2.credentials === "function" ? await config2.credentials() : config2.credentials;
      const configValue = (credentials == null ? void 0 : credentials.credentialScope) ?? (credentials == null ? void 0 : credentials.CredentialScope);
      return configValue;
    };
  }
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};
const getEndpointFromConfig = async (serviceId) => void 0;
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key2, value = null] = pair.split("=");
      key2 = decodeURIComponent(key2);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key2 in query)) {
        query[key2] = value;
      } else if (Array.isArray(query[key2])) {
        query[key2].push(value);
      } else {
        query[key2] = [query[key2], value];
      }
    }
  }
  return query;
}
const parseUrl = (url) => {
  if (typeof url === "string") {
    return parseUrl(new URL(url));
  }
  const { hostname, pathname, port, protocol, search: search2 } = url;
  let query;
  if (search2) {
    query = parseQueryString(search2);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};
const toEndpointV1 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};
const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context2) => {
  if (!clientConfig.endpoint) {
    const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
    if (endpointFromConfig) {
      clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
    }
  }
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context2);
  return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  var _a2;
  const endpointParams = {};
  const instructions = ((_a2 = instructionsSupplier == null ? void 0 : instructionsSupplier.getEndpointParameterInstructions) == null ? void 0 : _a2.call(instructionsSupplier)) || {};
  for (const [name2, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name2] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name2] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name2] = await createConfigValueProvider(instruction.name, name2, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};
const endpointMiddleware = ({ config: config2, instructions }) => {
  return (next, context2) => async (args) => {
    var _a2, _b2, _c2;
    const endpoint = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config2 }, context2);
    context2.endpointV2 = endpoint;
    context2.authSchemes = (_a2 = endpoint.properties) == null ? void 0 : _a2.authSchemes;
    const authScheme = (_b2 = context2.authSchemes) == null ? void 0 : _b2[0];
    if (authScheme) {
      context2["signing_region"] = authScheme.signingRegion;
      context2["signing_service"] = authScheme.signingName;
      const smithyContext = getSmithyContext(context2);
      const httpAuthOption = (_c2 = smithyContext == null ? void 0 : smithyContext.selectedHttpAuthScheme) == null ? void 0 : _c2.httpAuthOption;
      if (httpAuthOption) {
        httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
          signing_region: authScheme.signingRegion,
          signingRegion: authScheme.signingRegion,
          signing_service: authScheme.signingName,
          signingName: authScheme.signingName,
          signingRegionSet: authScheme.signingRegionSet
        }, authScheme.properties);
      }
    }
    return next({
      ...args
    });
  };
};
const deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    if (!("$metadata" in error)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error.message += "\n  " + hint;
      if (typeof error.$responseBodyText !== "undefined") {
        if (error.$response) {
          error.$response.body = error.$responseBodyText;
        }
      }
    }
    throw error;
  }
};
const serializerMiddleware = (options, serializer) => (next, context2) => async (args) => {
  var _a2;
  const endpoint = ((_a2 = context2.endpointV2) == null ? void 0 : _a2.url) && options.urlParser ? async () => options.urlParser(context2.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request = await serializer(args.input, { ...options, endpoint });
  return next({
    ...args,
    request
  });
};
const deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
const serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config2, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config2, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config2, serializer), serializerMiddlewareOption);
    }
  };
}
const endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
const getEndpointPlugin = (config2, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config: config2,
      instructions
    }), endpointMiddlewareOptions);
  }
});
const resolveEndpointConfig = (input2) => {
  const tls = input2.tls ?? true;
  const { endpoint } = input2;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider$1(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  return {
    ...input2,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider$1(input2.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider$1(input2.useFipsEndpoint ?? false)
  };
};
const httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: endpointMiddlewareOptions.name
};
const getHttpAuthSchemeEndpointRuleSetPlugin = (config2, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(httpAuthSchemeMiddleware(config2, {
      httpAuthSchemeParametersProvider,
      identityProviderConfigProvider
    }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
  }
});
({
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
});
const defaultErrorHandler = (signingProperties) => (error) => {
  throw error;
};
const defaultSuccessHandler = (httpResponse, signingProperties) => {
};
const httpSigningMiddleware = (config2) => (next, context2) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const smithyContext = getSmithyContext(context2);
  const scheme = smithyContext.selectedHttpAuthScheme;
  if (!scheme) {
    throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
  }
  const { httpAuthOption: { signingProperties = {} }, identity, signer: signer2 } = scheme;
  const output2 = await next({
    ...args,
    request: await signer2.sign(args.request, identity, signingProperties)
  }).catch((signer2.errorHandler || defaultErrorHandler)(signingProperties));
  (signer2.successHandler || defaultSuccessHandler)(output2.response, signingProperties);
  return output2;
};
var RETRY_MODES;
(function(RETRY_MODES2) {
  RETRY_MODES2["STANDARD"] = "standard";
  RETRY_MODES2["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
const DEFAULT_MAX_ATTEMPTS = 3;
const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;
const THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
const TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
const isClockSkewCorrectedError = (error) => {
  var _a2;
  return (_a2 = error.$metadata) == null ? void 0 : _a2.clockSkewCorrected;
};
const isThrottlingError = (error) => {
  var _a2, _b2;
  return ((_a2 = error.$metadata) == null ? void 0 : _a2.httpStatusCode) === 429 || THROTTLING_ERROR_CODES.includes(error.name) || ((_b2 = error.$retryable) == null ? void 0 : _b2.throttling) == true;
};
const isTransientError = (error) => {
  var _a2;
  return isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes((error == null ? void 0 : error.code) || "") || TRANSIENT_ERROR_STATUS_CODES.includes(((_a2 = error.$metadata) == null ? void 0 : _a2.httpStatusCode) || 0);
};
const isServerError = (error) => {
  var _a2;
  if (((_a2 = error.$metadata) == null ? void 0 : _a2.httpStatusCode) !== void 0) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
      return true;
    }
    return false;
  }
  return false;
};
class DefaultRateLimiter {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = (options == null ? void 0 : options.beta) ?? 0.7;
    this.minCapacity = (options == null ? void 0 : options.minCapacity) ?? 1;
    this.minFillRate = (options == null ? void 0 : options.minFillRate) ?? 0.5;
    this.scaleConstant = (options == null ? void 0 : options.scaleConstant) ?? 0.4;
    this.smooth = (options == null ? void 0 : options.smooth) ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay2 = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve) => setTimeout(resolve, delay2));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t2 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t2 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
}
const DEFAULT_RETRY_DELAY_BASE = 100;
const MAXIMUM_RETRY_DELAY = 20 * 1e3;
const THROTTLING_RETRY_DELAY_BASE = 500;
const INITIAL_RETRY_TOKENS = 500;
const RETRY_COST = 5;
const TIMEOUT_RETRY_COST = 10;
const NO_RETRY_INCREMENT = 1;
const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
const REQUEST_HEADER = "amz-sdk-request";
const getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay2) => {
    delayBase = delay2;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};
const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
  const getRetryCost = () => retryCost;
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
};
class StandardRetryStrategy {
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
}
class AdaptiveRetryStrategy {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
}
let getRandomValues$2;
const rnds8$1 = new Uint8Array(16);
function rng$1() {
  if (!getRandomValues$2) {
    getRandomValues$2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues$2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues$2(rnds8$1);
}
const byteToHex$1 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex$1.push((i + 256).toString(16).slice(1));
}
function unsafeStringify$1(arr, offset2 = 0) {
  return byteToHex$1[arr[offset2 + 0]] + byteToHex$1[arr[offset2 + 1]] + byteToHex$1[arr[offset2 + 2]] + byteToHex$1[arr[offset2 + 3]] + "-" + byteToHex$1[arr[offset2 + 4]] + byteToHex$1[arr[offset2 + 5]] + "-" + byteToHex$1[arr[offset2 + 6]] + byteToHex$1[arr[offset2 + 7]] + "-" + byteToHex$1[arr[offset2 + 8]] + byteToHex$1[arr[offset2 + 9]] + "-" + byteToHex$1[arr[offset2 + 10]] + byteToHex$1[arr[offset2 + 11]] + byteToHex$1[arr[offset2 + 12]] + byteToHex$1[arr[offset2 + 13]] + byteToHex$1[arr[offset2 + 14]] + byteToHex$1[arr[offset2 + 15]];
}
const randomUUID$1 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native$1 = {
  randomUUID: randomUUID$1
};
function v4$1(options, buf, offset2) {
  if (native$1.randomUUID && !buf && !options) {
    return native$1.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng$1)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify$1(rnds);
}
const asSdkError = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};
const resolveRetryConfig = (input2) => {
  const { retryStrategy } = input2;
  const maxAttempts = normalizeProvider$1(input2.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input2,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider$1(input2.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
};
class NoOpLogger {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
const getAllAliases = (name2, aliases) => {
  const _aliases = [];
  if (name2) {
    _aliases.push(name2);
  }
  if (aliases) {
    for (const alias of aliases) {
      _aliases.push(alias);
    }
  }
  return _aliases;
};
const getMiddlewareNameWithAliases = (name2, aliases) => {
  return `${name2 || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  let identifyOnResolve = false;
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = (entries) => entries.sort((a2, b2) => stepWeights[b2.step] - stepWeights[a2.step] || priorityWeights[b2.priority || "normal"] - priorityWeights[a2.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      const aliases = getAllAliases(entry.name, entry.aliases);
      if (aliases.includes(toRemove)) {
        isRemoved = true;
        for (const alias of aliases) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        for (const alias of getAllAliases(entry.name, entry.aliases)) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    var _a2;
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    (_a2 = toStack.identifyOnResolve) == null ? void 0 : _a2.call(toStack, stack.identifyOnResolve());
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug2 = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug2) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware, options = {}) => {
      const { name: name2, override, aliases: _aliases } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      const aliases = getAllAliases(name2, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name2, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = absoluteEntries.findIndex((entry2) => {
              var _a2;
              return entry2.name === alias || ((_a2 = entry2.aliases) == null ? void 0 : _a2.some((a2) => a2 === alias));
            });
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = absoluteEntries[toOverrideIndex];
            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name2, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
            }
            absoluteEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name: name2, override, aliases: _aliases } = options;
      const entry = {
        middleware,
        ...options
      };
      const aliases = getAllAliases(name2, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name2, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = relativeEntries.findIndex((entry2) => {
              var _a2;
              return entry2.name === alias || ((_a2 = entry2.aliases) == null ? void 0 : _a2.some((a2) => a2 === alias));
            });
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = relativeEntries[toOverrideIndex];
            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name2, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
            }
            relativeEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name: name2, aliases: _aliases } = entry;
        if (tags && tags.includes(toRemove)) {
          const aliases = getAllAliases(name2, _aliases);
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      var _a2;
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (((_a2 = from.identifyOnResolve) == null ? void 0 : _a2.call(from)) ?? false));
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
        return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
      });
    },
    identifyOnResolve(toggle) {
      if (typeof toggle === "boolean")
        identifyOnResolve = toggle;
      return identifyOnResolve;
    },
    resolve: (handler, context2) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware(handler, context2);
      }
      if (identifyOnResolve) {
        console.log(stack.identify());
      }
      return handler;
    }
  };
  return stack;
};
const stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
const priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};
class Client {
  constructor(config2) {
    this.middlewareStack = constructStack();
    this.config = config2;
  }
  send(command, optionsOrCb, cb2) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
}
const alphabetByEncoding = {};
const alphabetByValue = new Array(64);
for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
  const char = String.fromCharCode(i + start);
  alphabetByEncoding[char] = i;
  alphabetByValue[i] = char;
}
for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
  const char = String.fromCharCode(i + start);
  const index2 = i + 26;
  alphabetByEncoding[char] = index2;
  alphabetByValue[index2] = char;
}
for (let i = 0; i < 10; i++) {
  alphabetByEncoding[i.toString(10)] = i + 52;
  const char = i.toString(10);
  const index2 = i + 52;
  alphabetByEncoding[char] = index2;
  alphabetByValue[index2] = char;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
const bitsPerLetter = 6;
const bitsPerByte = 8;
const maxLetterValue = 63;
const fromBase64 = (input2) => {
  let totalByteLength = input2.length / 4 * 3;
  if (input2.slice(-2) === "==") {
    totalByteLength -= 2;
  } else if (input2.slice(-1) === "=") {
    totalByteLength--;
  }
  const out = new ArrayBuffer(totalByteLength);
  const dataView = new DataView(out);
  for (let i = 0; i < input2.length; i += 4) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i, limit = i + 3; j2 <= limit; j2++) {
      if (input2[j2] !== "=") {
        if (!(input2[j2] in alphabetByEncoding)) {
          throw new TypeError(`Invalid character ${input2[j2]} in base64 string.`);
        }
        bits |= alphabetByEncoding[input2[j2]] << (limit - j2) * bitsPerLetter;
        bitLength += bitsPerLetter;
      } else {
        bits >>= bitsPerLetter;
      }
    }
    const chunkOffset = i / 4 * 3;
    bits >>= bitLength % bitsPerByte;
    const byteLength2 = Math.floor(bitLength / bitsPerByte);
    for (let k2 = 0; k2 < byteLength2; k2++) {
      const offset2 = (byteLength2 - k2 - 1) * bitsPerByte;
      dataView.setUint8(chunkOffset + k2, (bits & 255 << offset2) >> offset2);
    }
  }
  return new Uint8Array(out);
};
const fromUtf8$3 = (input2) => new TextEncoder().encode(input2);
const toUint8Array = (data) => {
  if (typeof data === "string") {
    return fromUtf8$3(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};
const toUtf8$3 = (input2) => {
  if (typeof input2 === "string") {
    return input2;
  }
  if (typeof input2 !== "object" || typeof input2.byteOffset !== "number" || typeof input2.byteLength !== "number") {
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  }
  return new TextDecoder("utf-8").decode(input2);
};
function toBase64(_input) {
  let input2;
  if (typeof _input === "string") {
    input2 = fromUtf8$3(_input);
  } else {
    input2 = _input;
  }
  const isArrayLike = typeof input2 === "object" && typeof input2.length === "number";
  const isUint8Array = typeof input2 === "object" && typeof input2.byteOffset === "number" && typeof input2.byteLength === "number";
  if (!isArrayLike && !isUint8Array) {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  let str = "";
  for (let i = 0; i < input2.length; i += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i, limit = Math.min(i + 3, input2.length); j2 < limit; j2++) {
      bits |= input2[j2] << (limit - j2 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k2 = 1; k2 <= bitClusterCount; k2++) {
      const offset2 = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset2) >> offset2];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}
function transformToString(payload, encoding = "utf-8") {
  if (encoding === "base64") {
    return toBase64(payload);
  }
  return toUtf8$3(payload);
}
function transformFromString(str, encoding) {
  if (encoding === "base64") {
    return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
  }
  return Uint8ArrayBlobAdapter.mutate(fromUtf8$3(str));
}
class Uint8ArrayBlobAdapter extends Uint8Array {
  static fromString(source, encoding = "utf-8") {
    switch (typeof source) {
      case "string":
        return transformFromString(source, encoding);
      default:
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(source) {
    Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
    return source;
  }
  transformToString(encoding = "utf-8") {
    return transformToString(this, encoding);
  }
}
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`;
function buildQueryString(query) {
  const parts = [];
  for (let key2 of Object.keys(query).sort()) {
    const value = query[key2];
    key2 = escapeUri(key2);
    if (Array.isArray(value)) {
      for (let i = 0, iLen = value.length; i < iLen; i++) {
        parts.push(`${key2}=${escapeUri(value[i])}`);
      }
    } else {
      let qsEntry = key2;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
function requestTimeout(timeoutInMs = 0) {
  return new Promise((resolve, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}
const keepAliveSupport = {
  supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"))
};
class FetchHttpHandler {
  static create(instanceOrOptions) {
    if (typeof (instanceOrOptions == null ? void 0 : instanceOrOptions.handle) === "function") {
      return instanceOrOptions;
    }
    return new FetchHttpHandler(instanceOrOptions);
  }
  constructor(options) {
    if (typeof options === "function") {
      this.configProvider = options().then((opts) => opts || {});
    } else {
      this.config = options ?? {};
      this.configProvider = Promise.resolve(this.config);
    }
  }
  destroy() {
  }
  async handle(request, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    const requestTimeoutInMs = this.config.requestTimeout;
    const keepAlive = this.config.keepAlive === true;
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      const abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    let path = request.path;
    const queryString = buildQueryString(request.query || {});
    if (queryString) {
      path += `?${queryString}`;
    }
    if (request.fragment) {
      path += `#${request.fragment}`;
    }
    let auth2 = "";
    if (request.username != null || request.password != null) {
      const username = request.username ?? "";
      const password = request.password ?? "";
      auth2 = `${username}:${password}@`;
    }
    const { port, method } = request;
    const url = `${request.protocol}//${auth2}${request.hostname}${port ? `:${port}` : ""}${path}`;
    const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
    const requestOptions = {
      body,
      headers: new Headers(request.headers),
      method
    };
    if (body) {
      requestOptions.duplex = "half";
    }
    if (typeof AbortController !== "undefined") {
      requestOptions.signal = abortSignal;
    }
    if (keepAliveSupport.supported) {
      requestOptions.keepalive = keepAlive;
    }
    const fetchRequest = new Request(url, requestOptions);
    const raceOfPromises = [
      fetch(fetchRequest).then((response) => {
        const fetchHeaders = response.headers;
        const transformedHeaders = {};
        for (const pair of fetchHeaders.entries()) {
          transformedHeaders[pair[0]] = pair[1];
        }
        const hasReadableStream = response.body != void 0;
        if (!hasReadableStream) {
          return response.blob().then((body2) => ({
            response: new HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: body2
            })
          }));
        }
        return {
          response: new HttpResponse({
            headers: transformedHeaders,
            reason: response.statusText,
            statusCode: response.status,
            body: response.body
          })
        };
      }),
      requestTimeout(requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise((resolve, reject) => {
        abortSignal.onabort = () => {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }));
    }
    return Promise.race(raceOfPromises);
  }
  updateHttpClientConfig(key2, value) {
    this.config = void 0;
    this.configProvider = this.configProvider.then((config2) => {
      config2[key2] = value;
      return config2;
    });
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
const streamCollector = (stream) => {
  if (typeof Blob === "function" && stream instanceof Blob) {
    return collectBlob(stream);
  }
  return collectStream(stream);
};
async function collectBlob(blob) {
  const base64 = await readToBase64(blob);
  const arrayBuffer = fromBase64(base64);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  const chunks = [];
  const reader2 = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value } = await reader2.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset2 = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset2);
    offset2 += chunk.length;
  }
  return collected;
}
function readToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader2 = new FileReader();
    reader2.onloadend = () => {
      if (reader2.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = reader2.result ?? "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve(result.substring(dataOffset));
    };
    reader2.onabort = () => reject(new Error("Read aborted"));
    reader2.onerror = () => reject(reader2.error);
    reader2.readAsDataURL(blob);
  });
}
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
  let encodedByte = i.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = `0${encodedByte}`;
  }
  SHORT_TO_HEX[i] = encodedByte;
  HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i = 0; i < encoded.length; i += 2) {
    const encodedByte = encoded.slice(i, i + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes3) {
  let out = "";
  for (let i = 0; i < bytes3.byteLength; i++) {
    out += SHORT_TO_HEX[bytes3[i]];
  }
  return out;
}
const collectBody = async (streamBody = new Uint8Array(), context2) => {
  if (streamBody instanceof Uint8Array) {
    return Uint8ArrayBlobAdapter.mutate(streamBody);
  }
  if (!streamBody) {
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  }
  const fromContext = context2.streamCollector(streamBody);
  return Uint8ArrayBlobAdapter.mutate(await fromContext);
};
class Command {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder();
  }
  resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
    for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
      this.middlewareStack.use(mw);
    }
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      [SMITHY_CONTEXT_KEY]: {
        ...smithyContext
      },
      ...additionalContext
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
}
class ClassBuilder {
  constructor() {
    this._init = () => {
    };
    this._ep = {};
    this._middlewareFn = () => [];
    this._commandName = "";
    this._clientName = "";
    this._additionalContext = {};
    this._smithyContext = {};
    this._inputFilterSensitiveLog = (_) => _;
    this._outputFilterSensitiveLog = (_) => _;
    this._serializer = null;
    this._deserializer = null;
  }
  init(cb2) {
    this._init = cb2;
  }
  ep(endpointParameterInstructions) {
    this._ep = endpointParameterInstructions;
    return this;
  }
  m(middlewareSupplier) {
    this._middlewareFn = middlewareSupplier;
    return this;
  }
  s(service, operation, smithyContext = {}) {
    this._smithyContext = {
      service,
      operation,
      ...smithyContext
    };
    return this;
  }
  c(additionalContext = {}) {
    this._additionalContext = additionalContext;
    return this;
  }
  n(clientName, commandName) {
    this._clientName = clientName;
    this._commandName = commandName;
    return this;
  }
  f(inputFilter = (_) => _, outputFilter = (_) => _) {
    this._inputFilterSensitiveLog = inputFilter;
    this._outputFilterSensitiveLog = outputFilter;
    return this;
  }
  ser(serializer) {
    this._serializer = serializer;
    return this;
  }
  de(deserializer) {
    this._deserializer = deserializer;
    return this;
  }
  build() {
    const closure = this;
    let CommandRef;
    return CommandRef = class extends Command {
      static getEndpointParameterInstructions() {
        return closure._ep;
      }
      constructor(...[input2]) {
        super();
        this.serialize = closure._serializer;
        this.deserialize = closure._deserializer;
        this.input = input2 ?? {};
        closure._init(this);
      }
      resolveMiddleware(stack, configuration, options) {
        return this.resolveMiddlewareWithContext(stack, configuration, options, {
          CommandCtor: CommandRef,
          middlewareFn: closure._middlewareFn,
          clientName: closure._clientName,
          commandName: closure._commandName,
          inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
          outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
          smithyContext: closure._smithyContext,
          additionalContext: closure._additionalContext
        });
      }
    };
  }
}
const SENSITIVE_STRING = "***SensitiveInformation***";
class ServiceException extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
}
const decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v3]) => v3 !== void 0).forEach(([k2, v3]) => {
    if (exception[k2] == void 0 || exception[k2] === "") {
      exception[k2] = v3;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};
const throwDefaultError$1 = ({ output: output2, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata$1(output2);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: (parsedBody == null ? void 0 : parsedBody.code) || (parsedBody == null ? void 0 : parsedBody.Code) || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
  return ({ output: output2, parsedBody, errorCode }) => {
    throwDefaultError$1({ output: output2, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
};
const deserializeMetadata$1 = (output2) => ({
  httpStatusCode: output2.statusCode,
  requestId: output2.headers["x-amzn-requestid"] ?? output2.headers["x-amzn-request-id"] ?? output2.headers["x-amz-request-id"],
  extendedRequestId: output2.headers["x-amz-id-2"],
  cfId: output2.headers["x-amz-cf-id"]
});
const loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};
const getChecksumConfiguration = (runtimeConfig) => {
  const checksumAlgorithms = [];
  for (const id2 in AlgorithmId) {
    const algorithmId = AlgorithmId[id2];
    if (runtimeConfig[algorithmId] === void 0) {
      continue;
    }
    checksumAlgorithms.push({
      algorithmId: () => algorithmId,
      checksumConstructor: () => runtimeConfig[algorithmId]
    });
  }
  return {
    _checksumAlgorithms: checksumAlgorithms,
    addChecksumAlgorithm(algo) {
      this._checksumAlgorithms.push(algo);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
};
const resolveChecksumRuntimeConfig = (clientConfig) => {
  const runtimeConfig = {};
  clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
    runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
  });
  return runtimeConfig;
};
const getRetryConfiguration = (runtimeConfig) => {
  let _retryStrategy = runtimeConfig.retryStrategy;
  return {
    setRetryStrategy(retryStrategy) {
      _retryStrategy = retryStrategy;
    },
    retryStrategy() {
      return _retryStrategy;
    }
  };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
  const runtimeConfig = {};
  runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
  return runtimeConfig;
};
const getDefaultExtensionConfiguration = (runtimeConfig) => {
  return {
    ...getChecksumConfiguration(runtimeConfig),
    ...getRetryConfiguration(runtimeConfig)
  };
};
const resolveDefaultRuntimeConfig = (config2) => {
  return {
    ...resolveChecksumRuntimeConfig(config2),
    ...resolveRetryRuntimeConfig(config2)
  };
};
const StringWrapper = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);
const _json = (obj) => {
  if (obj == null) {
    return {};
  }
  if (Array.isArray(obj)) {
    return obj.filter((_) => _ != null).map(_json);
  }
  if (typeof obj === "object") {
    const target = {};
    for (const key2 of Object.keys(obj)) {
      if (obj[key2] == null) {
        continue;
      }
      target[key2] = _json(obj[key2]);
    }
    return target;
  }
  return obj;
};
const isStreamingPayload = (request) => (request == null ? void 0 : request.body) instanceof ReadableStream;
const retryMiddleware = (options) => (next, context2) => async (args) => {
  var _a2;
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context2["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request } = args;
    const isRequest = HttpRequest.isInstance(request);
    if (isRequest) {
      request.headers[INVOCATION_ID_HEADER] = v4$1();
    }
    while (true) {
      try {
        if (isRequest) {
          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output: output2 } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output2.$metadata.attempts = attempts + 1;
        output2.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output: output2 };
      } catch (e2) {
        const retryErrorInfo = getRetryErrorInfo(e2);
        lastError = asSdkError(e2);
        if (isRequest && isStreamingPayload(request)) {
          (_a2 = context2.logger instanceof NoOpLogger ? console : context2.logger) == null ? void 0 : _a2.warn("An error was encountered in a non-retryable streaming request.");
          throw lastError;
        }
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay2 = retryToken.getRetryDelay();
        totalRetryDelay += delay2;
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy == null ? void 0 : retryStrategy.mode)
      context2.userAgent = [...context2.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error) => {
  const errorInfo = {
    error,
    errorType: getRetryErrorType(error)
  };
  const retryAfterHint = getRetryAfterHint(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
const getRetryErrorType = (error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
const retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
const getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
});
const getRetryAfterHint = (response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key2) => key2.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};
const httpSigningMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["HTTP_SIGNING"],
  name: "httpSigningMiddleware",
  aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
  override: true,
  relation: "after",
  toMiddleware: retryMiddlewareOptions.name
};
const getHttpSigningPlugin = (config2) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
  }
});
class DefaultIdentityProviderConfig {
  constructor(config2) {
    this.authSchemes = /* @__PURE__ */ new Map();
    for (const [key2, value] of Object.entries(config2)) {
      if (value !== void 0) {
        this.authSchemes.set(key2, value);
      }
    }
  }
  getIdentityProvider(schemeId) {
    return this.authSchemes.get(schemeId);
  }
}
class NoAuthSigner {
  async sign(httpRequest, identity, signingProperties) {
    return httpRequest;
  }
}
const createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
const EXPIRATION_MS = 3e5;
const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
const doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;
const memoizeIdentityProvider = (provider2, isExpired, requiresRefresh) => {
  if (provider2 === void 0) {
    return void 0;
  }
  const normalizedProvider = typeof provider2 !== "function" ? async () => Promise.resolve(provider2) : provider2;
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async (options) => {
    if (!pending) {
      pending = normalizedProvider(options);
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
        resolved = await coalesceProvider(options);
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
      resolved = await coalesceProvider(options);
    }
    if (isConstant) {
      return resolved;
    }
    if (!requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider(options);
      return resolved;
    }
    return resolved;
  };
};
const normalizeProvider = (input2) => {
  if (typeof input2 === "function")
    return input2;
  const promisified = Promise.resolve(input2);
  return () => promisified;
};
const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
const contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
const getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});
const getDateHeader = (response) => {
  var _a2, _b2;
  return HttpResponse.isInstance(response) ? ((_a2 = response.headers) == null ? void 0 : _a2.date) ?? ((_b2 = response.headers) == null ? void 0 : _b2.Date) : void 0;
};
const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
const isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};
const throwSigningPropertyError = (name2, property) => {
  if (!property) {
    throw new Error(`Property \`${name2}\` is not resolved for AWS SDK SigV4Auth`);
  }
  return property;
};
const validateSigningProperties = async (signingProperties) => {
  var _a2, _b2, _c2;
  const context2 = throwSigningPropertyError("context", signingProperties.context);
  const config2 = throwSigningPropertyError("config", signingProperties.config);
  const authScheme = (_c2 = (_b2 = (_a2 = context2.endpointV2) == null ? void 0 : _a2.properties) == null ? void 0 : _b2.authSchemes) == null ? void 0 : _c2[0];
  const signerFunction = throwSigningPropertyError("signer", config2.signer);
  const signer2 = await signerFunction(authScheme);
  const signingRegion = signingProperties == null ? void 0 : signingProperties.signingRegion;
  const signingName = signingProperties == null ? void 0 : signingProperties.signingName;
  return {
    config: config2,
    signer: signer2,
    signingRegion,
    signingName
  };
};
class AwsSdkSigV4Signer {
  async sign(httpRequest, identity, signingProperties) {
    if (!HttpRequest.isInstance(httpRequest)) {
      throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
    }
    const { config: config2, signer: signer2, signingRegion, signingName } = await validateSigningProperties(signingProperties);
    const signedRequest = await signer2.sign(httpRequest, {
      signingDate: getSkewCorrectedDate(config2.systemClockOffset),
      signingRegion,
      signingService: signingName
    });
    return signedRequest;
  }
  errorHandler(signingProperties) {
    return (error) => {
      const serverTime = error.ServerTime ?? getDateHeader(error.$response);
      if (serverTime) {
        const config2 = throwSigningPropertyError("config", signingProperties.config);
        const initialSystemClockOffset = config2.systemClockOffset;
        config2.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config2.systemClockOffset);
        const clockSkewCorrected = config2.systemClockOffset !== initialSystemClockOffset;
        if (clockSkewCorrected && error.$metadata) {
          error.$metadata.clockSkewCorrected = true;
        }
      }
      throw error;
    };
  }
  successHandler(httpResponse, signingProperties) {
    const dateHeader = getDateHeader(httpResponse);
    if (dateHeader) {
      const config2 = throwSigningPropertyError("config", signingProperties.config);
      config2.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config2.systemClockOffset);
    }
  }
}
const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
const AUTH_HEADER = "authorization";
const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
const DATE_HEADER = "date";
const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
const SHA256_HEADER = "x-amz-content-sha256";
const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
const ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
const PROXY_HEADER_PATTERN = /^proxy-/;
const SEC_HEADER_PATTERN = /^sec-/;
const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
const MAX_CACHE_SIZE = 50;
const KEY_TYPE_IDENTIFIER = "aws4_request";
const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
  const credsHash = await hmac2(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
  const cacheKey2 = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
  if (cacheKey2 in signingKeyCache) {
    return signingKeyCache[cacheKey2];
  }
  cacheQueue.push(cacheKey2);
  while (cacheQueue.length > MAX_CACHE_SIZE) {
    delete signingKeyCache[cacheQueue.shift()];
  }
  let key2 = `AWS4${credentials.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
    key2 = await hmac2(sha256Constructor, key2, signable);
  }
  return signingKeyCache[cacheKey2] = key2;
};
const hmac2 = (ctor, secret, data) => {
  const hash2 = new ctor(secret);
  hash2.update(toUint8Array(data));
  return hash2.digest();
};
const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders == null ? void 0 : unsignableHeaders.has(canonicalHeaderName)) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};
const getCanonicalQuery = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key2 of Object.keys(query).sort()) {
    if (key2.toLowerCase() === SIGNATURE_HEADER) {
      continue;
    }
    keys.push(key2);
    const value = query[key2];
    if (typeof value === "string") {
      serialized[key2] = `${escapeUri(key2)}=${escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key2] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${escapeUri(key2)}=${escapeUri(value2)}`]), []).sort().join("&");
    }
  }
  return keys.map((key2) => serialized[key2]).filter((serialized2) => serialized2).join("&");
};
const isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
const getPayloadHash = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER) {
      return headers[headerName];
    }
  }
  if (body == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array(body));
    return toHex(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD;
};
class HeaderFormatter {
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes3 = fromUtf8$3(headerName);
      chunks.push(Uint8Array.from([bytes3.byteLength]), bytes3, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes3) => carry + bytes3.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = fromUtf8$3(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
}
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE2) {
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
class Int64 {
  constructor(bytes3) {
    this.bytes = bytes3;
    if (bytes3.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number2) {
    if (number2 > 9223372036854776e3 || number2 < -9223372036854776e3) {
      throw new Error(`${number2} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes3 = new Uint8Array(8);
    for (let i = 7, remaining = Math.abs(Math.round(number2)); i > -1 && remaining > 0; i--, remaining /= 256) {
      bytes3[i] = remaining;
    }
    if (number2 < 0) {
      negate(bytes3);
    }
    return new Int64(bytes3);
  }
  valueOf() {
    const bytes3 = this.bytes.slice(0);
    const negative = bytes3[0] & 128;
    if (negative) {
      negate(bytes3);
    }
    return parseInt(toHex(bytes3), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function negate(bytes3) {
  for (let i = 0; i < 8; i++) {
    bytes3[i] ^= 255;
  }
  for (let i = 7; i > -1; i--) {
    bytes3[i]++;
    if (bytes3[i] !== 0)
      break;
  }
}
const hasHeader = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};
const cloneRequest = ({ headers, query, ...rest }) => ({
  ...rest,
  headers: { ...headers },
  query: query ? cloneQuery(query) : void 0
});
const cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
  const param = query[paramName];
  return {
    ...carry,
    [paramName]: Array.isArray(param) ? [...param] : param
  };
}, {});
const moveHeadersToQuery = (request, options = {}) => {
  var _a2;
  const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
  for (const name2 of Object.keys(headers)) {
    const lname = name2.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !((_a2 = options.unhoistableHeaders) == null ? void 0 : _a2.has(lname))) {
      query[name2] = headers[name2];
      delete headers[name2];
    }
  }
  return {
    ...request,
    headers,
    query
  };
};
const prepareRequest = (request) => {
  request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
  for (const headerName of Object.keys(request.headers)) {
    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
      delete request.headers[headerName];
    }
  }
  return request;
};
const iso8601 = (time2) => toDate(time2).toISOString().replace(/\.\d{3}Z$/, "Z");
const toDate = (time2) => {
  if (typeof time2 === "number") {
    return new Date(time2 * 1e3);
  }
  if (typeof time2 === "string") {
    if (Number(time2)) {
      return new Date(Number(time2) * 1e3);
    }
    return new Date(time2);
  }
  return time2;
};
class SignatureV4 {
  constructor({ applyChecksum, credentials, region, service, sha256: sha2562, uriEscapePath = true }) {
    this.headerFormatter = new HeaderFormatter();
    this.service = service;
    this.sha256 = sha2562;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider$1(region);
    this.credentialProvider = normalizeProvider$1(credentials);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
    if (credentials.sessionToken) {
      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
    }
    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
    request.query[AMZ_DATE_QUERY_PARAM] = longDate;
    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
    return request;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else if (toSign.message) {
      return this.signMessage(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
    const hash2 = new this.sha256();
    hash2.update(headers);
    const hashedHeaders = toHex(await hash2.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
    const promise = this.signEvent({
      headers: this.headerFormatter.format(signableMessage.message.headers),
      payload: signableMessage.message.body
    }, {
      signingDate,
      signingRegion,
      signingService,
      priorSignature: signableMessage.priorSignature
    });
    return promise.then((signature2) => {
      return { message: signableMessage.message, signature: signature2 };
    });
  }
  async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate(signingDate);
    const hash2 = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const request = prepareRequest(requestToSign);
    const { longDate, shortDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    request.headers[AMZ_DATE_HEADER] = longDate;
    if (credentials.sessionToken) {
      request.headers[TOKEN_HEADER] = credentials.sessionToken;
    }
    const payloadHash = await getPayloadHash(request, this.sha256);
    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
      request.headers[SHA256_HEADER] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    const signature2 = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature2}`;
    return request;
  }
  createCanonicalRequest(request, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name2) => `${name2}:${canonicalHeaders[name2]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash2 = new this.sha256();
    hash2.update(toUint8Array(canonicalRequest));
    const hashedRequest = await hash2.digest();
    return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
  }
  getCanonicalPath({ path }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path.split("/")) {
        if ((pathSegment == null ? void 0 : pathSegment.length) === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${(path == null ? void 0 : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path == null ? void 0 : path.endsWith("/")) ? "/" : ""}`;
      const doubleEncoded = escapeUri(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash2 = new this.sha256(await keyPromise);
    hash2.update(toUint8Array(stringToSign));
    return toHex(await hash2.digest());
  }
  getSigningKey(credentials, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials) {
    if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
}
const formatDate = (now2) => {
  const longDate = iso8601(now2).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");
const resolveAwsSdkSigV4Config = (config2) => {
  let normalizedCreds;
  if (config2.credentials) {
    normalizedCreds = memoizeIdentityProvider(config2.credentials, isIdentityExpired, doesIdentityRequireRefresh);
  }
  if (!normalizedCreds) {
    if (config2.credentialDefaultProvider) {
      normalizedCreds = normalizeProvider(config2.credentialDefaultProvider(Object.assign({}, config2, {
        parentClientConfig: config2
      })));
    } else {
      normalizedCreds = async () => {
        throw new Error("`credentials` is missing");
      };
    }
  }
  const { signingEscapePath = true, systemClockOffset = config2.systemClockOffset || 0, sha256: sha2562 } = config2;
  let signer2;
  if (config2.signer) {
    signer2 = normalizeProvider(config2.signer);
  } else if (config2.regionInfoProvider) {
    signer2 = () => normalizeProvider(config2.region)().then(async (region) => [
      await config2.regionInfoProvider(region, {
        useFipsEndpoint: await config2.useFipsEndpoint(),
        useDualstackEndpoint: await config2.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      config2.signingRegion = config2.signingRegion || signingRegion || region;
      config2.signingName = config2.signingName || signingService || config2.serviceId;
      const params = {
        ...config2,
        credentials: normalizedCreds,
        region: config2.signingRegion,
        service: config2.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config2.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    });
  } else {
    signer2 = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: config2.signingName || config2.defaultSigningName,
        signingRegion: await normalizeProvider(config2.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      config2.signingRegion = config2.signingRegion || signingRegion;
      config2.signingName = config2.signingName || signingService || config2.serviceId;
      const params = {
        ...config2,
        credentials: normalizedCreds,
        region: config2.signingRegion,
        service: config2.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = config2.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    };
  }
  return {
    ...config2,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer: signer2
  };
};
const collectBodyString = (streamBody, context2) => collectBody(streamBody, context2).then((body) => context2.utf8Encoder(body));
const parseJsonBody = (streamBody, context2) => collectBodyString(streamBody, context2).then((encoded) => {
  if (encoded.length) {
    try {
      return JSON.parse(encoded);
    } catch (e2) {
      if ((e2 == null ? void 0 : e2.name) === "SyntaxError") {
        Object.defineProperty(e2, "$responseBodyText", {
          value: encoded
        });
      }
      throw e2;
    }
  }
  return {};
});
const parseJsonErrorBody = async (errorBody, context2) => {
  const value = await parseJsonBody(errorBody, context2);
  value.message = value.message ?? value.Message;
  return value;
};
const loadRestJsonErrorCode = (output2, data) => {
  const findKey = (object, key2) => Object.keys(object).find((k2) => k2.toLowerCase() === key2.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output2.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output2.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
};
const defaultCognitoIdentityProviderHttpAuthSchemeParametersProvider = async (config2, context2, input2) => {
  return {
    operation: getSmithyContext(context2).operation,
    region: await normalizeProvider$1(config2.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "cognito-idp",
      region: authParameters.region
    },
    propertiesExtractor: (config2, context2) => ({
      signingProperties: {
        config: config2,
        context: context2
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
const defaultCognitoIdentityProviderHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "AssociateSoftwareToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ChangePassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ConfirmDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ConfirmForgotPassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ConfirmSignUp": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "DeleteUser": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "DeleteUserAttributes": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ForgetDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ForgotPassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GetDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GetUser": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GetUserAttributeVerificationCode": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "GlobalSignOut": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "InitiateAuth": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ListDevices": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "ResendConfirmationCode": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "RespondToAuthChallenge": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "RevokeToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "SetUserMFAPreference": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "SetUserSettings": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "SignUp": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "UpdateAuthEventFeedback": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "UpdateDeviceStatus": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "UpdateUserAttributes": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "VerifySoftwareToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    case "VerifyUserAttribute": {
      options.push(createSmithyApiNoAuthHttpAuthOption());
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
    }
  }
  return options;
};
const resolveHttpAuthSchemeConfig = (config2) => {
  const config_0 = resolveAwsSdkSigV4Config(config2);
  return {
    ...config_0
  };
};
const resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "cognito-idp"
  };
};
const commonParams = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
const name = "@aws-sdk/client-cognito-identity-provider";
const description = "AWS SDK for JavaScript Cognito Identity Provider Client for Node.js, Browser and React Native";
const version = "3.582.0";
const scripts = {
  build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
  "build:cjs": "node ../../scripts/compilation/inline client-cognito-identity-provider",
  "build:es": "tsc -p tsconfig.es.json",
  "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
  "build:types": "tsc -p tsconfig.types.json",
  "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
  clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
  "extract:docs": "api-extractor run --local",
  "generate:client": "node ../../scripts/generate-clients/single-service --solo cognito-identity-provider"
};
const main = "./dist-cjs/index.js";
const types = "./dist-types/index.d.ts";
const module = "./dist-es/index.js";
const sideEffects = false;
const dependencies = {
  "@aws-crypto/sha256-browser": "3.0.0",
  "@aws-crypto/sha256-js": "3.0.0",
  "@aws-sdk/client-sso-oidc": "3.582.0",
  "@aws-sdk/client-sts": "3.582.0",
  "@aws-sdk/core": "3.582.0",
  "@aws-sdk/credential-provider-node": "3.582.0",
  "@aws-sdk/middleware-host-header": "3.577.0",
  "@aws-sdk/middleware-logger": "3.577.0",
  "@aws-sdk/middleware-recursion-detection": "3.577.0",
  "@aws-sdk/middleware-user-agent": "3.577.0",
  "@aws-sdk/region-config-resolver": "3.577.0",
  "@aws-sdk/types": "3.577.0",
  "@aws-sdk/util-endpoints": "3.577.0",
  "@aws-sdk/util-user-agent-browser": "3.577.0",
  "@aws-sdk/util-user-agent-node": "3.577.0",
  "@smithy/config-resolver": "^3.0.0",
  "@smithy/core": "^2.0.1",
  "@smithy/fetch-http-handler": "^3.0.1",
  "@smithy/hash-node": "^3.0.0",
  "@smithy/invalid-dependency": "^3.0.0",
  "@smithy/middleware-content-length": "^3.0.0",
  "@smithy/middleware-endpoint": "^3.0.0",
  "@smithy/middleware-retry": "^3.0.1",
  "@smithy/middleware-serde": "^3.0.0",
  "@smithy/middleware-stack": "^3.0.0",
  "@smithy/node-config-provider": "^3.0.0",
  "@smithy/node-http-handler": "^3.0.0",
  "@smithy/protocol-http": "^4.0.0",
  "@smithy/smithy-client": "^3.0.1",
  "@smithy/types": "^3.0.0",
  "@smithy/url-parser": "^3.0.0",
  "@smithy/util-base64": "^3.0.0",
  "@smithy/util-body-length-browser": "^3.0.0",
  "@smithy/util-body-length-node": "^3.0.0",
  "@smithy/util-defaults-mode-browser": "^3.0.1",
  "@smithy/util-defaults-mode-node": "^3.0.1",
  "@smithy/util-endpoints": "^2.0.0",
  "@smithy/util-middleware": "^3.0.0",
  "@smithy/util-retry": "^3.0.0",
  "@smithy/util-utf8": "^3.0.0",
  tslib: "^2.6.2"
};
const devDependencies = {
  "@tsconfig/node16": "16.1.3",
  "@types/node": "^16.18.96",
  concurrently: "7.0.0",
  "downlevel-dts": "0.10.1",
  rimraf: "3.0.2",
  typescript: "~4.9.5"
};
const engines = {
  node: ">=16.0.0"
};
const typesVersions = {
  "<4.0": {
    "dist-types/*": [
      "dist-types/ts3.4/*"
    ]
  }
};
const files = [
  "dist-*/**"
];
const author = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
};
const license = "Apache-2.0";
const browser = {
  "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
const homepage = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity-provider";
const repository = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-cognito-identity-provider"
};
const packageInfo = {
  name,
  description,
  version,
  scripts,
  main,
  types,
  module,
  sideEffects,
  dependencies,
  devDependencies,
  engines,
  typesVersions,
  files,
  author,
  license,
  browser,
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage,
  repository
};
var build$4 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __decorate(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v3) {
      return step([n2, v3]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p2 in m2)
    if (p2 !== "default" && !exports.hasOwnProperty(p2))
      exports[p2] = m2[p2];
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s2 += arguments[i].length;
  for (var r2 = Array(s2), k2 = 0, i = 0; i < il2; i++)
    for (var a2 = arguments[i], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __await(v3) {
  return this instanceof __await ? (this.v = v3, this) : new __await(v3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v3) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v3, a2, b2]) > 1 || resume(n2, v3);
        });
      };
  }
  function resume(n2, v3) {
    try {
      step(g2[n2](v3));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v3) {
    if (f2(v3), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v3) {
      return (p2 = !p2) ? { value: __await(o2[n2](v3)), done: n2 === "return" } : f2 ? f2(v3) : v3;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o2[n2](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d2, v3) {
    Promise.resolve(v3).then(function(v5) {
      resolve({ value: v5, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule)
    return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k2 in mod2)
      if (Object.hasOwnProperty.call(mod2, k2))
        result[k2] = mod2[k2];
  }
  result.default = mod2;
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var crossPlatformSha256 = {};
var ie11Sha256 = {};
var isEmptyData$1 = {};
var hasRequiredIsEmptyData$1;
function requireIsEmptyData$1() {
  if (hasRequiredIsEmptyData$1)
    return isEmptyData$1;
  hasRequiredIsEmptyData$1 = 1;
  Object.defineProperty(isEmptyData$1, "__esModule", { value: true });
  isEmptyData$1.isEmptyData = void 0;
  function isEmptyData2(data) {
    if (typeof data === "string") {
      return data.length === 0;
    }
    return data.byteLength === 0;
  }
  isEmptyData$1.isEmptyData = isEmptyData2;
  return isEmptyData$1;
}
var constants$1 = {};
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1)
    return constants$1;
  hasRequiredConstants$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
    exports.SHA_256_HASH = { name: "SHA-256" };
    exports.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: exports.SHA_256_HASH
    };
    exports.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  })(constants$1);
  return constants$1;
}
const fromUtf8$2 = (input2) => {
  const bytes3 = [];
  for (let i = 0, len = input2.length; i < len; i++) {
    const value = input2.charCodeAt(i);
    if (value < 128) {
      bytes3.push(value);
    } else if (value < 2048) {
      bytes3.push(value >> 6 | 192, value & 63 | 128);
    } else if (i + 1 < input2.length && (value & 64512) === 55296 && (input2.charCodeAt(i + 1) & 64512) === 56320) {
      const surrogatePair = 65536 + ((value & 1023) << 10) + (input2.charCodeAt(++i) & 1023);
      bytes3.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
    } else {
      bytes3.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
    }
  }
  return Uint8Array.from(bytes3);
};
const toUtf8$2 = (input2) => {
  let decoded = "";
  for (let i = 0, len = input2.length; i < len; i++) {
    const byte = input2[i];
    if (byte < 128) {
      decoded += String.fromCharCode(byte);
    } else if (192 <= byte && byte < 224) {
      const nextByte = input2[++i];
      decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
    } else if (240 <= byte && byte < 365) {
      const surrogatePair = [byte, input2[++i], input2[++i], input2[++i]];
      const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
      decoded += decodeURIComponent(encoded);
    } else {
      decoded += String.fromCharCode((byte & 15) << 12 | (input2[++i] & 63) << 6 | input2[++i] & 63);
    }
  }
  return decoded;
};
function fromUtf8$1(input2) {
  return new TextEncoder().encode(input2);
}
function toUtf8$1(input2) {
  return new TextDecoder("utf-8").decode(input2);
}
const fromUtf8 = (input2) => typeof TextEncoder === "function" ? fromUtf8$1(input2) : fromUtf8$2(input2);
const toUtf8 = (input2) => typeof TextDecoder === "function" ? toUtf8$1(input2) : toUtf8$2(input2);
const distEs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromUtf8,
  toUtf8
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(distEs$1);
const fallbackWindow = {};
function locateWindow() {
  if (typeof window !== "undefined") {
    return window;
  } else if (typeof self !== "undefined") {
    return self;
  }
  return fallbackWindow;
}
const distEs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  locateWindow
}, Symbol.toStringTag, { value: "Module" }));
const require$$5$1 = /* @__PURE__ */ getAugmentedNamespace(distEs);
var hasRequiredIe11Sha256;
function requireIe11Sha256() {
  if (hasRequiredIe11Sha256)
    return ie11Sha256;
  hasRequiredIe11Sha256 = 1;
  Object.defineProperty(ie11Sha256, "__esModule", { value: true });
  ie11Sha256.Sha256 = void 0;
  var isEmptyData_1 = requireIsEmptyData$1();
  var constants_1 = requireConstants$1();
  var util_utf8_browser_1 = require$$0$1;
  var util_locate_window_1 = require$$5$1;
  var Sha256 = (
    /** @class */
    function() {
      function Sha2562(secret) {
        this.secret = secret;
        this.reset();
      }
      Sha2562.prototype.update = function(toHash) {
        var _this = this;
        if ((0, isEmptyData_1.isEmptyData)(toHash)) {
          return;
        }
        this.operation = this.operation.then(function(operation) {
          operation.onerror = function() {
            _this.operation = Promise.reject(new Error("Error encountered updating hash"));
          };
          operation.process(toArrayBufferView(toHash));
          return operation;
        });
        this.operation.catch(function() {
        });
      };
      Sha2562.prototype.digest = function() {
        return this.operation.then(function(operation) {
          return new Promise(function(resolve, reject) {
            operation.onerror = function() {
              reject(new Error("Error encountered finalizing hash"));
            };
            operation.oncomplete = function() {
              if (operation.result) {
                resolve(new Uint8Array(operation.result));
              }
              reject(new Error("Error encountered finalizing hash"));
            };
            operation.finish();
          });
        });
      };
      Sha2562.prototype.reset = function() {
        if (this.secret) {
          this.operation = getKeyPromise(this.secret).then(function(keyData) {
            return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
          });
          this.operation.catch(function() {
          });
        } else {
          this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
        }
      };
      return Sha2562;
    }()
  );
  ie11Sha256.Sha256 = Sha256;
  function getKeyPromise(secret) {
    return new Promise(function(resolve, reject) {
      var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
      keyOperation.oncomplete = function() {
        if (keyOperation.result) {
          resolve(keyOperation.result);
        }
        reject(new Error("ImportKey completed without importing key."));
      };
      keyOperation.onerror = function() {
        reject(new Error("ImportKey failed to import key."));
      };
    });
  }
  function toArrayBufferView(data) {
    if (typeof data === "string") {
      return (0, util_utf8_browser_1.fromUtf8)(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }
  return ie11Sha256;
}
var webCryptoSha256 = {};
var build$3 = {};
var convertToBuffer = {};
var hasRequiredConvertToBuffer;
function requireConvertToBuffer() {
  if (hasRequiredConvertToBuffer)
    return convertToBuffer;
  hasRequiredConvertToBuffer = 1;
  Object.defineProperty(convertToBuffer, "__esModule", { value: true });
  convertToBuffer.convertToBuffer = void 0;
  var util_utf8_browser_1 = require$$0$1;
  var fromUtf82 = typeof Buffer2 !== "undefined" && Buffer2.from ? function(input2) {
    return Buffer2.from(input2, "utf8");
  } : util_utf8_browser_1.fromUtf8;
  function convertToBuffer$1(data) {
    if (data instanceof Uint8Array)
      return data;
    if (typeof data === "string") {
      return fromUtf82(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }
  convertToBuffer.convertToBuffer = convertToBuffer$1;
  return convertToBuffer;
}
var isEmptyData = {};
var hasRequiredIsEmptyData;
function requireIsEmptyData() {
  if (hasRequiredIsEmptyData)
    return isEmptyData;
  hasRequiredIsEmptyData = 1;
  Object.defineProperty(isEmptyData, "__esModule", { value: true });
  isEmptyData.isEmptyData = void 0;
  function isEmptyData$12(data) {
    if (typeof data === "string") {
      return data.length === 0;
    }
    return data.byteLength === 0;
  }
  isEmptyData.isEmptyData = isEmptyData$12;
  return isEmptyData;
}
var numToUint8 = {};
var hasRequiredNumToUint8;
function requireNumToUint8() {
  if (hasRequiredNumToUint8)
    return numToUint8;
  hasRequiredNumToUint8 = 1;
  Object.defineProperty(numToUint8, "__esModule", { value: true });
  numToUint8.numToUint8 = void 0;
  function numToUint8$1(num) {
    return new Uint8Array([
      (num & 4278190080) >> 24,
      (num & 16711680) >> 16,
      (num & 65280) >> 8,
      num & 255
    ]);
  }
  numToUint8.numToUint8 = numToUint8$1;
  return numToUint8;
}
var uint32ArrayFrom = {};
var hasRequiredUint32ArrayFrom;
function requireUint32ArrayFrom() {
  if (hasRequiredUint32ArrayFrom)
    return uint32ArrayFrom;
  hasRequiredUint32ArrayFrom = 1;
  Object.defineProperty(uint32ArrayFrom, "__esModule", { value: true });
  uint32ArrayFrom.uint32ArrayFrom = void 0;
  function uint32ArrayFrom$1(a_lookUpTable) {
    if (!Uint32Array.from) {
      var return_array = new Uint32Array(a_lookUpTable.length);
      var a_index = 0;
      while (a_index < a_lookUpTable.length) {
        return_array[a_index] = a_lookUpTable[a_index];
        a_index += 1;
      }
      return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
  }
  uint32ArrayFrom.uint32ArrayFrom = uint32ArrayFrom$1;
  return uint32ArrayFrom;
}
var hasRequiredBuild$3;
function requireBuild$3() {
  if (hasRequiredBuild$3)
    return build$3;
  hasRequiredBuild$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = requireConvertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = requireIsEmptyData();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = requireNumToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = requireUint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  })(build$3);
  return build$3;
}
var hasRequiredWebCryptoSha256;
function requireWebCryptoSha256() {
  if (hasRequiredWebCryptoSha256)
    return webCryptoSha256;
  hasRequiredWebCryptoSha256 = 1;
  Object.defineProperty(webCryptoSha256, "__esModule", { value: true });
  webCryptoSha256.Sha256 = void 0;
  var util_1 = requireBuild$3();
  var constants_1 = requireConstants$1();
  var util_locate_window_1 = require$$5$1;
  var Sha256 = (
    /** @class */
    function() {
      function Sha2562(secret) {
        this.toHash = new Uint8Array(0);
        this.secret = secret;
        this.reset();
      }
      Sha2562.prototype.update = function(data) {
        if ((0, util_1.isEmptyData)(data)) {
          return;
        }
        var update5 = (0, util_1.convertToBuffer)(data);
        var typedArray = new Uint8Array(this.toHash.byteLength + update5.byteLength);
        typedArray.set(this.toHash, 0);
        typedArray.set(update5, this.toHash.byteLength);
        this.toHash = typedArray;
      };
      Sha2562.prototype.digest = function() {
        var _this = this;
        if (this.key) {
          return this.key.then(function(key2) {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key2, _this.toHash).then(function(data) {
              return new Uint8Array(data);
            });
          });
        }
        if ((0, util_1.isEmptyData)(this.toHash)) {
          return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
        }
        return Promise.resolve().then(function() {
          return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
        }).then(function(data) {
          return Promise.resolve(new Uint8Array(data));
        });
      };
      Sha2562.prototype.reset = function() {
        var _this = this;
        this.toHash = new Uint8Array(0);
        if (this.secret && this.secret !== void 0) {
          this.key = new Promise(function(resolve, reject) {
            (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
          });
          this.key.catch(function() {
          });
        }
      };
      return Sha2562;
    }()
  );
  webCryptoSha256.Sha256 = Sha256;
  return webCryptoSha256;
}
var build$2 = {};
var jsSha256 = {};
var constants = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants;
  hasRequiredConstants = 1;
  Object.defineProperty(constants, "__esModule", { value: true });
  constants.MAX_HASHABLE_LENGTH = constants.INIT = constants.KEY = constants.DIGEST_LENGTH = constants.BLOCK_SIZE = void 0;
  constants.BLOCK_SIZE = 64;
  constants.DIGEST_LENGTH = 32;
  constants.KEY = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  constants.INIT = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  constants.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
  return constants;
}
var RawSha256 = {};
var hasRequiredRawSha256;
function requireRawSha256() {
  if (hasRequiredRawSha256)
    return RawSha256;
  hasRequiredRawSha256 = 1;
  Object.defineProperty(RawSha256, "__esModule", { value: true });
  RawSha256.RawSha256 = void 0;
  var constants_1 = requireConstants();
  var RawSha256$1 = (
    /** @class */
    function() {
      function RawSha2562() {
        this.state = Int32Array.from(constants_1.INIT);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(64);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
      }
      RawSha2562.prototype.update = function(data) {
        if (this.finished) {
          throw new Error("Attempted to update an already finished hash.");
        }
        var position = 0;
        var byteLength2 = data.byteLength;
        this.bytesHashed += byteLength2;
        if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        while (byteLength2 > 0) {
          this.buffer[this.bufferLength++] = data[position++];
          byteLength2--;
          if (this.bufferLength === constants_1.BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
          }
        }
      };
      RawSha2562.prototype.digest = function() {
        if (!this.finished) {
          var bitsHashed = this.bytesHashed * 8;
          var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
          var undecoratedLength = this.bufferLength;
          bufferView.setUint8(this.bufferLength++, 128);
          if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {
              bufferView.setUint8(i, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
          }
          for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {
            bufferView.setUint8(i, 0);
          }
          bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
          bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
          this.hashBuffer();
          this.finished = true;
        }
        var out = new Uint8Array(constants_1.DIGEST_LENGTH);
        for (var i = 0; i < 8; i++) {
          out[i * 4] = this.state[i] >>> 24 & 255;
          out[i * 4 + 1] = this.state[i] >>> 16 & 255;
          out[i * 4 + 2] = this.state[i] >>> 8 & 255;
          out[i * 4 + 3] = this.state[i] >>> 0 & 255;
        }
        return out;
      };
      RawSha2562.prototype.hashBuffer = function() {
        var _a2 = this, buffer2 = _a2.buffer, state = _a2.state;
        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
        for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
          if (i < 16) {
            this.temp[i] = (buffer2[i * 4] & 255) << 24 | (buffer2[i * 4 + 1] & 255) << 16 | (buffer2[i * 4 + 2] & 255) << 8 | buffer2[i * 4 + 3] & 255;
          } else {
            var u2 = this.temp[i - 2];
            var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
            u2 = this.temp[i - 15];
            var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
            this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
          }
          var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;
          var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
          state7 = state6;
          state6 = state5;
          state5 = state4;
          state4 = state3 + t1 | 0;
          state3 = state2;
          state2 = state1;
          state1 = state0;
          state0 = t1 + t2 | 0;
        }
        state[0] += state0;
        state[1] += state1;
        state[2] += state2;
        state[3] += state3;
        state[4] += state4;
        state[5] += state5;
        state[6] += state6;
        state[7] += state7;
      };
      return RawSha2562;
    }()
  );
  RawSha256.RawSha256 = RawSha256$1;
  return RawSha256;
}
var hasRequiredJsSha256;
function requireJsSha256() {
  if (hasRequiredJsSha256)
    return jsSha256;
  hasRequiredJsSha256 = 1;
  Object.defineProperty(jsSha256, "__esModule", { value: true });
  jsSha256.Sha256 = void 0;
  var tslib_1 = require$$0$2;
  var constants_1 = requireConstants();
  var RawSha256_1 = requireRawSha256();
  var util_1 = requireBuild$3();
  var Sha256 = (
    /** @class */
    function() {
      function Sha2562(secret) {
        this.secret = secret;
        this.hash = new RawSha256_1.RawSha256();
        this.reset();
      }
      Sha2562.prototype.update = function(toHash) {
        if ((0, util_1.isEmptyData)(toHash) || this.error) {
          return;
        }
        try {
          this.hash.update((0, util_1.convertToBuffer)(toHash));
        } catch (e2) {
          this.error = e2;
        }
      };
      Sha2562.prototype.digestSync = function() {
        if (this.error) {
          throw this.error;
        }
        if (this.outer) {
          if (!this.outer.finished) {
            this.outer.update(this.hash.digest());
          }
          return this.outer.digest();
        }
        return this.hash.digest();
      };
      Sha2562.prototype.digest = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a2) {
            return [2, this.digestSync()];
          });
        });
      };
      Sha2562.prototype.reset = function() {
        this.hash = new RawSha256_1.RawSha256();
        if (this.secret) {
          this.outer = new RawSha256_1.RawSha256();
          var inner = bufferFromSecret(this.secret);
          var outer = new Uint8Array(constants_1.BLOCK_SIZE);
          outer.set(inner);
          for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
            inner[i] ^= 54;
            outer[i] ^= 92;
          }
          this.hash.update(inner);
          this.outer.update(outer);
          for (var i = 0; i < inner.byteLength; i++) {
            inner[i] = 0;
          }
        }
      };
      return Sha2562;
    }()
  );
  jsSha256.Sha256 = Sha256;
  function bufferFromSecret(secret) {
    var input2 = (0, util_1.convertToBuffer)(secret);
    if (input2.byteLength > constants_1.BLOCK_SIZE) {
      var bufferHash = new RawSha256_1.RawSha256();
      bufferHash.update(input2);
      input2 = bufferHash.digest();
    }
    var buffer2 = new Uint8Array(constants_1.BLOCK_SIZE);
    buffer2.set(input2);
    return buffer2;
  }
  return jsSha256;
}
var hasRequiredBuild$2;
function requireBuild$2() {
  if (hasRequiredBuild$2)
    return build$2;
  hasRequiredBuild$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0$2;
    tslib_1.__exportStar(requireJsSha256(), exports);
  })(build$2);
  return build$2;
}
var build$1 = {};
var supportsWebCrypto = {};
var hasRequiredSupportsWebCrypto;
function requireSupportsWebCrypto() {
  if (hasRequiredSupportsWebCrypto)
    return supportsWebCrypto;
  hasRequiredSupportsWebCrypto = 1;
  Object.defineProperty(supportsWebCrypto, "__esModule", { value: true });
  supportsWebCrypto.supportsZeroByteGCM = supportsWebCrypto.supportsSubtleCrypto = supportsWebCrypto.supportsSecureRandom = supportsWebCrypto.supportsWebCrypto = void 0;
  var tslib_1 = require$$0$2;
  var subtleCryptoMethods = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function supportsWebCrypto$1(window2) {
    if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
      var subtle = window2.crypto.subtle;
      return supportsSubtleCrypto(subtle);
    }
    return false;
  }
  supportsWebCrypto.supportsWebCrypto = supportsWebCrypto$1;
  function supportsSecureRandom(window2) {
    if (typeof window2 === "object" && typeof window2.crypto === "object") {
      var getRandomValues2 = window2.crypto.getRandomValues;
      return typeof getRandomValues2 === "function";
    }
    return false;
  }
  supportsWebCrypto.supportsSecureRandom = supportsSecureRandom;
  function supportsSubtleCrypto(subtle) {
    return subtle && subtleCryptoMethods.every(function(methodName) {
      return typeof subtle[methodName] === "function";
    });
  }
  supportsWebCrypto.supportsSubtleCrypto = supportsSubtleCrypto;
  function supportsZeroByteGCM(subtle) {
    return tslib_1.__awaiter(this, void 0, void 0, function() {
      var key2, zeroByteAuthTag;
      return tslib_1.__generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            if (!supportsSubtleCrypto(subtle))
              return [2, false];
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, 4, , 5]);
            return [4, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
          case 2:
            key2 = _b2.sent();
            return [4, subtle.encrypt({
              name: "AES-GCM",
              iv: new Uint8Array(Array(12)),
              additionalData: new Uint8Array(Array(16)),
              tagLength: 128
            }, key2, new Uint8Array(0))];
          case 3:
            zeroByteAuthTag = _b2.sent();
            return [2, zeroByteAuthTag.byteLength === 16];
          case 4:
            _b2.sent();
            return [2, false];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  supportsWebCrypto.supportsZeroByteGCM = supportsZeroByteGCM;
  return supportsWebCrypto;
}
var hasRequiredBuild$1;
function requireBuild$1() {
  if (hasRequiredBuild$1)
    return build$1;
  hasRequiredBuild$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0$2;
    tslib_1.__exportStar(requireSupportsWebCrypto(), exports);
  })(build$1);
  return build$1;
}
var build = {};
var CryptoOperation = {};
var hasRequiredCryptoOperation;
function requireCryptoOperation() {
  if (hasRequiredCryptoOperation)
    return CryptoOperation;
  hasRequiredCryptoOperation = 1;
  Object.defineProperty(CryptoOperation, "__esModule", { value: true });
  return CryptoOperation;
}
var Key = {};
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey)
    return Key;
  hasRequiredKey = 1;
  Object.defineProperty(Key, "__esModule", { value: true });
  return Key;
}
var KeyOperation = {};
var hasRequiredKeyOperation;
function requireKeyOperation() {
  if (hasRequiredKeyOperation)
    return KeyOperation;
  hasRequiredKeyOperation = 1;
  Object.defineProperty(KeyOperation, "__esModule", { value: true });
  return KeyOperation;
}
var MsSubtleCrypto = {};
var hasRequiredMsSubtleCrypto;
function requireMsSubtleCrypto() {
  if (hasRequiredMsSubtleCrypto)
    return MsSubtleCrypto;
  hasRequiredMsSubtleCrypto = 1;
  Object.defineProperty(MsSubtleCrypto, "__esModule", { value: true });
  return MsSubtleCrypto;
}
var MsWindow = {};
var hasRequiredMsWindow;
function requireMsWindow() {
  if (hasRequiredMsWindow)
    return MsWindow;
  hasRequiredMsWindow = 1;
  Object.defineProperty(MsWindow, "__esModule", { value: true });
  MsWindow.isMsWindow = void 0;
  var msSubtleCryptoMethods = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function quacksLikeAnMsWindow(window2) {
    return "MSInputMethodContext" in window2 && "msCrypto" in window2;
  }
  function isMsWindow(window2) {
    if (quacksLikeAnMsWindow(window2) && window2.msCrypto.subtle !== void 0) {
      var _a2 = window2.msCrypto, getRandomValues2 = _a2.getRandomValues, subtle_1 = _a2.subtle;
      return msSubtleCryptoMethods.map(function(methodName) {
        return subtle_1[methodName];
      }).concat(getRandomValues2).every(function(method) {
        return typeof method === "function";
      });
    }
    return false;
  }
  MsWindow.isMsWindow = isMsWindow;
  return MsWindow;
}
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild)
    return build;
  hasRequiredBuild = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0$2;
    tslib_1.__exportStar(requireCryptoOperation(), exports);
    tslib_1.__exportStar(requireKey(), exports);
    tslib_1.__exportStar(requireKeyOperation(), exports);
    tslib_1.__exportStar(requireMsSubtleCrypto(), exports);
    tslib_1.__exportStar(requireMsWindow(), exports);
  })(build);
  return build;
}
var hasRequiredCrossPlatformSha256;
function requireCrossPlatformSha256() {
  if (hasRequiredCrossPlatformSha256)
    return crossPlatformSha256;
  hasRequiredCrossPlatformSha256 = 1;
  Object.defineProperty(crossPlatformSha256, "__esModule", { value: true });
  crossPlatformSha256.Sha256 = void 0;
  var ie11Sha256_1 = requireIe11Sha256();
  var webCryptoSha256_1 = requireWebCryptoSha256();
  var sha256_js_1 = requireBuild$2();
  var supports_web_crypto_1 = requireBuild$1();
  var ie11_detection_1 = requireBuild();
  var util_locate_window_1 = require$$5$1;
  var util_1 = requireBuild$3();
  var Sha256 = (
    /** @class */
    function() {
      function Sha2562(secret) {
        if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
          this.hash = new webCryptoSha256_1.Sha256(secret);
        } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
          this.hash = new ie11Sha256_1.Sha256(secret);
        } else {
          this.hash = new sha256_js_1.Sha256(secret);
        }
      }
      Sha2562.prototype.update = function(data, encoding) {
        this.hash.update((0, util_1.convertToBuffer)(data));
      };
      Sha2562.prototype.digest = function() {
        return this.hash.digest();
      };
      Sha2562.prototype.reset = function() {
        this.hash.reset();
      };
      return Sha2562;
    }()
  );
  crossPlatformSha256.Sha256 = Sha256;
  return crossPlatformSha256;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
  var tslib_1 = require$$0$2;
  tslib_1.__exportStar(requireCrossPlatformSha256(), exports);
  var ie11Sha256_1 = requireIe11Sha256();
  Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function() {
    return ie11Sha256_1.Sha256;
  } });
  var webCryptoSha256_1 = requireWebCryptoSha256();
  Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function() {
    return webCryptoSha256_1.Sha256;
  } });
})(build$4);
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
const BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
const PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
const OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
const ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua2) {
    const match = ua2.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua2) {
    const match = ua2.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua2, _const) {
    if (regexp.test(ua2)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version2) {
    switch (version2) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version2) {
    const v3 = version2.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v3.push(0);
    if (v3[0] !== 10)
      return void 0;
    switch (v3[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version2) {
    const v3 = version2.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v3.push(0);
    if (v3[0] === 1 && v3[1] < 5)
      return void 0;
    if (v3[0] === 1 && v3[1] < 6)
      return "Cupcake";
    if (v3[0] === 1 && v3[1] >= 6)
      return "Donut";
    if (v3[0] === 2 && v3[1] < 2)
      return "Eclair";
    if (v3[0] === 2 && v3[1] === 2)
      return "Froyo";
    if (v3[0] === 2 && v3[1] > 2)
      return "Gingerbread";
    if (v3[0] === 3)
      return "Honeycomb";
    if (v3[0] === 4 && v3[1] < 1)
      return "Ice Cream Sandwich";
    if (v3[0] === 4 && v3[1] < 4)
      return "Jelly Bean";
    if (v3[0] === 4 && v3[1] >= 4)
      return "KitKat";
    if (v3[0] === 5)
      return "Lollipop";
    if (v3[0] === 6)
      return "Marshmallow";
    if (v3[0] === 7)
      return "Nougat";
    if (v3[0] === 8)
      return "Oreo";
    if (v3[0] === 9)
      return "Pie";
    return void 0;
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version2) {
    return version2.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = Utils.getVersionPrecision(versionA);
    const versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version2) => {
      const delta = precision - Utils.getVersionPrecision(version2);
      const _version = version2 + new Array(delta + 1).join(".0");
      return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i += 1) {
      result.push(iterator(arr[i]));
    }
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i = 0, l2 = arr.length; i < l2; i += 1) {
      const value = arr[i];
      if (predicate(value, i)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i;
    let l2;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i = 0, l2 = assigners.length; i < l2; i += 1) {
      const assigner = assigners[i];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key2) => {
          result[key2] = assigner[key2];
        });
      }
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
const browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua2) {
      const browser2 = {
        name: "Googlebot"
      };
      const version2 = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Samsung Internet for Android"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Whale/i],
    describe(ua2) {
      const browser2 = {
        name: "NAVER Whale Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "MZ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/focus/i],
    describe(ua2) {
      const browser2 = {
        name: "Focus"
      };
      const version2 = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/swing/i],
    describe(ua2) {
      const browser2 = {
        name: "Swing"
      };
      const version2 = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/coast/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera Coast"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera Touch"
      };
      const version2 = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Yandex Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "UC Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua2) {
      const browser2 = {
        name: "Maxthon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua2) {
      const browser2 = {
        name: "Epiphany"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/puffin/i],
    describe(ua2) {
      const browser2 = {
        name: "Puffin"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua2) {
      const browser2 = {
        name: "Sleipnir"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua2) {
      const browser2 = {
        name: "K-Meleon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua2) {
      const browser2 = {
        name: "WeChat"
      };
      const version2 = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua2) {
      const browser2 = {
        name: /qqbrowserlite/i.test(ua2) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua2) {
      const browser2 = {
        name: "Internet Explorer"
      };
      const version2 = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua2) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua2) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua2) {
      const browser2 = {
        name: "Vivaldi"
      };
      const version2 = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua2) {
      const browser2 = {
        name: "SeaMonkey"
      };
      const version2 = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua2) {
      const browser2 = {
        name: "Sailfish"
      };
      const version2 = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/silk/i],
    describe(ua2) {
      const browser2 = {
        name: "Amazon Silk"
      };
      const version2 = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/phantom/i],
    describe(ua2) {
      const browser2 = {
        name: "PhantomJS"
      };
      const version2 = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua2) {
      const browser2 = {
        name: "SlimerJS"
      };
      const version2 = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua2) {
      const browser2 = {
        name: "BlackBerry"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua2) {
      const browser2 = {
        name: "WebOS Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/bada/i],
    describe(ua2) {
      const browser2 = {
        name: "Bada"
      };
      const version2 = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/tizen/i],
    describe(ua2) {
      const browser2 = {
        name: "Tizen"
      };
      const version2 = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua2) {
      const browser2 = {
        name: "QupZilla"
      };
      const version2 = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua2) {
      const browser2 = {
        name: "Firefox"
      };
      const version2 = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/electron/i],
    describe(ua2) {
      const browser2 = {
        name: "Electron"
      };
      const version2 = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Miui"
      };
      const version2 = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chromium/i],
    describe(ua2) {
      const browser2 = {
        name: "Chromium"
      };
      const version2 = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua2) {
      const browser2 = {
        name: "Chrome"
      };
      const version2 = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/GSA/i],
    describe(ua2) {
      const browser2 = {
        name: "Google Search"
      };
      const version2 = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua2) {
      const browser2 = {
        name: "Android Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua2) {
      const browser2 = {
        name: "PlayStation 4"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua2) {
      const browser2 = {
        name: "Safari"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua2) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua2.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua2),
        version: Utils.getSecondMatch(regexp, ua2)
      };
    }
  }
];
const osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua2);
      return {
        name: OS_MAP.Roku,
        version: version2
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.WindowsPhone,
        version: version2
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua2);
      const versionName = Utils.getWindowsVersionName(version2);
      return {
        name: OS_MAP.Windows,
        version: version2,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua2) {
      const result = {
        name: OS_MAP.iOS
      };
      const version2 = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua2);
      if (version2) {
        result.version = version2;
      }
      return result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua2).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version2);
      const os = {
        name: OS_MAP.MacOS,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua2).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: version2
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua2);
      const versionName = Utils.getAndroidVersionName(version2);
      const os = {
        name: OS_MAP.Android,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua2);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version2 && version2.length) {
        os.version = version2;
      }
      return os;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua2) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua2) || Utils.getFirstMatch(/\bbb(\d+)/i, ua2);
      return {
        name: OS_MAP.BlackBerry,
        version: version2
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.Bada,
        version: version2
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.Tizen,
        version: version2
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua2) {
      const version2 = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.PlayStation4,
        version: version2
      };
    }
  }
];
const platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua2) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua2) && "Nova";
      const platform2 = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform2.model = model;
      }
      return platform2;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua2) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua2);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];
const enginesParsersList = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua2) {
      const isBlinkBased = /\sedg\//i.test(ua2);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version2 = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua2);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: version2
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version2 = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version2 = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version2 = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version2 = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(browsersList, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(osParsersList, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name: name2 } = this.getOS();
    if (toLowerCase) {
      return String(name2).toLowerCase() || "";
    }
    return name2 || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform2 = Utils.find(platformParsersList, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform2) {
      this.parsedResult.platform = platform2.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key2) => {
      const currentDefinition = checkTree[key2];
      if (typeof currentDefinition === "string") {
        browsers[key2] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key2] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isOS(name2));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name2) => this.isPlatform(name2)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name2) => this.isBrowser(name2, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version2) {
    let expectedResults = [0];
    let comparableVersion = version2;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version2[0] === ">" || version2[0] === "<") {
      comparableVersion = version2.substr(1);
      if (version2[1] === "=") {
        isLoose = true;
        comparableVersion = version2.substr(2);
      } else {
        expectedResults = [];
      }
      if (version2[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version2[0] === "=") {
      comparableVersion = version2.substr(1);
    } else if (version2[0] === "~") {
      isLoose = true;
      comparableVersion = version2.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new Parser(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new Parser(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
const defaultUserAgent = ({ serviceId, clientVersion }) => async () => {
  var _a2, _b2, _c2, _d2, _e2;
  const parsedUA = typeof window !== "undefined" && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0;
  const sections = [
    ["aws-sdk-js", clientVersion],
    ["ua", "2.0"],
    [`os/${((_b2 = parsedUA == null ? void 0 : parsedUA.os) == null ? void 0 : _b2.name) || "other"}`, (_c2 = parsedUA == null ? void 0 : parsedUA.os) == null ? void 0 : _c2.version],
    ["lang/js"],
    ["md/browser", `${((_d2 = parsedUA == null ? void 0 : parsedUA.browser) == null ? void 0 : _d2.name) ?? "unknown"}_${((_e2 = parsedUA == null ? void 0 : parsedUA.browser) == null ? void 0 : _e2.version) ?? "unknown"}`]
  ];
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  return sections;
};
const invalidProvider = (message) => () => Promise.reject(message);
const TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
const calculateBodyLength = (body) => {
  if (typeof body === "string") {
    if (TEXT_ENCODER) {
      return TEXT_ENCODER.encode(body).byteLength;
    }
    let len = body.length;
    for (let i = len - 1; i >= 0; i--) {
      const code2 = body.charCodeAt(i);
      if (code2 > 127 && code2 <= 2047)
        len++;
      else if (code2 > 2047 && code2 <= 65535)
        len += 2;
      if (code2 >= 56320 && code2 <= 57343)
        i--;
    }
    return len;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};
const s = "required", t = "fn", u = "argv", v = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = { [s]: false, "type": "String" }, i$1 = { [s]: true, "default": false, "type": "Boolean" }, j = { [v]: "Endpoint" }, k = { [t]: c, [u]: [{ [v]: "UseFIPS" }, true] }, l = { [t]: c, [u]: [{ [v]: "UseDualStack" }, true] }, m = {}, n = { [t]: "getAttr", [u]: [{ [v]: g }, "supportsFIPS"] }, o = { [t]: c, [u]: [true, { [t]: "getAttr", [u]: [{ [v]: g }, "supportsDualStack"] }] }, p = [k], q = [l], r$1 = [{ [v]: "Region" }];
const _data = { version: "1.0", parameters: { Region: h, UseDualStack: i$1, UseFIPS: i$1, Endpoint: h }, rules: [{ conditions: [{ [t]: b, [u]: [j] }], rules: [{ conditions: p, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: q, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: j, properties: m, headers: m }, type: e }], type: f }, { conditions: [{ [t]: b, [u]: r$1 }], rules: [{ conditions: [{ [t]: "aws.partition", [u]: r$1, assign: g }], rules: [{ conditions: [k, l], rules: [{ conditions: [{ [t]: c, [u]: [a, n] }, o], rules: [{ endpoint: { url: "https://cognito-idp-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: p, rules: [{ conditions: [{ [t]: c, [u]: [n, a] }], rules: [{ endpoint: { url: "https://cognito-idp-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: q, rules: [{ conditions: [o], rules: [{ endpoint: { url: "https://cognito-idp.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://cognito-idp.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;
const defaultEndpointResolver = (endpointParams, context2 = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context2.logger
  });
};
customEndpointFunctions.aws = awsEndpointFunctions;
const getRuntimeConfig$1 = (config2) => {
  return {
    apiVersion: "2016-04-18",
    base64Decoder: (config2 == null ? void 0 : config2.base64Decoder) ?? fromBase64,
    base64Encoder: (config2 == null ? void 0 : config2.base64Encoder) ?? toBase64,
    disableHostPrefix: (config2 == null ? void 0 : config2.disableHostPrefix) ?? false,
    endpointProvider: (config2 == null ? void 0 : config2.endpointProvider) ?? defaultEndpointResolver,
    extensions: (config2 == null ? void 0 : config2.extensions) ?? [],
    httpAuthSchemeProvider: (config2 == null ? void 0 : config2.httpAuthSchemeProvider) ?? defaultCognitoIdentityProviderHttpAuthSchemeProvider,
    httpAuthSchemes: (config2 == null ? void 0 : config2.httpAuthSchemes) ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new AwsSdkSigV4Signer()
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new NoAuthSigner()
      }
    ],
    logger: (config2 == null ? void 0 : config2.logger) ?? new NoOpLogger(),
    serviceId: (config2 == null ? void 0 : config2.serviceId) ?? "Cognito Identity Provider",
    urlParser: (config2 == null ? void 0 : config2.urlParser) ?? parseUrl,
    utf8Decoder: (config2 == null ? void 0 : config2.utf8Decoder) ?? fromUtf8$3,
    utf8Encoder: (config2 == null ? void 0 : config2.utf8Encoder) ?? toUtf8$3
  };
};
const memoize = (provider2, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider2();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  {
    return async (options) => {
      if (!hasResult || (options == null ? void 0 : options.forceRefresh)) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
};
const DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
const resolveDefaultsModeConfig = ({ defaultsMode } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode == null ? void 0 : mode.toLowerCase()) {
    case "auto":
      return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(mode == null ? void 0 : mode.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
});
const isMobileBrowser = () => {
  var _a2, _b2;
  const parsedUA = typeof window !== "undefined" && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0;
  const platform2 = (_b2 = parsedUA == null ? void 0 : parsedUA.platform) == null ? void 0 : _b2.type;
  return platform2 === "tablet" || platform2 === "mobile";
};
const getRuntimeConfig = (config2) => {
  const defaultsMode = resolveDefaultsModeConfig(config2);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig$1(config2);
  return {
    ...clientSharedValues,
    ...config2,
    runtime: "browser",
    defaultsMode,
    bodyLengthChecker: (config2 == null ? void 0 : config2.bodyLengthChecker) ?? calculateBodyLength,
    credentialDefaultProvider: (config2 == null ? void 0 : config2.credentialDefaultProvider) ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: (config2 == null ? void 0 : config2.defaultUserAgentProvider) ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo.version }),
    maxAttempts: (config2 == null ? void 0 : config2.maxAttempts) ?? DEFAULT_MAX_ATTEMPTS,
    region: (config2 == null ? void 0 : config2.region) ?? invalidProvider("Region is missing"),
    requestHandler: FetchHttpHandler.create((config2 == null ? void 0 : config2.requestHandler) ?? defaultConfigProvider),
    retryMode: (config2 == null ? void 0 : config2.retryMode) ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
    sha256: (config2 == null ? void 0 : config2.sha256) ?? build$4.Sha256,
    streamCollector: (config2 == null ? void 0 : config2.streamCollector) ?? streamCollector,
    useDualstackEndpoint: (config2 == null ? void 0 : config2.useDualstackEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
    useFipsEndpoint: (config2 == null ? void 0 : config2.useFipsEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
  };
};
const getAwsRegionExtensionConfiguration = (runtimeConfig) => {
  let runtimeConfigRegion = async () => {
    if (runtimeConfig.region === void 0) {
      throw new Error("Region is missing from runtimeConfig");
    }
    const region = runtimeConfig.region;
    if (typeof region === "string") {
      return region;
    }
    return region();
  };
  return {
    setRegion(region) {
      runtimeConfigRegion = region;
    },
    region() {
      return runtimeConfigRegion;
    }
  };
};
const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
  return {
    region: awsRegionExtensionConfiguration.region()
  };
};
const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index2 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index2 === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index2, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
const resolveHttpAuthRuntimeConfig = (config2) => {
  return {
    httpAuthSchemes: config2.httpAuthSchemes(),
    httpAuthSchemeProvider: config2.httpAuthSchemeProvider(),
    credentials: config2.credentials()
  };
};
const asPartial = (t2) => t2;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
  };
};
class CognitoIdentityProviderClient extends Client {
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveUserAgentConfig(_config_5);
    const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
    const _config_8 = resolveRuntimeExtensions(_config_7, (configuration == null ? void 0 : configuration.extensions) || []);
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
    this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
      identityProviderConfigProvider: this.getIdentityProviderConfigProvider()
    }));
    this.middlewareStack.use(getHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
  getDefaultHttpAuthSchemeParametersProvider() {
    return defaultCognitoIdentityProviderHttpAuthSchemeParametersProvider;
  }
  getIdentityProviderConfigProvider() {
    return async (config2) => new DefaultIdentityProviderConfig({
      "aws.auth#sigv4": config2.credentials
    });
  }
}
class CognitoIdentityProviderServiceException extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, CognitoIdentityProviderServiceException.prototype);
  }
}
class InternalErrorException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InternalErrorException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalErrorException";
    this.$fault = "server";
    Object.setPrototypeOf(this, InternalErrorException.prototype);
  }
}
class InvalidParameterException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidParameterException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidParameterException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidParameterException.prototype);
  }
}
class NotAuthorizedException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "NotAuthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "NotAuthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, NotAuthorizedException.prototype);
  }
}
class ResourceNotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
  }
}
class TooManyRequestsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TooManyRequestsException.prototype);
  }
}
class UserImportInProgressException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserImportInProgressException",
      $fault: "client",
      ...opts
    });
    this.name = "UserImportInProgressException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserImportInProgressException.prototype);
  }
}
class UserNotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "UserNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserNotFoundException.prototype);
  }
}
class InvalidLambdaResponseException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidLambdaResponseException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidLambdaResponseException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidLambdaResponseException.prototype);
  }
}
class LimitExceededException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    this.name = "LimitExceededException";
    this.$fault = "client";
    Object.setPrototypeOf(this, LimitExceededException.prototype);
  }
}
class TooManyFailedAttemptsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "TooManyFailedAttemptsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyFailedAttemptsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, TooManyFailedAttemptsException.prototype);
  }
}
class UnexpectedLambdaException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnexpectedLambdaException",
      $fault: "client",
      ...opts
    });
    this.name = "UnexpectedLambdaException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnexpectedLambdaException.prototype);
  }
}
class UserLambdaValidationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserLambdaValidationException",
      $fault: "client",
      ...opts
    });
    this.name = "UserLambdaValidationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserLambdaValidationException.prototype);
  }
}
class CodeDeliveryFailureException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "CodeDeliveryFailureException",
      $fault: "client",
      ...opts
    });
    this.name = "CodeDeliveryFailureException";
    this.$fault = "client";
    Object.setPrototypeOf(this, CodeDeliveryFailureException.prototype);
  }
}
class InvalidPasswordException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidPasswordException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidPasswordException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidPasswordException.prototype);
  }
}
class InvalidSmsRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidSmsRoleAccessPolicyException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidSmsRoleAccessPolicyException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidSmsRoleAccessPolicyException.prototype);
  }
}
class InvalidSmsRoleTrustRelationshipException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidSmsRoleTrustRelationshipException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidSmsRoleTrustRelationshipException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidSmsRoleTrustRelationshipException.prototype);
  }
}
class PreconditionNotMetException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "PreconditionNotMetException",
      $fault: "client",
      ...opts
    });
    this.name = "PreconditionNotMetException";
    this.$fault = "client";
    Object.setPrototypeOf(this, PreconditionNotMetException.prototype);
  }
}
class UnsupportedUserStateException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedUserStateException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedUserStateException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedUserStateException.prototype);
  }
}
class UsernameExistsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UsernameExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "UsernameExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UsernameExistsException.prototype);
  }
}
class AliasExistsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "AliasExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "AliasExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, AliasExistsException.prototype);
  }
}
class InvalidUserPoolConfigurationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidUserPoolConfigurationException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidUserPoolConfigurationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidUserPoolConfigurationException.prototype);
  }
}
class MFAMethodNotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "MFAMethodNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "MFAMethodNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, MFAMethodNotFoundException.prototype);
  }
}
class PasswordResetRequiredException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "PasswordResetRequiredException",
      $fault: "client",
      ...opts
    });
    this.name = "PasswordResetRequiredException";
    this.$fault = "client";
    Object.setPrototypeOf(this, PasswordResetRequiredException.prototype);
  }
}
class UserNotConfirmedException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserNotConfirmedException",
      $fault: "client",
      ...opts
    });
    this.name = "UserNotConfirmedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserNotConfirmedException.prototype);
  }
}
class UserPoolAddOnNotEnabledException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserPoolAddOnNotEnabledException",
      $fault: "client",
      ...opts
    });
    this.name = "UserPoolAddOnNotEnabledException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserPoolAddOnNotEnabledException.prototype);
  }
}
class InvalidEmailRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidEmailRoleAccessPolicyException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidEmailRoleAccessPolicyException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidEmailRoleAccessPolicyException.prototype);
  }
}
class CodeMismatchException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "CodeMismatchException",
      $fault: "client",
      ...opts
    });
    this.name = "CodeMismatchException";
    this.$fault = "client";
    Object.setPrototypeOf(this, CodeMismatchException.prototype);
  }
}
class ExpiredCodeException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ExpiredCodeException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredCodeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ExpiredCodeException.prototype);
  }
}
class SoftwareTokenMFANotFoundException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "SoftwareTokenMFANotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "SoftwareTokenMFANotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, SoftwareTokenMFANotFoundException.prototype);
  }
}
class ConcurrentModificationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ConcurrentModificationException",
      $fault: "client",
      ...opts
    });
    this.name = "ConcurrentModificationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
  }
}
class ForbiddenException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ForbiddenException",
      $fault: "client",
      ...opts
    });
    this.name = "ForbiddenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ForbiddenException.prototype);
  }
}
class GroupExistsException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "GroupExistsException",
      $fault: "client",
      ...opts
    });
    this.name = "GroupExistsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, GroupExistsException.prototype);
  }
}
class DuplicateProviderException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "DuplicateProviderException",
      $fault: "client",
      ...opts
    });
    this.name = "DuplicateProviderException";
    this.$fault = "client";
    Object.setPrototypeOf(this, DuplicateProviderException.prototype);
  }
}
class UserPoolTaggingException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UserPoolTaggingException",
      $fault: "client",
      ...opts
    });
    this.name = "UserPoolTaggingException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UserPoolTaggingException.prototype);
  }
}
class InvalidOAuthFlowException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "InvalidOAuthFlowException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidOAuthFlowException";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidOAuthFlowException.prototype);
  }
}
class ScopeDoesNotExistException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "ScopeDoesNotExistException",
      $fault: "client",
      ...opts
    });
    this.name = "ScopeDoesNotExistException";
    this.$fault = "client";
    Object.setPrototypeOf(this, ScopeDoesNotExistException.prototype);
  }
}
class UnsupportedIdentityProviderException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedIdentityProviderException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedIdentityProviderException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedIdentityProviderException.prototype);
  }
}
class UnauthorizedException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnauthorizedException.prototype);
  }
}
class UnsupportedOperationException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedOperationException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedOperationException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
  }
}
class UnsupportedTokenTypeException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "UnsupportedTokenTypeException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedTokenTypeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, UnsupportedTokenTypeException.prototype);
  }
}
const AttributeTypeFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Value && { Value: SENSITIVE_STRING }
});
const AuthenticationResultTypeFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.AccessToken && { AccessToken: SENSITIVE_STRING },
  ...obj.RefreshToken && { RefreshToken: SENSITIVE_STRING },
  ...obj.IdToken && { IdToken: SENSITIVE_STRING }
});
const InitiateAuthRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.AuthParameters && { AuthParameters: SENSITIVE_STRING },
  ...obj.ClientId && { ClientId: SENSITIVE_STRING },
  ...obj.UserContextData && { UserContextData: SENSITIVE_STRING }
});
const InitiateAuthResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Session && { Session: SENSITIVE_STRING },
  ...obj.AuthenticationResult && {
    AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
  }
});
const RespondToAuthChallengeRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.ClientId && { ClientId: SENSITIVE_STRING },
  ...obj.Session && { Session: SENSITIVE_STRING },
  ...obj.ChallengeResponses && { ChallengeResponses: SENSITIVE_STRING },
  ...obj.UserContextData && { UserContextData: SENSITIVE_STRING }
});
const RespondToAuthChallengeResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Session && { Session: SENSITIVE_STRING },
  ...obj.AuthenticationResult && {
    AuthenticationResult: AuthenticationResultTypeFilterSensitiveLog(obj.AuthenticationResult)
  }
});
class EnableSoftwareTokenMFAException extends CognitoIdentityProviderServiceException {
  constructor(opts) {
    super({
      name: "EnableSoftwareTokenMFAException",
      $fault: "client",
      ...opts
    });
    this.name = "EnableSoftwareTokenMFAException";
    this.$fault = "client";
    Object.setPrototypeOf(this, EnableSoftwareTokenMFAException.prototype);
  }
}
const SignUpRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.ClientId && { ClientId: SENSITIVE_STRING },
  ...obj.SecretHash && { SecretHash: SENSITIVE_STRING },
  ...obj.Username && { Username: SENSITIVE_STRING },
  ...obj.Password && { Password: SENSITIVE_STRING },
  ...obj.UserAttributes && {
    UserAttributes: obj.UserAttributes.map((item2) => AttributeTypeFilterSensitiveLog(item2))
  },
  ...obj.ValidationData && {
    ValidationData: obj.ValidationData.map((item2) => AttributeTypeFilterSensitiveLog(item2))
  },
  ...obj.UserContextData && { UserContextData: SENSITIVE_STRING }
});
const se_InitiateAuthCommand = async (input2, context2) => {
  const headers = sharedHeaders("InitiateAuth");
  let body;
  body = JSON.stringify(_json(input2));
  return buildHttpRpcRequest(context2, headers, "/", void 0, body);
};
const se_RespondToAuthChallengeCommand = async (input2, context2) => {
  const headers = sharedHeaders("RespondToAuthChallenge");
  let body;
  body = JSON.stringify(_json(input2));
  return buildHttpRpcRequest(context2, headers, "/", void 0, body);
};
const se_SignUpCommand = async (input2, context2) => {
  const headers = sharedHeaders("SignUp");
  let body;
  body = JSON.stringify(_json(input2));
  return buildHttpRpcRequest(context2, headers, "/", void 0, body);
};
const de_InitiateAuthCommand = async (output2, context2) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context2);
  }
  const data = await parseJsonBody(output2.body, context2);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
const de_RespondToAuthChallengeCommand = async (output2, context2) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context2);
  }
  const data = await parseJsonBody(output2.body, context2);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
const de_SignUpCommand = async (output2, context2) => {
  if (output2.statusCode >= 300) {
    return de_CommandError(output2, context2);
  }
  const data = await parseJsonBody(output2.body, context2);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata(output2),
    ...contents
  };
  return response;
};
const de_CommandError = async (output2, context2) => {
  const parsedOutput = {
    ...output2,
    body: await parseJsonErrorBody(output2.body, context2)
  };
  const errorCode = loadRestJsonErrorCode(output2, parsedOutput.body);
  switch (errorCode) {
    case "InternalErrorException":
    case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
      throw await de_InternalErrorExceptionRes(parsedOutput);
    case "InvalidParameterException":
    case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput);
    case "NotAuthorizedException":
    case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
      throw await de_NotAuthorizedExceptionRes(parsedOutput);
    case "ResourceNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput);
    case "TooManyRequestsException":
    case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput);
    case "UserImportInProgressException":
    case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
      throw await de_UserImportInProgressExceptionRes(parsedOutput);
    case "UserNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
      throw await de_UserNotFoundExceptionRes(parsedOutput);
    case "InvalidLambdaResponseException":
    case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
      throw await de_InvalidLambdaResponseExceptionRes(parsedOutput);
    case "LimitExceededException":
    case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput);
    case "TooManyFailedAttemptsException":
    case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
      throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput);
    case "UnexpectedLambdaException":
    case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
      throw await de_UnexpectedLambdaExceptionRes(parsedOutput);
    case "UserLambdaValidationException":
    case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
      throw await de_UserLambdaValidationExceptionRes(parsedOutput);
    case "CodeDeliveryFailureException":
    case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
      throw await de_CodeDeliveryFailureExceptionRes(parsedOutput);
    case "InvalidPasswordException":
    case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
      throw await de_InvalidPasswordExceptionRes(parsedOutput);
    case "InvalidSmsRoleAccessPolicyException":
    case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
      throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput);
    case "InvalidSmsRoleTrustRelationshipException":
    case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
      throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput);
    case "PreconditionNotMetException":
    case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
      throw await de_PreconditionNotMetExceptionRes(parsedOutput);
    case "UnsupportedUserStateException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedUserStateException":
      throw await de_UnsupportedUserStateExceptionRes(parsedOutput);
    case "UsernameExistsException":
    case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
      throw await de_UsernameExistsExceptionRes(parsedOutput);
    case "AliasExistsException":
    case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
      throw await de_AliasExistsExceptionRes(parsedOutput);
    case "InvalidUserPoolConfigurationException":
    case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
      throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput);
    case "MFAMethodNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
      throw await de_MFAMethodNotFoundExceptionRes(parsedOutput);
    case "PasswordResetRequiredException":
    case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
      throw await de_PasswordResetRequiredExceptionRes(parsedOutput);
    case "UserNotConfirmedException":
    case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
      throw await de_UserNotConfirmedExceptionRes(parsedOutput);
    case "UserPoolAddOnNotEnabledException":
    case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
      throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput);
    case "InvalidEmailRoleAccessPolicyException":
    case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
      throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput);
    case "CodeMismatchException":
    case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
      throw await de_CodeMismatchExceptionRes(parsedOutput);
    case "ExpiredCodeException":
    case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
      throw await de_ExpiredCodeExceptionRes(parsedOutput);
    case "SoftwareTokenMFANotFoundException":
    case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
      throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput);
    case "ConcurrentModificationException":
    case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput);
    case "ForbiddenException":
    case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
      throw await de_ForbiddenExceptionRes(parsedOutput);
    case "GroupExistsException":
    case "com.amazonaws.cognitoidentityprovider#GroupExistsException":
      throw await de_GroupExistsExceptionRes(parsedOutput);
    case "DuplicateProviderException":
    case "com.amazonaws.cognitoidentityprovider#DuplicateProviderException":
      throw await de_DuplicateProviderExceptionRes(parsedOutput);
    case "UserPoolTaggingException":
    case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
      throw await de_UserPoolTaggingExceptionRes(parsedOutput);
    case "InvalidOAuthFlowException":
    case "com.amazonaws.cognitoidentityprovider#InvalidOAuthFlowException":
      throw await de_InvalidOAuthFlowExceptionRes(parsedOutput);
    case "ScopeDoesNotExistException":
    case "com.amazonaws.cognitoidentityprovider#ScopeDoesNotExistException":
      throw await de_ScopeDoesNotExistExceptionRes(parsedOutput);
    case "UnsupportedIdentityProviderException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedIdentityProviderException":
      throw await de_UnsupportedIdentityProviderExceptionRes(parsedOutput);
    case "UnauthorizedException":
    case "com.amazonaws.cognitoidentityprovider#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput);
    case "UnsupportedOperationException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedOperationException":
      throw await de_UnsupportedOperationExceptionRes(parsedOutput);
    case "UnsupportedTokenTypeException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedTokenTypeException":
      throw await de_UnsupportedTokenTypeExceptionRes(parsedOutput);
    case "EnableSoftwareTokenMFAException":
    case "com.amazonaws.cognitoidentityprovider#EnableSoftwareTokenMFAException":
      throw await de_EnableSoftwareTokenMFAExceptionRes(parsedOutput);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output: output2,
        parsedBody,
        errorCode
      });
  }
};
const de_AliasExistsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new AliasExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_CodeDeliveryFailureExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new CodeDeliveryFailureException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_CodeMismatchExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new CodeMismatchException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ConcurrentModificationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_DuplicateProviderExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new DuplicateProviderException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_EnableSoftwareTokenMFAExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new EnableSoftwareTokenMFAException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ExpiredCodeExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ExpiredCodeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ForbiddenExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ForbiddenException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_GroupExistsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new GroupExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InternalErrorExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InternalErrorException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidEmailRoleAccessPolicyExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidEmailRoleAccessPolicyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidLambdaResponseExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidLambdaResponseException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidOAuthFlowExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidOAuthFlowException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidParameterExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidParameterException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidPasswordExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidPasswordException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidSmsRoleAccessPolicyExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidSmsRoleAccessPolicyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidSmsRoleTrustRelationshipExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidSmsRoleTrustRelationshipException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_InvalidUserPoolConfigurationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidUserPoolConfigurationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_MFAMethodNotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new MFAMethodNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_NotAuthorizedExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new NotAuthorizedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_PasswordResetRequiredExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new PasswordResetRequiredException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_PreconditionNotMetExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new PreconditionNotMetException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_ScopeDoesNotExistExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new ScopeDoesNotExistException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_SoftwareTokenMFANotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new SoftwareTokenMFANotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_TooManyFailedAttemptsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new TooManyFailedAttemptsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnauthorizedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnexpectedLambdaExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnexpectedLambdaException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedIdentityProviderExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedIdentityProviderException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedOperationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedOperationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedTokenTypeExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedTokenTypeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UnsupportedUserStateExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UnsupportedUserStateException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserImportInProgressExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserImportInProgressException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserLambdaValidationExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserLambdaValidationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UsernameExistsExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UsernameExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserNotConfirmedExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserNotConfirmedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserNotFoundExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserPoolAddOnNotEnabledExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserPoolAddOnNotEnabledException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const de_UserPoolTaggingExceptionRes = async (parsedOutput, context2) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new UserPoolTaggingException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
const deserializeMetadata = (output2) => ({
  httpStatusCode: output2.statusCode,
  requestId: output2.headers["x-amzn-requestid"] ?? output2.headers["x-amzn-request-id"] ?? output2.headers["x-amz-request-id"],
  extendedRequestId: output2.headers["x-amz-id-2"],
  cfId: output2.headers["x-amz-cf-id"]
});
const throwDefaultError = withBaseException(CognitoIdentityProviderServiceException);
const buildHttpRpcRequest = async (context2, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context2.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
function sharedHeaders(operation) {
  return {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AWSCognitoIdentityProviderService.${operation}`
  };
}
class InitiateAuthCommand extends Command.classBuilder().ep({
  ...commonParams
}).m(function(Command2, cs, config2, o2) {
  return [
    getSerdePlugin(config2, this.serialize, this.deserialize),
    getEndpointPlugin(config2, Command2.getEndpointParameterInstructions())
  ];
}).s("AWSCognitoIdentityProviderService", "InitiateAuth", {}).n("CognitoIdentityProviderClient", "InitiateAuthCommand").f(InitiateAuthRequestFilterSensitiveLog, InitiateAuthResponseFilterSensitiveLog).ser(se_InitiateAuthCommand).de(de_InitiateAuthCommand).build() {
}
class RespondToAuthChallengeCommand extends Command.classBuilder().ep({
  ...commonParams
}).m(function(Command2, cs, config2, o2) {
  return [
    getSerdePlugin(config2, this.serialize, this.deserialize),
    getEndpointPlugin(config2, Command2.getEndpointParameterInstructions())
  ];
}).s("AWSCognitoIdentityProviderService", "RespondToAuthChallenge", {}).n("CognitoIdentityProviderClient", "RespondToAuthChallengeCommand").f(RespondToAuthChallengeRequestFilterSensitiveLog, RespondToAuthChallengeResponseFilterSensitiveLog).ser(se_RespondToAuthChallengeCommand).de(de_RespondToAuthChallengeCommand).build() {
}
class SignUpCommand extends Command.classBuilder().ep({
  ...commonParams
}).m(function(Command2, cs, config2, o2) {
  return [
    getSerdePlugin(config2, this.serialize, this.deserialize),
    getEndpointPlugin(config2, Command2.getEndpointParameterInstructions())
  ];
}).s("AWSCognitoIdentityProviderService", "SignUp", {}).n("CognitoIdentityProviderClient", "SignUpCommand").f(SignUpRequestFilterSensitiveLog, void 0).ser(se_SignUpCommand).de(de_SignUpCommand).build() {
}
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m2, p2) => {
    let code2 = p2.charCodeAt(0).toString(16).toUpperCase();
    if (code2.length < 2) {
      code2 = "0" + code2;
    }
    return "%" + code2;
  }));
}
function base64UrlDecode(str) {
  let output2 = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output2.length % 4) {
    case 0:
      break;
    case 2:
      output2 += "==";
      break;
    case 3:
      output2 += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output2);
  } catch (err) {
    return atob(output2);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e2.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e2.message})`);
  }
}
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
const _excluded$3 = ["signatures"];
const INTENTS_VERSION = 1;
const VERSION = `${INTENTS_VERSION} (Web ${VERSION$1})`;
function makeIntent(name2, lifespan, data) {
  const issuedAt = Math.floor(Date.now() / 1e3);
  const expiresAt = issuedAt + lifespan;
  return {
    version: VERSION,
    issuedAt,
    expiresAt,
    name: name2,
    data
  };
}
async function signIntent(session, intent) {
  const hash2 = hashIntent(intent);
  const signature2 = await session.sign(new Uint8Array(hash2));
  return _extends$2({}, intent, {
    signatures: [{
      sessionId: await session.sessionId(),
      signature: signature2
    }]
  });
}
function hashIntent(intent) {
  const {
    version: version2,
    issuedAt,
    expiresAt,
    name: name2,
    data
  } = intent;
  const hashableIntent = {
    version: version2,
    issuedAt,
    expiresAt,
    name: name2,
    data
  };
  const encoded = toUtf8Bytes(canonicalize(hashableIntent));
  return arrayify(keccak256$2(encoded));
}
function changeIntentTime(intent, now2) {
  const unsignedIntent = _objectWithoutPropertiesLoose$2(intent, _excluded$3);
  const lifespan = intent.expiresAt - intent.issuedAt;
  unsignedIntent.issuedAt = Math.floor(now2.getTime() / 1e3);
  unsignedIntent.expiresAt = unsignedIntent.issuedAt + lifespan;
  return unsignedIntent;
}
let IntentName = /* @__PURE__ */ function(IntentName2) {
  IntentName2["initiateAuth"] = "initiateAuth";
  IntentName2["openSession"] = "openSession";
  IntentName2["closeSession"] = "closeSession";
  IntentName2["validateSession"] = "validateSession";
  IntentName2["finishValidateSession"] = "finishValidateSession";
  IntentName2["listSessions"] = "listSessions";
  IntentName2["getSession"] = "getSession";
  IntentName2["sessionAuthProof"] = "sessionAuthProof";
  IntentName2["feeOptions"] = "feeOptions";
  IntentName2["signMessage"] = "signMessage";
  IntentName2["sendTransaction"] = "sendTransaction";
  IntentName2["getTransactionReceipt"] = "getTransactionReceipt";
  IntentName2["federateAccount"] = "federateAccount";
  IntentName2["removeAccount"] = "removeAccount";
  IntentName2["listAccounts"] = "listAccounts";
  IntentName2["getIdToken"] = "getIdToken";
  return IntentName2;
}({});
let IntentResponseCode = /* @__PURE__ */ function(IntentResponseCode2) {
  IntentResponseCode2["authInitiated"] = "authInitiated";
  IntentResponseCode2["sessionOpened"] = "sessionOpened";
  IntentResponseCode2["sessionClosed"] = "sessionClosed";
  IntentResponseCode2["sessionList"] = "sessionList";
  IntentResponseCode2["validationRequired"] = "validationRequired";
  IntentResponseCode2["validationStarted"] = "validationStarted";
  IntentResponseCode2["validationFinished"] = "validationFinished";
  IntentResponseCode2["sessionAuthProof"] = "sessionAuthProof";
  IntentResponseCode2["signedMessage"] = "signedMessage";
  IntentResponseCode2["feeOptions"] = "feeOptions";
  IntentResponseCode2["transactionReceipt"] = "transactionReceipt";
  IntentResponseCode2["transactionFailed"] = "transactionFailed";
  IntentResponseCode2["getSessionResponse"] = "getSessionResponse";
  IntentResponseCode2["accountList"] = "accountList";
  IntentResponseCode2["accountFederated"] = "accountFederated";
  IntentResponseCode2["accountRemoved"] = "accountRemoved";
  IntentResponseCode2["idToken"] = "idToken";
  return IntentResponseCode2;
}({});
let FeeTokenType = /* @__PURE__ */ function(FeeTokenType2) {
  FeeTokenType2["unknown"] = "unknown";
  FeeTokenType2["erc20Token"] = "erc20Token";
  FeeTokenType2["erc1155Token"] = "erc1155Token";
  return FeeTokenType2;
}({});
let IdentityType = /* @__PURE__ */ function(IdentityType2) {
  IdentityType2["None"] = "None";
  IdentityType2["Guest"] = "Guest";
  IdentityType2["OIDC"] = "OIDC";
  IdentityType2["Email"] = "Email";
  IdentityType2["PlayFab"] = "PlayFab";
  IdentityType2["Stytch"] = "Stytch";
  return IdentityType2;
}({});
function signMessage({
  wallet,
  chainId,
  message,
  lifespan
}) {
  return makeIntent(IntentName.signMessage, lifespan, {
    wallet,
    network: chainId.toString(),
    message: message.startsWith("0x") ? message : hexlify(toUtf8Bytes(message))
  });
}
const _excluded$2 = ["lifespan"], _excluded2$2 = ["lifespan"], _excluded3$2 = ["lifespan"], _excluded4$1 = ["lifespan"], _excluded5 = ["lifespan"], _excluded6 = ["lifespan"], _excluded7 = ["lifespan"], _excluded8 = ["lifespan"], _excluded9 = ["lifespan"];
async function initiateAuth(_ref) {
  let {
    lifespan
  } = _ref, data = _objectWithoutPropertiesLoose$2(_ref, _excluded$2);
  return makeIntent(IntentName.initiateAuth, lifespan, data);
}
async function openSession(_ref2) {
  let {
    lifespan
  } = _ref2, data = _objectWithoutPropertiesLoose$2(_ref2, _excluded2$2);
  return makeIntent(IntentName.openSession, lifespan, data);
}
async function validateSession(_ref3) {
  let {
    lifespan
  } = _ref3, data = _objectWithoutPropertiesLoose$2(_ref3, _excluded3$2);
  return makeIntent(IntentName.validateSession, lifespan, data);
}
function finishValidateSession(_ref4) {
  let {
    lifespan
  } = _ref4, data = _objectWithoutPropertiesLoose$2(_ref4, _excluded4$1);
  return makeIntent(IntentName.finishValidateSession, lifespan, data);
}
function closeSession(_ref5) {
  let {
    lifespan
  } = _ref5, data = _objectWithoutPropertiesLoose$2(_ref5, _excluded5);
  return makeIntent(IntentName.closeSession, lifespan, data);
}
function listSessions(_ref6) {
  let {
    lifespan
  } = _ref6, data = _objectWithoutPropertiesLoose$2(_ref6, _excluded6);
  return makeIntent(IntentName.listSessions, lifespan, data);
}
function getSession(_ref7) {
  let {
    lifespan
  } = _ref7, data = _objectWithoutPropertiesLoose$2(_ref7, _excluded7);
  return makeIntent(IntentName.getSession, lifespan, data);
}
function sessionAuthProof(_ref8) {
  let {
    lifespan
  } = _ref8, data = _objectWithoutPropertiesLoose$2(_ref8, _excluded8);
  return makeIntent(IntentName.sessionAuthProof, lifespan, data);
}
function getIdToken(_ref9) {
  let {
    lifespan
  } = _ref9, data = _objectWithoutPropertiesLoose$2(_ref9, _excluded9);
  return makeIntent(IntentName.getIdToken, lifespan, data);
}
const _excluded$1$1 = ["token", "to", "value"], _excluded2$1 = ["token", "to", "id", "safe", "data"], _excluded3$1 = ["token", "to", "values", "data"], _excluded4 = ["to", "value", "abi", "func", "args"];
function feeOptions({
  lifespan,
  wallet,
  identifier,
  chainId,
  transactions: transactions2
}) {
  return makeIntent(IntentName.feeOptions, lifespan, {
    identifier,
    wallet,
    network: chainId.toString(),
    transactions: transactions2.map((tx) => {
      if (!tx.to || tx.to === AddressZero) {
        throw new Error("Contract creation not supported");
      }
      if (!isEthersTx(tx)) {
        return tx;
      }
      return {
        type: "transaction",
        to: tx.to,
        value: BigNumber.from(tx.value || 0).toHexString(),
        data: hexlify(tx.data || [])
      };
    })
  });
}
function sendTransactions({
  lifespan,
  wallet,
  identifier,
  chainId,
  transactions: transactions2,
  transactionsFeeQuote,
  transactionsFeeOption
}) {
  return makeIntent(IntentName.sendTransaction, lifespan, {
    identifier,
    wallet,
    network: chainId.toString(),
    transactions: withTransactionFee(transactions2, transactionsFeeOption).map((tx) => {
      if (!tx.to || tx.to === AddressZero) {
        throw new Error("Contract creation not supported");
      }
      if (!isEthersTx(tx)) {
        return tx;
      }
      return {
        type: "transaction",
        to: tx.to,
        value: BigNumber.from(tx.value || 0).toHexString(),
        data: hexlify(tx.data || [])
      };
    }),
    transactionsFeeQuote
  });
}
function withTransactionFee(transactions2, feeOption) {
  const extendedTransactions = [...transactions2];
  if (feeOption) {
    switch (feeOption.token.type) {
      case FeeTokenType.unknown:
        extendedTransactions.push({
          to: feeOption.to,
          value: feeOption.value
        });
        break;
      case FeeTokenType.erc20Token:
        if (!feeOption.token.contractAddress) {
          throw new Error("contract address is required");
        }
        extendedTransactions.push(erc20({
          tokenAddress: feeOption.token.contractAddress,
          to: feeOption.to,
          value: feeOption.value
        }));
        break;
      case FeeTokenType.erc1155Token:
        if (!feeOption.token.contractAddress) {
          throw new Error("contract address is required");
        }
        if (!feeOption.token.tokenID) {
          throw new Error("token ID is required");
        }
        extendedTransactions.push(erc1155({
          tokenAddress: feeOption.token.contractAddress,
          to: feeOption.to,
          vals: [{
            id: feeOption.token.tokenID,
            amount: feeOption.value
          }]
        }));
        break;
    }
  }
  return extendedTransactions;
}
function getTransactionReceipt({
  lifespan,
  chainId,
  wallet,
  metaTxHash
}) {
  return makeIntent(IntentName.getTransactionReceipt, lifespan, {
    wallet,
    network: chainId.toString(),
    metaTxHash
  });
}
function sendERC20(_ref) {
  let {
    token,
    to,
    value
  } = _ref, args = _objectWithoutPropertiesLoose$2(_ref, _excluded$1$1);
  return sendTransactions(_extends$2({
    transactions: [erc20({
      tokenAddress: token,
      to,
      value: value.toString()
    })]
  }, args));
}
function sendERC721(_ref2) {
  let {
    token,
    to,
    id: id2,
    safe,
    data
  } = _ref2, args = _objectWithoutPropertiesLoose$2(_ref2, _excluded2$1);
  return sendTransactions(_extends$2({
    transactions: [erc721({
      tokenAddress: token,
      to,
      id: id2,
      data,
      safe
    })]
  }, args));
}
function sendERC1155(_ref3) {
  let {
    token,
    to,
    values,
    data
  } = _ref3, args = _objectWithoutPropertiesLoose$2(_ref3, _excluded3$1);
  const vals = values.map((v3) => ({
    id: v3.id,
    amount: BigNumber.from(v3.amount).toString()
  }));
  return sendTransactions(_extends$2({
    transactions: [erc1155({
      tokenAddress: token,
      to,
      vals,
      data
    })]
  }, args));
}
function sendDelayedEncode(_ref4) {
  let {
    to,
    value,
    abi: abi2,
    func,
    args
  } = _ref4, otherArgs = _objectWithoutPropertiesLoose$2(_ref4, _excluded4);
  return sendTransactions(_extends$2({
    transactions: [delayedEncode({
      to,
      value: BigNumber.from(value).toString(),
      data: {
        abi: abi2,
        func,
        args
      }
    })]
  }, otherArgs));
}
function erc20(data) {
  const sendERC20Args = data;
  const transactionERC20 = data;
  if (sendERC20Args.token !== void 0) {
    return {
      type: "erc20send",
      tokenAddress: sendERC20Args.token,
      to: sendERC20Args.to,
      value: sendERC20Args.value.toString()
    };
  } else if (transactionERC20.tokenAddress !== void 0) {
    return _extends$2({
      type: "erc20send"
    }, transactionERC20);
  } else {
    throw new Error("Invalid ERC20 transaction");
  }
}
function erc721(data) {
  const sendERC721Args = data;
  const transactionERC721 = data;
  if (sendERC721Args.token !== void 0) {
    return {
      type: "erc721send",
      tokenAddress: sendERC721Args.token,
      to: sendERC721Args.to,
      id: sendERC721Args.id,
      data: sendERC721Args.data,
      safe: sendERC721Args.safe
    };
  } else if (transactionERC721.tokenAddress !== void 0) {
    return _extends$2({
      type: "erc721send"
    }, transactionERC721);
  } else {
    throw new Error("Invalid ERC721 transaction");
  }
}
function erc1155(data) {
  const sendERC1155Args = data;
  const transactionERC1155 = data;
  if (sendERC1155Args.values !== void 0) {
    return {
      type: "erc1155send",
      vals: sendERC1155Args.values.map((v3) => ({
        id: v3.id,
        amount: BigNumber.from(v3.amount).toString()
      })),
      tokenAddress: sendERC1155Args.token,
      to: sendERC1155Args.to,
      data: sendERC1155Args.data
    };
  } else if (transactionERC1155.vals !== void 0) {
    return {
      type: "erc1155send",
      vals: transactionERC1155.vals.map((v3) => ({
        id: v3.id,
        amount: BigNumber.from(v3.amount).toString()
      })),
      tokenAddress: transactionERC1155.tokenAddress,
      to: transactionERC1155.to,
      data: transactionERC1155.data
    };
  } else {
    throw new Error("Invalid ERC1155 transaction");
  }
}
function delayedEncode(data) {
  const sendDelayedEncodeArgs = data;
  const transactionDelayedEncode = data;
  if (sendDelayedEncodeArgs.abi !== void 0) {
    return {
      type: "delayedEncode",
      to: sendDelayedEncodeArgs.to,
      value: BigNumber.from(sendDelayedEncodeArgs.value).toString(),
      data: {
        abi: sendDelayedEncodeArgs.abi,
        func: sendDelayedEncodeArgs.func,
        args: sendDelayedEncodeArgs.args
      }
    };
  } else if (transactionDelayedEncode.data !== void 0) {
    return {
      type: "delayedEncode",
      to: transactionDelayedEncode.to,
      value: transactionDelayedEncode.value,
      data: transactionDelayedEncode.data
    };
  } else {
    throw new Error("Invalid delayed encode transaction");
  }
}
function combineTransactionIntents(intents) {
  if (intents.length === 0) {
    throw new Error("No packets provided");
  }
  const network2 = intents[0].data.network;
  const wallet = intents[0].data.wallet;
  const lifespan = intents[0].expiresAt - intents[0].issuedAt;
  const identifier = intents[0].data.identifier;
  const transactionsFeeQuote = intents[0].data.transactionsFeeQuote;
  if (!intents.every((intent) => intent.data.network === network2)) {
    throw new Error("All packets must have the same chainId");
  }
  if (!intents.every((intent) => intent.data.wallet === wallet)) {
    throw new Error("All packets must have the same wallet");
  }
  return makeIntent(IntentName.sendTransaction, lifespan, {
    network: network2,
    wallet,
    identifier,
    transactions: intents.flatMap((intent) => intent.data.transactions),
    transactionsFeeQuote
  });
}
function isEthersTx(tx) {
  return !["transaction", "erc20send", "erc721send", "erc1155send", "delayedEncode"].includes(tx.type);
}
class StoreObj {
  constructor(store, key2, defaultValue) {
    this.store = store;
    this.key = key2;
    this.defaultValue = defaultValue;
  }
  async get() {
    const value = await this.store.get(this.key);
    return value ? value : this.defaultValue;
  }
  async set(value) {
    if (value) {
      await this.store.set(this.key, value);
    } else {
      await this.store.set(this.key, null);
    }
  }
}
class LocalStore {
  constructor() {
    this.store = void 0;
    if (WindowLocalStorage.isAvailable()) {
      this.store = new WindowLocalStorage();
    } else {
      this.store = new MemoryStore();
    }
  }
  async get(key2) {
    return this.store.get(key2);
  }
  async set(key2, value) {
    return this.store.set(key2, value);
  }
}
class WindowLocalStorage {
  static isAvailable() {
    return typeof window === "object" && typeof window.localStorage === "object";
  }
  constructor() {
    if (!WindowLocalStorage.isAvailable()) {
      throw new Error("No localStorage");
    }
  }
  async get(key2) {
    return window.localStorage.getItem(key2);
  }
  async set(key2, value) {
    if (!value) {
      window.localStorage.removeItem(key2);
    } else {
      window.localStorage.setItem(key2, value);
    }
  }
}
class MemoryStore {
  constructor() {
    this.store = {};
    this.store = {};
  }
  async get(key2) {
    return this.store[key2] || null;
  }
  async set(key2, value) {
    if (value) {
      this.store[key2] = value;
    } else {
      delete this.store[key2];
    }
  }
}
const idbName$1 = "seq-waas-session-p256k1";
const idbStoreName$1 = "seq-waas-session";
async function newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend) {
  const privateKey = await secureStoreBackend.get(idbName$1, idbStoreName$1, sessionId);
  if (!privateKey) {
    throw new Error("No private key found");
  }
  const wallet = new Wallet$1(privateKey);
  return {
    sessionId() {
      return wallet.getAddress();
    },
    sign(message) {
      return wallet.signMessage(message);
    },
    clear: async () => {
      await secureStoreBackend.delete(idbName$1, idbStoreName$1, sessionId);
    }
  };
}
async function newSECP256K1SessionFromPrivateKey(privateKey, secureStoreBackend) {
  const wallet = new Wallet$1(privateKey);
  const sessionId = await wallet.getAddress();
  await secureStoreBackend.set(idbName$1, idbStoreName$1, sessionId, privateKey);
  return newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend);
}
async function newSECP256K1Session(secureStoreBackend) {
  const wallet = Wallet$1.createRandom();
  return newSECP256K1SessionFromPrivateKey(wallet.privateKey, secureStoreBackend);
}
let KeyTypes = /* @__PURE__ */ function(KeyTypes2) {
  KeyTypes2[KeyTypes2["ECDSAP256K1"] = 0] = "ECDSAP256K1";
  KeyTypes2[KeyTypes2["ECDSAP256R1"] = 1] = "ECDSAP256R1";
  return KeyTypes2;
}({});
const idbName = "seq-waas-session-p256r1";
const idbStoreName = "seq-waas-session";
async function newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend) {
  const keys = await secureStoreBackend.get(idbName, idbStoreName, sessionId);
  if (!keys || !keys.privateKey) {
    throw new Error("No private key found");
  }
  const encoder2 = new TextEncoder();
  return {
    sessionId: async () => {
      const pubKeyRaw = await cryptoBackend.exportKey("raw", keys.publicKey);
      const pubKeyTypedRaw = new Uint8Array(pubKeyRaw.byteLength + 1);
      pubKeyTypedRaw[0] = KeyTypes.ECDSAP256R1;
      pubKeyTypedRaw.set(new Uint8Array(pubKeyRaw), 1);
      return hexlify(pubKeyTypedRaw);
    },
    sign: async (message) => {
      if (typeof message === "string") {
        if (message.startsWith("0x")) {
          message = message.slice(2);
          message = arrayify(message);
        } else {
          message = encoder2.encode(message);
        }
      }
      const signatureBuff = await cryptoBackend.sign({
        name: "ECDSA",
        hash: {
          name: "SHA-256"
        }
      }, keys.privateKey, message);
      return hexlify(new Uint8Array(signatureBuff));
    },
    clear: async () => {
      await secureStoreBackend.delete(idbName, idbStoreName, sessionId);
    }
  };
}
async function newSECP256R1SessionFromKeyPair(keyPair2, cryptoBackend, secureStoreBackend) {
  const sessionId = await pubKeyToSessionId(cryptoBackend, keyPair2.publicKey);
  await secureStoreBackend.set(idbName, idbStoreName, sessionId, keyPair2);
  return newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend);
}
async function newSECP256R1Session(cryptoBackend, secureStoreBackend) {
  const generatedKeys = await cryptoBackend.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, false, ["sign", "verify"]);
  return newSECP256R1SessionFromKeyPair(generatedKeys, cryptoBackend, secureStoreBackend);
}
async function pubKeyToSessionId(cryptoBackend, pubKey) {
  const pubKeyRaw = await cryptoBackend.exportKey("raw", pubKey);
  const pubKeyTypedRaw = new Uint8Array(pubKeyRaw.byteLength + 1);
  pubKeyTypedRaw[0] = KeyTypes.ECDSAP256R1;
  pubKeyTypedRaw.set(new Uint8Array(pubKeyRaw), 1);
  return hexlify(pubKeyTypedRaw);
}
async function newSessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend) {
  if (!secureStoreBackend) {
    throw new Error("No secure store available");
  }
  if (cryptoBackend) {
    return newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend);
  } else {
    return newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend);
  }
}
async function newSession(cryptoBackend, secureStoreBackend) {
  if (!secureStoreBackend) {
    throw new Error("No secure store available");
  }
  if (cryptoBackend) {
    return newSECP256R1Session(cryptoBackend, secureStoreBackend);
  } else {
    return newSECP256K1Session(secureStoreBackend);
  }
}
const _excluded$4 = ["lifespan"], _excluded2 = ["lifespan"], _excluded3 = ["lifespan"];
function listAccounts(_ref) {
  let {
    lifespan
  } = _ref, data = _objectWithoutPropertiesLoose$2(_ref, _excluded$4);
  return makeIntent(IntentName.listAccounts, lifespan, data);
}
function federateAccount(_ref2) {
  let {
    lifespan
  } = _ref2, data = _objectWithoutPropertiesLoose$2(_ref2, _excluded2);
  return makeIntent(IntentName.federateAccount, lifespan, data);
}
function removeAccount(_ref3) {
  let {
    lifespan
  } = _ref3, data = _objectWithoutPropertiesLoose$2(_ref3, _excluded3);
  return makeIntent(IntentName.removeAccount, lifespan, data);
}
const nameToId = Object.entries(networks).reduce((acc, [key2, value]) => {
  acc[value.name] = value.chainId;
  return acc;
}, {});
const idToName = Object.entries(nameToId).reduce((acc, [key2, value]) => {
  acc[value] = key2;
  return acc;
}, {});
function toNetworkID(network2) {
  const networkNumber = typeof network2 === "number" ? network2 : parseInt(network2);
  if (networkNumber in idToName) {
    return networkNumber;
  }
  const networkLower = network2.toString().toLowerCase();
  if (networkLower in nameToId) {
    return nameToId[networkLower];
  }
  throw new Error(`Unknown network: ${network2}`);
}
const getDefaultSubtleCryptoBackend = () => {
  if (isWindowSubtleCryptoAvailable()) {
    return new WindowSubtleCryptoBackend();
  } else {
    return null;
  }
};
function isWindowSubtleCryptoAvailable() {
  return typeof window === "object" && typeof window.crypto === "object" && typeof window.crypto.subtle === "object";
}
class WindowSubtleCryptoBackend {
  constructor() {
    if (!isWindowSubtleCryptoAvailable()) {
      throw new Error("window.crypto.subtle is not available");
    }
  }
  async generateKey(algorithm, extractable, keyUsages) {
    return window.crypto.subtle.generateKey(algorithm, extractable, keyUsages);
  }
  async exportKey(format2, key2) {
    const keyData = await window.crypto.subtle.exportKey(format2, key2);
    return new Uint8Array(keyData);
  }
  async digest(algorithm, data) {
    const digest9 = await window.crypto.subtle.digest(algorithm, data);
    return new Uint8Array(digest9);
  }
  async sign(algorithm, key2, data) {
    const signature2 = await window.crypto.subtle.sign(algorithm, key2, data);
    return new Uint8Array(signature2);
  }
  async verify(algorithm, key2, signature2, data) {
    return window.crypto.subtle.verify(algorithm, key2, signature2, data);
  }
  getRandomValues(len) {
    const randomValues = new Uint8Array(len);
    return window.crypto.getRandomValues(randomValues);
  }
}
const getDefaultSecureStoreBackend = () => {
  if (isIndexedDbAvailable()) {
    return new IndexedDbSecureStoreBackend();
  } else {
    return null;
  }
};
function isIndexedDbAvailable() {
  return typeof indexedDB === "object";
}
class IndexedDbSecureStoreBackend {
  constructor() {
    this.db = void 0;
    if (!isIndexedDbAvailable()) {
      throw new Error("IndexedDB is not available");
    }
    this.db = null;
  }
  async openDB(dbName, dbStoreName, version2) {
    if (this.db) {
      return this.db;
    }
    this.db = await openDB(dbName, 1, {
      upgrade(db2) {
        db2.createObjectStore(dbStoreName);
      }
    });
    return this.db;
  }
  async get(dbName, dbStoreName, key2) {
    const db2 = await this.openDB(dbName, dbStoreName, 1);
    const tx = db2.transaction(dbStoreName, "readonly");
    const value = await db2.get(dbStoreName, key2);
    await tx.done;
    return value;
  }
  async set(dbName, dbStoreName, key2, value) {
    const db2 = await this.openDB(dbName, dbStoreName, 1);
    const tx = db2.transaction(dbStoreName, "readwrite");
    await db2.put(dbStoreName, value, key2);
    await tx.done;
    return true;
  }
  async delete(dbName, dbStoreName, key2) {
    const db2 = await this.openDB(dbName, dbStoreName, 1);
    const tx = db2.transaction(dbStoreName, "readwrite");
    await db2.delete(dbStoreName, key2);
    await tx.done;
    return true;
  }
}
const SEQUENCE_WAAS_WALLET_KEY = "@0xsequence.waas.wallet";
const SEQUENCE_WAAS_SESSION_ID_KEY = "@0xsequence.waas.session_id";
const SEQUENCE_WAAS_STATUS_KEY = "@0xsequence.waas.status";
const DEFAULT_LIFESPAN = 5 * 60;
class SequenceWaaSBase {
  constructor(config2 = {
    network: 1
  }, store = new LocalStore(), cryptoBackend = getDefaultSubtleCryptoBackend(), secureStoreBackend = getDefaultSecureStoreBackend()) {
    this.config = config2;
    this.store = store;
    this.cryptoBackend = cryptoBackend;
    this.secureStoreBackend = secureStoreBackend;
    this.status = void 0;
    this.sessionId = void 0;
    this.wallet = void 0;
    this.sessionObservers = [];
    this.gettingSessionIdPromise = void 0;
    this.status = new StoreObj(this.store, SEQUENCE_WAAS_STATUS_KEY, "signed-out");
    this.sessionId = new StoreObj(this.store, SEQUENCE_WAAS_SESSION_ID_KEY, void 0);
    this.wallet = new StoreObj(this.store, SEQUENCE_WAAS_WALLET_KEY, void 0);
  }
  async getAddress() {
    return this.getWalletAddress();
  }
  async getWalletAddress() {
    if (!await this.isSignedIn()) {
      throw new Error("Not signed in");
    }
    const wallet = await this.wallet.get();
    if (!wallet) {
      throw new Error("No wallet");
    }
    return wallet;
  }
  async commonArgs(args) {
    var _args$lifespan;
    return _extends$2({}, args, {
      identifier: args == null ? void 0 : args.identifier,
      wallet: await this.getWalletAddress(),
      lifespan: (_args$lifespan = args == null ? void 0 : args.lifespan) != null ? _args$lifespan : DEFAULT_LIFESPAN,
      chainId: toNetworkID(args.network || this.config.network)
    });
  }
  /**
   * Builds a payload that can be sent to the WaaS API to sign a transaction.
   * It automatically signs the payload, and attaches the current wallet address.
   *
   * @param packet The action already packed into a packet
   * @returns A payload that can be sent to the WaaS API
   */
  async signIntent(intent) {
    const sessionId = await this.getSessionId();
    if (sessionId === void 0) {
      throw new Error("session not open");
    }
    const session = await newSessionFromSessionId(sessionId, this.cryptoBackend, this.secureStoreBackend);
    return signIntent(session, intent);
  }
  async signUsingSessionKey(message) {
    const sessionId = await this.getSessionId();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const signer2 = await newSessionFromSessionId(sessionId, this.cryptoBackend, this.secureStoreBackend);
    return signer2.sign(message);
  }
  /**
   * This method will return session id.
   *
   * @returns an id of the session
   */
  async getSessionId() {
    var _this = this;
    if (this.gettingSessionIdPromise) {
      return this.gettingSessionIdPromise;
    }
    const promiseGenerator = async function promiseGenerator2() {
      let sessionId = await _this.sessionId.get();
      if (!sessionId) {
        const session = await newSession(_this.cryptoBackend, _this.secureStoreBackend);
        sessionId = await session.sessionId();
        await _this.sessionId.set(sessionId);
        _this.signalObservers(_this.sessionObservers, sessionId);
      }
      _this.gettingSessionIdPromise = void 0;
      return sessionId;
    };
    this.gettingSessionIdPromise = promiseGenerator();
    return this.gettingSessionIdPromise;
  }
  /**
   * This method will initiate a sign-in process with the waas API. It must be performed
   * when the user wants to sign in to the app, in parallel with the authentication of the
   * application's own authentication system.
   *
   * This method begins the sign-in process, but does not complete it. The returned payload
   * must be sent to the waas API to complete the sign-in. The waas API will return a receipt
   * that must be sent to the `completeSignIn` method to complete the sign-in.
   *
   * @param idToken Information about the user that can be used to prove their identity
   * @returns a session payload that **must** be sent to the waas API to complete the sign-in
   * @throws {Error} If the session is already signed in or there is a pending sign-in
   */
  async signInWithIdToken(idToken) {
    const status = await this.status.get();
    if (status !== "signed-out") {
      await this.completeSignOut();
      throw new Error("you are already signed in");
    }
    const sessionId = await this.getSessionId();
    const intent = await openSession({
      sessionId,
      identityType: IdentityType.None,
      idToken,
      lifespan: DEFAULT_LIFESPAN
    });
    await this.status.set("pending");
    return this.signIntent(intent);
  }
  async initiateGuestAuth() {
    const sessionId = await this.getSessionId();
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Guest,
      verifier: sessionId,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateEmailAuth(email2) {
    const sessionId = await this.getSessionId();
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Email,
      verifier: `${email2};${sessionId}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateIdTokenAuth(idToken, exp) {
    const sessionId = await this.getSessionId();
    const idTokenHash = keccak256$2(toUtf8Bytes(idToken));
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.OIDC,
      verifier: `${idTokenHash};${exp}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateStytchAuth(idToken, exp) {
    const sessionId = await this.getSessionId();
    const idTokenHash = keccak256$2(toUtf8Bytes(idToken));
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Stytch,
      verifier: `${idTokenHash};${exp}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiatePlayFabAuth(titleId, sessionTicket) {
    const sessionId = await this.getSessionId();
    const ticketHash = keccak256$2(toUtf8Bytes(sessionTicket));
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.PlayFab,
      verifier: `${titleId}|${ticketHash}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async completeAuth(params, optParams) {
    const sessionId = await this.getSessionId();
    const intent = await openSession(_extends$2({}, optParams, {
      sessionId,
      lifespan: DEFAULT_LIFESPAN
    }, params));
    await this.status.set("pending");
    return this.signIntent(intent);
  }
  onSessionStateChanged(callback) {
    this.sessionObservers.push(callback);
    return () => {
      this.sessionObservers = this.sessionObservers.filter((o2) => o2 != callback);
    };
  }
  async signOut({
    lifespan,
    sessionId
  } = {}) {
    sessionId = sessionId || await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = closeSession({
      lifespan: lifespan || DEFAULT_LIFESPAN,
      sessionId
    });
    return this.signIntent(intent);
  }
  async signOutSession(sessionId) {
    const intent = closeSession({
      lifespan: DEFAULT_LIFESPAN,
      sessionId
    });
    return this.signIntent(intent);
  }
  async listSessions() {
    const intent = listSessions({
      lifespan: DEFAULT_LIFESPAN,
      wallet: await this.getWalletAddress()
    });
    return this.signIntent(intent);
  }
  async completeSignOut() {
    await Promise.all([this.status.set("signed-out"), this.wallet.set(void 0), this.sessionId.set(void 0)]);
    this.signalObservers(this.sessionObservers, null);
  }
  /**
   * This method will complete a sign-in process with the waas API. It must be performed
   * after the `signIn` method, when the waas API has returned a receipt.
   *
   * This method completes the sign-in process by validating the receipt's proof.
   * If the proof is invalid or there is no pending sign-in, it will throw an error.
   *
   * After this method is called, the wallet is ready to be used to sign transactions.
   *
   * @param receipt The receipt returned by the waas API after the `signIn` method
   * @returns The wallet address of the user that signed in
   * @throws {Error} If there is no pending sign-in or the receipt is invalid
   */
  async completeSignIn(receipt) {
    if (receipt.result) {
      return this.completeSignIn(receipt.result);
    }
    const status = await this.status.get();
    if (receipt.code !== "sessionOpened") {
      throw new Error("Invalid receipt");
    }
    if (status !== "pending") {
      throw new Error("No pending sign in");
    }
    await Promise.all([this.status.set("signed-in"), this.wallet.set(receipt.data.wallet)]);
    return receipt.data.wallet;
  }
  async isSignedIn() {
    const status = await this.status.get();
    return status === "signed-in";
  }
  async sessionAuthProof(args) {
    var _args$lifespan2;
    const packet = sessionAuthProof({
      lifespan: (_args$lifespan2 = args.lifespan) != null ? _args$lifespan2 : DEFAULT_LIFESPAN,
      network: toNetworkID(args.network || this.config.network).toString(),
      wallet: await this.getWalletAddress(),
      nonce: args.nonce
    });
    return this.signIntent(packet);
  }
  //
  // Signer methods
  //
  /**
   * This method can be used to sign message using waas API. It can only be used
   * after successfully signing in with the `signIn` and `completeSignIn` methods.
   *
   * The method does not sign the message. It only returns a payload
   * that must be sent to the waas API to complete the sign process.
   *
   * @param chainId The network on which the message will be signed
   * @param message  The message that will be signed
   * @return a payload that must be sent to the waas API to complete sign process
   */
  async signMessage(args) {
    var _args$lifespan3;
    const packet = signMessage(_extends$2({
      chainId: toNetworkID(args.network || this.config.network)
    }, args, {
      lifespan: (_args$lifespan3 = args.lifespan) != null ? _args$lifespan3 : DEFAULT_LIFESPAN,
      wallet: await this.getWalletAddress()
    }));
    return this.signIntent(packet);
  }
  /**
   * This method can be used to send transactions to the waas API. It can only be used
   * after successfully signing in with the `signIn` and `completeSignIn` methods.
   *
   * The method does not send the transactions to the network. It only returns a payload
   * that must be sent to the waas API to complete the transaction.
   *
   * @param transactions The transactions to be sent
   * @param chainId The network on which the transactions will be sent
   * @returns a payload that must be sent to the waas API to complete the transaction
   */
  async sendTransaction(args) {
    const intent = sendTransactions(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async getTransactionReceipt(args) {
    const intent = getTransactionReceipt(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC20(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error("Cannot burn tokens using sendERC20");
    }
    const intent = sendERC20(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC721(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error("Cannot burn tokens using sendERC721");
    }
    const intent = sendERC721(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC1155(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error("Cannot burn tokens using sendERC1155");
    }
    const intent = sendERC1155(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async callContract(args) {
    const intent = sendDelayedEncode(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async feeOptions(args) {
    const intent = feeOptions(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async validateSession({
    deviceMetadata
  }) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = await validateSession({
      lifespan: DEFAULT_LIFESPAN,
      sessionId,
      deviceMetadata,
      wallet: await this.getWalletAddress()
    });
    return this.signIntent(intent);
  }
  async getSession() {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = getSession({
      sessionId,
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async finishValidateSession(salt, challenge) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const wallet = await this.getWalletAddress();
    const intent = finishValidateSession({
      sessionId,
      wallet,
      lifespan: DEFAULT_LIFESPAN,
      salt,
      challenge
    });
    return this.signIntent(intent);
  }
  async listAccounts() {
    const intent = listAccounts({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async linkAccount(params) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = federateAccount(_extends$2({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      sessionId
    }, params));
    return this.signIntent(intent);
  }
  async removeAccount({
    accountId
  }) {
    const intent = removeAccount({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      accountId
    });
    return this.signIntent(intent);
  }
  async getIdToken({
    nonce
  }) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = getIdToken({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      sessionId,
      nonce
    });
    return this.signIntent(intent);
  }
  async batch(intents) {
    const combined = combineTransactionIntents(intents);
    return this.signIntent(combined);
  }
  signalObservers(observers2, value) {
    observers2.forEach((observer) => observer(value));
  }
  async updateIntentTime(intent, time2) {
    const newIntent = changeIntentTime(intent, time2);
    return this.signIntent(newIntent);
  }
}
class WaasAuthenticator {
  constructor(hostname, fetch2) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = "/rpc/WaasAuthenticator/";
    this.registerSession = (args, headers, signal) => {
      return this.fetch(this.url("RegisterSession"), createHTTPRequest(args, headers, signal)).then((res) => {
        return buildResponse(res).then((_data2) => {
          return {
            session: _data2.session,
            response: _data2.response
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.sendIntent = (args, headers, signal) => {
      return this.fetch(this.url("SendIntent"), createHTTPRequest(args, headers, signal)).then((res) => {
        return buildResponse(res).then((_data2) => {
          return {
            response: _data2.response
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.chainList = (headers, signal) => {
      return this.fetch(this.url("ChainList"), createHTTPRequest({}, headers, signal)).then((res) => {
        return buildResponse(res).then((_data2) => {
          return {
            chains: _data2.chains
          };
        });
      }, (error) => {
        throw WebrpcRequestFailedError7.new({
          cause: `fetch(): ${error.message || ""}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input2, init3) => fetch2(input2, init3);
  }
  url(name2) {
    return this.hostname + this.path + name2;
  }
}
const createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: _extends$2({}, headers, {
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse = (res) => {
  return res.text().then((text2) => {
    let data;
    try {
      data = JSON.parse(text2);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError7.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text2}`
      });
    }
    if (!res.ok) {
      const code2 = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode[code2] || WebrpcError7).new(data);
    }
    return data;
  });
};
class WebrpcError7 extends Error {
  constructor(name2, code2, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    this.msg = void 0;
    this.name = name2 || "WebrpcError";
    this.code = typeof code2 === "number" ? code2 : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError7.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
}
class WebrpcEndpointError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcEndpoint", code2 = 0, message = "endpoint error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError7.prototype);
  }
}
class WebrpcRequestFailedError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcRequestFailed", code2 = -1, message = "request failed", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError7.prototype);
  }
}
class WebrpcBadRouteError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadRoute", code2 = -2, message = "bad route", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError7.prototype);
  }
}
class WebrpcBadMethodError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadMethod", code2 = -3, message = "bad method", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError7.prototype);
  }
}
class WebrpcBadRequestError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadRequest", code2 = -4, message = "bad request", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError7.prototype);
  }
}
class WebrpcBadResponseError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcBadResponse", code2 = -5, message = "bad response", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError7.prototype);
  }
}
class WebrpcServerPanicError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcServerPanic", code2 = -6, message = "server panic", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError7.prototype);
  }
}
class WebrpcInternalErrorError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcInternalError", code2 = -7, message = "internal error", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError7.prototype);
  }
}
class WebrpcClientDisconnectedError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcClientDisconnected", code2 = -8, message = "client disconnected", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError7.prototype);
  }
}
class WebrpcStreamLostError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcStreamLost", code2 = -9, message = "stream lost", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError7.prototype);
  }
}
class WebrpcStreamFinishedError7 extends WebrpcError7 {
  constructor(name2 = "WebrpcStreamFinished", code2 = -10, message = "stream finished", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError7.prototype);
  }
}
class UnauthorizedError6 extends WebrpcError7 {
  constructor(name2 = "Unauthorized", code2 = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError6.prototype);
  }
}
class TenantNotFoundError extends WebrpcError7 {
  constructor(name2 = "TenantNotFound", code2 = 1001, message = "Tenant not found", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TenantNotFoundError.prototype);
  }
}
class EmailAlreadyInUseError extends WebrpcError7 {
  constructor(name2 = "EmailAlreadyInUse", code2 = 7e3, message = "Could not create account as the email is already in use", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, EmailAlreadyInUseError.prototype);
  }
}
class AccountAlreadyLinkedError extends WebrpcError7 {
  constructor(name2 = "AccountAlreadyLinked", code2 = 7001, message = "Could not link account as it is linked to another wallet", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AccountAlreadyLinkedError.prototype);
  }
}
class ProofVerificationFailedError extends WebrpcError7 {
  constructor(name2 = "ProofVerificationFailed", code2 = 7002, message = "The authentication proof could not be verified", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ProofVerificationFailedError.prototype);
  }
}
class AnswerIncorrectError extends WebrpcError7 {
  constructor(name2 = "AnswerIncorrect", code2 = 7003, message = "The provided answer is incorrect", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, AnswerIncorrectError.prototype);
  }
}
class ChallengeExpiredError extends WebrpcError7 {
  constructor(name2 = "ChallengeExpired", code2 = 7004, message = "The challenge has expired", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, ChallengeExpiredError.prototype);
  }
}
class TooManyAttemptsError extends WebrpcError7 {
  constructor(name2 = "TooManyAttempts", code2 = 7005, message = "Too many attempts", status = 0, cause) {
    super(name2, code2, message, status, cause);
    Object.setPrototypeOf(this, TooManyAttemptsError.prototype);
  }
}
const webrpcErrorByCode = {
  [0]: WebrpcEndpointError7,
  [-1]: WebrpcRequestFailedError7,
  [-2]: WebrpcBadRouteError7,
  [-3]: WebrpcBadMethodError7,
  [-4]: WebrpcBadRequestError7,
  [-5]: WebrpcBadResponseError7,
  [-6]: WebrpcServerPanicError7,
  [-7]: WebrpcInternalErrorError7,
  [-8]: WebrpcClientDisconnectedError7,
  [-9]: WebrpcStreamLostError7,
  [-10]: WebrpcStreamFinishedError7,
  [1e3]: UnauthorizedError6,
  [1001]: TenantNotFoundError,
  [7e3]: EmailAlreadyInUseError,
  [7001]: AccountAlreadyLinkedError,
  [7002]: ProofVerificationFailedError,
  [7003]: AnswerIncorrectError,
  [7004]: ChallengeExpiredError,
  [7005]: TooManyAttemptsError
};
function isInitiateAuthResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.authInitiated && typeof receipt.data === "object" && typeof receipt.data.sessionId === "string" && typeof receipt.data.identityType === "string" && typeof receipt.data.expiresIn === "number";
}
function isSentTransactionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "transactionReceipt" && typeof receipt.data === "object" && typeof receipt.data.txHash === "string" && typeof receipt.data.receipt === "object" && typeof receipt.data.request === "object";
}
function isTimedOutTransactionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "transactionReceipt" && typeof receipt.data === "object" && typeof receipt.data.metaTxHash === "string" && !receipt.data.txHash && typeof receipt.data.request === "object";
}
function isFailedTransactionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "transactionFailed" && typeof receipt.data === "object" && typeof receipt.data.request === "object" && Array.isArray(receipt.data.simulations) && typeof receipt.data.error === "string";
}
function isMaySentTransactionResponse(receipt) {
  return isSentTransactionResponse(receipt) || isFailedTransactionResponse(receipt) || isTimedOutTransactionResponse(receipt);
}
function isSignedMessageResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "signedMessage" && typeof receipt.data === "object" && typeof receipt.data.message === "string" && typeof receipt.data.signature === "string";
}
function isSessionAuthProofResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "sessionAuthProof" && typeof receipt.data === "object" && typeof receipt.data.sessionId === "string" && typeof receipt.data.network === "string" && typeof receipt.data.wallet === "string" && typeof receipt.data.message === "string" && typeof receipt.data.signature === "string";
}
function isFeeOptionsResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "feeOptions" && typeof receipt.data === "object" && Array.isArray(receipt.data.feeOptions);
}
function isValidationRequiredResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.validationRequired && typeof receipt.data === "object" && typeof receipt.data.sessionId === "string";
}
function isFinishValidateSessionResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.validationFinished && typeof receipt.data === "object";
}
function isCloseSessionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "sessionClosed";
}
function isGetSessionResponse(receipt) {
  return typeof receipt === "object" && typeof receipt.code === "string" && receipt.code === "getSessionResponse" && typeof receipt.data === "object" && typeof receipt.data.session === "string" && typeof receipt.data.wallet === "string";
}
function isLinkAccountResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.accountFederated && typeof receipt.data === "object" && typeof receipt.data.account === "object";
}
function isListAccountsResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.accountList && typeof receipt.data === "object";
}
function isIntentTimeError(error) {
  var _error$cause, _error$cause2;
  return !!(error instanceof WebrpcError7 && ((_error$cause = error.cause) != null && _error$cause.endsWith("intent is invalid: intent expired") || (_error$cause2 = error.cause) != null && _error$cause2.endsWith("intent is invalid: intent issued in the future")));
}
function isGetIdTokenResponse(receipt) {
  return typeof receipt === "object" && receipt.code === IntentResponseCode.idToken && typeof receipt.data === "object" && typeof receipt.data.idToken === "string";
}
class EmailAuth {
  constructor(region, clientId) {
    this.region = region;
    this.clientId = clientId;
    this.cognitoMemo = void 0;
  }
  cognito() {
    if (!this.cognitoMemo) {
      this.cognitoMemo = new CognitoIdentityProviderClient({
        region: this.region
      });
    }
    return this.cognitoMemo;
  }
  signUp(email2) {
    email2 = email2.toLowerCase().trim();
    return this.cognito().send(new SignUpCommand({
      ClientId: this.clientId,
      Username: email2,
      Password: "aB1%" + getRandomString(14),
      UserAttributes: [{
        Name: "email",
        Value: email2
      }]
    }));
  }
  signIn(email2) {
    email2 = email2.toLowerCase().trim();
    return this.cognito().send(new InitiateAuthCommand({
      AuthFlow: "CUSTOM_AUTH",
      ClientId: this.clientId,
      AuthParameters: {
        USERNAME: email2
      }
    }));
  }
  async initiateAuth({
    email: email2
  }) {
    let res;
    email2 = email2.toLowerCase().trim();
    try {
      res = await this.signIn(email2);
    } catch (e2) {
      if (e2 instanceof UserLambdaValidationException && e2.message.includes("user not found")) {
        await this.signUp(email2);
        res = await this.signIn(email2);
      } else {
        throw e2;
      }
    }
    if (!res.Session) {
      throw new Error("response session is empty");
    }
    return {
      // Notice: rename session to instance to avoid
      // confusion with the native waas session
      instance: res.Session,
      email: email2
    };
  }
  async finalizeAuth({
    instance,
    email: email2,
    answer,
    sessionHash
  }) {
    email2 = email2.toLowerCase().trim();
    const res = await this.cognito().send(new RespondToAuthChallengeCommand({
      ClientId: this.clientId,
      Session: instance,
      ChallengeName: "CUSTOM_CHALLENGE",
      ChallengeResponses: {
        USERNAME: email2,
        ANSWER: answer
      },
      ClientMetadata: {
        SESSION_HASH: sessionHash
      }
    }));
    if (!res.AuthenticationResult || !res.AuthenticationResult.IdToken) {
      throw new Error("AuthenticationResult.IdToken is empty");
    }
    return {
      idToken: res.AuthenticationResult.IdToken
    };
  }
}
function getRandomString(len) {
  return Array.from(getRandomValues$1(len)).map((nr) => nr.toString(16).padStart(2, "0")).join("");
}
function getRandomValues$1(len) {
  const randomValues = new Uint8Array(len);
  if (typeof window === "object" && typeof window.crypto === "object") {
    return window.crypto.getRandomValues(randomValues);
  } else {
    console.warn("window.crypto.getRandomValues is not available. Falling back to less secure Math.random().");
    const _randomValues = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      const randomInteger = Math.floor(Math.random() * 256);
      _randomValues[i] = randomInteger;
    }
    return _randomValues;
  }
}
class Challenge {
}
class GuestChallenge extends Challenge {
  constructor(sessionId, challenge) {
    super();
    this.sessionId = sessionId;
    this.challenge = challenge;
  }
  getIntentParams() {
    const answer = keccak256$2(toUtf8Bytes(this.challenge + this.sessionId));
    return {
      identityType: IdentityType.Guest,
      verifier: this.sessionId,
      answer
    };
  }
  withAnswer(answer) {
    return this;
  }
}
class EmailChallenge extends Challenge {
  constructor(email2, sessionId, challenge) {
    super();
    this.email = email2;
    this.sessionId = sessionId;
    this.challenge = challenge;
    this.hashedAnswer = void 0;
  }
  getIntentParams() {
    return {
      identityType: IdentityType.Email,
      verifier: `${this.email};${this.sessionId}`,
      answer: this.hashedAnswer
    };
  }
  setAnswer(answer) {
    this.hashedAnswer = keccak256$2(toUtf8Bytes(this.challenge + answer));
  }
  withAnswer(answer) {
    const challenge = new EmailChallenge(this.email, this.sessionId, this.challenge);
    challenge.setAnswer(answer);
    return challenge;
  }
}
class IdTokenChallenge extends Challenge {
  constructor(idToken) {
    super();
    this.idToken = idToken;
  }
  getIntentParams() {
    const decoded = jwtDecode(this.idToken);
    const idTokenHash = keccak256$2(toUtf8Bytes(this.idToken));
    return {
      identityType: IdentityType.OIDC,
      verifier: `${idTokenHash};${decoded.exp}`,
      answer: this.idToken
    };
  }
  withAnswer() {
    return this;
  }
}
class StytchChallenge extends IdTokenChallenge {
  constructor(idToken) {
    super(idToken);
    this.idToken = idToken;
  }
  getIntentParams() {
    return _extends$2({}, super.getIntentParams(), {
      identityType: IdentityType.Stytch
    });
  }
}
class PlayFabChallenge extends Challenge {
  constructor(titleId, sessionTicket) {
    super();
    this.titleId = titleId;
    this.sessionTicket = sessionTicket;
  }
  getIntentParams() {
    const ticketHash = keccak256$2(toUtf8Bytes(this.sessionTicket));
    return {
      identityType: IdentityType.PlayFab,
      verifier: `${this.titleId}|${ticketHash}`,
      answer: this.sessionTicket
    };
  }
  withAnswer() {
    return this;
  }
}
function parseSequenceWaaSConfigKey(key2) {
  return JSON.parse(atob(key2));
}
function defaultArgsOrFail(config2) {
  const key2 = config2.waasConfigKey;
  const keyOverrides = key2 ? parseSequenceWaaSConfigKey(key2) : {};
  const preconfig = _extends$2({}, config2, keyOverrides);
  if (preconfig.network === void 0) {
    preconfig.network = 1;
  }
  if (preconfig.projectId === void 0) {
    throw new Error("Missing project id");
  }
  if (preconfig.projectAccessKey === void 0) {
    throw new Error("Missing access key");
  }
  return preconfig;
}
class SequenceWaaS {
  constructor(config2, store = new LocalStore(), cryptoBackend = getDefaultSubtleCryptoBackend(), secureStoreBackend = getDefaultSecureStoreBackend()) {
    this.store = store;
    this.cryptoBackend = cryptoBackend;
    this.secureStoreBackend = secureStoreBackend;
    this.waas = void 0;
    this.client = void 0;
    this.validationRequiredCallback = [];
    this.emailConflictCallback = [];
    this.emailAuthCodeRequiredCallback = [];
    this.validationRequiredSalt = void 0;
    this.config = void 0;
    this.deviceName = void 0;
    this.emailClient = void 0;
    this.lastDate = void 0;
    this.config = defaultArgsOrFail(config2);
    this.waas = new SequenceWaaSBase(_extends$2({
      network: 1
    }, config2), this.store, this.cryptoBackend, this.secureStoreBackend);
    this.client = new WaasAuthenticator(this.config.rpcServer, this.fetch.bind(this));
    this.deviceName = new StoreObj(this.store, "@0xsequence.waas.auth.deviceName", void 0);
  }
  get email() {
    if (this.emailClient) {
      return this.emailClient;
    }
    if (!this.config.emailRegion) {
      throw new Error("Missing emailRegion");
    }
    if (!this.config.emailClientId) {
      throw new Error("Missing emailClientId");
    }
    this.emailClient = new EmailAuth(this.config.emailRegion, this.config.emailClientId);
    return this.emailClient;
  }
  async onValidationRequired(callback) {
    this.validationRequiredCallback.push(callback);
    return () => {
      this.validationRequiredCallback = this.validationRequiredCallback.filter((c2) => c2 !== callback);
    };
  }
  onEmailConflict(callback) {
    this.emailConflictCallback.push(callback);
    return () => {
      this.emailConflictCallback = this.emailConflictCallback.filter((c2) => c2 !== callback);
    };
  }
  onEmailAuthCodeRequired(callback) {
    this.emailAuthCodeRequiredCallback.push(callback);
    return () => {
      this.emailAuthCodeRequiredCallback = this.emailAuthCodeRequiredCallback.filter((c2) => c2 !== callback);
    };
  }
  async handleValidationRequired({
    onValidationRequired
  } = {}) {
    var _await$this$deviceNam;
    const proceed = onValidationRequired ? onValidationRequired() : true;
    if (!proceed) {
      return false;
    }
    const intent = await this.waas.validateSession({
      deviceMetadata: (_await$this$deviceNam = await this.deviceName.get()) != null ? _await$this$deviceNam : "Unknown device"
    });
    const sendIntent = await this.sendIntent(intent);
    this.validationRequiredSalt = sendIntent.data.salt;
    for (const callback of this.validationRequiredCallback) {
      callback();
    }
    return this.waitForSessionValid();
  }
  headers() {
    return {
      "X-Access-Key": this.config.projectAccessKey
    };
  }
  async sendIntent(intent) {
    const sessionId = await this.waas.getSessionId();
    if (!sessionId) {
      throw new Error("session not open");
    }
    try {
      const res = await this.client.sendIntent({
        intent
      }, this.headers());
      return res.response;
    } catch (e2) {
      if (isIntentTimeError(e2) && this.lastDate) {
        const newIntent = await this.waas.updateIntentTime(intent, this.lastDate);
        const res = await this.client.sendIntent({
          intent: newIntent
        }, this.headers());
        return res.response;
      }
      throw e2;
    }
  }
  async isSignedIn() {
    return this.waas.isSignedIn();
  }
  signIn(creds, sessionName) {
    var _this = this;
    const isEmailAuth = "email" in creds;
    if (isEmailAuth && this.emailAuthCodeRequiredCallback.length == 0) {
      return Promise.reject("Missing emailAuthCodeRequired callback");
    }
    return new Promise(async function(resolve, reject) {
      const challenge = await _this.initAuth(creds);
      const respondToChallenge = async function respondToChallenge2(answer) {
        try {
          const res = await _this.completeAuth(challenge.withAnswer(answer), {
            sessionName
          });
          resolve(res);
        } catch (e2) {
          if (e2 instanceof AnswerIncorrectError) {
            throw e2;
          } else if (e2 instanceof EmailAlreadyInUseError) {
            const forceCreate = async function forceCreate2() {
              try {
                const res = await _this.completeAuth(challenge.withAnswer(answer), {
                  sessionName,
                  forceCreateAccount: true
                });
                resolve(res);
              } catch (e3) {
                reject(e3);
              }
            };
            const info = {
              type: IdentityType.None,
              email: "",
              issuer: ""
            };
            if (e2.cause) {
              const parts = e2.cause.split("|");
              if (parts.length >= 2) {
                info.type = parts[0];
                info.email = parts[1];
              }
              if (parts.length >= 3) {
                info.issuer = parts[2];
              }
            }
            for (const callback of _this.emailConflictCallback) {
              callback(info, forceCreate);
            }
          } else {
            reject(e2);
          }
        }
      };
      if (isEmailAuth) {
        for (const callback of _this.emailAuthCodeRequiredCallback) {
          callback(respondToChallenge);
        }
      } else {
        respondToChallenge("");
      }
    });
  }
  async initAuth(identity) {
    if ("guest" in identity && identity.guest) {
      return this.initGuestAuth();
    } else if ("idToken" in identity) {
      return this.initIdTokenAuth(identity.idToken);
    } else if ("email" in identity) {
      return this.initEmailAuth(identity.email);
    } else if ("playFabTitleId" in identity) {
      return this.initPlayFabAuth(identity.playFabTitleId, identity.playFabSessionTicket);
    }
    throw new Error("invalid identity");
  }
  async initGuestAuth() {
    const sessionId = await this.waas.getSessionId();
    const intent = await this.waas.initiateGuestAuth();
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new GuestChallenge(sessionId, res.data.challenge);
  }
  async initIdTokenAuth(idToken) {
    var _decoded$iss;
    const decoded = jwtDecode(idToken);
    const isStytch = ((_decoded$iss = decoded.iss) == null ? void 0 : _decoded$iss.startsWith("stytch.com/")) || false;
    const intent = isStytch ? await this.waas.initiateStytchAuth(idToken, decoded.exp) : await this.waas.initiateIdTokenAuth(idToken, decoded.exp);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return isStytch ? new StytchChallenge(idToken) : new IdTokenChallenge(idToken);
  }
  async initEmailAuth(email2) {
    const sessionId = await this.waas.getSessionId();
    const intent = await this.waas.initiateEmailAuth(email2);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new EmailChallenge(email2, sessionId, res.data.challenge);
  }
  async initPlayFabAuth(titleId, sessionTicket) {
    const intent = await this.waas.initiatePlayFabAuth(titleId, sessionTicket);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new PlayFabChallenge(titleId, sessionTicket);
  }
  async completeAuth(challenge, opts) {
    if (!opts) {
      opts = {};
    }
    if (!opts.sessionName) {
      opts.sessionName = "session name";
    }
    const intent = await this.waas.completeAuth(challenge.getIntentParams(), {
      forceCreateAccount: opts.forceCreateAccount
    });
    try {
      const res = await this.registerSession(intent, opts.sessionName);
      await this.waas.completeSignIn({
        code: "sessionOpened",
        data: {
          sessionId: res.session.id,
          wallet: res.response.data.wallet
        }
      });
      return {
        sessionId: res.session.id,
        wallet: res.response.data.wallet,
        email: res.session.identity.email
      };
    } catch (e2) {
      if (!(e2 instanceof EmailAlreadyInUseError) && !(e2 instanceof AnswerIncorrectError)) {
        await this.waas.completeSignOut();
      }
      throw e2;
    }
  }
  async registerSession(intent, name2) {
    try {
      const res = await this.client.registerSession({
        intent,
        friendlyName: name2
      }, this.headers());
      return res;
    } catch (e2) {
      if (isIntentTimeError(e2) && this.lastDate) {
        const newIntent = await this.waas.updateIntentTime(intent, this.lastDate);
        return await this.client.registerSession({
          intent: newIntent,
          friendlyName: name2
        }, this.headers());
      }
      throw e2;
    }
  }
  async refreshSession() {
    throw new Error("Not implemented");
  }
  async getSessionId() {
    return this.waas.getSessionId();
  }
  async getSessionHash() {
    const sessionId = (await this.waas.getSessionId()).toLowerCase();
    return keccak256$2(toUtf8Bytes(sessionId));
  }
  async dropSession({
    sessionId,
    strict
  } = {}) {
    const thisSessionId = await this.waas.getSessionId();
    if (!thisSessionId) {
      throw new Error("session not open");
    }
    const closeSessionId = sessionId || thisSessionId;
    try {
      const intent = await this.waas.signOutSession(closeSessionId);
      const result = await this.sendIntent(intent);
      if (!isCloseSessionResponse(result)) {
        throw new Error(`Invalid response: ${JSON.stringify(result)}`);
      }
    } catch (e2) {
      if (strict) {
        throw e2;
      }
      console.error(e2);
    }
    if (closeSessionId === thisSessionId) {
      if (!this.secureStoreBackend) {
        throw new Error("No secure store available");
      }
      const session = await newSessionFromSessionId(thisSessionId, this.cryptoBackend, this.secureStoreBackend);
      session.clear();
      await this.waas.completeSignOut();
      await this.deviceName.set(void 0);
    }
  }
  async listSessions() {
    const sessionId = await this.waas.getSessionId();
    if (!sessionId) {
      throw new Error("session not open");
    }
    const intent = await this.waas.listSessions();
    const res = await this.sendIntent(intent);
    return res.data.map((session) => _extends$2({}, session, {
      isThis: session.id === sessionId
    }));
  }
  // WaaS specific methods
  async getAddress() {
    return this.waas.getAddress();
  }
  async validateSession(args) {
    if (await this.isSessionValid()) {
      return true;
    }
    return this.handleValidationRequired(args);
  }
  async finishValidateSession(challenge) {
    const intent = await this.waas.finishValidateSession(this.validationRequiredSalt, challenge);
    const result = await this.sendIntent(intent);
    if (!isFinishValidateSessionResponse(result)) {
      throw new Error(`Invalid response: ${JSON.stringify(result)}`);
    }
    this.validationRequiredSalt = "";
    return result.data.isValid;
  }
  async isSessionValid() {
    const intent = await this.waas.getSession();
    const result = await this.sendIntent(intent);
    if (!isGetSessionResponse(result)) {
      throw new Error(`Invalid response: ${JSON.stringify(result)}`);
    }
    return result.data.validated;
  }
  async waitForSessionValid(timeout = 6e5, pollRate = 2e3) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (await this.isSessionValid()) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, pollRate));
    }
    return false;
  }
  async sessionAuthProof({
    nonce,
    network: network2,
    validation
  }) {
    const intent = await this.waas.sessionAuthProof({
      nonce,
      network: network2
    });
    return await this.trySendIntent({
      validation
    }, intent, isSessionAuthProofResponse);
  }
  async listAccounts() {
    const intent = await this.waas.listAccounts();
    const res = await this.sendIntent(intent);
    if (!isListAccountsResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async linkAccount(challenge) {
    const intent = await this.waas.linkAccount(challenge.getIntentParams());
    const res = await this.sendIntent(intent);
    if (!isLinkAccountResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async removeAccount(accountId) {
    const intent = await this.waas.removeAccount({
      accountId
    });
    await this.sendIntent(intent);
  }
  async getIdToken(args) {
    const intent = await this.waas.getIdToken({
      nonce: args == null ? void 0 : args.nonce
    });
    const res = await this.sendIntent(intent);
    if (!isGetIdTokenResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async useIdentifier(args) {
    if (args.identifier) {
      return args;
    }
    const identifier = `ts-sdk-${Date.now()}-${await this.waas.getSessionId()}`;
    return _extends$2({}, args, {
      identifier
    });
  }
  async trySendIntent(args, intent, isExpectedResponse) {
    const response = await this.sendIntent(intent);
    if (isExpectedResponse(response)) {
      return response;
    }
    if (isValidationRequiredResponse(response)) {
      const proceed = await this.handleValidationRequired(args.validation);
      if (proceed) {
        const response2 = await this.sendIntent(intent);
        if (isExpectedResponse(response2)) {
          return response2;
        }
      }
    }
    throw new Error(JSON.stringify(response));
  }
  async signMessage(args) {
    const intent = await this.waas.signMessage(await this.useIdentifier(args));
    return this.trySendIntent(args, intent, isSignedMessageResponse);
  }
  async trySendTransactionIntent(intent, args) {
    let result = await this.trySendIntent(args, intent, isMaySentTransactionResponse);
    while (isTimedOutTransactionResponse(result)) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      const receiptArgs = {
        metaTxHash: result.data.metaTxHash,
        network: intent.data.network,
        identifier: intent.data.identifier,
        validation: args.validation
      };
      const receiptIntent = await this.waas.getTransactionReceipt(await this.useIdentifier(receiptArgs));
      result = await this.trySendIntent(receiptArgs, receiptIntent, isMaySentTransactionResponse);
    }
    return result;
  }
  async sendTransaction(args) {
    const intent = await this.waas.sendTransaction(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC20(args) {
    const intent = await this.waas.sendERC20(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC721(args) {
    const intent = await this.waas.sendERC721(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC1155(args) {
    const intent = await this.waas.sendERC1155(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async callContract(args) {
    const intent = await this.waas.callContract(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async feeOptions(args) {
    const intent = await this.waas.feeOptions(await this.useIdentifier(args));
    return this.trySendIntent(args, intent, isFeeOptionsResponse);
  }
  async networkList() {
    const networks2 = [];
    const chainList = await this.client.chainList({
      "X-Access-Key": this.config.projectAccessKey
    });
    for (const chain of chainList.chains) {
      networks2.push({
        id: chain.id,
        name: chain.name,
        isEnabled: chain.isEnabled
      });
    }
    return networks2;
  }
  onSessionStateChanged(callback) {
    return this.waas.onSessionStateChanged(callback);
  }
  // Special version of fetch that keeps track of the last seen Date header
  async fetch(input2, init3) {
    const res = await window.fetch(input2, init3);
    const headerValue = res.headers.get("date");
    if (headerValue) {
      this.lastDate = new Date(headerValue);
    }
    return res;
  }
}
const accountTypeText = (info) => {
  if (!info) {
    return "Unknown account type";
  }
  if (info.type === IdentityType.PlayFab) {
    return "PlayFab login";
  }
  if (info.type === IdentityType.Email) {
    return "Email login";
  }
  if (info.type === IdentityType.OIDC) {
    if (info.issuer.includes("cognito-idp")) {
      return "Legacy Email login";
    }
    switch (info.issuer) {
      case "https://accounts.google.com":
        return "Google login";
      case "https://appleid.apple.com":
        return "Apple login";
      default:
        return "Unknown account type";
    }
  }
  return info.type;
};
const useEmailConflict = () => {
  const { connectors } = useConnect();
  const forceCreateFuncRef = reactExports.useRef(null);
  const [isOpen, toggleModal] = reactExports.useState(false);
  const [emailConflictInfo, setEmailConflictInfo] = reactExports.useState(null);
  const waasConnector = connectors.find((connector) => !!connector.sequenceWaas);
  const waas = waasConnector == null ? void 0 : waasConnector.sequenceWaas;
  reactExports.useEffect(() => {
    if (waas) {
      const disposer = waas.onEmailConflict(async (info, forceCreate) => {
        forceCreateFuncRef.current = forceCreate;
        setEmailConflictInfo(info);
        toggleModal(true);
      });
      return disposer;
    }
  }, []);
  return {
    toggleEmailConflictModal: toggleModal,
    isEmailConflictOpen: isOpen,
    emailConflictInfo: {
      email: (emailConflictInfo == null ? void 0 : emailConflictInfo.email) ?? "Unknown",
      type: accountTypeText(emailConflictInfo)
    },
    forceCreate: async () => {
      var _a2;
      return (_a2 = forceCreateFuncRef.current) == null ? void 0 : _a2.call(forceCreateFuncRef, true);
    }
  };
};
const getModalPositionCss = (position) => {
  switch (position) {
    case "top-right":
      return {
        top: "0px",
        right: "0px"
      };
    case "top-left":
      return {
        top: "0px",
        left: "0px"
      };
    case "top-center":
      return {
        top: "0px"
      };
    case "bottom-right":
      return {
        bottom: "0px",
        right: "0px"
      };
    case "bottom-left":
      return {
        bottom: "0px",
        left: "0px"
      };
    case "bottom-center":
      return {
        bottom: "0px"
      };
    case "middle-right":
      return {
        right: "0px"
      };
    case "middle-left":
      return {
        left: "0px"
      };
    case "center":
    default:
      return {};
  }
};
var dist = {};
var AppleSigninButton$1 = {};
var useScript$1 = {};
Object.defineProperty(useScript$1, "__esModule", {
  value: true
});
useScript$1.default = void 0;
var _react$2 = reactExports;
function useScript(src) {
  (0, _react$2.useEffect)(
    function() {
      if (!src) {
        return;
      }
      var script = document.querySelectorAll('script[src="'.concat(src, '"]'))[0];
      if (!script) {
        script = document.createElement("script");
        script.src = src;
        script.async = true;
        document.body.appendChild(script);
      }
    },
    [src]
    // Only re-run effect if script src changes
  );
}
var _default$3 = useScript;
useScript$1.default = _default$3;
var appleAuthHelpers = {};
var waitForVar$1 = {};
Object.defineProperty(waitForVar$1, "__esModule", {
  value: true
});
waitForVar$1.default = void 0;
var waitForVar = function waitForVar2(name2) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    pollFrequency: 1e3,
    retries: 100,
    parent: window
  }, _ref$pollFrequency = _ref.pollFrequency, pollFrequency = _ref$pollFrequency === void 0 ? 1e3 : _ref$pollFrequency, _ref$retries = _ref.retries, inRetries = _ref$retries === void 0 ? 100 : _ref$retries, _ref$parent = _ref.parent, parent2 = _ref$parent === void 0 ? window : _ref$parent;
  if (parent2 && parent2.hasOwnProperty(name2)) {
    return Promise.resolve(parent2[name2]);
  }
  if (!inRetries) {
    return Promise.resolve(void 0);
  }
  var retries = inRetries - 1;
  return new Promise(function(resolve) {
    return setTimeout(resolve, typeof pollFrequency === "function" ? pollFrequency({
      retries
    }) : pollFrequency);
  }).then(function() {
    return waitForVar2(name2, {
      pollFrequency,
      parent: parent2,
      retries
    });
  });
};
var _default$2 = waitForVar;
waitForVar$1.default = _default$2;
Object.defineProperty(appleAuthHelpers, "__esModule", {
  value: true
});
appleAuthHelpers.default = void 0;
var _waitForVar = _interopRequireDefault$2(waitForVar$1);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var APPLE_SCRIPT_SRC = "https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js";
var signIn = function signIn2(_ref) {
  var authOptions = _ref.authOptions, onSuccess = _ref.onSuccess, onError = _ref.onError;
  return (
    /** wait for apple sript to load */
    (0, _waitForVar.default)("AppleID").then(function() {
      if (!window.AppleID) {
        console.error(new Error("Error loading apple script"));
      }
      window.AppleID.auth.init(authOptions);
      return window.AppleID.auth.signIn().then(function(response) {
        if (onSuccess) {
          onSuccess(response);
        }
        return response;
      }).catch(function(err) {
        if (onError) {
          onError(err);
        } else {
          console.error(err);
        }
        return null;
      });
    }).catch(function(err) {
      if (onError) {
        onError(err);
      } else {
        console.error(err);
      }
      return null;
    })
  );
};
var _default$1 = {
  APPLE_SCRIPT_SRC,
  signIn
};
appleAuthHelpers.default = _default$1;
Object.defineProperty(AppleSigninButton$1, "__esModule", {
  value: true
});
AppleSigninButton$1.default = void 0;
var _react$1 = _interopRequireDefault$1(reactExports);
var _useScript = _interopRequireDefault$1(useScript$1);
var _appleAuthHelpers = _interopRequireDefault$1(appleAuthHelpers);
var _excluded$1 = ["onSuccess", "onError", "skipScript", "authOptions", "iconProps", "render", "uiType", "className", "noDefaultStyle", "buttonExtraChildren"];
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var _style = "\n.react-apple-signin-auth-btn {\n  background-color: transparent;\n  border: none;\n  padding: 0;\n  cursor: pointer;\n  border-radius: 4px;\n  padding: 0 8px 0 2px;\n  font-size: 14px;\n  font-size: 1em;\n  line-height: 1;\n  border: 1px solid #000;\n  overflow: hidden;\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n}\n.react-apple-signin-auth-btn-light {\n  background-color: #FFF;\n  color: #000;\n  border-color: #000;\n}\n.react-apple-signin-auth-btn-dark {\n  background-color: #000;\n  color: #FFF;\n  border-color: #FFF;\n}".replace(/ {2}|\n/g, "");
var AppleSigninButton = function AppleSigninButton2(_ref) {
  var onSuccess = _ref.onSuccess, onError = _ref.onError, _ref$skipScript = _ref.skipScript, skipScript = _ref$skipScript === void 0 ? false : _ref$skipScript, authOptions = _ref.authOptions, iconProps = _ref.iconProps, render = _ref.render, _ref$uiType = _ref.uiType, uiType = _ref$uiType === void 0 ? "dark" : _ref$uiType, className = _ref.className, _ref$noDefaultStyle = _ref.noDefaultStyle, noDefaultStyle = _ref$noDefaultStyle === void 0 ? false : _ref$noDefaultStyle, _ref$buttonExtraChild = _ref.buttonExtraChildren, buttonExtraChildren = _ref$buttonExtraChild === void 0 ? "Continue with Apple" : _ref$buttonExtraChild, rest = _objectWithoutProperties$1(_ref, _excluded$1);
  (0, _useScript.default)(skipScript ? null : _appleAuthHelpers.default.APPLE_SCRIPT_SRC);
  var handleClick = function handleClick2(e2) {
    if (e2) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    _appleAuthHelpers.default.signIn({
      authOptions,
      onSuccess,
      onError
    });
  };
  var props = _objectSpread$1({
    children: /* @__PURE__ */ _react$1.default.createElement(_react$1.default.Fragment, null, /* @__PURE__ */ _react$1.default.createElement("svg", _extends$1({
      width: "24px",
      height: "44px",
      viewBox: "0 0 24 44"
    }, iconProps), /* @__PURE__ */ _react$1.default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ _react$1.default.createElement("rect", {
      fill: uiType === "light" ? "#FFF" : "#000",
      x: "0",
      y: "0",
      width: "24",
      height: "44"
    }), /* @__PURE__ */ _react$1.default.createElement("path", {
      d: "M12.2337427,16.9879688 C12.8896607,16.9879688 13.7118677,16.5445313 14.2014966,15.9532812 C14.6449341,15.4174609 14.968274,14.6691602 14.968274,13.9208594 C14.968274,13.8192383 14.9590357,13.7176172 14.9405591,13.6344727 C14.2107349,13.6621875 13.3330982,14.1241016 12.8065162,14.7430664 C12.3907935,15.2142188 12.012024,15.9532812 12.012024,16.7108203 C12.012024,16.8216797 12.0305005,16.9325391 12.0397388,16.9694922 C12.0859302,16.9787305 12.1598365,16.9879688 12.2337427,16.9879688 Z M9.92417241,28.1662891 C10.8202857,28.1662891 11.2175318,27.5658008 12.3353638,27.5658008 C13.4716724,27.5658008 13.721106,28.1478125 14.7188404,28.1478125 C15.6980982,28.1478125 16.3540162,27.2424609 16.972981,26.3555859 C17.6658521,25.339375 17.9522388,24.3416406 17.9707154,24.2954492 C17.9060474,24.2769727 16.0306763,23.5101953 16.0306763,21.3576758 C16.0306763,19.491543 17.5088013,18.6508594 17.5919459,18.5861914 C16.612688,17.1819727 15.1253248,17.1450195 14.7188404,17.1450195 C13.6194849,17.1450195 12.7233716,17.8101758 12.1598365,17.8101758 C11.5501099,17.8101758 10.7463794,17.1819727 9.79483648,17.1819727 C7.98413335,17.1819727 6.14571538,18.6785742 6.14571538,21.5054883 C6.14571538,23.2607617 6.8293482,25.1176563 7.67003179,26.3186328 C8.39061773,27.3348438 9.01882085,28.1662891 9.92417241,28.1662891 Z",
      fill: uiType === "light" ? "#000" : "#FFF",
      fillRule: "nonzero"
    }))), buttonExtraChildren),
    onClick: handleClick
  }, rest);
  if (render) {
    return render(props);
  }
  return /* @__PURE__ */ _react$1.default.createElement(_react$1.default.Fragment, null, /* @__PURE__ */ _react$1.default.createElement("button", _extends$1({
    className: "".concat(noDefaultStyle ? "" : "react-apple-signin-auth-btn react-apple-signin-auth-btn-".concat(uiType)).concat(className ? " ".concat(className) : ""),
    type: "button",
    "aria-label": "Signin with apple ID"
  }, props)), noDefaultStyle ? null : /* @__PURE__ */ _react$1.default.createElement("style", null, _style));
};
var _default = AppleSigninButton;
AppleSigninButton$1.default = _default;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "appleAuthHelpers", {
    enumerable: true,
    get: function get2() {
      return _appleAuthHelpers2.default;
    }
  });
  Object.defineProperty(exports, "useScript", {
    enumerable: true,
    get: function get2() {
      return _useScript2.default;
    }
  });
  exports.default = void 0;
  var _AppleSigninButton = _interopRequireDefault2(AppleSigninButton$1);
  var _appleAuthHelpers2 = _interopRequireDefault2(appleAuthHelpers);
  var _useScript2 = _interopRequireDefault2(useScript$1);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var _default2 = _AppleSigninButton.default;
  exports.default = _default2;
})(dist);
sequenceWallet.type = "sequence";
function sequenceWallet(params) {
  const { defaultNetwork, connect: connect2, walletAppURL } = params;
  const { projectAccessKey: projectAccessKey2 } = connect2;
  return createConnector((config2) => ({
    id: "sequence",
    name: "Sequence",
    type: sequenceWallet.type,
    params,
    setEmail(email2) {
      if (params.connect.settings) {
        params.connect.settings.signInWithEmail = email2;
      }
    },
    async setup() {
      const provider2 = await this.getProvider();
      provider2.on("chainChanged", (chainIdHex) => {
        config2.emitter.emit("change", { chainId: normalizeChainId$1(chainIdHex) });
      });
      provider2.on("disconnect", () => {
        this.onDisconnect();
      });
    },
    async connect() {
      var _a2, _b2, _c2, _d2, _e2;
      const provider2 = await this.getProvider();
      if (!provider2.isConnected()) {
        const localStorageTheme = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(LocalStorageKey.Theme));
        const ethAuthSettings = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem(LocalStorageKey.EthAuthSettings)) ?? {};
        const connectOptionsWithTheme = {
          authorize: true,
          ...ethAuthSettings,
          ...connect2,
          settings: {
            theme: localStorageTheme || "dark",
            ...connect2 == null ? void 0 : connect2.settings
          }
        };
        const e2 = await provider2.connect(connectOptionsWithTheme);
        if (e2.error) {
          throw new UserRejectedRequestError(new Error(e2.error));
        }
        if (!e2.connected) {
          throw new UserRejectedRequestError(new Error("Wallet connection rejected"));
        }
        const proofString = (_c2 = e2.proof) == null ? void 0 : _c2.proofString;
        const proofTypedData = (_d2 = e2.proof) == null ? void 0 : _d2.typedData;
        if (proofString && proofTypedData) {
          const jsonEthAuthProof = {
            proofString,
            typedData: proofTypedData
          };
          await ((_e2 = config2.storage) == null ? void 0 : _e2.setItem(LocalStorageKey.EthAuthProof, jsonEthAuthProof));
        }
      }
      const accounts = await this.getAccounts();
      return {
        accounts: [...accounts],
        chainId: provider2.getChainId()
      };
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      provider2.disconnect();
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      const signer2 = provider2.getSigner();
      const account2 = getAddress(await signer2.getAddress());
      return [account2];
    },
    async getProvider() {
      try {
        const provider2 = sequence$1.getWallet();
        return provider2;
      } catch (err) {
        if (!projectAccessKey2) {
          throw "projectAccessKey not found";
        }
        const provider2 = sequence$1.initWallet(projectAccessKey2, {
          defaultNetwork,
          transports: {
            walletAppURL: walletAppURL || "https://sequence.app"
          },
          defaultEIP6492: true,
          analytics: false
        });
        const chainId = provider2.getChainId();
        config2.emitter.emit("change", { chainId: normalizeChainId$1(chainId) });
        return provider2;
      }
    },
    async isAuthorized() {
      try {
        const account2 = await this.getAccounts();
        return !!account2;
      } catch (e2) {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const provider2 = await this.getProvider();
      const chain = config2.chains.find((c2) => c2.id === chainId) || config2.chains[0];
      provider2.setDefaultChainId(normalizeChainId$1(chainId));
      config2.emitter.emit("change", { chainId });
      return chain;
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = provider2.getChainId();
      return chainId;
    },
    async onAccountsChanged(accounts) {
      return { account: accounts[0] };
    },
    async onChainChanged(chain) {
      const provider2 = await this.getProvider();
      config2.emitter.emit("change", { chainId: normalizeChainId$1(chain) });
      provider2.setDefaultChainId(normalizeChainId$1(chain));
    },
    async onConnect(_connectinfo) {
    },
    async onDisconnect() {
      var _a2;
      await ((_a2 = config2.storage) == null ? void 0 : _a2.removeItem(LocalStorageKey.EthAuthProof));
      config2.emitter.emit("disconnect");
    }
  }));
}
function normalizeChainId$1(chainId) {
  if (typeof chainId === "object")
    return normalizeChainId$1(chainId.chainId);
  if (typeof chainId === "string")
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset2) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
sequenceWaasWallet.type = "sequence-waas";
function sequenceWaasWallet(params) {
  const isDev = !!(params == null ? void 0 : params.isDev);
  const nodesUrl = isDev ? "https://dev-nodes.sequence.app" : "https://nodes.sequence.app";
  const showConfirmationModal = params.enableConfirmationModal ?? false;
  const sequenceWaas = new SequenceWaaS({
    waasConfigKey: params.waasConfigKey,
    projectAccessKey: params.projectAccessKey,
    network: params.network ?? 137
  });
  const sequenceWaasProvider = new SequenceWaasProvider(sequenceWaas, showConfirmationModal, nodesUrl);
  return createConnector((config2) => ({
    id: `sequence-waas`,
    name: "Sequence WaaS",
    type: sequenceWaasWallet.type,
    sequenceWaas,
    sequenceWaasProvider,
    params,
    async setup() {
      var _a2, _b2, _c2;
      if (typeof window !== "object") {
        return;
      }
      const provider2 = await this.getProvider();
      if (params.googleClientId) {
        await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem(LocalStorageKey.WaasGoogleClientID, params.googleClientId));
      }
      if (params.appleClientId) {
        await ((_b2 = config2.storage) == null ? void 0 : _b2.setItem(LocalStorageKey.WaasAppleClientID, params.appleClientId));
      }
      if (params.appleRedirectURI) {
        await ((_c2 = config2.storage) == null ? void 0 : _c2.setItem(LocalStorageKey.WaasAppleRedirectURI, params.appleRedirectURI));
      }
      provider2.on("disconnect", () => {
        this.onDisconnect();
      });
    },
    async connect(_connectInfo) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
      const provider2 = await this.getProvider();
      const isSignedIn = await provider2.sequenceWaas.isSignedIn();
      if (!isSignedIn) {
        const googleIdToken = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(LocalStorageKey.WaasGoogleIdToken));
        const emailIdToken = await ((_b2 = config2.storage) == null ? void 0 : _b2.getItem(LocalStorageKey.WaasEmailIdToken));
        const appleIdToken = await ((_c2 = config2.storage) == null ? void 0 : _c2.getItem(LocalStorageKey.WaasAppleIdToken));
        let idToken;
        if (params.loginType === "google" && googleIdToken) {
          idToken = googleIdToken;
        } else if (params.loginType === "email" && emailIdToken) {
          idToken = emailIdToken;
        } else if (params.loginType === "apple" && appleIdToken) {
          idToken = appleIdToken;
        }
        await ((_d2 = config2.storage) == null ? void 0 : _d2.removeItem(LocalStorageKey.WaasGoogleIdToken));
        await ((_e2 = config2.storage) == null ? void 0 : _e2.removeItem(LocalStorageKey.WaasEmailIdToken));
        await ((_f2 = config2.storage) == null ? void 0 : _f2.removeItem(LocalStorageKey.WaasAppleIdToken));
        if (idToken) {
          try {
            const signInResponse = await provider2.sequenceWaas.signIn({ idToken }, randomName());
            if (signInResponse == null ? void 0 : signInResponse.email) {
              await ((_g2 = config2.storage) == null ? void 0 : _g2.setItem(LocalStorageKey.WaasSignInEmail, signInResponse.email));
            }
          } catch (e2) {
            console.log(e2);
            await this.disconnect();
            throw e2;
          }
        }
      }
      const accounts = await this.getAccounts();
      if (accounts.length) {
        await ((_h2 = config2.storage) == null ? void 0 : _h2.setItem(LocalStorageKey.WaasActiveLoginType, params.loginType));
      } else {
        throw new Error("No accounts found");
      }
      return {
        accounts,
        chainId: await this.getChainId()
      };
    },
    async disconnect() {
      var _a2;
      const provider2 = await this.getProvider();
      try {
        await provider2.sequenceWaas.dropSession({ sessionId: await provider2.sequenceWaas.getSessionId() });
      } catch (e2) {
        console.log(e2);
      }
      await ((_a2 = config2.storage) == null ? void 0 : _a2.removeItem(LocalStorageKey.WaasActiveLoginType));
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      try {
        const isSignedIn = await provider2.sequenceWaas.isSignedIn();
        if (isSignedIn) {
          const address = await provider2.sequenceWaas.getAddress();
          return [getAddress(address)];
        }
      } catch (err) {
        return [];
      }
      return [];
    },
    async getProvider() {
      return sequenceWaasProvider;
    },
    async isAuthorized() {
      var _a2;
      const provider2 = await this.getProvider();
      const activeWaasOption = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(LocalStorageKey.WaasActiveLoginType));
      if (params.loginType !== activeWaasOption) {
        return false;
      }
      try {
        return await provider2.sequenceWaas.isSignedIn();
      } catch (e2) {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const provider2 = await this.getProvider();
      const chain = config2.chains.find((c2) => c2.id === chainId) || config2.chains[0];
      await provider2.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: hexValue(chainId) }]
      });
      config2.emitter.emit("change", { chainId });
      return chain;
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      return provider2.getChainId();
    },
    async onAccountsChanged(accounts) {
      return { account: accounts[0] };
    },
    async onChainChanged(chain) {
      config2.emitter.emit("change", { chainId: normalizeChainId(chain) });
    },
    async onConnect(_connectInfo) {
    },
    async onDisconnect() {
      await this.disconnect();
    }
  }));
}
class SequenceWaasProvider extends BaseProvider {
  constructor(sequenceWaas, showConfirmation, nodesUrl) {
    var _a2;
    super(sequenceWaas.config.network);
    __publicField(this, "sequenceWaas");
    __publicField(this, "showConfirmation");
    __publicField(this, "nodesUrl");
    __publicField(this, "jsonRpcProvider");
    __publicField(this, "requestConfirmationHandler");
    __publicField(this, "feeConfirmationHandler");
    __publicField(this, "currentNetwork", this.network);
    this.sequenceWaas = sequenceWaas;
    this.showConfirmation = showConfirmation;
    this.nodesUrl = nodesUrl;
    const initialChain = sequenceWaas.config.network;
    const initialChainName = (_a2 = sequence$1.network.allNetworks.find((n2) => n2.chainId === initialChain || n2.name === initialChain)) == null ? void 0 : _a2.name;
    const initialJsonRpcProvider = new JsonRpcProvider$1(`${nodesUrl}/${initialChainName}/${sequenceWaas.config.projectAccessKey}`);
    this.jsonRpcProvider = initialJsonRpcProvider;
  }
  async request({ method, params }) {
    var _a2;
    if (method === "wallet_switchEthereumChain") {
      const chainId = normalizeChainId(params == null ? void 0 : params[0].chainId);
      const networkName = (_a2 = sequence$1.network.allNetworks.find((n2) => n2.chainId === chainId)) == null ? void 0 : _a2.name;
      const jsonRpcProvider = new JsonRpcProvider$1(`${this.nodesUrl}/${networkName}/${this.sequenceWaas.config.projectAccessKey}`);
      this.jsonRpcProvider = jsonRpcProvider;
      this.currentNetwork = getNetwork$1(chainId);
      return null;
    }
    if (method === "eth_chainId") {
      return hexValue(this.currentNetwork.chainId);
    }
    if (method === "eth_accounts") {
      const address = await this.sequenceWaas.getAddress();
      const account2 = getAddress(address);
      return [account2];
    }
    if (method === "eth_sendTransaction") {
      const txns = await resolveProperties$1(params == null ? void 0 : params[0]);
      const chainId = this.getChainId();
      const feeOptionsResponse = await this.checkTransactionFeeOptions({ transactions: [txns], chainId });
      const feeOptions2 = feeOptionsResponse == null ? void 0 : feeOptionsResponse.feeOptions;
      let selectedFeeOption;
      if (!(feeOptionsResponse == null ? void 0 : feeOptionsResponse.isSponsored) && feeOptions2 && feeOptions2.length > 0) {
        if (!this.feeConfirmationHandler) {
          throw new TransactionRejectedRpcError(new Error("Unable to send transaction: please use UseWaasFeeOptions hook and pick a fee option"));
        }
        const id2 = v4();
        const confirmation = await this.feeConfirmationHandler.confirmFeeOption(id2, feeOptions2, txns, chainId);
        if (!confirmation.confirmed) {
          throw new UserRejectedRequestError(new Error("User rejected send transaction request"));
        }
        if (id2 !== confirmation.id) {
          throw new UserRejectedRequestError(new Error("User confirmation ids do not match"));
        }
        selectedFeeOption = feeOptions2.find((feeOption) => feeOption.token.contractAddress === confirmation.feeTokenAddress);
      }
      if (this.requestConfirmationHandler && this.showConfirmation) {
        const id2 = v4();
        const confirmation = await this.requestConfirmationHandler.confirmSignTransactionRequest(id2, txns, chainId);
        if (!confirmation.confirmed) {
          throw new UserRejectedRequestError(new Error("User rejected send transaction request"));
        }
        if (id2 !== confirmation.id) {
          throw new UserRejectedRequestError(new Error("User confirmation ids do not match"));
        }
      }
      const response = await this.sequenceWaas.sendTransaction({
        transactions: [await resolveProperties$1(params == null ? void 0 : params[0])],
        network: chainId,
        transactionsFeeOption: selectedFeeOption,
        transactionsFeeQuote: feeOptionsResponse == null ? void 0 : feeOptionsResponse.feeQuote
      });
      console.log("response", response);
      if (response.code === "transactionFailed") {
        throw new TransactionRejectedRpcError(new Error(`Unable to send transaction: ${response.data.error}`));
      }
      if (response.code === "transactionReceipt") {
        const { txHash } = response.data;
        return txHash;
      }
    }
    if (method === "eth_sign" || method === "eth_signTypedData" || method === "eth_signTypedData_v4" || method === "personal_sign") {
      if (this.requestConfirmationHandler && this.showConfirmation) {
        const id2 = v4();
        const confirmation = await this.requestConfirmationHandler.confirmSignMessageRequest(id2, params == null ? void 0 : params[0], this.currentNetwork.chainId);
        if (!confirmation.confirmed) {
          throw new UserRejectedRequestError(new Error("User rejected sign message request"));
        }
        if (id2 !== confirmation.id) {
          throw new UserRejectedRequestError(new Error("User confirmation ids do not match"));
        }
      }
      const sig = await this.sequenceWaas.signMessage({ message: params == null ? void 0 : params[0], network: this.currentNetwork.chainId });
      return sig.data.signature;
    }
    return await this.jsonRpcProvider.send(method, params ?? []);
  }
  async getTransaction(txHash) {
    return await this.jsonRpcProvider.getTransaction(txHash);
  }
  detectNetwork() {
    return Promise.resolve(this.currentNetwork);
  }
  getChainId() {
    return this.currentNetwork.chainId;
  }
  async checkTransactionFeeOptions({ transactions: transactions2, chainId }) {
    const resp = await this.sequenceWaas.feeOptions({
      transactions: transactions2,
      network: chainId
    });
    if (resp.data.feeQuote && resp.data.feeOptions) {
      return { feeQuote: resp.data.feeQuote, feeOptions: resp.data.feeOptions, isSponsored: false };
    }
    return { feeQuote: resp.data.feeQuote, feeOptions: resp.data.feeOptions, isSponsored: true };
  }
}
const DEVICE_EMOJIS = [
  // 256 emojis for unsigned byte range 0 - 255
  ...""
];
function randomName() {
  const wordlistSize = 2048;
  const words2 = wordlists.en;
  const randomEmoji = DEVICE_EMOJIS[Math.floor(Math.random() * DEVICE_EMOJIS.length)];
  const randomWord1 = words2.getWord(Math.floor(Math.random() * wordlistSize));
  const randomWord2 = words2.getWord(Math.floor(Math.random() * wordlistSize));
  return `${randomEmoji} ${randomWord1} ${randomWord2}`;
}
function normalizeChainId(chainId) {
  if (typeof chainId === "object")
    return normalizeChainId(chainId.chainId);
  if (typeof chainId === "string")
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
function useEmailAuth({ connector, onSuccess }) {
  if (!connector) {
    return {
      inProgress: false,
      loading: false,
      error: void 0,
      initiateAuth: async (_email) => {
      },
      sendChallengeAnswer: async (_answer) => {
      }
    };
  }
  const [email2, setEmail] = reactExports.useState("");
  const [error, setError] = reactExports.useState();
  const [loading, setLoading] = reactExports.useState(false);
  const [instance, setInstance] = reactExports.useState("");
  const [respondWithCode, setRespondWithCode] = reactExports.useState();
  const getSequenceWaas = () => {
    if (!connector) {
      throw new Error("Connector is not defined");
    }
    const sequenceWaas = connector.sequenceWaas;
    if (!sequenceWaas) {
      throw new Error("Connector does not support SequenceWaaS");
    }
    return sequenceWaas;
  };
  const initiateAuth2 = async (email3) => {
    const params = connector.params;
    const waas = getSequenceWaas();
    setLoading(true);
    setError(void 0);
    if (params.emailAuthVersion === 1) {
      try {
        const { instance: instance2 } = await waas.email.initiateAuth({ email: email3 });
        setInstance(instance2);
        setEmail(email3);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    } else {
      waas.onEmailAuthCodeRequired(async (respondWithCode2) => {
        setRespondWithCode(() => respondWithCode2);
      });
      waas.signIn({ email: email3 }, randomName()).then((signInResponse) => {
        onSuccess({ version: 2, signInResponse });
        if (signInResponse.email) {
          setEmail(signInResponse.email);
        }
      }).catch((err) => {
        setError(err);
      });
      setLoading(false);
    }
  };
  const sendChallengeAnswer = async (answer) => {
    const params = connector.params;
    const waas = getSequenceWaas();
    setLoading(true);
    setError(void 0);
    if (params.emailAuthVersion === 1) {
      try {
        const sessionHash = await waas.getSessionHash();
        const { idToken } = await waas.email.finalizeAuth({ instance, answer, email: email2, sessionHash });
        onSuccess({ version: 1, idToken });
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    } else {
      if (!respondWithCode) {
        throw new Error("Email v2 auth, respondWithCode is not defined");
      }
      try {
        await respondWithCode(answer);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }
  };
  const cancel = () => {
    setLoading(false);
    setRespondWithCode(null);
    setError(void 0);
  };
  return {
    inProgress: loading || !!instance,
    loading,
    error,
    initiateAuth: initiateAuth2,
    sendChallengeAnswer,
    cancel
  };
}
const isEmailValid = (email2) => {
  return /^\S+@\S+\.\S{2,}$/.test(email2);
};
const compareAddress$2 = (a2, b2) => {
  return a2.toLowerCase() === b2.toLowerCase();
};
var ValueType$2;
(function(ValueType2) {
  ValueType2[ValueType2["VERY_LARGE"] = 0] = "VERY_LARGE";
  ValueType2[ValueType2["FRACTION"] = 1] = "FRACTION";
  ValueType2[ValueType2["VERY_TINY"] = 2] = "VERY_TINY";
  ValueType2[ValueType2["MIXED"] = 3] = "MIXED";
})(ValueType$2 || (ValueType$2 = {}));
const capitalize$1 = (word) => {
  return word.charAt(0).toUpperCase() + word.slice(1);
};
const BUTTON_SIZE = "14";
const ICON_SIZE = "10";
const getLogo = (theme, walletProps) => theme === "dark" ? walletProps.logoDark || walletProps.monochromeLogoDark : walletProps.logoLight || walletProps.monochromeLogoLight;
const ConnectButton = (props) => {
  const { connector, label, onConnect } = props;
  const { theme } = useTheme$1();
  const walletProps = connector._wallet;
  const Logo = getLogo(theme, walletProps);
  return jsxRuntimeExports$1.jsx(Tooltip, { message: label || walletProps.name, children: jsxRuntimeExports$1.jsx(Card, { clickable: true, width: BUTTON_SIZE, height: BUTTON_SIZE, padding: "2", borderRadius: "xs", justifyContent: "center", alignItems: "center", onClick: () => onConnect(connector), children: jsxRuntimeExports$1.jsx(Box, { as: Logo, width: ICON_SIZE, height: ICON_SIZE }) }) });
};
const GoogleWaasConnectButton = (props) => {
  const { connector, onConnect } = props;
  const storage = useStorage();
  const [enableGoogleTooltip, setEnableGoogleTooltip] = reactExports.useState(false);
  const { theme } = useTheme$1();
  const walletProps = connector._wallet;
  const Logo = getLogo(theme, walletProps);
  reactExports.useEffect(() => {
    setTimeout(() => {
      setEnableGoogleTooltip(true);
    }, 300);
  });
  return jsxRuntimeExports$1.jsx(Tooltip, { message: "Google", disabled: !enableGoogleTooltip, children: jsxRuntimeExports$1.jsxs(Card, { clickable: true, background: "transparent", borderRadius: "xs", padding: "0", width: BUTTON_SIZE, height: BUTTON_SIZE, position: "relative", children: [jsxRuntimeExports$1.jsx(Box, { width: "full", height: "full", overflow: "hidden", borderRadius: "sm", alignItems: "center", justifyContent: "center", style: { opacity: 1e-7, transform: "scale(1.4)" }, children: jsxRuntimeExports$1.jsx(GoogleLogin, { type: "icon", size: "large", width: "56", onSuccess: (credentialResponse) => {
    if (credentialResponse.credential) {
      storage == null ? void 0 : storage.setItem(LocalStorageKey.WaasGoogleIdToken, credentialResponse.credential);
      onConnect(connector);
    }
  }, onError: () => {
    console.log("Login Failed");
  } }) }), jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", borderRadius: "xs", display: "flex", justifyContent: "center", alignItems: "center", position: "absolute", pointerEvents: "none", width: "full", height: "full", top: "0", right: "0", children: jsxRuntimeExports$1.jsx(Box, { as: Logo, width: ICON_SIZE, height: ICON_SIZE }) })] }) });
};
const AppleWaasConnectButton = (props) => {
  const { connector, onConnect } = props;
  const storage = useStorage();
  const { data: appleClientId2 } = useStorageItem(LocalStorageKey.WaasAppleClientID);
  const { data: appleRedirectUri } = useStorageItem(LocalStorageKey.WaasAppleRedirectURI);
  return appleClientId2 && appleRedirectUri ? jsxRuntimeExports$1.jsx(ConnectButton, { connector, onConnect: () => {
    dist.appleAuthHelpers.signIn({
      authOptions: {
        clientId: appleClientId2,
        redirectURI: appleRedirectUri,
        scope: "openid email",
        usePopup: true
      },
      onSuccess: (response) => {
        var _a2;
        if ((_a2 = response.authorization) == null ? void 0 : _a2.id_token) {
          storage == null ? void 0 : storage.setItem(LocalStorageKey.WaasAppleIdToken, response.authorization.id_token);
          onConnect(connector);
        } else {
          console.log("Apple login error: No id_token found");
        }
      },
      onError: (error) => console.error(error)
    });
  } }) : null;
};
const EmailConnectButton = (props) => {
  const { onClick } = props;
  return jsxRuntimeExports$1.jsx(Tooltip, { message: "Email", children: jsxRuntimeExports$1.jsx(Card, { clickable: true, width: BUTTON_SIZE, height: BUTTON_SIZE, padding: "2", borderRadius: "xs", justifyContent: "center", alignItems: "center", onClick, children: jsxRuntimeExports$1.jsx(SvgEmailIcon, { size: "xl", color: "text100" }) }) });
};
const SequenceLogo$1 = ({ ...props }) => {
  return jsxRuntimeExports$1.jsx(React.Fragment, { children: jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", style: { fill: "none" }, id: "svg1316", version: "1.1", viewBox: "0 0 396 396", ...props, children: [jsxRuntimeExports$1.jsx("g", { transform: "translate(0,38)", id: "g1256", clipPath: "url(#clip0_5_131)", children: jsxRuntimeExports$1.jsxs("g", { id: "g1254", clipPath: "url(#clip1_5_131)", children: [jsxRuntimeExports$1.jsx("path", { style: { fill: "#111111" }, id: "path1232", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint0_linear_5_13" }, id: "path1234", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint1_linear_5_131" }, id: "path1236", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint2_linear_5_131)" }, id: "path1238", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint3_linear_5_131)" }, id: "path1240", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint4_linear_5_131)" }, id: "path1242", d: "m 98.9999,238.126 c 0,-10.965 -8.8648,-19.854 -19.8,-19.854 -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.966 8.8648,19.855 19.8,19.855 10.9352,0 19.8,-8.889 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint5_linear_5_131)" }, id: "path1244", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint6_linear_5_131)" }, id: "path1246", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint7_linear_5_131)" }, id: "path1248", d: "M 316.8,59.5632 H 158.4 c -10.935,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.865,19.8544 19.8,19.8544 h 158.4 c 10.935,0 19.8,-8.8892 19.8,-19.8544 0,-10.9653 -8.865,-19.8544 -19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint8_linear_5_131)" }, id: "path1250", d: "M 316.8,218.272 H 158.4 c -10.935,0 -19.8,8.889 -19.8,19.854 0,10.966 8.865,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.889 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint9_linear_5_131)" }, id: "path1252", d: "M 237.6,138.981 H 79.2 c -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.965 8.8648,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.89 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" })] }) }), jsxRuntimeExports$1.jsxs("defs", { id: "defs1314", children: [jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "318", x2: "198", y1: "4.0585401e-05", x1: "198", id: "paint0_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1258", stopColor: "#1D273D" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1260", stopColor: "#0D0F13", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "63", x2: "92.5", y1: "99", x1: "65.5", id: "paint1_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1263", stopColor: "#4462FE" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1265", stopColor: "#7D69FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint2_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1268", stopColor: "#3757FD" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1270", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint3_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1273", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1275", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "223.5", x2: "91.5", y1: "251.5", x1: "65", id: "paint4_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1278", stopColor: "#BC3EE6" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1280", stopColor: "#D972F1", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "146", x2: "329.5", y1: "172", x1: "305", id: "paint5_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1283", stopColor: "#29BDFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1285", stopColor: "#96E7FB", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "176.772", x2: "334.56699", y1: "178.418", x1: "300.17999", id: "paint6_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1288", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1290", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "60", x2: "317.5", y1: "99", x1: "154.5", id: "paint7_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1293", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1295", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "218", x2: "312.5", y1: "258", x1: "156", id: "paint8_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1298", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1300", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "139", x2: "235.5", y1: "179", x1: "86.000099", id: "paint9_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1303", stopColor: "#6634FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1305", stopColor: "#9C6DFF", offset: "1" })] }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip0_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1308", height: "317.67001", width: "396" }) }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip1_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1311", height: "317.67001", width: "396" }) })] })] }) });
};
const PoweredBySequence = () => {
  return jsxRuntimeExports$1.jsxs(Box, { onClick: () => {
    if (typeof window !== "undefined") {
      window.open("https://sequence.xyz");
    }
  }, gap: "1", marginTop: "4", flexDirection: "row", alignItems: "center", justifyContent: "center", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "small", color: "text100", children: "Powered by Sequence" }), jsxRuntimeExports$1.jsx(Box, { height: "5", width: "5", children: jsxRuntimeExports$1.jsx(SequenceLogo$1, {}) })] });
};
const Banner = ({ config: config2 = {} }) => {
  const { signIn: signIn3 = {} } = config2;
  const { logoUrl } = signIn3;
  return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: logoUrl && jsxRuntimeExports$1.jsx(Box, { marginTop: "5", justifyContent: "center", alignItems: "center", children: jsxRuntimeExports$1.jsx(Image$1, { src: logoUrl, style: { height: "110px" } }) }) });
};
const EmailWaasVerify = (props) => {
  const { isLoading, error, onConfirm } = props;
  const [waasEmailPinCode, setWaasEmailPinCode] = reactExports.useState([]);
  return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: jsxRuntimeExports$1.jsxs(Box, { paddingY: "6", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Text, { marginTop: "5", marginBottom: "4", variant: "normal", color: "text80", children: "Enter code received in email." }), jsxRuntimeExports$1.jsx(PINCodeInput, { value: waasEmailPinCode, digits: 6, group: 3, onChange: setWaasEmailPinCode, disabled: isLoading }), jsxRuntimeExports$1.jsxs(Box, { gap: "4", marginTop: "4", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Button, { variant: "primary", disabled: waasEmailPinCode.includes("") || isLoading, label: "Confirm", onClick: () => onConfirm(waasEmailPinCode.join("")), "data-id": "verifyButton" }), isLoading && jsxRuntimeExports$1.jsx(Spinner, {}), error && jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "negative", textAlign: "center", children: error.message })] })] }) });
};
const ExtendedWalletList = ({ onConnect, connectors }) => {
  const { theme } = useTheme$1();
  const { isPending } = useConnect();
  return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", marginTop: "5", children: connectors.map((connector) => {
    const Logo = theme === "dark" ? connector._wallet.logoDark : connector._wallet.logoLight;
    const walletName = connector._wallet.name;
    const connectorId = connector._wallet.id;
    return jsxRuntimeExports$1.jsx(Button, { width: "full", shape: "square", leftIcon: () => jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", alignItems: "center", style: { backgroundColor: connector._wallet.iconBackground }, width: "8", height: "8", overflow: "hidden", children: jsxRuntimeExports$1.jsx(Logo, { style: { width: 30 } }) }), onClick: () => onConnect(connector), label: jsxRuntimeExports$1.jsxs(Text, { children: [walletName, isPending] }) }, connectorId);
  }) });
};
const Connect = (props) => {
  dist.useScript(dist.appleAuthHelpers.APPLE_SCRIPT_SRC);
  const { onClose, emailConflictInfo, config: config2 = {} } = props;
  const { signIn: signIn3 = {} } = config2;
  const { isConnected } = useAccount();
  const storage = useStorage();
  const [email2, setEmail] = reactExports.useState("");
  const [showEmailInput, setShowEmailInput] = reactExports.useState(false);
  const [showEmailWaasPinInput, setShowEmailWaasPinInput] = reactExports.useState(false);
  const [showExtendedList, setShowExtendedList] = reactExports.useState(false);
  const { connectors, connect: connect2 } = useConnect();
  const hasInjectedSequenceConnector = connectors.some((c2) => c2.id === "app.sequence");
  const baseWalletConnectors = connectors.filter((c2) => {
    return c2._wallet && (c2._wallet.type === "wallet" || c2._wallet.type === void 0);
  }).filter((c2) => {
    var _a2;
    if (((_a2 = c2._wallet) == null ? void 0 : _a2.id) === "sequence" && hasInjectedSequenceConnector) {
      return false;
    }
    return true;
  });
  const mockConnector = baseWalletConnectors.find((connector) => {
    return connector._wallet.id === "mock";
  });
  const injectedConnectors = connectors.filter((c2) => c2.type === "injected").filter((connector) => {
    if (connector.id === "com.coinbase.wallet") {
      return !connectors.find((connector2) => {
        var _a2;
        return ((_a2 = connector2 == null ? void 0 : connector2._wallet) == null ? void 0 : _a2.id) === "coinbase-wallet";
      });
    }
    return true;
  }).map((connector) => {
    const Logo = (props2) => {
      return jsxRuntimeExports$1.jsx(Image$1, { src: connector.icon, alt: connector.name, disableAnimation: true, ...props2 });
    };
    return {
      ...connector,
      _wallet: {
        id: connector.id,
        name: connector.name,
        logoLight: Logo,
        logoDark: Logo,
        type: "wallet"
      }
    };
  });
  const socialAuthConnectors = connectors.filter((c2) => {
    var _a2;
    return ((_a2 = c2._wallet) == null ? void 0 : _a2.type) === "social";
  });
  const walletConnectors = [...baseWalletConnectors, ...injectedConnectors];
  const emailConnector = socialAuthConnectors.find((c2) => c2._wallet.id.includes("email"));
  const isEmailOnly = emailConnector && socialAuthConnectors.length === 1 && walletConnectors.length === 0;
  const displayExtendedListButton = walletConnectors.length > 7;
  const onChangeEmail = (ev) => {
    setEmail(ev.target.value);
  };
  reactExports.useEffect(() => {
    if (isConnected) {
      onClose();
    }
  }, [isConnected]);
  const onConnect = (connector) => {
    if (signIn3.useMock && mockConnector) {
      connect2({ connector: mockConnector });
      return;
    }
    if (connector._wallet.id === "email") {
      const email3 = prompt("Auto-email login, please specify the email address:");
      if ("setEmail" in connector) {
        connector.setEmail(email3);
      }
    }
    connect2({ connector });
  };
  const onConnectInlineEmail = async (e2) => {
    e2.preventDefault();
    if (signIn3.useMock && mockConnector) {
      connect2({ connector: mockConnector });
      return;
    }
    if (emailConnector) {
      if ("setEmail" in emailConnector) {
        emailConnector.setEmail(email2);
      }
      if (emailConnector._wallet.id === "email-waas") {
        try {
          await initiateEmailAuth(email2);
          setShowEmailWaasPinInput(true);
        } catch (e3) {
          console.log(e3);
        }
      } else {
        connect2({ connector: emailConnector });
      }
    }
  };
  const { inProgress: emailAuthInProgress, loading: emailAuthLoading, error: emailAuthError, initiateAuth: initiateEmailAuth, sendChallengeAnswer } = useEmailAuth({
    connector: emailConnector,
    onSuccess: async (result) => {
      console.log("Successfult email auth", result);
      if (emailConnector) {
        if (result.version === 1) {
          storage == null ? void 0 : storage.setItem(LocalStorageKey.WaasEmailIdToken, result.idToken);
        }
        connect2({ connector: emailConnector });
      }
    }
  });
  reactExports.useEffect(() => {
    if (emailConflictInfo) {
      setShowEmailWaasPinInput(false);
    }
  }, [emailConflictInfo]);
  if (showEmailWaasPinInput) {
    return jsxRuntimeExports$1.jsx(EmailWaasVerify, { error: emailAuthError, isLoading: emailAuthLoading, onConfirm: sendChallengeAnswer });
  }
  if (showExtendedList) {
    return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Box, { position: "absolute", top: "4", children: jsxRuntimeExports$1.jsx(IconButton, { icon: SvgChevronLeftIcon, onClick: () => setShowExtendedList(false), size: "xs" }) }), jsxRuntimeExports$1.jsx(ExtendedWalletList, { connectors: walletConnectors, onConnect })] });
  }
  return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Banner, { config: config2 }), jsxRuntimeExports$1.jsx(Box, { marginTop: "6", children: emailConnector && (showEmailInput || isEmailOnly) ? jsxRuntimeExports$1.jsxs("form", { onSubmit: onConnectInlineEmail, children: [jsxRuntimeExports$1.jsx(TextInput, { onChange: onChangeEmail, value: email2, name: "email", placeholder: "Enter email", "data-1p-ignore": true }), jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", justifyContent: "center", marginTop: "4", children: [!emailAuthInProgress && jsxRuntimeExports$1.jsxs(Box, { gap: "2", width: "full", children: [!isEmailOnly && jsxRuntimeExports$1.jsx(Button, { label: "Back", width: "full", onClick: () => setShowEmailInput(false) }), jsxRuntimeExports$1.jsx(Button, { type: "submit", variant: "primary", disabled: !isEmailValid(email2), width: "full", label: "Continue", rightIcon: SvgChevronRightIcon })] }), emailAuthInProgress && jsxRuntimeExports$1.jsx(Spinner, {})] })] }) : jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [socialAuthConnectors.length > 0 && jsxRuntimeExports$1.jsx(Box, { marginTop: "2", gap: "2", flexDirection: "row", justifyContent: "center", alignItems: "center", flexWrap: "wrap", children: socialAuthConnectors.map((connector) => {
    return jsxRuntimeExports$1.jsx(Box, { aspectRatio: "1/1", alignItems: "center", justifyContent: "center", children: connector._wallet.id === "google-waas" ? jsxRuntimeExports$1.jsx(GoogleWaasConnectButton, { connector, onConnect }) : connector._wallet.id === "apple-waas" ? jsxRuntimeExports$1.jsx(AppleWaasConnectButton, { connector, onConnect }) : connector._wallet.id.includes("email") ? jsxRuntimeExports$1.jsx(EmailConnectButton, { onClick: () => setShowEmailInput(true) }) : jsxRuntimeExports$1.jsx(ConnectButton, { connector, onConnect }) }, connector.uid);
  }) }), walletConnectors.length > 0 && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [socialAuthConnectors.length > 0 && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Divider, { color: "backgroundSecondary" }), jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", alignItems: "center", children: jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: "or select a wallet" }) })] }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", gap: "2", flexDirection: "row", justifyContent: "center", alignItems: "center", children: walletConnectors.slice(0, 7).map((connector) => {
    return jsxRuntimeExports$1.jsx(ConnectButton, { connector, onConnect }, connector.uid);
  }) }), displayExtendedListButton && jsxRuntimeExports$1.jsx(Box, { marginTop: "4", justifyContent: "center", children: jsxRuntimeExports$1.jsx(Button, { shape: "square", size: "xs", onClick: () => setShowExtendedList(true), label: "More options", rightIcon: SvgChevronRightIcon }) })] })] }) }), jsxRuntimeExports$1.jsx(PoweredBySequence, {})] });
};
const getNetworkColor = (chainId, mode = "light") => {
  switch (chainId) {
    case ChainId.MAINNET:
      return mode === "light" ? "#abf" : "#abf";
    case ChainId.POLYGON:
      return mode === "light" ? "#c7a6ff" : "#c7a6ff";
    case ChainId.ARBITRUM:
      return mode === "light" ? "#52A7E6" : "#52A7E6";
    case ChainId.OPTIMISM:
      return mode === "light" ? "#DB3132" : "#DB3132";
    case ChainId.BSC:
      return mode === "light" ? "#CB9C1D" : "#EEB445";
    case ChainId.AVALANCHE:
      return mode === "light" ? "#E84142" : "#E84142";
    case ChainId.GNOSIS:
      return mode === "light" ? "#00193C" : "#D8E8FF";
    case ChainId.GOERLI:
      return mode === "light" ? "#A77A00" : "#FFA700";
    case ChainId.POLYGON_MUMBAI:
    case ChainId.POLYGON_AMOY:
      return mode === "light" ? "#D68828" : "#FFA700";
    default:
      return mode === "light" ? "#abf" : "#abf";
  }
};
const getNetworkBackgroundColor = (chainId, mode = "light") => {
  switch (chainId) {
    case ChainId.MAINNET:
      return mode === "light" ? "#132362" : "#132362";
    case ChainId.POLYGON:
      return mode === "light" ? "#350881" : "#350881";
    case ChainId.ARBITRUM:
      return mode === "light" ? "#EDF7FF" : "#0C3754";
    case ChainId.OPTIMISM:
      return mode === "light" ? "#FFEAE9" : "#390B0C";
    case ChainId.BSC:
      return mode === "light" ? "#FFE8AB" : "#554018";
    case ChainId.AVALANCHE:
      return mode === "light" ? "#FBDFDF" : "#390B0C";
    case ChainId.GNOSIS:
      return mode === "light" ? "#D8E8FF" : "#00193C";
    case ChainId.GOERLI:
      return mode === "light" ? "#FFD871" : "#554018";
    case ChainId.POLYGON_MUMBAI:
    case ChainId.POLYGON_AMOY:
      return mode === "light" ? "#FFE8CD" : "#554018";
    default:
      return mode === "light" ? "#132362" : "#132362";
  }
};
const getNetwork = (chainId) => {
  const network2 = networks[chainId];
  if (!network2) {
    throw new Error(`Unknown network chainId: ${chainId}`);
  }
  return network2;
};
const NetworkBadge$1 = ({ chainId }) => {
  const network2 = getNetwork(chainId);
  const chainColor = getNetworkColor(chainId);
  const chainBGColor = getNetworkBackgroundColor(chainId);
  return jsxRuntimeExports$1.jsxs(Box, { height: "6", paddingY: "1", paddingLeft: "1.5", paddingRight: "2", gap: "1", style: {
    background: chainBGColor
  }, borderRadius: "xs", flexDirection: "row", justifyContent: "center", alignItems: "center", width: "fit", children: [jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "xsmall", style: {
    color: chainColor
  }, children: capitalize$1(network2.title ?? network2.name) })] });
};
const PageHeading = (props) => {
  const { children, ...rest } = props;
  return jsxRuntimeExports$1.jsx(Text, { as: "h1", variant: "normal", fontWeight: "bold", color: "text100", textAlign: "center", marginTop: "10", marginBottom: "6", ...rest, children });
};
const useProjectAccessKey = () => {
  const { projectAccessKey: projectAccessKey2 } = useKitConfig();
  return projectAccessKey2;
};
const useAPIClient = () => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const clientUrl = isDev ? "https://dev-api.sequence.app" : "https://api.sequence.app";
  const apiClient = reactExports.useMemo(() => {
    return new SequenceAPIClient(clientUrl, projectAccessKey2);
  }, [projectAccessKey2]);
  return apiClient;
};
const useIndexerClient = (chainId) => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const indexerClients = reactExports.useMemo(() => {
    return /* @__PURE__ */ new Map();
  }, [projectAccessKey2, isDev]);
  const network2 = networks[chainId];
  const clientUrl = isDev ? `https://dev-${network2.name}-indexer.sequence.app` : `https://${network2.name}-indexer.sequence.app`;
  if (!indexerClients.has(chainId)) {
    indexerClients.set(chainId, new SequenceIndexer(clientUrl, projectAccessKey2));
  }
  const indexerClient = indexerClients.get(chainId);
  if (!indexerClient) {
    throw new Error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
  }
  return indexerClient;
};
const useIndexerClients = (chainIds) => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const indexerClients = reactExports.useMemo(() => {
    return /* @__PURE__ */ new Map();
  }, [projectAccessKey2, isDev]);
  const result = /* @__PURE__ */ new Map();
  for (const chainId of chainIds) {
    const network2 = networks[chainId];
    const clientUrl = isDev ? `https://dev-${network2.name}-indexer.sequence.app` : `https://${network2.name}-indexer.sequence.app`;
    if (!indexerClients.has(chainId)) {
      indexerClients.set(chainId, new SequenceIndexer(clientUrl, projectAccessKey2));
    }
    const indexerClient = indexerClients.get(chainId);
    if (!indexerClient) {
      throw new Error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
    }
    result.set(chainId, indexerClient);
  }
  return result;
};
const useMetadataClient = () => {
  const projectAccessKey2 = useProjectAccessKey();
  const { isDev = false } = useKitConfig();
  const metadataClient = reactExports.useMemo(() => {
    const clientUrl = isDev ? "https://dev-metadata.sequence.app" : "https://metadata.sequence.app";
    return new SequenceMetadata(clientUrl, projectAccessKey2);
  }, [projectAccessKey2]);
  return metadataClient;
};
const time$1 = {
  oneSecond: 1 * 1e3,
  oneMinute: 60 * 1e3,
  oneHour: 60 * 60 * 1e3
};
const getNativeTokenBalance = async (indexerClient, chainId, accountAddress) => {
  const res = await indexerClient.getEtherBalance({ accountAddress });
  const tokenBalance = {
    chainId,
    contractAddress: zeroAddress,
    accountAddress,
    balance: (res == null ? void 0 : res.balance.balanceWei) || "0",
    contractType: ContractType$1.UNKNOWN,
    blockHash: "",
    blockNumber: 0,
    tokenID: ""
  };
  return tokenBalance;
};
const getTokenBalances = async (indexerClient, args) => {
  const res = await indexerClient.getTokenBalances({
    accountAddress: args.accountAddress,
    includeMetadata: args.includeMetadata ?? true,
    metadataOptions: {
      verifiedOnly: args.verifiedOnly ?? true
    },
    ...args.contractAddress && { contractAddress: args.contractAddress }
  });
  return (res == null ? void 0 : res.balances) || [];
};
const getBalances = async (indexerClient, chainId, args) => {
  if (!args.accountAddress) {
    return [];
  }
  const balances = (await Promise.allSettled([
    getNativeTokenBalance(indexerClient, chainId, args.accountAddress),
    getTokenBalances(indexerClient, args)
  ])).map((res) => res.status === "fulfilled" ? res.value : []).flat();
  return balances;
};
const useBalances = ({ chainIds, ...args }) => {
  const indexerClients = useIndexerClients(chainIds);
  return useQuery$1({
    queryKey: ["balances", chainIds, args],
    queryFn: async () => {
      const res = (await Promise.all(Array.from(indexerClients.entries()).map(([chainId, indexerClient]) => getBalances(indexerClient, chainId, args)))).flat();
      return res;
    },
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: chainIds.length > 0 && !!args.accountAddress
  });
};
const useCoinBalance = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useQuery$1({
    queryKey: ["coinBalance", args],
    queryFn: async () => {
      if (compareAddress$2((args == null ? void 0 : args.contractAddress) || "", zeroAddress)) {
        const res = await getNativeTokenBalance(indexerClient, args.chainId, args.accountAddress);
        return res;
      } else {
        const res = await getTokenBalances(indexerClient, args);
        return res[0];
      }
    },
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress
  });
};
const useCollectibleBalance = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useQuery$1({
    queryKey: ["collectibleBalance", args],
    queryFn: async () => {
      const res = await indexerClient.getTokenBalances({
        accountAddress: args.accountAddress,
        contractAddress: args.contractAddress,
        tokenID: args.tokenId,
        includeMetadata: true,
        metadataOptions: {
          verifiedOnly: args.verifiedOnly ?? true
        }
      });
      return res.balances[0];
    },
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress && !!args.contractAddress && !!args.tokenId
  });
};
const getCollectionBalance = async (indexerClient, args) => {
  const res = await indexerClient.getTokenBalances({
    accountAddress: args.accountAddress,
    contractAddress: args.contractAddress,
    includeMetadata: args.includeMetadata ?? true,
    metadataOptions: {
      verifiedOnly: args.verifiedOnly ?? true
    }
  });
  return (res == null ? void 0 : res.balances) || [];
};
const useCollectionBalance = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useQuery$1({
    queryKey: ["collectionBalance", args],
    queryFn: () => getCollectionBalance(indexerClient, args),
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress && !!args.contractAddress
  });
};
const useExchangeRate = (toCurrency) => {
  const apiClient = useAPIClient();
  return useQuery$1({
    queryKey: ["exchangeRate", toCurrency],
    queryFn: async () => {
      if (toCurrency === "USD") {
        return 1;
      }
      const res = await apiClient.getExchangeRate({ toCurrency });
      return res.exchangeRate.value;
    },
    retry: true,
    staleTime: time$1.oneMinute * 10
  });
};
const getCoinPrices = async (apiClient, tokens) => {
  if (tokens.length === 0) {
    return [];
  }
  const res = await apiClient.getCoinPrices({ tokens });
  return (res == null ? void 0 : res.tokenPrices) || [];
};
const useCoinPrices = (tokens) => {
  const apiClient = useAPIClient();
  return useQuery$1({
    queryKey: ["coinPrices", tokens],
    queryFn: () => getCoinPrices(apiClient, tokens),
    retry: true,
    staleTime: time$1.oneMinute,
    enabled: tokens.length > 0
  });
};
const getCollectiblePrices = async (apiClient, tokens) => {
  if (tokens.length === 0) {
    return [];
  }
  const res = await apiClient.getCollectiblePrices({ tokens });
  return (res == null ? void 0 : res.tokenPrices) || [];
};
const useCollectiblePrices = (tokens) => {
  const apiClient = useAPIClient();
  return useQuery$1({
    queryKey: ["useCollectiblePrices", tokens],
    queryFn: () => getCollectiblePrices(apiClient, tokens),
    retry: true,
    staleTime: time$1.oneMinute,
    enabled: tokens.length > 0
  });
};
const useTokenMetadata = (chainId, contractAddress, tokenIds) => {
  const metadataClient = useMetadataClient();
  return useQuery$1({
    queryKey: ["tokenMetadata", chainId, contractAddress, tokenIds],
    queryFn: async () => {
      const res = await metadataClient.getTokenMetadata({
        chainID: String(chainId),
        contractAddress,
        tokenIDs: tokenIds
      });
      return res.tokenMetadata;
    },
    retry: true,
    staleTime: time$1.oneMinute * 10,
    enabled: !!chainId && !!contractAddress
  });
};
const useContractInfo = (chainId, contractAddress) => {
  const metadataClient = useMetadataClient();
  return useQuery$1({
    queryKey: ["contractInfo", chainId, contractAddress],
    queryFn: async () => {
      const res = await metadataClient.getContractInfo({
        chainID: String(chainId),
        contractAddress
      });
      return res.contractInfo;
    },
    retry: true,
    staleTime: time$1.oneMinute * 10,
    enabled: !!chainId && !!contractAddress
  });
};
const getTransactionHistory = async (indexerClient, { contractAddress, accountAddress, tokenId, page }) => {
  const res = indexerClient.getTransactionHistory({
    includeMetadata: true,
    page,
    filter: {
      accountAddress,
      contractAddress,
      tokenID: tokenId
    }
  });
  return res;
};
const useTransactionHistory = (args) => {
  const indexerClient = useIndexerClient(args.chainId);
  return useInfiniteQuery({
    queryKey: ["transactionHistory", args],
    queryFn: ({ pageParam }) => {
      return getTransactionHistory(indexerClient, {
        ...args,
        page: { page: pageParam }
      });
    },
    getNextPageParam: ({ page }) => {
      if (!page.more) {
        return void 0;
      }
      return (page == null ? void 0 : page.page) || 1;
    },
    initialPageParam: 1,
    retry: true,
    staleTime: time$1.oneSecond * 30,
    enabled: !!args.chainId && !!args.accountAddress
  });
};
const chains$1 = allNetworks.reduce((acc, network2) => {
  if (network2.deprecated) {
    return acc;
  }
  if (network2.name.startsWith("hardhat")) {
    return acc;
  }
  acc[network2.chainId] = defineChain({
    id: network2.chainId,
    name: network2.title,
    shortName: network2.name,
    nativeCurrency: {
      name: network2.nativeToken.name,
      symbol: network2.nativeToken.symbol,
      decimals: network2.nativeToken.decimals
    },
    rpcUrls: {
      default: {
        http: [network2.rpcUrl]
      }
    },
    ...network2.blockExplorer ? {
      blockExplorers: {
        default: {
          name: network2.blockExplorer.name,
          url: network2.blockExplorer.rootUrl
        }
      }
    } : void 0
  });
  return acc;
}, {});
const getNativeTokenInfoByChainId = (chainId, wagmiChains) => {
  var _a2, _b2;
  const chain = wagmiChains.find((chain2) => chain2.id === chainId) || chains$1[chainId];
  if (chain) {
    return {
      chainId: chain.id,
      name: chain.nativeCurrency.name,
      symbol: chain.nativeCurrency.symbol,
      decimals: chain.nativeCurrency.decimals,
      logoURI: nativeTokenImageUrl(chain.id),
      blockExplorerName: (_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.name,
      blockExplorerUrl: (_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url
    };
  }
  return {
    chainId,
    name: "Unknown",
    symbol: "???",
    decimals: 18,
    logoURI: ""
  };
};
var utils = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$b);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$f);
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$d);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$8);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$j);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$c);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$6);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$4);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$h);
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$k);
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$7);
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$1);
const require$$12 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$5);
const require$$13 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$i);
const require$$14 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$g);
const require$$15 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$a);
const require$$16 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$e);
const require$$17 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$9);
const require$$18 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
const require$$19 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$3);
const require$$20 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$2);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v3) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v3 });
  } : function(o2, v3) {
    o2["default"] = v3;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding2(result, mod2, k2);
    }
    __setModuleDefault2(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
  exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
  var abi_1 = require$$0;
  Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
    return abi_1.AbiCoder;
  } });
  Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
    return abi_1.checkResultErrors;
  } });
  Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
    return abi_1.ConstructorFragment;
  } });
  Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
    return abi_1.defaultAbiCoder;
  } });
  Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
    return abi_1.ErrorFragment;
  } });
  Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
    return abi_1.EventFragment;
  } });
  Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
    return abi_1.FormatTypes;
  } });
  Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
    return abi_1.Fragment;
  } });
  Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
    return abi_1.FunctionFragment;
  } });
  Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
    return abi_1.Indexed;
  } });
  Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
    return abi_1.Interface;
  } });
  Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
    return abi_1.LogDescription;
  } });
  Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
    return abi_1.ParamType;
  } });
  Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
    return abi_1.TransactionDescription;
  } });
  var address_1 = require$$1;
  Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
    return address_1.getAddress;
  } });
  Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
    return address_1.getCreate2Address;
  } });
  Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
    return address_1.getContractAddress;
  } });
  Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
    return address_1.getIcapAddress;
  } });
  Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
    return address_1.isAddress;
  } });
  var base64 = __importStar2(require$$2);
  exports.base64 = base64;
  var basex_1 = require$$3;
  Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
    return basex_1.Base58;
  } });
  var bytes_1 = require$$4;
  Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
    return bytes_1.arrayify;
  } });
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return bytes_1.concat;
  } });
  Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
    return bytes_1.hexConcat;
  } });
  Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
    return bytes_1.hexDataSlice;
  } });
  Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
    return bytes_1.hexDataLength;
  } });
  Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
    return bytes_1.hexlify;
  } });
  Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
    return bytes_1.hexStripZeros;
  } });
  Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
    return bytes_1.hexValue;
  } });
  Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
    return bytes_1.hexZeroPad;
  } });
  Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
    return bytes_1.isBytes;
  } });
  Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
    return bytes_1.isBytesLike;
  } });
  Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
    return bytes_1.isHexString;
  } });
  Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
    return bytes_1.joinSignature;
  } });
  Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
    return bytes_1.zeroPad;
  } });
  Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
    return bytes_1.splitSignature;
  } });
  Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
    return bytes_1.stripZeros;
  } });
  var hash_1 = require$$5;
  Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
    return hash_1._TypedDataEncoder;
  } });
  Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
    return hash_1.dnsEncode;
  } });
  Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
    return hash_1.hashMessage;
  } });
  Object.defineProperty(exports, "id", { enumerable: true, get: function() {
    return hash_1.id;
  } });
  Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
    return hash_1.isValidName;
  } });
  Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
    return hash_1.namehash;
  } });
  var hdnode_1 = require$$6;
  Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
    return hdnode_1.defaultPath;
  } });
  Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
    return hdnode_1.entropyToMnemonic;
  } });
  Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
    return hdnode_1.getAccountPath;
  } });
  Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
    return hdnode_1.HDNode;
  } });
  Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
    return hdnode_1.isValidMnemonic;
  } });
  Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToEntropy;
  } });
  Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToSeed;
  } });
  var json_wallets_1 = require$$7;
  Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
    return json_wallets_1.getJsonWalletAddress;
  } });
  var keccak256_1 = require$$8;
  Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
    return keccak256_1.keccak256;
  } });
  var logger_1 = require$$9;
  Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
    return logger_1.Logger;
  } });
  var sha2_1 = require$$10;
  Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
    return sha2_1.computeHmac;
  } });
  Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
    return sha2_1.ripemd160;
  } });
  Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
    return sha2_1.sha256;
  } });
  Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
    return sha2_1.sha512;
  } });
  var solidity_1 = require$$11;
  Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
    return solidity_1.keccak256;
  } });
  Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
    return solidity_1.pack;
  } });
  Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
    return solidity_1.sha256;
  } });
  var random_1 = require$$12;
  Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
    return random_1.randomBytes;
  } });
  Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
    return random_1.shuffled;
  } });
  var properties_1 = require$$13;
  Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
    return properties_1.checkProperties;
  } });
  Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
    return properties_1.deepCopy;
  } });
  Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
    return properties_1.defineReadOnly;
  } });
  Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
    return properties_1.getStatic;
  } });
  Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
    return properties_1.resolveProperties;
  } });
  Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
    return properties_1.shallowCopy;
  } });
  var RLP = __importStar2(require$$14);
  exports.RLP = RLP;
  var signing_key_1 = require$$15;
  Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
    return signing_key_1.computePublicKey;
  } });
  Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
    return signing_key_1.recoverPublicKey;
  } });
  Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
    return signing_key_1.SigningKey;
  } });
  var strings_1 = require$$16;
  Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
    return strings_1.formatBytes32String;
  } });
  Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
    return strings_1.nameprep;
  } });
  Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
    return strings_1.parseBytes32String;
  } });
  Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
    return strings_1._toEscapedUtf8String;
  } });
  Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
    return strings_1.toUtf8Bytes;
  } });
  Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
    return strings_1.toUtf8CodePoints;
  } });
  Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
    return strings_1.toUtf8String;
  } });
  Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
    return strings_1.Utf8ErrorFuncs;
  } });
  var transactions_1 = require$$17;
  Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
    return transactions_1.accessListify;
  } });
  Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
    return transactions_1.computeAddress;
  } });
  Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
    return transactions_1.parse;
  } });
  Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
    return transactions_1.recoverAddress;
  } });
  Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
    return transactions_1.serialize;
  } });
  Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
    return transactions_1.TransactionTypes;
  } });
  var units_1 = require$$18;
  Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
    return units_1.commify;
  } });
  Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
    return units_1.formatEther;
  } });
  Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
    return units_1.parseEther;
  } });
  Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
    return units_1.formatUnits;
  } });
  Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
    return units_1.parseUnits;
  } });
  var wallet_1 = require$$19;
  Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
    return wallet_1.verifyMessage;
  } });
  Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
    return wallet_1.verifyTypedData;
  } });
  var web_1 = require$$20;
  Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
    return web_1._fetchData;
  } });
  Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
    return web_1.fetchJson;
  } });
  Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
    return web_1.poll;
  } });
  var sha2_2 = require$$10;
  Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
    return sha2_2.SupportedAlgorithm;
  } });
  var strings_2 = require$$16;
  Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
    return strings_2.UnicodeNormalizationForm;
  } });
  Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
    return strings_2.Utf8ErrorReason;
  } });
})(utils);
var DecodingType;
(function(DecodingType2) {
  DecodingType2["APPROVE"] = "approve";
  DecodingType2["TRANSFER"] = "transfer";
  DecodingType2["SWAP"] = "swap";
  DecodingType2["AWARD_ITEM"] = "awardItem";
  DecodingType2["UNIMPLEMENTED"] = "unimplemented";
  DecodingType2["UNKNOWN"] = "unknown";
})(DecodingType || (DecodingType = {}));
const transformArgs = (args) => {
  return Object.fromEntries(args.map((arg, i) => [
    arg.name && !arg.name.startsWith("unnamed") ? arg.name : `_${i}`,
    Array.isArray(arg.value) ? arg.type.startsWith("(") && (arg.type.endsWith(")") || arg.type.endsWith(")[]")) ? transformArgs(arg.value) : arg.value : arg.value
  ]));
};
const createTxnData = (to, call2, value, data) => {
  const args = transformArgs(call2.args);
  const byteSignature = hexDataSlice(data, 0, 4);
  let objs = [];
  switch (call2.signature) {
    case "execute((bool,bool,uint256,address,uint256,bytes)[],uint256,bytes)":
    case "selfExecute((bool,bool,uint256,address,uint256,bytes)[])": {
      const txns = call2.args[0].value;
      objs = txns.map((txn) => txn.call ? createTxnData(txn.target, txn.call, txn.value, txn.data) : {
        to: txn.target,
        signature: "",
        byteSignature: hexDataSlice(txn.data, 0, 4),
        methodName: "",
        args: {},
        objs: [],
        value: BigNumber.from(txn.value).toString(),
        data: hexlify(txn.data)
      });
    }
  }
  return {
    to,
    signature: call2.signature,
    byteSignature,
    methodName: call2.function,
    args,
    objs,
    value: BigNumber.from(value).toString(),
    data: hexlify(data)
  };
};
const encodeTransactions = (transactions2) => {
  return transactions2.map((transaction2) => {
    if ("target" in transaction2) {
      return transaction2;
    } else {
      return { ...transaction2, target: transaction2.to };
    }
  }).map((transaction2) => ({
    delegateCall: transaction2.delegateCall ?? false,
    revertOnError: transaction2.revertOnError ?? false,
    gasLimit: transaction2.gasLimit ?? 0,
    target: transaction2.target ?? "0x0000000000000000000000000000000000000000",
    value: transaction2.value ?? 0,
    data: transaction2.data ?? "0x"
  }));
};
var ByteSignature;
(function(ByteSignature2) {
  ByteSignature2["SEQUENCE_DEPLOY"] = "0x32c02a14";
  ByteSignature2["SEQUENCE_PUBLISH_CONFIG"] = "0x44d466c2";
  ByteSignature2["SEQUENCE_UPDATE_IMAGE_HASH"] = "0x29561426";
  ByteSignature2["SEQUENCE_UPDATE_IMPLEMENTATION"] = "0x025b22bc";
  ByteSignature2["SEQUENCE_REQUIRE_SESSION_NONCE"] = "0x8853baa0";
  ByteSignature2["EXECUTE"] = "0x7a9a1628";
  ByteSignature2["SELF_EXECUTE"] = "0x61c2926c";
  ByteSignature2["APPROVE"] = "0x095ea7b3";
  ByteSignature2["TRANSFER"] = "0xa9059cbb";
  ByteSignature2["DEPOSIT"] = "0xd0e30db0";
  ByteSignature2["WITHDRAW"] = "0x2e1a7d4d";
  ByteSignature2["ERC721_SAFE_TRANSFER_FROM"] = "0x42842e0e";
  ByteSignature2["ERC721_SAFE_TRANSFER_FROM_WITH_DATA"] = "0xb88d4fde";
  ByteSignature2["ERC1155_SAFE_TRANSFER_FROM"] = "0xf242432a";
  ByteSignature2["ERC1155_SAFE_BATCH_TRANSFER_FROM"] = "0x2eb2c2d6";
  ByteSignature2["NIFTYSWAP_BUY_TOKENS"] = "0xd93e8aaa";
  ByteSignature2["TRANSFORM_ERC20"] = "0x415565b0";
  ByteSignature2["OUTBOUND_TRANSFER_TO"] = "0xa44bbb15";
  ByteSignature2["CELER_SEND"] = "0xa5977fbb";
  ByteSignature2["UNISWAPV3_MULTICALL"] = "0x5ae401dc";
  ByteSignature2["UNISWAPV2_SWAP_EXACT_TOKENS_FOR_TOKENS"] = "0x38ed1739";
  ByteSignature2["UNISWAPV2_SWAP_TOKENS_FOR_EXACT_TOKENS"] = "0x8803dbee";
  ByteSignature2["UNISWAPV2_SWAP_EXACT_ETH_FOR_TOKENS"] = "0x7ff36ab5";
  ByteSignature2["UNISWAPV2_SWAP_ETH_FOR_EXACT_TOKENS"] = "0xfb3bdb41";
  ByteSignature2["UNISWAPV2_SWAP_TOKENS_FOR_EXACT_ETH"] = "0x4a25d94a";
  ByteSignature2["UNISWAPV2_SWAP_EXACT_TOKENS_FOR_ETH"] = "0x18cbafe5";
  ByteSignature2["AWARD_ITEM"] = "0xcf378343";
})(ByteSignature || (ByteSignature = {}));
const decodeTxnData = async (apiClient, txns) => {
  const mainModule2 = new Interface(mainModuleAbi);
  const callData = mainModule2.encodeFunctionData("selfExecute", [txns]);
  try {
    const { call: call2 } = await apiClient.decodeContractCall({ callData });
    return createTxnData("", call2, 0, callData);
  } catch (err) {
    throw err;
  }
};
const decodeTransactions = async (apiClient, accountAddress, txns) => {
  const encodedTxns = encodeTransactions(txns);
  const decodedTxnDatas = (await decodeTxnData(apiClient, encodedTxns)).objs;
  const from = utils.getAddress(accountAddress);
  const txnProps = encodedTxns.map((txn, i) => {
    const decodedTxnData = decodedTxnDatas[i];
    const data = txn.data.toString();
    const value = BigNumber.from(txn.value).toString();
    const target = txn.target;
    if (data === "0x" || !data) {
      return {
        signature: "",
        byteSignature: "",
        type: DecodingType.TRANSFER,
        methodName: "nativeTokenTransfer",
        transferType: TxnTransferType.SEND,
        contractAddress: AddressZero,
        contractType: ContractType$1.UNKNOWN,
        from,
        to: utils.getAddress(txn.target),
        tokenIds: ["0"],
        amounts: [value],
        target,
        value
      };
    }
    if (!decodedTxnData) {
      return void 0;
    }
    const contractAddress = utils.getAddress(txn.target);
    const baseDecoding = {
      type: DecodingType.UNIMPLEMENTED,
      signature: decodedTxnData.signature,
      byteSignature: decodedTxnData.byteSignature,
      methodName: decodedTxnData.methodName,
      target,
      value
    };
    switch (decodedTxnData.byteSignature) {
      case ByteSignature.TRANSFER: {
        const { args } = decodedTxnData;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC20,
          from,
          to: utils.getAddress(args.recipient),
          tokenIds: ["0"],
          amounts: [String(args.amount)]
        };
      }
      case ByteSignature.ERC721_SAFE_TRANSFER_FROM:
      case ByteSignature.ERC721_SAFE_TRANSFER_FROM_WITH_DATA: {
        const args = decodedTxnData.args;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC721,
          from,
          to: utils.getAddress(args.to),
          tokenIds: [args.tokenId],
          amounts: ["1"]
        };
      }
      case ByteSignature.ERC1155_SAFE_TRANSFER_FROM: {
        const args = decodedTxnData.args;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC1155,
          from,
          to: utils.getAddress(args._to),
          tokenIds: [args._id],
          amounts: [args._amount]
        };
      }
      case ByteSignature.ERC1155_SAFE_BATCH_TRANSFER_FROM: {
        const { args } = decodedTxnData;
        return {
          ...baseDecoding,
          type: DecodingType.TRANSFER,
          transferType: TxnTransferType.SEND,
          contractAddress,
          contractType: ContractType$1.ERC1155,
          from,
          to: utils.getAddress(args._to),
          tokenIds: args._ids,
          amounts: args._amounts
        };
      }
      case ByteSignature.AWARD_ITEM: {
        const { args } = decodedTxnData;
        return {
          ...baseDecoding,
          type: DecodingType.AWARD_ITEM,
          contractAddress,
          // @ts-ignore-next-line
          to: utils.getAddress(args._0),
          amount: "1"
        };
      }
    }
    return void 0;
  });
  return txnProps.flatMap((txn) => {
    if (txn) {
      return [txn];
    }
    return [];
  });
};
const mainModuleAbi = [
  {
    type: "function",
    name: "nonce",
    constant: true,
    inputs: [],
    outputs: [
      {
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view"
  },
  {
    type: "function",
    name: "readNonce",
    constant: true,
    inputs: [
      {
        type: "uint256"
      }
    ],
    outputs: [
      {
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view"
  },
  {
    type: "function",
    name: "updateImplementation",
    constant: false,
    inputs: [
      {
        type: "address"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "selfExecute",
    constant: false,
    inputs: [
      {
        components: [
          {
            type: "bool",
            name: "delegateCall"
          },
          {
            type: "bool",
            name: "revertOnError"
          },
          {
            type: "uint256",
            name: "gasLimit"
          },
          {
            type: "address",
            name: "target"
          },
          {
            type: "uint256",
            name: "value"
          },
          {
            type: "bytes",
            name: "data"
          }
        ],
        type: "tuple[]"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "execute",
    constant: false,
    inputs: [
      {
        components: [
          {
            type: "bool",
            name: "delegateCall"
          },
          {
            type: "bool",
            name: "revertOnError"
          },
          {
            type: "uint256",
            name: "gasLimit"
          },
          {
            type: "address",
            name: "target"
          },
          {
            type: "uint256",
            name: "value"
          },
          {
            type: "bytes",
            name: "data"
          }
        ],
        type: "tuple[]"
      },
      {
        type: "uint256"
      },
      {
        type: "bytes"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "createContract",
    inputs: [
      {
        type: "bytes"
      }
    ],
    payable: true,
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "setExtraImageHash",
    constant: false,
    inputs: [
      {
        type: "bytes32",
        name: "imageHash"
      },
      {
        type: "uint256",
        name: "expiration"
      }
    ],
    outputs: [],
    payable: false,
    stateMutability: "nonpayable"
  }
];
const CollectibleTileImage$1 = ({ imageUrl }) => {
  return jsxRuntimeExports$1.jsx(Card, { padding: "0", aspectRatio: "1/1", justifyContent: "center", alignItems: "center", overflow: "hidden", borderRadius: "sm", background: "backgroundSecondary", children: jsxRuntimeExports$1.jsx(Image$1, { style: { height: "100%" }, src: imageUrl }) });
};
const TxnDetailsSkeleton = () => {
  return jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 30, height: 30 }, borderRadius: "circle" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 100, height: 14 } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 75, height: 14 } })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", alignItems: "flex-end", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 100, height: 14 } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: 50, height: 12 } })] })] });
};
const TxnDetails = ({ address, txs, chainId }) => {
  const apiClient = useAPIClient();
  const [decodingType, setDecodingType] = reactExports.useState(void 0);
  const [transferProps, setTransferProps] = reactExports.useState([]);
  const [awardItemProps, setAwardItemProps] = reactExports.useState([]);
  const getTxnProps = async () => {
    var _a2;
    const decodedTxnDatas = await decodeTransactions(apiClient, address, txs);
    const type = (_a2 = decodedTxnDatas[0]) == null ? void 0 : _a2.type;
    setDecodingType(type);
    if (type === DecodingType.TRANSFER) {
      setTransferProps(decodedTxnDatas);
    }
    if (type === DecodingType.AWARD_ITEM) {
      setAwardItemProps(decodedTxnDatas);
    }
  };
  reactExports.useEffect(() => {
    getTxnProps();
  }, []);
  if (!decodingType) {
    return jsxRuntimeExports$1.jsx(TxnDetailsSkeleton, {});
  }
  if (decodingType === DecodingType.UNKNOWN) {
    return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {});
  }
  if (transferProps[0]) {
    return jsxRuntimeExports$1.jsx(TransferItemInfo, { address, transferProps: transferProps[0], chainId });
  }
  if (awardItemProps[0]) {
    return jsxRuntimeExports$1.jsx(AwardItemInfo, { awardItemProps: awardItemProps[0] });
  }
};
const TransferItemInfo = ({ address, transferProps, chainId }) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
  const { chains: chains2 } = useConfig();
  const contractAddress = transferProps.contractAddress;
  const toAddress = transferProps.to;
  const isNativeCoin = contractAddress ? compareAddress$2(contractAddress, AddressZero) : true;
  const is1155 = transferProps.contractType === ContractType$1.ERC1155;
  const isNFT = transferProps.contractType === ContractType$1.ERC1155 || transferProps.contractType === ContractType$1.ERC721;
  const nativeTokenInfo = getNativeTokenInfoByChainId(chainId, chains2);
  const { data: balances = [] } = useBalances({
    chainIds: [chainId],
    accountAddress: address,
    contractAddress
  });
  const { data: tokenMetadata } = useTokenMetadata(chainId, contractAddress, transferProps.tokenIds ?? []);
  const tokenBalance = contractAddress ? balances.find((b2) => compareAddress$2(b2.contractAddress, contractAddress)) : void 0;
  const decimals = isNativeCoin ? nativeTokenInfo.decimals : ((_a2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _a2.decimals) || 18;
  const imageUrl = isNativeCoin ? nativeTokenInfo.logoURI : isNFT ? (_b2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _b2.image : (_c2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _c2.logoURI;
  const name2 = isNativeCoin ? nativeTokenInfo.name : isNFT ? (_d2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _d2.name : ((_e2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _e2.name) || "";
  const symbol = isNativeCoin ? nativeTokenInfo.symbol : isNFT ? "" : ((_f2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _f2.symbol) || "";
  const amountSending = transferProps.amounts[0] ?? transferProps.value;
  const showSquareImage = isNFT;
  return jsxRuntimeExports$1.jsxs(Card, { children: [jsxRuntimeExports$1.jsx(Box, { marginBottom: "2", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: capitalize$1(transferProps.type ?? "") }) }), jsxRuntimeExports$1.jsx(Box, { alignItems: "flex-end", justifyContent: "space-between", marginBottom: "2", children: jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", gap: "2", children: [showSquareImage ? jsxRuntimeExports$1.jsx(Box, { style: { width: "40px" }, children: jsxRuntimeExports$1.jsx(CollectibleTileImage$1, { imageUrl }) }) : jsxRuntimeExports$1.jsx(TokenImage, { src: imageUrl, symbol, size: "md" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Box, { flexDirection: "row", alignItems: "center", gap: "1", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: name2 }) }), jsxRuntimeExports$1.jsxs(Text, { color: "text50", variant: "normal", children: [" ", `${formatUnits$1(amountSending, is1155 ? (_g2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _g2.decimals : isNFT ? 0 : decimals)} ${symbol} `] })] })] }) }), toAddress !== void 0 && jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", color: "text50", children: "To" }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", borderRadius: "md", background: "backgroundSecondary", width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", padding: "4", style: { height: "52px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: toAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle$1(toAddress.substring(2), 12)}` })] }) })] })] });
};
const AwardItemInfo = ({ awardItemProps }) => {
  return jsxRuntimeExports$1.jsxs(Card, { children: [jsxRuntimeExports$1.jsx(Box, { marginBottom: "2", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: "Mint" }) }), jsxRuntimeExports$1.jsx(Box, { alignItems: "flex-end", justifyContent: "space-between", marginBottom: "2", children: jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Box, { style: { width: "40px" }, children: jsxRuntimeExports$1.jsx(CollectibleTileImage$1, { imageUrl: "https://dev-metadata.sequence.app/projects/277/collections/62/tokens/0/image.jpeg" }) }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Box, { flexDirection: "row", alignItems: "center", gap: "1", children: jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: "Waas Demo NFT" }) }), jsxRuntimeExports$1.jsx(Text, { color: "text50", variant: "normal", children: awardItemProps.amount })] })] }) }), awardItemProps.to !== void 0 && jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", color: "text50", children: "To" }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", borderRadius: "md", background: "backgroundSecondary", width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", padding: "4", style: { height: "52px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: awardItemProps.to, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle$1(awardItemProps.to.substring(2), 12)}` })] }) })] })] });
};
const truncateAtMiddle$1 = (text2, truncateAt) => {
  let finalText = text2;
  if (text2.length >= truncateAt) {
    finalText = text2.slice(0, truncateAt / 2) + "..." + text2.slice(text2.length - truncateAt / 2, text2.length);
  }
  return finalText;
};
const KitProvider = (props) => {
  var _a2, _b2;
  const { config: config2, children } = props;
  const { defaultTheme = "dark", signIn: signIn3 = {}, position = "center", displayedAssets: displayedAssetsSetting = [], ethAuth = {}, disableAnalytics = false } = config2;
  const defaultAppName = signIn3.projectName || "app";
  const { expiry = DEFAULT_SESSION_EXPIRATION, app = defaultAppName, origin, nonce } = ethAuth;
  const { projectName } = signIn3;
  const [openConnectModal, setOpenConnectModal] = reactExports.useState(false);
  const [theme, setTheme] = reactExports.useState(defaultTheme || "dark");
  const [modalPosition, setModalPosition] = reactExports.useState(position);
  const [displayedAssets, setDisplayedAssets] = reactExports.useState(displayedAssetsSetting);
  const [analytics, setAnalytics] = reactExports.useState();
  const { address, isConnected } = useAccount();
  const wagmiConfig2 = useConfig();
  const storage = useStorage();
  const connections = useConnections();
  const waasConnector = (_a2 = connections.find((c2) => c2.connector.id.includes("waas"))) == null ? void 0 : _a2.connector;
  const [pendingRequestConfirmation, confirmPendingRequest, rejectPendingRequest] = useWaasConfirmationHandler(waasConnector);
  const googleWaasConnector = wagmiConfig2.connectors.find((c2) => c2.id === "sequence-waas" && c2._wallet.id === "google-waas");
  const googleClientId2 = ((_b2 = googleWaasConnector == null ? void 0 : googleWaasConnector.params) == null ? void 0 : _b2.googleClientId) || "";
  const setupAnalytics2 = (projectAccessKey2) => {
    const s2 = sequence$1.initWallet(projectAccessKey2);
    const sequenceAnalytics = s2.client.analytics;
    setAnalytics(sequenceAnalytics);
  };
  reactExports.useEffect(() => {
    if (!isConnected) {
      analytics == null ? void 0 : analytics.reset();
      return;
    }
    if (address) {
      analytics == null ? void 0 : analytics.identify(address.toLowerCase());
    }
  }, [analytics, address, isConnected]);
  reactExports.useEffect(() => {
    if (!disableAnalytics) {
      setupAnalytics2(config2.projectAccessKey);
    }
  }, []);
  reactExports.useEffect(() => {
    if (theme !== defaultTheme) {
      setTheme(defaultTheme);
    }
  }, [defaultTheme]);
  reactExports.useEffect(() => {
    if (modalPosition !== position) {
      setModalPosition(position);
    }
  }, [position]);
  reactExports.useEffect(() => {
    if (typeof theme === "object")
      ;
    else {
      localStorage.setItem(LocalStorageKey.Theme, theme);
    }
    storage == null ? void 0 : storage.setItem(LocalStorageKey.EthAuthSettings, {
      expiry,
      app,
      origin: origin || location.origin,
      nonce
    });
  }, [theme, ethAuth]);
  reactExports.useEffect(() => {
    setDisplayedAssets(displayedAssets);
  }, [displayedAssetsSetting]);
  const { isEmailConflictOpen, emailConflictInfo, toggleEmailConflictModal } = useEmailConflict();
  return jsxRuntimeExports$1.jsx(KitConfigContextProvider, { value: config2, children: jsxRuntimeExports$1.jsx(ThemeContextProvider, { value: {
    theme,
    setTheme,
    position: modalPosition,
    setPosition: setModalPosition
  }, children: jsxRuntimeExports$1.jsx(GoogleOAuthProvider, { clientId: googleClientId2, children: jsxRuntimeExports$1.jsx(ConnectModalContextProvider, { value: { setOpenConnectModal, openConnectModalState: openConnectModal }, children: jsxRuntimeExports$1.jsx(WalletConfigContextProvider, { value: { setDisplayedAssets, displayedAssets }, children: jsxRuntimeExports$1.jsxs(AnalyticsContextProvider, { value: { setAnalytics, analytics }, children: [jsxRuntimeExports$1.jsx("div", { id: "kit-provider", children: jsxRuntimeExports$1.jsx(ThemeProvider, { root: "#kit-provider", scope: "kit", theme, children: jsxRuntimeExports$1.jsxs(AnimatePresence, { children: [openConnectModal && jsxRuntimeExports$1.jsx(Modal, { scroll: false, backdropColor: "backgroundBackdrop", size: "sm", contentProps: {
    style: {
      maxWidth: "364px",
      ...getModalPositionCss(position)
    }
  }, onClose: () => setOpenConnectModal(false), children: jsxRuntimeExports$1.jsxs(Box, { padding: "4", children: [jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", color: "text100", alignItems: "center", fontWeight: "medium", style: {
    marginTop: "4px"
  }, children: jsxRuntimeExports$1.jsxs(Text, { children: ["Sign in ", projectName ? `to ${projectName}` : ""] }) }), jsxRuntimeExports$1.jsx(Connect, { onClose: () => {
    setOpenConnectModal(false);
  }, ...props, emailConflictInfo })] }) }), pendingRequestConfirmation && jsxRuntimeExports$1.jsx(Modal, { scroll: false, backdropColor: "backgroundBackdrop", size: "sm", contentProps: {
    style: {
      maxWidth: "364px",
      ...getModalPositionCss(position)
    }
  }, isDismissible: false, onClose: () => {
    rejectPendingRequest("");
  }, children: jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingTop: "4", paddingBottom: "2", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", justifyContent: "center", color: "text100", alignItems: "center", fontWeight: "medium", style: {
    marginTop: "4px"
  }, children: [jsxRuntimeExports$1.jsxs(Text, { as: "h1", variant: "large", marginBottom: "5", children: ["Confirm ", pendingRequestConfirmation.type === "signMessage" ? "signing message" : "transaction"] }), pendingRequestConfirmation.type === "signMessage" && jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", width: "full", children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", color: "text50", children: "Message" }), jsxRuntimeExports$1.jsx(Card, { marginTop: "2", paddingY: "6", children: jsxRuntimeExports$1.jsx(Text, { variant: "normal", marginBottom: "4", children: toUtf8String(pendingRequestConfirmation.message ?? "") }) })] }), pendingRequestConfirmation.type === "signTransaction" && jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", width: "full", children: [jsxRuntimeExports$1.jsx(TxnDetails, { address: address ?? "", txs: pendingRequestConfirmation.txs ?? [], chainId: pendingRequestConfirmation.chainId ?? ChainId.POLYGON }), jsxRuntimeExports$1.jsx(Collapsible, { label: "Transaction data", marginTop: "4", children: jsxRuntimeExports$1.jsx(Card, { overflowX: "scroll", marginY: "3", children: jsxRuntimeExports$1.jsx(Text, { variant: "code", marginBottom: "4", children: JSON.stringify(pendingRequestConfirmation.txs, null, 2) }) }) })] }), pendingRequestConfirmation.chainId && jsxRuntimeExports$1.jsxs(Box, { width: "full", marginTop: "3", justifyContent: "flex-end", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Box, { width: "1/2", justifyContent: "flex-start", children: jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: "Network" }) }), jsxRuntimeExports$1.jsx(Box, { width: "1/2", justifyContent: "flex-end", children: jsxRuntimeExports$1.jsx(NetworkBadge$1, { chainId: pendingRequestConfirmation.chainId }) })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", width: "full", marginTop: "5", children: [jsxRuntimeExports$1.jsx(Button, { width: "full", shape: "square", size: "lg", label: "Reject", onClick: () => {
    rejectPendingRequest(pendingRequestConfirmation == null ? void 0 : pendingRequestConfirmation.id);
  } }), jsxRuntimeExports$1.jsx(Button, { alignItems: "center", textAlign: "center", width: "full", shape: "square", size: "lg", label: "Confirm", variant: "primary", onClick: () => {
    confirmPendingRequest(pendingRequestConfirmation == null ? void 0 : pendingRequestConfirmation.id);
  } })] })] }), jsxRuntimeExports$1.jsx(PoweredBySequence, {})] }) }), isEmailConflictOpen && emailConflictInfo && jsxRuntimeExports$1.jsx(Modal, { size: "sm", scroll: false, onClose: () => toggleEmailConflictModal(false), children: jsxRuntimeExports$1.jsxs(Box, { padding: "4", children: [jsxRuntimeExports$1.jsx(PageHeading, { children: "Email already in use" }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Text, { variant: "normal", color: "text80", textAlign: "center", children: ["Another account with this email address ", jsxRuntimeExports$1.jsxs(Text, { color: "text100", children: ["(", emailConflictInfo.email, ")"] }), " ", "already exists with account type ", jsxRuntimeExports$1.jsxs(Text, { color: "text100", children: ["(", emailConflictInfo.type, ")"] }), ". Please sign in again with the correct account."] }), jsxRuntimeExports$1.jsx(Box, { marginTop: "4", gap: "2", alignItems: "center", justifyContent: "center", children: jsxRuntimeExports$1.jsx(Button, { label: "OK", onClick: () => toggleEmailConflictModal(false) }) })] })] }) })] }) }) }), children] }) }) }) }) }) });
};
const getAppleLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "white" : "black";
  const AppleLogo = (props) => {
    return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M27.166 20.8774C27.1338 17.335 30.0617 15.633 30.1936 15.5493C28.5463 13.1395 25.9852 12.8113 25.0714 12.7727C22.8932 12.5507 20.8179 14.0565 19.7111 14.0565C18.6043 14.0565 16.8991 12.8049 15.0909 12.8403C12.7131 12.8757 10.5221 14.2205 9.2962 16.3505C6.8284 20.6297 8.66557 26.9777 11.0722 30.4557C12.2498 32.1545 13.6494 34.0689 15.493 33.9981C17.2691 33.9273 17.9383 32.8495 20.0811 32.8495C22.224 32.8495 22.8289 33.9981 24.7014 33.9627C26.6094 33.9241 27.8191 32.2253 28.9871 30.5201C30.3352 28.5478 30.8918 26.6366 30.924 26.5369C30.8822 26.5208 27.2046 25.1116 27.166 20.8774Z", fill: fillColor }), jsxRuntimeExports$1.jsx("path", { d: "M23.6429 10.4722C24.621 9.28822 25.2806 7.64089 25.1004 6C23.6911 6.05791 21.9859 6.93949 20.9756 8.12351C20.0715 9.16917 19.2768 10.8455 19.4923 12.4542C21.0592 12.5764 22.6648 11.653 23.6429 10.4722Z", fill: fillColor })] });
  };
  return AppleLogo;
};
const getAppleMonochromeLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "#FFFFFF" : "#000000";
  const AppleOtcLogo = (props) => {
    return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M27.166 20.8774C27.1338 17.335 30.0617 15.633 30.1936 15.5493C28.5463 13.1395 25.9852 12.8113 25.0714 12.7727C22.8932 12.5507 20.8179 14.0565 19.7111 14.0565C18.6043 14.0565 16.8991 12.8049 15.0909 12.8403C12.7131 12.8757 10.5221 14.2205 9.2962 16.3505C6.8284 20.6297 8.66557 26.9777 11.0722 30.4557C12.2498 32.1545 13.6494 34.0689 15.493 33.9981C17.2691 33.9273 17.9383 32.8495 20.0811 32.8495C22.224 32.8495 22.8289 33.9981 24.7014 33.9627C26.6094 33.9241 27.8191 32.2253 28.9871 30.5201C30.3352 28.5478 30.8918 26.6366 30.924 26.5369C30.8822 26.5208 27.2046 25.1116 27.166 20.8774Z", fill: fillColor }), jsxRuntimeExports$1.jsx("path", { d: "M23.6429 10.4722C24.621 9.28822 25.2806 7.64089 25.1004 6C23.6911 6.05791 21.9859 6.93949 20.9756 8.12351C20.0715 9.16917 19.2768 10.8455 19.4923 12.4542C21.0592 12.5764 22.6648 11.653 23.6429 10.4722Z", fill: fillColor })] });
  };
  return AppleOtcLogo;
};
const apple = (options) => ({
  id: "apple",
  isSequenceBased: true,
  logoDark: getAppleLogo({ isDarkMode: true }),
  logoLight: getAppleLogo({ isDarkMode: false }),
  monochromeLogoDark: getAppleMonochromeLogo({ isDarkMode: true }),
  monochromeLogoLight: getAppleMonochromeLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Apple",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "apple"
        }
      }
    });
    return connector;
  }
});
const appleWaas = (options) => ({
  id: "apple-waas",
  logoDark: getAppleLogo({ isDarkMode: true }),
  logoLight: getAppleLogo({ isDarkMode: false }),
  monochromeLogoDark: getAppleMonochromeLogo({ isDarkMode: true }),
  monochromeLogoLight: getAppleMonochromeLogo({ isDarkMode: false }),
  name: "Apple",
  type: "social",
  createConnector: () => {
    const connector = sequenceWaasWallet({
      ...options,
      loginType: "apple"
    });
    return connector;
  }
});
coinbaseWallet$1.type = "coinbaseWallet";
function coinbaseWallet$1(parameters = {}) {
  if (parameters.version === "3" || parameters.headlessMode)
    return version3(parameters);
  return version4(parameters);
}
function version4(parameters) {
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    supportsSimulation: true,
    type: coinbaseWallet$1.type,
    async connect({ chainId } = {}) {
      try {
        const provider2 = await this.getProvider();
        const accounts = (await provider2.request({
          method: "eth_requestAccounts"
        })).map((x) => getAddress(x));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a2;
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider2.disconnect();
      (_a2 = provider2.close) == null ? void 0 : _a2.call(provider2);
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      return (await provider2.request({
        method: "eth_accounts"
      })).map((x) => getAddress(x));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = await provider2.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const { default: CoinbaseSDK_ } = await __vitePreload(() => import("./index-BIKT5yla.js").then((n2) => n2.i), true ? __vite__mapDeps([0,1,2]) : void 0, import.meta.url);
        const CoinbaseSDK = (() => {
          if (typeof CoinbaseSDK_ !== "function" && typeof CoinbaseSDK_.default === "function")
            return CoinbaseSDK_.default;
          return CoinbaseSDK_;
        })();
        sdk = new CoinbaseSDK({
          ...parameters,
          appChainIds: config2.chains.map((x) => x.id)
        });
        walletProvider = sdk.makeWeb3Provider({
          ...parameters,
          options: parameters.preference ?? "all"
        });
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2, _d2;
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider2 = await this.getProvider();
      try {
        await provider2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config2.emitter.emit("disconnect");
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
function version3(parameters) {
  const reloadOnDisconnect = false;
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    supportsSimulation: true,
    type: coinbaseWallet$1.type,
    async connect({ chainId } = {}) {
      try {
        const provider2 = await this.getProvider();
        const accounts = (await provider2.request({
          method: "eth_requestAccounts"
        })).map((x) => getAddress(x));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain == null ? void 0 : chain.id) ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider2.disconnect();
      provider2.close();
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      return (await provider2.request({
        method: "eth_accounts"
      })).map((x) => getAddress(x));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = await provider2.request({ method: "eth_chainId" });
      return Number(chainId);
    },
    async getProvider() {
      var _a2;
      if (!walletProvider) {
        const { default: SDK_ } = await __vitePreload(() => import("./index-l3XLtm4P.js").then((n2) => n2.i), true ? __vite__mapDeps([3,1,2]) : void 0, import.meta.url);
        let SDK;
        if (typeof SDK_ !== "function" && typeof SDK_.default === "function")
          SDK = SDK_.default;
        else
          SDK = SDK_;
        sdk = new SDK({ reloadOnDisconnect, ...parameters });
        const walletExtensionChainId = (_a2 = sdk.walletExtension) == null ? void 0 : _a2.getChainId();
        const chain = config2.chains.find((chain2) => parameters.chainId ? chain2.id === parameters.chainId : chain2.id === walletExtensionChainId) || config2.chains[0];
        const chainId = parameters.chainId || (chain == null ? void 0 : chain.id);
        const jsonRpcUrl = parameters.jsonRpcUrl || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2, _d2;
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider2 = await this.getProvider();
      try {
        await provider2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d2 = chain.rpcUrls.default) == null ? void 0 : _d2.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config2.emitter.emit("disconnect");
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
walletConnect$1.type = "walletConnect";
function walletConnect$1(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  const NAMESPACE = "eip155";
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config2) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect$1.type,
    async setup() {
      const provider2 = await this.getProvider().catch(() => null);
      if (!provider2)
        return;
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider2.on("session_delete", sessionDelete);
      }
    },
    async connect({ chainId, ...rest } = {}) {
      var _a2, _b2;
      try {
        const provider2 = await this.getProvider();
        if (!provider2)
          throw new ProviderNotFoundError();
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider2.on("display_uri", displayUri);
        }
        let targetChainId = chainId;
        if (!targetChainId) {
          const state = await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem("state")) ?? {};
          const isChainSupported = config2.chains.some((x) => x.id === state.chainId);
          if (isChainSupported)
            targetChainId = state.chainId;
          else
            targetChainId = (_b2 = config2.chains[0]) == null ? void 0 : _b2.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const isChainsStale = await this.isChainsStale();
        if (provider2.session && isChainsStale)
          await provider2.disconnect();
        if (!provider2.session || isChainsStale) {
          const optionalChains = config2.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
          await provider2.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(config2.chains.map((x) => x.id));
        }
        const accounts = (await provider2.enable()).map((x) => getAddress(x));
        const currentChainId = await this.getChainId();
        if (displayUri) {
          provider2.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider2.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider2.on("session_delete", sessionDelete);
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      try {
        await (provider2 == null ? void 0 : provider2.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        if (chainChanged) {
          provider2 == null ? void 0 : provider2.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider2 == null ? void 0 : provider2.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider2 == null ? void 0 : provider2.on("connect", connect2);
        }
        if (accountsChanged) {
          provider2 == null ? void 0 : provider2.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider2 == null ? void 0 : provider2.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      return provider2.accounts.map((x) => getAddress(x));
    },
    async getProvider({ chainId } = {}) {
      var _a2;
      async function initProvider() {
        const optionalChains = config2.chains.map((x) => x.id);
        if (!optionalChains.length)
          return;
        const { EthereumProvider } = await __vitePreload(() => import("./index.es-DNjTQ7Rd.js"), true ? __vite__mapDeps([4,2]) : void 0, import.meta.url);
        return await EthereumProvider.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: parameters.projectId,
          rpcMap: Object.fromEntries(config2.chains.map((chain) => [
            chain.id,
            chain.rpcUrls.default.http[0]
          ])),
          showQrModal: parameters.showQrModal ?? true
        });
      }
      if (!provider_) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider_ = await providerPromise;
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Infinity);
      }
      if (chainId)
        await ((_a2 = this.switchChain) == null ? void 0 : _a2.call(this, { chainId }));
      return provider_;
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      return provider2.chainId;
    },
    async isAuthorized() {
      try {
        const [accounts, provider2] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        if (!accounts.length)
          return false;
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider2.session) {
          await provider2.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b2, _c2;
      const provider2 = await this.getProvider();
      if (!provider2)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x) => x.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          new Promise((resolve) => {
            const listener = ({ chainId: currentChainId }) => {
              if (currentChainId === chainId) {
                config2.emitter.off("change", listener);
                resolve();
              }
            };
            config2.emitter.on("change", listener);
          }),
          provider2.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          })
        ]);
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return chain;
      } catch (err) {
        const error = err;
        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          else
            blockExplorerUrls = ((_a2 = chain.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b2 = chain.blockExplorers) == null ? void 0 : _b2.default.url] : [];
          let rpcUrls;
          if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
            rpcUrls = addEthereumChainParameter.rpcUrls;
          else
            rpcUrls = [...chain.rpcUrls.default.http];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain.nativeCurrency,
            rpcUrls
          };
          await provider2.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config2.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config2.emitter.emit("disconnect");
      const provider2 = await this.getProvider();
      if (accountsChanged) {
        provider2.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider2.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider2.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider2.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config2.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a2, _b2, _c2;
      if (!provider_)
        return [];
      const chainIds = (_c2 = (_b2 = (_a2 = provider_.session) == null ? void 0 : _a2.namespaces[NAMESPACE]) == null ? void 0 : _b2.chains) == null ? void 0 : _c2.map((chain) => parseInt(chain.split(":")[1] || ""));
      return chainIds ?? [];
    },
    async getRequestedChainsIds() {
      var _a2;
      return await ((_a2 = config2.storage) == null ? void 0 : _a2.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!isNewChainsStale)
        return false;
      const connectorChains = config2.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id2) => connectorChains.includes(id2)))
        return false;
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id2) => requestedChains.includes(id2));
    },
    async setRequestedChainsIds(chains2) {
      var _a2;
      await ((_a2 = config2.storage) == null ? void 0 : _a2.setItem(this.requestedChainsStorageKey, chains2));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}
const CoinbaseWalletLogo = (props) => {
  return jsxRuntimeExports$1.jsxs("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [jsxRuntimeExports$1.jsx("rect", { width: "28", height: "28", fill: "#2C5FF6" }), jsxRuntimeExports$1.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 23.8C19.4124 23.8 23.8 19.4124 23.8 14C23.8 8.58761 19.4124 4.2 14 4.2C8.58761 4.2 4.2 8.58761 4.2 14C4.2 19.4124 8.58761 23.8 14 23.8ZM11.55 10.8C11.1358 10.8 10.8 11.1358 10.8 11.55V16.45C10.8 16.8642 11.1358 17.2 11.55 17.2H16.45C16.8642 17.2 17.2 16.8642 17.2 16.45V11.55C17.2 11.1358 16.8642 10.8 16.45 10.8H11.55Z", fill: "white" })] });
};
const coinbaseWallet = (params) => ({
  id: "coinbase-wallet",
  logoDark: CoinbaseWalletLogo,
  logoLight: CoinbaseWalletLogo,
  name: "Coinbase Wallet",
  type: "wallet",
  createConnector: () => {
    const connector = coinbaseWallet$1({ ...params });
    return connector;
  }
});
const getEmailLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "white" : "black";
  const EmailLogo = (props) => {
    return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 35 34", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M17.0826 16.3805C17.1802 16.4598 17.32 16.4598 17.4176 16.3805L30.1401 6.04341C30.5283 5.72801 30.3053 5.09985 29.8051 5.09985H4.69499C4.19482 5.09985 3.9718 5.72801 4.35998 6.04341L17.0826 16.3805Z", fill: fillColor }), jsxRuntimeExports$1.jsx("path", { d: "M19.7626 19.2667L33.3838 8.19943C33.731 7.91735 34.2501 8.16441 34.2501 8.61174V24.2249C34.2501 26.5721 32.3473 28.4749 30.0001 28.4749H4.50006C2.15285 28.4749 0.250061 26.5721 0.250061 24.2249V8.61174C0.250061 8.16441 0.769134 7.91735 1.11631 8.19943L14.7375 19.2667C16.2014 20.4561 18.2987 20.4561 19.7626 19.2667Z", fill: fillColor })] });
  };
  return EmailLogo;
};
const email = (options) => ({
  id: "email",
  isSequenceBased: true,
  logoDark: getEmailLogo({ isDarkMode: true }),
  logoLight: getEmailLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Email",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInOptions: ["email"]
        }
      }
    });
    return connector;
  }
});
const emailWaas = ({ emailAuthVersion = 2, ...rest }) => ({
  id: "email-waas",
  logoDark: getEmailLogo({ isDarkMode: true }),
  logoLight: getEmailLogo({ isDarkMode: false }),
  name: "Email",
  type: "social",
  createConnector: () => {
    const options = { emailAuthVersion, ...rest };
    const connector = sequenceWaasWallet({
      ...options,
      loginType: "email"
    });
    return connector;
  }
});
const FacebookLogo = (props) => {
  return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: [jsxRuntimeExports$1.jsx("path", { d: "M17.4214 36.9716C9.27855 35.5145 3.10712 28.4859 3.10712 20.0001C3.10712 10.5715 10.8214 2.85718 20.25 2.85718C29.6785 2.85718 37.3928 10.5715 37.3928 20.0001C37.3928 28.4859 31.2214 35.5145 23.0785 36.9716L22.1357 36.2002H18.3643L17.4214 36.9716Z", fill: "url(#paint0_linear_193_14528)" }), jsxRuntimeExports$1.jsx("path", { d: "M26.9357 24.7999L27.7072 19.9999H23.1643V16.657C23.1643 15.2856 23.6786 14.257 25.7357 14.257H27.9643V9.88558C26.7643 9.71415 25.3929 9.54272 24.1929 9.54272C20.25 9.54272 17.5071 11.9427 17.5071 16.2285V19.9999H13.2214V24.7999H17.5071V36.8857C18.45 37.0571 19.3929 37.1429 20.3357 37.1429C21.2786 37.1429 22.2214 37.0571 23.1643 36.8857V24.7999H26.9357Z", fill: "white" }), jsxRuntimeExports$1.jsx("defs", { children: jsxRuntimeExports$1.jsxs("linearGradient", { id: "paint0_linear_193_14528", x1: "20.2508", y1: "35.9507", x2: "20.2508", y2: "2.85086", gradientUnits: "userSpaceOnUse", children: [jsxRuntimeExports$1.jsx("stop", { stopColor: "#0062E0" }), jsxRuntimeExports$1.jsx("stop", { offset: "1", stopColor: "#19AFFF" })] }) })] });
};
const getFacebookMonochromeLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "#FFFFFF" : "#000000";
  const FacebookMonochromeLogo = (props) => {
    return jsxRuntimeExports$1.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: jsxRuntimeExports$1.jsx("path", { d: "M25.8582 10.4398C24.1222 10.4398 23.6288 11.2098 23.6288 12.9073V15.709H28.246L27.791 20.2476H23.6279V34H18.1024V20.2468H14.375V15.7081H18.1042V12.9851C18.1042 8.40625 19.9399 6 25.0891 6C26.1942 6 27.5163 6.0875 28.3055 6.19775V10.459", fill: fillColor }) });
  };
  return FacebookMonochromeLogo;
};
const facebook = (options) => ({
  id: "facebook",
  isSequenceBased: true,
  logoDark: FacebookLogo,
  logoLight: FacebookLogo,
  monochromeLogoDark: getFacebookMonochromeLogo({ isDarkMode: true }),
  monochromeLogoLight: getFacebookMonochromeLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Facebook",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "facebook"
        }
      }
    });
    return connector;
  }
});
const GoogleLogo = (props) => {
  return jsxRuntimeExports$1.jsx("svg", { viewBox: "0 0 41 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsxRuntimeExports$1.jsx("g", { id: "Frame 2114", children: jsxRuntimeExports$1.jsxs("g", { id: "Group", children: [jsxRuntimeExports$1.jsx("path", { id: "Vector", d: "M20.7497 16.8828V23.5218H29.9756C29.5705 25.6568 28.3548 27.4647 26.5314 28.6803L32.095 32.9972C35.3366 30.0051 37.2068 25.6102 37.2068 20.3895C37.2068 19.1739 37.0977 18.005 36.895 16.883L20.7497 16.8828Z", fill: "#4285F4" }), jsxRuntimeExports$1.jsx("path", { id: "Vector_2", d: "M11.1424 23.2627L9.88756 24.2232L5.44592 27.6829C8.2667 33.2777 14.0481 37.1427 20.7493 37.1427C25.3778 37.1427 29.2583 35.6154 32.0947 32.9973L26.5311 28.6803C25.0038 29.7089 23.0557 30.3324 20.7493 30.3324C16.2922 30.3324 12.5053 27.3246 11.1494 23.2726L11.1424 23.2627Z", fill: "#34A853" }), jsxRuntimeExports$1.jsx("path", { id: "Vector_3", d: "M5.44594 12.3169C4.27718 14.6233 3.60712 17.2259 3.60712 19.9999C3.60712 22.7739 4.27718 25.3765 5.44594 27.6829C5.44594 27.6984 11.1499 23.2569 11.1499 23.2569C10.8071 22.2284 10.6044 21.1375 10.6044 19.9997C10.6044 18.8619 10.8071 17.7711 11.1499 16.7425L5.44594 12.3169Z", fill: "#FBBC05" }), jsxRuntimeExports$1.jsx("path", { id: "Vector_4", d: "M20.7497 9.6829C23.2744 9.6829 25.5185 10.5556 27.3107 12.2387L32.2198 7.32972C29.2431 4.55574 25.3783 2.85693 20.7497 2.85693C14.0484 2.85693 8.2667 6.70628 5.44592 12.3167L11.1497 16.7427C12.5055 12.6907 16.2926 9.6829 20.7497 9.6829Z", fill: "#EA4335" })] }) }) });
};
const getMonochromeGoogleLogo = ({ isDarkMode }) => {
  const fillColor = isDarkMode ? "white" : "black";
  const GoogleMonochromeLogo = (props) => {
    return jsxRuntimeExports$1.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 41 40", fill: "none", ...props, children: jsxRuntimeExports$1.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M25.8355 14.7613C24.5584 13.5329 22.9441 12.9032 21.1356 12.9032C17.9377 12.9032 15.2302 15.0813 14.2595 18.0232L14.2593 18.023C14.0142 18.7662 13.8712 19.5609 13.8712 20.3866C13.8712 21.2124 14.004 22.0072 14.2594 22.7504L14.2587 22.751H14.2595C15.2302 25.6929 17.9377 27.871 21.1356 27.871C22.7907 27.871 24.1904 27.4168 25.2939 26.6736V26.6732C26.5812 25.7958 27.4497 24.5055 27.746 22.9777H21.1355V18.3223H32.6808C32.8034 19.0758 32.875 19.85 32.875 20.6655C32.875 24.4332 31.5467 27.6126 29.2377 29.77L29.2378 29.7703C27.2148 31.6594 24.446 32.7742 21.1356 32.7742C16.3438 32.7742 12.2059 29.9871 10.1931 25.9407V25.94L10.193 25.9401C9.35521 24.2678 8.875 22.3891 8.875 20.3866C8.875 18.384 9.35521 16.5053 10.193 14.833H10.1934C12.2063 10.7869 16.344 8 21.1356 8C24.446 8 27.2148 9.22839 29.3298 11.231L25.8355 14.7613Z", fill: fillColor }) });
  };
  return GoogleMonochromeLogo;
};
const google = (options) => ({
  id: "google",
  isSequenceBased: true,
  logoDark: GoogleLogo,
  logoLight: GoogleLogo,
  monochromeLogoDark: getMonochromeGoogleLogo({ isDarkMode: true }),
  monochromeLogoLight: getMonochromeGoogleLogo({ isDarkMode: false }),
  name: "Google",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "google"
        }
      }
    });
    return connector;
  }
});
const googleWaas = (options) => ({
  id: "google-waas",
  logoDark: GoogleLogo,
  logoLight: GoogleLogo,
  monochromeLogoDark: getMonochromeGoogleLogo({ isDarkMode: true }),
  monochromeLogoLight: getMonochromeGoogleLogo({ isDarkMode: false }),
  name: "Google",
  type: "social",
  createConnector: () => {
    const connector = sequenceWaasWallet({
      ...options,
      loginType: "google"
    });
    return connector;
  }
});
const SequenceLogo = (props) => {
  return jsxRuntimeExports$1.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", style: { fill: "none" }, id: "svg1316", version: "1.1", viewBox: "0 0 396 396", ...props, children: [jsxRuntimeExports$1.jsx("g", { transform: "translate(0,38)", id: "g1256", clipPath: "url(#clip0_5_131)", children: jsxRuntimeExports$1.jsxs("g", { id: "g1254", clipPath: "url(#clip1_5_131)", children: [jsxRuntimeExports$1.jsx("path", { style: { fill: "#111111" }, id: "path1232", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint0_linear_5_13" }, id: "path1234", d: "M 0,67.5049 V 250.165 c 0,37.282 30.1402,67.505 67.32,67.505 h 261.36 c 37.18,0 67.32,-30.223 67.32,-67.505 V 67.5049 C 396,30.223 365.86,0 328.68,0 H 67.32 C 30.1402,0 0,30.223 0,67.5049 Z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint1_linear_5_131" }, id: "path1236", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint2_linear_5_131)" }, id: "path1238", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint3_linear_5_131)" }, id: "path1240", d: "m 98.9999,79.4176 c 0,-10.9653 -8.8648,-19.8544 -19.8,-19.8544 -10.9352,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.8648,19.8544 19.8,19.8544 10.9352,0 19.8,-8.8892 19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint4_linear_5_131)" }, id: "path1242", d: "m 98.9999,238.126 c 0,-10.965 -8.8648,-19.854 -19.8,-19.854 -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.966 8.8648,19.855 19.8,19.855 10.9352,0 19.8,-8.889 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint5_linear_5_131)" }, id: "path1244", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint6_linear_5_131)" }, id: "path1246", d: "m 336.6,158.835 c 0,-10.965 -8.865,-19.854 -19.8,-19.854 -10.935,0 -19.8,8.889 -19.8,19.854 0,10.965 8.865,19.855 19.8,19.855 10.935,0 19.8,-8.89 19.8,-19.855 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint7_linear_5_131)" }, id: "path1248", d: "M 316.8,59.5632 H 158.4 c -10.935,0 -19.8,8.8891 -19.8,19.8544 0,10.9652 8.865,19.8544 19.8,19.8544 h 158.4 c 10.935,0 19.8,-8.8892 19.8,-19.8544 0,-10.9653 -8.865,-19.8544 -19.8,-19.8544 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint8_linear_5_131)" }, id: "path1250", d: "M 316.8,218.272 H 158.4 c -10.935,0 -19.8,8.889 -19.8,19.854 0,10.966 8.865,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.889 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" }), jsxRuntimeExports$1.jsx("path", { style: { fill: "url(#paint9_linear_5_131)" }, id: "path1252", d: "M 237.6,138.981 H 79.2 c -10.9352,0 -19.8,8.889 -19.8,19.854 0,10.965 8.8648,19.855 19.8,19.855 h 158.4 c 10.935,0 19.8,-8.89 19.8,-19.855 0,-10.965 -8.865,-19.854 -19.8,-19.854 z" })] }) }), jsxRuntimeExports$1.jsxs("defs", { id: "defs1314", children: [jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "318", x2: "198", y1: "4.0585401e-05", x1: "198", id: "paint0_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1258", stopColor: "#1D273D" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1260", stopColor: "#0D0F13", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "63", x2: "92.5", y1: "99", x1: "65.5", id: "paint1_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1263", stopColor: "#4462FE" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1265", stopColor: "#7D69FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint2_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1268", stopColor: "#3757FD" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1270", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "97.591103", x2: "96.137703", y1: "99.291199", x1: "62.879902", id: "paint3_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1273", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1275", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "223.5", x2: "91.5", y1: "251.5", x1: "65", id: "paint4_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1278", stopColor: "#BC3EE6" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1280", stopColor: "#D972F1", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "146", x2: "329.5", y1: "172", x1: "305", id: "paint5_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1283", stopColor: "#29BDFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1285", stopColor: "#96E7FB", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "176.772", x2: "334.56699", y1: "178.418", x1: "300.17999", id: "paint6_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1288", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1290", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "60", x2: "317.5", y1: "99", x1: "154.5", id: "paint7_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1293", stopColor: "#23BBFF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1295", stopColor: "#85E7FF", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "218", x2: "312.5", y1: "258", x1: "156", id: "paint8_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1298", stopColor: "#2447FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1300", stopColor: "#6980FA", offset: "1" })] }), jsxRuntimeExports$1.jsxs("linearGradient", { gradientUnits: "userSpaceOnUse", y2: "139", x2: "235.5", y1: "179", x1: "86.000099", id: "paint9_linear_5_131", children: [jsxRuntimeExports$1.jsx("stop", { id: "stop1303", stopColor: "#6634FF" }), jsxRuntimeExports$1.jsx("stop", { id: "stop1305", stopColor: "#9C6DFF", offset: "1" })] }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip0_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1308", height: "317.67001", width: "396" }) }), jsxRuntimeExports$1.jsx("clipPath", { id: "clip1_5_131", children: jsxRuntimeExports$1.jsx("rect", { style: { fill: "#ffffff" }, y: "0", x: "0", id: "rect1311", height: "317.67001", width: "396" }) })] })] });
};
const sequence = (options) => ({
  id: "sequence",
  isSequenceBased: true,
  logoDark: SequenceLogo,
  logoLight: SequenceLogo,
  // iconBackground: '#777',
  name: "Sequence",
  type: "wallet",
  createConnector: (projectAccessKey2) => {
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options.connect
      }
    });
    return connector;
  }
});
const getTwitchLogo = ({ isDarkMode }) => {
  let fillColor;
  if (isDarkMode === void 0) {
    fillColor = "#9146FF";
  } else {
    fillColor = isDarkMode ? "white" : "black";
  }
  const TwitchLogo = (props) => {
    return jsxRuntimeExports$1.jsx("svg", { version: "1.1", id: "Layer_1", xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", viewBox: "0 0 2400 2800", transform: "scale(0.80)", ...props, children: jsxRuntimeExports$1.jsx("g", { children: jsxRuntimeExports$1.jsxs("g", { id: "Layer_1-2", children: [jsxRuntimeExports$1.jsx("path", { fill: fillColor, d: "M500,0L0,500v1800h600v500l500-500h400l900-900V0H500z M2200,1300l-400,400h-400l-350,350v-350H600V200h1600\n                  V1300z" }), jsxRuntimeExports$1.jsx("rect", { x: "1700", y: "550", fill: fillColor, width: "200", height: "600" }), jsxRuntimeExports$1.jsx("rect", { x: "1150", y: "550", fill: fillColor, width: "200", height: "600" })] }) }) });
  };
  return TwitchLogo;
};
const twitch = (options) => ({
  id: "twitch",
  isSequenceBased: true,
  logoDark: getTwitchLogo({}),
  logoLight: getTwitchLogo({}),
  monochromeLogoDark: getTwitchLogo({ isDarkMode: true }),
  monochromeLogoLight: getTwitchLogo({ isDarkMode: false }),
  // iconBackground: '#fff',
  name: "Twitch",
  type: "social",
  createConnector: (projectAccessKey2) => {
    var _a2;
    const connector = sequenceWallet({
      ...options,
      connect: {
        projectAccessKey: projectAccessKey2,
        ...options == null ? void 0 : options.connect,
        settings: {
          ...(_a2 = options == null ? void 0 : options.connect) == null ? void 0 : _a2.settings,
          signInWith: "twitch"
        }
      }
    });
    return connector;
  }
});
const WalletConnectLogo = (props) => {
  return jsxRuntimeExports$1.jsx("svg", { fill: "none", viewBox: "0 0 480 332", xmlns: "http://www.w3.org/2000/svg", ...props, children: jsxRuntimeExports$1.jsx("path", { d: "m126.613 93.9842c62.622-61.3123 164.152-61.3123 226.775 0l7.536 7.3788c3.131 3.066 3.131 8.036 0 11.102l-25.781 25.242c-1.566 1.533-4.104 1.533-5.67 0l-10.371-10.154c-43.687-42.7734-114.517-42.7734-158.204 0l-11.107 10.874c-1.565 1.533-4.103 1.533-5.669 0l-25.781-25.242c-3.132-3.066-3.132-8.036 0-11.102zm280.093 52.2038 22.946 22.465c3.131 3.066 3.131 8.036 0 11.102l-103.463 101.301c-3.131 3.065-8.208 3.065-11.339 0l-73.432-71.896c-.783-.767-2.052-.767-2.835 0l-73.43 71.896c-3.131 3.065-8.208 3.065-11.339 0l-103.4657-101.302c-3.1311-3.066-3.1311-8.036 0-11.102l22.9456-22.466c3.1311-3.065 8.2077-3.065 11.3388 0l73.4333 71.897c.782.767 2.051.767 2.834 0l73.429-71.897c3.131-3.065 8.208-3.065 11.339 0l73.433 71.897c.783.767 2.052.767 2.835 0l73.431-71.895c3.132-3.066 8.208-3.066 11.339 0z", fill: "#3396ff" }) });
};
const walletConnect = (options) => ({
  id: "wallet-connect",
  logoDark: WalletConnectLogo,
  logoLight: WalletConnectLogo,
  // iconBackground: '#fff',
  name: "Walletconnect",
  type: "wallet",
  createConnector: () => {
    const connector = walletConnect$1({
      ...options
    });
    return connector;
  }
});
const getKitConnectWallets = (projectAccessKey2, wallets) => {
  const connectors = [];
  wallets.forEach((wallet) => {
    const { createConnector: createConnector2, ...metaProperties } = wallet;
    const walletProperties = { ...metaProperties };
    const createConnectorOverride = (config2) => {
      const connector = createConnector2(projectAccessKey2);
      const res = connector(config2);
      res._wallet = { ...walletProperties };
      return res;
    };
    connectors.push(createConnectorOverride);
  });
  return connectors;
};
const getDefaultConnectors = ({ walletConnectProjectId, defaultChainId, projectAccessKey: projectAccessKey2, appName }) => {
  const connectors = getKitConnectWallets(projectAccessKey2, [
    email({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }),
    google({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }),
    facebook({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }),
    twitch({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }),
    apple({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }),
    sequence({
      defaultNetwork: defaultChainId,
      connect: {
        app: appName
      }
    }),
    walletConnect({
      projectId: walletConnectProjectId
    })
  ]);
  return connectors;
};
const getDefaultWaasConnectors = ({ projectAccessKey: projectAccessKey2, waasConfigKey: waasConfigKey2, googleClientId: googleClientId2, appleClientId: appleClientId2, appleRedirectURI: appleRedirectURI2, walletConnectProjectId, appName, defaultChainId, enableConfirmationModal, emailAuthVersion, isDev = false }) => {
  const wallets = [
    emailWaas({
      emailAuthVersion,
      projectAccessKey: projectAccessKey2,
      waasConfigKey: waasConfigKey2,
      enableConfirmationModal,
      network: defaultChainId,
      isDev
    }),
    coinbaseWallet({
      appName
    }),
    walletConnect({
      projectId: walletConnectProjectId
    })
  ];
  if (googleClientId2) {
    wallets.push(googleWaas({
      projectAccessKey: projectAccessKey2,
      googleClientId: googleClientId2,
      waasConfigKey: waasConfigKey2,
      enableConfirmationModal,
      network: defaultChainId,
      isDev
    }));
  }
  if (appleClientId2 && appleRedirectURI2) {
    wallets.push(appleWaas({
      projectAccessKey: projectAccessKey2,
      appleClientId: appleClientId2,
      appleRedirectURI: appleRedirectURI2,
      waasConfigKey: waasConfigKey2,
      enableConfirmationModal,
      network: defaultChainId,
      isDev
    }));
  }
  const connectors = getKitConnectWallets(projectAccessKey2, wallets);
  return connectors;
};
const getDefaultChains = (chainIdsFilter) => {
  if (chainIdsFilter) {
    return chainIdsFilter.map((chainId) => {
      const chain = chains$1[chainId];
      if (!chain) {
        throw new Error(`Chain with id ${chainId} not supported by Sequence`);
      }
      return chain;
    });
  }
  return Object.values(chains$1);
};
function walletClientToSigner(walletClient) {
  var _a2, _b2;
  const { account: account2, chain, transport } = walletClient;
  const network2 = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: (_b2 = (_a2 = chain.contracts) == null ? void 0 : _a2.ensRegistry) == null ? void 0 : _b2.address
  };
  const provider2 = new Web3Provider(transport, network2);
  const signer2 = provider2.getSigner(account2.address);
  return signer2;
}
function publicClientToProvider(publicClient) {
  var _a2, _b2;
  const { chain, transport } = publicClient;
  const network2 = {
    chainId: chain.id,
    name: chain.name,
    ensAddress: (_b2 = (_a2 = chain.contracts) == null ? void 0 : _a2.ensRegistry) == null ? void 0 : _b2.address
  };
  if (transport.type === "fallback")
    return new FallbackProvider(transport.transports.map(({ value }) => new JsonRpcProvider$1(value == null ? void 0 : value.url, network2)));
  return new JsonRpcProvider$1(transport.url, network2);
}
const signEthAuthProof = async (walletClient, storage) => {
  const proofInformation = await storage.getItem(LocalStorageKey.EthAuthProof);
  if (proofInformation) {
    return proofInformation;
  }
  const proofSettings = await storage.getItem(LocalStorageKey.EthAuthSettings);
  if (!proofSettings) {
    throw new Error("No ETHAuth settings found");
  }
  const walletAddress = walletClient.account.address;
  const proof = new Proof();
  proof.address = walletAddress;
  proof.claims.app = proofSettings.app || "app";
  proof.claims.ogn = proofSettings.origin;
  proof.claims.n = proofSettings.nonce;
  proof.setExpiryIn(proofSettings.expiry ? Math.max(proofSettings.expiry, 200) : DEFAULT_SESSION_EXPIRATION);
  const typedData = proof.messageTypedData();
  typedData.domain.verifyingContract;
  const signer2 = walletClientToSigner(walletClient);
  const signature2 = await signer2._signTypedData(typedData.domain, typedData.types, typedData.message);
  proof.signature = signature2;
  const ethAuth = new ETHAuth();
  const proofString = await ethAuth.encodeProof(proof, true);
  return {
    typedData,
    proofString
  };
};
const validateEthProof = async (walletClient, publicClient, proof) => {
  const walletAddress = walletClient.account.address;
  const ethAuth = new ETHAuth();
  const decodedProof = await ethAuth.decodeProof(proof.proofString, true);
  const provider2 = publicClientToProvider(publicClient);
  const isValid2 = await sequence$1.utils.isValidTypedDataSignature(walletAddress, proof.typedData, decodedProof.signature, provider2);
  return isValid2;
};
const mock = (options) => ({
  id: "mock",
  isSequenceBased: true,
  logoDark: SequenceLogo,
  logoLight: SequenceLogo,
  // iconBackground: '#777',
  name: "Mock",
  type: "wallet",
  createConnector: () => {
    const connector = mock$1(options);
    return connector;
  }
});
const useOpenConnectModal = () => {
  const { setOpenConnectModal, openConnectModalState } = useConnectModalContext();
  return { setOpenConnectModal, openConnectModalState };
};
const useTheme = () => {
  const { setTheme, theme, position, setPosition } = useThemeContext();
  return {
    setTheme,
    theme,
    position,
    setPosition
  };
};
const useWalletSettings = () => {
  const { setDisplayedAssets, displayedAssets } = useWalletConfigContext();
  return {
    displayedAssets,
    setDisplayedAssets
  };
};
let _pendingFeeConfirmation;
function useWaasFeeOptions() {
  var _a2;
  const connections = useConnections();
  const waasConnector = (_a2 = connections.find((c2) => c2.connector.id.includes("waas"))) == null ? void 0 : _a2.connector;
  const [pendingFeeOptionConfirmation, setPendingFeeOptionConfirmation] = reactExports.useState();
  function confirmPendingFeeOption(id2, feeTokenAddress) {
    _pendingFeeConfirmation == null ? void 0 : _pendingFeeConfirmation.resolve({ id: id2, feeTokenAddress, confirmed: true });
    setPendingFeeOptionConfirmation(void 0);
    _pendingFeeConfirmation = void 0;
  }
  function rejectPendingFeeOption(id2) {
    _pendingFeeConfirmation == null ? void 0 : _pendingFeeConfirmation.resolve({ id: id2, feeTokenAddress: void 0, confirmed: false });
    setPendingFeeOptionConfirmation(void 0);
    _pendingFeeConfirmation = void 0;
  }
  reactExports.useEffect(() => {
    async function setup() {
      if (!waasConnector) {
        return;
      }
      const waasProvider = waasConnector.sequenceWaasProvider;
      if (!waasProvider) {
        return;
      }
      waasProvider.feeConfirmationHandler = {
        confirmFeeOption(id2, options, txs, chainId) {
          const pending = new Deferred();
          setPendingFeeOptionConfirmation({ id: id2, options, chainId });
          _pendingFeeConfirmation = pending;
          return pending.promise;
        }
      };
    }
    setup();
  });
  return [pendingFeeOptionConfirmation, confirmPendingFeeOption, rejectPendingFeeOption];
}
const createGenericContext$1 = () => {
  const genericContext = reactExports.createContext(void 0);
  const useGenericContext = () => {
    const contextIsDefined = reactExports.useContext(genericContext);
    if (!contextIsDefined) {
      throw new Error("useGenericContext must be used within a Provider");
    }
    return contextIsDefined;
  };
  return [useGenericContext, genericContext.Provider];
};
const [useAddFundsModalContext, AddFundsContextProvider] = createGenericContext$1();
const [useCheckoutModalContext, CheckoutModalContextProvider] = createGenericContext$1();
const [useNavigationContext$1, NavigationContextProvider$1] = createGenericContext$1();
const HEADER_HEIGHT$1 = "54px";
const useNavigation$1 = () => {
  const { setHistory, history, defaultLocation } = useNavigationContext$1();
  const setNavigation = (navigation2) => {
    const childElement = document.getElementById("sequence-kit-wallet-content");
    const parentElement = childElement == null ? void 0 : childElement.parentElement;
    parentElement == null ? void 0 : parentElement.scrollTo(0, 0);
    const newHistory = [...history, navigation2];
    setHistory(newHistory);
  };
  const goBack = () => {
    const newHistory = [...history];
    newHistory.pop();
    setHistory(newHistory);
  };
  const navigation = history.length > 0 ? history[history.length - 1] : defaultLocation;
  return { setNavigation, history, setHistory, goBack, navigation };
};
const NavigationHeader$1 = ({ secondaryText, primaryText, disableBack = false }) => {
  const { goBack, history } = useNavigation$1();
  const onClickBack = () => {
    goBack();
  };
  return jsxRuntimeExports$1.jsxs(Box, { background: "backgroundPrimary", zIndex: "20", position: "fixed", width: "full", flexDirection: "row", alignItems: "center", justifyContent: "space-between", style: {
    height: HEADER_HEIGHT$1,
    paddingTop: "6px",
    backgroundColor: vars.colors.backgroundPrimary
  }, children: [history.length > 0 && !disableBack ? jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickBack, icon: SvgChevronLeftIcon, size: "sm", style: {
    background: "rgba(0,0,0,0)",
    width: "44px"
  } }) : jsxRuntimeExports$1.jsx(Box, {}), jsxRuntimeExports$1.jsxs(Box, { width: "full", alignItems: "center", justifyContent: "center", style: { marginLeft: "40px" }, children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text50", children: secondaryText }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text100", children: primaryText })] }), jsxRuntimeExports$1.jsx(Box, { style: {
    width: "44px"
  } })] });
};
const fetchSardineClientToken = async ({ order, isDev, projectAccessKey: projectAccessKey2, tokenMetadata }) => {
  const accessKey = isDev ? "17xhjK4yjRf1fr0am8kgKfICAAAAAAAAA" : projectAccessKey2;
  const url = isDev ? "https://dev-api.sequence.app/rpc/API/GetSardineNFTCheckoutToken" : "https://api.sequence.app/rpc/API/GetSardineNFTCheckoutToken";
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Access-Key": `${accessKey || ""}`
    },
    body: JSON.stringify({
      params: {
        name: (tokenMetadata == null ? void 0 : tokenMetadata.name) || "Unknown",
        imageUrl: (tokenMetadata == null ? void 0 : tokenMetadata.image) || "https://sequence.market/images/placeholder.png",
        network: networks[order.chainId].name,
        recipientAddress: order.recipientAddress,
        contractAddress: order.contractAddress,
        platform: "calldata_execution",
        blockchainNftId: order.nftId,
        quantity: Number(order.nftQuantity),
        decimals: Number((order == null ? void 0 : order.nftDecimals) || 0),
        tokenAmount: order.currencyQuantity,
        tokenAddress: order.currencyAddress,
        tokenSymbol: order.currencySymbol,
        tokenDecimals: Number(order.currencyDecimals),
        callData: order.calldata,
        ...(order == null ? void 0 : order.approvedSpenderAddress) ? { approvedSpenderAddress: order.approvedSpenderAddress } : {}
      }
    })
  });
  const { resp: { orderId, token } } = await res.json();
  return {
    token,
    orderId
  };
};
const fetchSardineOrderStatus = async (orderId, isDev, projectAccessKey2) => {
  const accessKey = isDev ? "17xhjK4yjRf1fr0am8kgKfICAAAAAAAAA" : projectAccessKey2;
  const url = isDev ? "https://dev-api.sequence.app/rpc/API/GetSardineNFTCheckoutOrderStatus" : "https://api.sequence.app/rpc/API/GetSardineNFTCheckoutOrderStatus";
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Access-Key": `${accessKey}`
    },
    body: JSON.stringify({
      orderId
    })
  });
  const json = await response.json();
  console.log("json:", json);
  return json;
};
const useAddFundsModal = () => {
  const { triggerAddFunds, closeAddFunds, addFundsSettings } = useAddFundsModalContext();
  return { triggerAddFunds, closeAddFunds, addFundsSettings };
};
const useCheckoutModal = () => {
  const { triggerCheckout, closeCheckout, settings } = useCheckoutModalContext();
  return { triggerCheckout, closeCheckout, settings };
};
const compareAddress$1 = (a2, b2) => {
  return a2.toLowerCase() === b2.toLowerCase();
};
var ValueType$1;
(function(ValueType2) {
  ValueType2[ValueType2["VERY_LARGE"] = 0] = "VERY_LARGE";
  ValueType2[ValueType2["FRACTION"] = 1] = "FRACTION";
  ValueType2[ValueType2["VERY_TINY"] = 2] = "VERY_TINY";
  ValueType2[ValueType2["MIXED"] = 3] = "MIXED";
})(ValueType$1 || (ValueType$1 = {}));
const formatDisplay$1 = (_val) => {
  if (isNaN(Number(_val))) {
    console.error(`display format error ${_val} is not a number`);
    return "NaN";
  }
  const val = Number(_val);
  if (val === 0) {
    return "0";
  }
  let valMode;
  if (val > 1e8) {
    valMode = ValueType$1.VERY_LARGE;
  } else if (val < 1e-10) {
    valMode = ValueType$1.VERY_TINY;
  } else if (val < 1) {
    valMode = ValueType$1.FRACTION;
  } else {
    valMode = ValueType$1.MIXED;
  }
  let notation = void 0;
  let config2;
  switch (valMode) {
    case ValueType$1.VERY_LARGE:
      notation = "compact";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType$1.VERY_TINY:
      notation = "scientific";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType$1.FRACTION:
      notation = "standard";
      config2 = {
        maximumSignificantDigits: 4
      };
      break;
    default:
      notation = "standard";
      config2 = {
        maximumFractionDigits: 2
      };
  }
  return Intl.NumberFormat("en-US", {
    notation,
    ...config2
  }).format(val);
};
const useSardineClientToken = (args, disabled) => {
  return useQuery$1({
    queryKey: ["useSardineClientToken", args],
    queryFn: async () => {
      const res = await fetchSardineClientToken(args);
      return res;
    },
    retry: false,
    staleTime: 0,
    enabled: !disabled,
    refetchOnWindowFocus: false
  });
};
const POLLING_TIME = 10 * 1e3;
const PendingTransaction = () => {
  var _a2;
  const nav = useNavigation$1();
  const { settings } = useCheckoutModal();
  const { params: { creditCardCheckout } } = nav.navigation;
  const { setNavigation } = nav;
  const projectAccessKey2 = useProjectAccessKey();
  const { data: tokensMetadata, isLoading: isLoadingTokenMetadata } = useTokenMetadata(creditCardCheckout.chainId, creditCardCheckout.nftAddress, [creditCardCheckout.nftId]);
  const tokenMetadata = tokensMetadata ? tokensMetadata[0] : void 0;
  const isDev = ((_a2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a2.isDev) || false;
  const disableSardineClientTokenFetch = isLoadingTokenMetadata;
  const { data, isLoading, isError } = useSardineClientToken({
    order: creditCardCheckout,
    isDev,
    projectAccessKey: projectAccessKey2,
    tokenMetadata
  }, disableSardineClientTokenFetch);
  const authToken = data == null ? void 0 : data.token;
  const url = isDev ? `https://crypto.sandbox.sardine.ai/?client_token=${authToken}&show_features=true` : `https://crypto.sardine.ai/?client_token=${authToken}&show_features=true`;
  const pollForOrderStatus = async () => {
    var _a3;
    try {
      if (!data) {
        return;
      }
      const { orderId } = data;
      console.log("Polling for transaction status");
      const isDev2 = (creditCardCheckout == null ? void 0 : creditCardCheckout.isDev) || false;
      const pollResponse = await fetchSardineOrderStatus(orderId, isDev2, projectAccessKey2);
      const status = pollResponse.resp.status;
      const transactionHash = (_a3 = pollResponse.resp) == null ? void 0 : _a3.transactionHash;
      console.log("transaction status poll response:", status);
      if (status === "Draft") {
        return;
      }
      if (status === "Complete") {
        setNavigation && setNavigation({
          location: "transaction-success",
          params: {
            transactionHash
          }
        });
        return;
      }
      if (status === "Declined" || status === "Cancelled") {
        setNavigation && setNavigation({
          location: "transaction-error",
          params: {
            error: new Error("Failed to transfer collectible")
          }
        });
        return;
      }
    } catch (e2) {
      console.error("An error occurred while fetching the transaction status");
      setNavigation && setNavigation({
        location: "transaction-error",
        params: {
          error: e2
        }
      });
    }
  };
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      pollForOrderStatus();
    }, POLLING_TIME);
    return () => {
      clearInterval(interval);
    };
  }, []);
  if (isError) {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "6", style: {
      height: "500px",
      width: "380px"
    }, children: jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "An error has occurred" }) }) });
  }
  if (isLoading || !authToken) {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "6", style: {
      height: "500px",
      width: "380px"
    }, children: jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Spinner, { size: "lg" }) }) });
  }
  return jsxRuntimeExports$1.jsx(Box, { alignItems: "center", justifyContent: "center", style: { height: "620px" }, children: jsxRuntimeExports$1.jsx("iframe", { src: url, style: {
    maxHeight: "500px",
    height: "100%",
    maxWidth: "380px",
    width: "100%"
  } }) });
};
const TransactionSuccess = () => {
  var _a2, _b2, _c2;
  const { settings } = useCheckoutModal();
  const nav = useNavigation$1();
  const navigation = nav.navigation;
  const chainId = ((_a2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a2.chainId) || ChainId.POLYGON;
  const network2 = sequence$1.network.allNetworks.find((n2) => n2.chainId === chainId);
  reactExports.useEffect(() => {
    var _a3, _b3, _c3, _d2;
    ((_a3 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a3.onSuccess) && ((_b3 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _b3.onSuccess(navigation.params.transactionHash, settings == null ? void 0 : settings.creditCardCheckout));
    ((_c3 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _c3.onSuccess) && ((_d2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _d2.onSuccess(navigation.params.transactionHash, settings == null ? void 0 : settings.creditCardCheckout));
  }, []);
  return jsxRuntimeExports$1.jsx(Box, { style: { height: "500px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", position: "absolute", style: { top: "50%", right: "50%", transform: "translate(50%, -50%)" }, children: [jsxRuntimeExports$1.jsx(NotificationSuccessIcon, {}), jsxRuntimeExports$1.jsx(Text, { fontSize: "xlarge", children: "Success!" }), jsxRuntimeExports$1.jsx(Text, { textAlign: "center", variant: "normal", color: "text80", children: "Purchase was successful, item was sent to your wallet." }), navigation.params.transactionHash && jsxRuntimeExports$1.jsxs(Text, { as: "a", variant: "small", underline: true, marginTop: "6", color: "text100", href: `${(_b2 = network2 == null ? void 0 : network2.blockExplorer) == null ? void 0 : _b2.rootUrl}/tx/${navigation.params.transactionHash}`, target: "_blank", rel: "noreferrer", children: ["View on ", (_c2 = network2 == null ? void 0 : network2.blockExplorer) == null ? void 0 : _c2.name] })] }) });
};
const NotificationSuccessIcon = () => jsxRuntimeExports$1.jsx(Box, { color: "white", background: "positive", alignItems: "center", justifyContent: "center", width: "16", height: "16", borderRadius: "circle", marginBottom: "2", children: jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { size: "xl" }) });
const TransactionError = () => {
  const { closeCheckout, settings } = useCheckoutModal();
  const nav = useNavigation$1();
  const navigation = nav.navigation;
  reactExports.useEffect(() => {
    setTimeout(() => {
      var _a2, _b2;
      closeCheckout();
      ((_a2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _a2.onError) && ((_b2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _b2.onError(navigation.params.error, settings == null ? void 0 : settings.creditCardCheckout));
    }, 3e3);
  }, []);
  return jsxRuntimeExports$1.jsx(Box, { style: { height: "500px" }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", position: "absolute", style: { top: "50%", right: "50%", transform: "translate(50%, -50%)" }, children: [jsxRuntimeExports$1.jsx(NotificationErrorIcon, {}), jsxRuntimeExports$1.jsx(Text, { fontSize: "xlarge", children: "Error" }), jsxRuntimeExports$1.jsx(Text, { textAlign: "center", variant: "normal", color: "text80", children: "An error occurred while processing the transaction." })] }) });
};
const NotificationErrorIcon = () => jsxRuntimeExports$1.jsx(Box, { color: "white", alignItems: "center", justifyContent: "center", width: "16", height: "16", borderRadius: "circle", marginBottom: "2", background: "negative", children: jsxRuntimeExports$1.jsx(SvgCloseIcon, { size: "xl" }) });
const OrderSummaryItem = ({ contractAddress, tokenId, quantityRaw, chainId }) => {
  const { data: tokenMetadata, isPending: isPendingTokenMetadata } = useTokenMetadata(chainId, contractAddress, [tokenId]);
  const { data: contractInfo, isPending: isPendingContractInfo } = useContractInfo(chainId, contractAddress);
  const isPending = isPendingTokenMetadata || isPendingContractInfo;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(OrderSummarySkeleton, {});
  }
  const { name: name2 = "unknown", image, decimals = 0 } = (tokenMetadata == null ? void 0 : tokenMetadata[0]) ?? {};
  const { logoURI: collectionLogoURI, name: collectionName = "Unknown Collection" } = contractInfo || {};
  const balanceFormatted = formatUnits$1(quantityRaw, decimals);
  return jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", alignItems: "flex-start", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Box, { aspectRatio: "1/1", height: "full", justifyContent: "center", alignItems: "center", style: { width: "80px" }, children: jsxRuntimeExports$1.jsx(Image$1, { src: image, borderRadius: "md", style: { maxWidth: "80px", height: "80px", objectFit: "cover" } }) }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsxs(Box, { gap: "1", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: collectionLogoURI, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { marginLeft: "1", fontSize: "small", color: "text80", fontWeight: "bold", children: collectionName }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", justifyContent: "center", style: {
    width: "180px"
  }, children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontSize: "normal", fontWeight: "normal", children: name2 }), jsxRuntimeExports$1.jsx(Text, { color: "text50", fontSize: "normal", fontWeight: "normal", children: `#${tokenId}` })] })] })] }), jsxRuntimeExports$1.jsx(Box, { height: "full", fontSize: "small", color: "text50", fontWeight: "bold", children: `x${formatDisplay$1(balanceFormatted)}` })] });
};
const OrderSummarySkeleton = () => {
  return jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", alignItems: "flex-start", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "80px", height: "80px" } }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "100px", height: "14px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "180px", height: "34px" } })] })] }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "14px", height: "14px" } })] });
};
const CheckoutSelection = () => {
  var _a2, _b2, _c2, _d2, _e2;
  const { chains: chains2 } = useConfig();
  const { setNavigation } = useNavigation$1();
  const { closeCheckout, settings } = useCheckoutModal();
  const { address: accountAddress } = useAccount();
  const cryptoCheckoutSettings = settings == null ? void 0 : settings.cryptoCheckout;
  const creditCardCheckoutSettings = settings == null ? void 0 : settings.creditCardCheckout;
  const displayCreditCardCheckout = !!creditCardCheckoutSettings;
  const displayCryptoCheckout = !!cryptoCheckoutSettings;
  const { data: contractInfoData, isLoading: isPendingContractInfo } = useContractInfo((cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.chainId) || 1, ((_a2 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _a2.contractAddress) || "");
  const { data: balancesData, isPending: isPendingBalances } = useBalances({
    chainIds: [(cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.chainId) || 1],
    accountAddress: accountAddress || ""
  });
  const isPending = (isPendingContractInfo || isPendingBalances) && cryptoCheckoutSettings;
  const isNativeToken = compareAddress$1(((_b2 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _b2.contractAddress) || "", AddressZero);
  const nativeTokenInfo = getNativeTokenInfoByChainId((cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.chainId) || 1, chains2);
  const coinDecimals = isNativeToken ? nativeTokenInfo.decimals : (contractInfoData == null ? void 0 : contractInfoData.decimals) || 0;
  const coinSymbol = isNativeToken ? nativeTokenInfo.symbol : (contractInfoData == null ? void 0 : contractInfoData.symbol) || "COIN";
  const coinImageUrl = isNativeToken ? nativeTokenInfo.logoURI : (contractInfoData == null ? void 0 : contractInfoData.logoURI) || "";
  const coinBalance = balancesData == null ? void 0 : balancesData.find((balance) => {
    var _a3;
    return compareAddress$1(balance.contractAddress, ((_a3 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _a3.contractAddress) || "");
  });
  const userBalanceRaw = coinBalance ? coinBalance.balance : "0";
  const requestedAmountRaw = ((_c2 = cryptoCheckoutSettings == null ? void 0 : cryptoCheckoutSettings.coinQuantity) == null ? void 0 : _c2.amountRequiredRaw) || "0";
  const userBalance = formatUnits$1(userBalanceRaw, coinDecimals);
  const requestAmount = formatUnits$1(requestedAmountRaw, coinDecimals);
  const isInsufficientBalance = BigNumber.from(userBalanceRaw).lt(BigNumber.from(requestedAmountRaw));
  const orderSummaryItems = (settings == null ? void 0 : settings.orderSummaryItems) || [];
  const chainId = ((_d2 = settings == null ? void 0 : settings.cryptoCheckout) == null ? void 0 : _d2.chainId) || ((_e2 = settings == null ? void 0 : settings.creditCardCheckout) == null ? void 0 : _e2.chainId) || 1;
  const triggerSardineTransaction = async () => {
    console.log("trigger sardine transaction");
    if (settings == null ? void 0 : settings.creditCardCheckout) {
      setNavigation({
        location: "transaction-pending",
        params: {
          creditCardCheckout: settings.creditCardCheckout
        }
      });
    }
  };
  const onClickPayWithCard = () => {
    if (settings == null ? void 0 : settings.creditCardCheckout) {
      triggerSardineTransaction();
    } else {
      setNavigation({
        location: "transaction-form"
      });
    }
  };
  const onClickPayWithCrypto = () => {
    var _a3;
    console.log("trigger transaction");
    const transaction2 = (_a3 = settings == null ? void 0 : settings.cryptoCheckout) == null ? void 0 : _a3.triggerTransaction;
    transaction2 && transaction2();
    closeCheckout();
  };
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "5", paddingBottom: "5", style: {
    marginTop: HEADER_HEIGHT$1
  }, flexDirection: "column", gap: "3", children: [orderSummaryItems.length > 0 && jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "normal", fontSize: "normal", color: "text50", children: "Order summary" }), jsxRuntimeExports$1.jsx(Tooltip, { vOffset: -2, side: "bottom", message: jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: ["Please note that NFTs are digital assets", jsxRuntimeExports$1.jsx("br", {}), " ,and as such, cannot be delivered physically."] }), children: jsxRuntimeExports$1.jsx(Box, { width: "5", height: "5", children: jsxRuntimeExports$1.jsx(SvgHelpIcon, { color: "text80" }) }) })] }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: orderSummaryItems.map((orderSummaryItem, index2) => {
    return jsxRuntimeExports$1.jsx(OrderSummaryItem, { ...orderSummaryItem, chainId }, index2);
  }) }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", children: jsxRuntimeExports$1.jsx(Divider, { color: "backgroundSecondary", style: {
    margin: "0px"
  } }) })] }), displayCryptoCheckout && jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "normal", fontSize: "normal", color: "text50", children: "Total" }), isPending ? jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "100px", height: "17px" } }) : jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "1", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: coinImageUrl, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "normal", fontSize: "normal", color: "text100", children: `${formatDisplay$1(requestAmount)} ${coinSymbol}` })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "2", children: [displayCreditCardCheckout && jsxRuntimeExports$1.jsx(Button, { style: {
    borderRadius: vars.radii.md,
    height: "56px"
  }, width: "full", borderRadius: "md", leftIcon: SvgPaymentsIcon, variant: "primary", label: "Pay with credit card", rightIcon: SvgChevronRightIcon, onClick: onClickPayWithCard }), displayCryptoCheckout && !isInsufficientBalance && !isPending && jsxRuntimeExports$1.jsx(Button, { style: {
    borderRadius: vars.radii.md,
    height: "56px"
  }, width: "full", leftIcon: () => jsxRuntimeExports$1.jsx(TokenImage, { src: coinImageUrl, size: "sm" }), variant: "primary", label: `Pay with ${coinSymbol}`, rightIcon: SvgChevronRightIcon, onClick: onClickPayWithCrypto }), displayCryptoCheckout && (isInsufficientBalance || isPending) && jsxRuntimeExports$1.jsx(Button, { shape: "square", width: "full", variant: "glass", label: jsxRuntimeExports$1.jsxs(Box, { placeItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: coinImageUrl, size: "sm" }), jsxRuntimeExports$1.jsxs(Text, { children: ["Insufficient $", coinSymbol] })] }), onClick: onClickPayWithCrypto, disabled: true })] }), displayCryptoCheckout && jsxRuntimeExports$1.jsx(Box, { width: "full", justifyContent: "flex-end", children: isPending ? jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "102px", height: "14px" } }) : jsxRuntimeExports$1.jsxs(Text, { fontWeight: "bold", fontSize: "small", color: "text50", children: ["Balance: ", `${formatDisplay$1(userBalance)} ${coinSymbol}`] }) })] });
};
const TRANSAK_API_KEY = "5911d9ec-46b5-48fa-a755-d59a715ff0cf";
const getTransakLink = (addFundsSettings) => {
  const defaultNetworks = "ethereum,mainnet,arbitrum,optimism,polygon,polygonzkevm,zksync,base,bnb,oasys,astar,avaxcchain";
  const options = {
    apiKey: TRANSAK_API_KEY,
    referrerDomain: window.location.origin,
    walletAddress: addFundsSettings.walletAddress,
    fiatCurrency: addFundsSettings == null ? void 0 : addFundsSettings.fiatCurrency,
    disableWalletAddressForm: "true",
    defaultFiatAmount: (addFundsSettings == null ? void 0 : addFundsSettings.defaultFiatAmount) || "50",
    defaultCryptoCurrency: (addFundsSettings == null ? void 0 : addFundsSettings.defaultCryptoCurrency) || "USDC",
    networks: (addFundsSettings == null ? void 0 : addFundsSettings.networks) || defaultNetworks
  };
  const url = new URL("https://global.transak.com");
  Object.keys(options).forEach((k2) => {
    const option = options[k2];
    if (option) {
      url.searchParams.append(k2, option);
    }
  });
  return url.href;
};
const AddFundsContent = () => {
  const { addFundsSettings } = useAddFundsModal();
  if (!addFundsSettings) {
    return;
  }
  const link = getTransakLink(addFundsSettings);
  return jsxRuntimeExports$1.jsx(Box, { alignItems: "center", width: "full", paddingX: "4", paddingBottom: "4", height: "full", style: { height: "600px" }, children: jsxRuntimeExports$1.jsx(Box, { as: "iframe", width: "full", height: "full", borderWidth: "none", src: link }) });
};
const KitCheckoutProvider = (props) => {
  const queryClient2 = new QueryClient();
  return jsxRuntimeExports$1.jsx(QueryClientProvider, { client: queryClient2, children: jsxRuntimeExports$1.jsx(KitCheckoutContent, { ...props }) });
};
const KitCheckoutContent = ({ children }) => {
  const { theme, position } = useTheme();
  const [openCheckoutModal, setOpenCheckoutModal] = reactExports.useState(false);
  const [openAddFundsModal, setOpenAddFundsModal] = reactExports.useState(false);
  const [settings, setSettings] = reactExports.useState();
  const [addFundsSettings, setAddFundsSettings] = reactExports.useState();
  const [history, setHistory] = reactExports.useState([]);
  const getDefaultLocation = () => {
    const orderSummaryItems = (settings == null ? void 0 : settings.orderSummaryItems) || [];
    const creditCardSettings = settings == null ? void 0 : settings.creditCardCheckout;
    if (orderSummaryItems.length === 0 && creditCardSettings) {
      return {
        location: "transaction-pending",
        params: {
          creditCardCheckout: creditCardSettings
        }
      };
    } else {
      return {
        location: "select-method-checkout"
      };
    }
  };
  const navigation = history.length > 0 ? history[history.length - 1] : getDefaultLocation();
  const triggerCheckout = (settings2) => {
    setSettings(settings2);
    setOpenCheckoutModal(true);
  };
  const closeCheckout = () => {
    setOpenCheckoutModal(false);
  };
  const triggerAddFunds = (settings2) => {
    setAddFundsSettings(settings2);
    setOpenAddFundsModal(true);
  };
  const closeAddFunds = () => {
    setOpenAddFundsModal(false);
  };
  const getCheckoutContent = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      case "select-method-checkout":
        return jsxRuntimeExports$1.jsx(CheckoutSelection, {});
      case "transaction-pending":
        return jsxRuntimeExports$1.jsx(PendingTransaction, {});
      case "transaction-success":
        return jsxRuntimeExports$1.jsx(TransactionSuccess, {});
      case "transaction-error":
        return jsxRuntimeExports$1.jsx(TransactionError, {});
      case "transaction-form":
      default:
        return jsxRuntimeExports$1.jsx(CheckoutSelection, {});
    }
  };
  const getCheckoutHeader = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      case "select-method-checkout":
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Checkout" });
      case "transaction-success":
      case "transaction-error":
      case "transaction-pending":
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { disableBack: true, primaryText: "Pay with credit or debit card" });
      case "transaction-form":
      default:
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Pay with credit or debit card" });
    }
  };
  const getAddFundsHeader = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      default:
        return jsxRuntimeExports$1.jsx(NavigationHeader$1, { primaryText: "Add funds with credit card or debit card" });
    }
  };
  const getAddFundsContent = () => {
    const { location: location2 } = navigation;
    switch (location2) {
      default:
        return jsxRuntimeExports$1.jsx(AddFundsContent, {});
    }
  };
  reactExports.useEffect(() => {
    if (openCheckoutModal || openAddFundsModal) {
      setHistory([]);
    }
  }, [openCheckoutModal, openAddFundsModal]);
  return jsxRuntimeExports$1.jsx(AddFundsContextProvider, { value: {
    triggerAddFunds,
    closeAddFunds,
    addFundsSettings
  }, children: jsxRuntimeExports$1.jsx(CheckoutModalContextProvider, { value: {
    triggerCheckout,
    closeCheckout,
    settings,
    theme
  }, children: jsxRuntimeExports$1.jsxs(NavigationContextProvider$1, { value: { history, setHistory, defaultLocation: getDefaultLocation() }, children: [jsxRuntimeExports$1.jsx("div", { id: "kit-checkout", children: jsxRuntimeExports$1.jsx(ThemeProvider, { root: "#kit-checkout", scope: "kit", theme, children: jsxRuntimeExports$1.jsxs(AnimatePresence, { children: [openCheckoutModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      maxWidth: "400px",
      height: "auto",
      ...getModalPositionCss(position)
    }
  }, scroll: false, backdropColor: "backgroundBackdrop", onClose: () => setOpenCheckoutModal(false), children: jsxRuntimeExports$1.jsxs(Box, { id: "sequence-kit-checkout-content", children: [getCheckoutHeader(), getCheckoutContent()] }) }), openAddFundsModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      maxWidth: "400px",
      height: "auto",
      ...getModalPositionCss(position)
    }
  }, scroll: false, backdropColor: "backgroundBackdrop", onClose: () => setOpenAddFundsModal(false), children: jsxRuntimeExports$1.jsxs(Box, { id: "sequence-kit-add-funds-content", children: [getAddFundsHeader(), getAddFundsContent()] }) })] }) }) }), children] }) }) });
};
const ERC_1155_ABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "_amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ERC_20_ABI = [
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ERC_721_ABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const supportedFiatCurrencies = [
  { symbol: "USD", sign: "$", name: { message: "US Dollar" }, decimals: 2 },
  { symbol: "CAD", sign: "$", name: { message: "Canadian Dollar" }, decimals: 2 },
  { symbol: "GBP", sign: "", name: { message: "British Pound Sterling" }, decimals: 2 },
  { symbol: "EUR", sign: "", name: { message: "Euro" }, decimals: 2 },
  { symbol: "CNY", sign: "", name: { message: "Chinese Yuan" }, decimals: 2 },
  { symbol: "JPY", sign: "", name: { message: "Japanese Yen" }, decimals: 2 },
  { symbol: "KRW", sign: "", name: { message: "South Korean Won" }, decimals: 2 },
  { symbol: "SGD", sign: "$", name: { message: "Singapore Dollar" }, decimals: 2 },
  { symbol: "CHF", sign: "CHF ", name: { message: "Swiss Franc" }, decimals: 2 },
  { symbol: "AUD", sign: "$", name: { message: "Australian Dollar" }, decimals: 2 },
  { symbol: "NZD", sign: "$", name: { message: "New Zealand Dollar" }, decimals: 2 },
  { symbol: "SEK", sign: "kr ", name: { message: "Swedish Krona" }, decimals: 2 },
  { symbol: "NOK", sign: "kr ", name: { message: "Norwegian Krone" }, decimals: 2 },
  { symbol: "MXN", sign: "$", name: { message: "Mexican Peso" }, decimals: 2 },
  { symbol: "INR", sign: "", name: { message: "Indian Rupee" }, decimals: 2 },
  { symbol: "ZAR", sign: "R ", name: { message: "South African Rand" }, decimals: 2 },
  { symbol: "TRY", sign: "", name: { message: "Turkish Lira" }, decimals: 2 },
  { symbol: "BRL", sign: "R$", name: { message: "Brazilian Real" }, decimals: 2 },
  { symbol: "DKK", sign: "kr ", name: { message: "Danish Krone" }, decimals: 2 },
  { symbol: "PLN", sign: "z ", name: { message: "Polish Zloty" }, decimals: 2 },
  { symbol: "THB", sign: "", name: { message: "Thai Baht" }, decimals: 2 },
  { symbol: "IDR", sign: "Rp", name: { message: "Indonesian Rupiah" }, decimals: 2 }
];
const defaultFiatCurrency = supportedFiatCurrencies[0];
const HEADER_HEIGHT = "54px";
const createGenericContext = () => {
  const genericContext = reactExports.createContext(void 0);
  const useGenericContext = () => {
    const contextIsDefined = reactExports.useContext(genericContext);
    if (!contextIsDefined) {
      throw new Error("useGenericContext must be used within a Provider");
    }
    return contextIsDefined;
  };
  return [useGenericContext, genericContext.Provider];
};
const [useWalletModalContext, WalletModalContextProvider] = createGenericContext();
const [useNavigationContext, NavigationContextProvider] = createGenericContext();
const useOpenWalletModal = () => {
  const { setOpenWalletModal, openWalletModalState } = useWalletModalContext();
  return { setOpenWalletModal, openWalletModalState };
};
const compareAddress = (a2, b2) => {
  return a2.toLowerCase() === b2.toLowerCase();
};
const truncateAtMiddle = (text2, truncateAt) => {
  let finalText = text2;
  if (text2.length >= truncateAt) {
    finalText = text2.slice(0, truncateAt / 2) + "..." + text2.slice(text2.length - truncateAt / 2, text2.length);
  }
  return finalText;
};
const formatAddress = (text2) => {
  return `0x${truncateAtMiddle((text2 == null ? void 0 : text2.substring(2)) || "", 8)}`;
};
var ValueType;
(function(ValueType2) {
  ValueType2[ValueType2["VERY_LARGE"] = 0] = "VERY_LARGE";
  ValueType2[ValueType2["FRACTION"] = 1] = "FRACTION";
  ValueType2[ValueType2["VERY_TINY"] = 2] = "VERY_TINY";
  ValueType2[ValueType2["MIXED"] = 3] = "MIXED";
})(ValueType || (ValueType = {}));
const formatDisplay = (_val) => {
  if (isNaN(Number(_val))) {
    console.error(`display format error ${_val} is not a number`);
    return "NaN";
  }
  const val = Number(_val);
  if (val === 0) {
    return "0";
  }
  let valMode;
  if (val > 1e8) {
    valMode = ValueType.VERY_LARGE;
  } else if (val < 1e-10) {
    valMode = ValueType.VERY_TINY;
  } else if (val < 1) {
    valMode = ValueType.FRACTION;
  } else {
    valMode = ValueType.MIXED;
  }
  let notation = void 0;
  let config2;
  switch (valMode) {
    case ValueType.VERY_LARGE:
      notation = "compact";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType.VERY_TINY:
      notation = "scientific";
      config2 = {
        maximumFractionDigits: 4
      };
      break;
    case ValueType.FRACTION:
      notation = "standard";
      config2 = {
        maximumSignificantDigits: 4
      };
      break;
    default:
      notation = "standard";
      config2 = {
        maximumFractionDigits: 2
      };
  }
  return Intl.NumberFormat("en-US", {
    notation,
    ...config2
  }).format(val);
};
const capitalize = (word) => {
  return word.charAt(0).toUpperCase() + word.slice(1);
};
const limitDecimals = (value, decimals) => {
  const splitValue = value.split(".");
  if (splitValue.length === 1) {
    return value;
  }
  return `${splitValue[0]}.${splitValue[1].slice(0, decimals)}`;
};
const isEthAddress = (value) => {
  const ethAddressRegEx = /0x[a-fA-F0-9]{40}/;
  const isEthAddress2 = ethAddressRegEx.test(value);
  return isEthAddress2;
};
const sampleSize = (collection, n2) => {
  const length = collection.length;
  if (!length || n2 < 1) {
    return [];
  }
  n2 = n2 > length ? length : n2;
  const sampled = new Array(n2);
  const indexes = /* @__PURE__ */ new Set();
  while (indexes.size < n2) {
    indexes.add(Math.floor(Math.random() * length));
  }
  let index2 = 0;
  for (const i of indexes) {
    sampled[index2++] = collection[i];
  }
  return sampled;
};
const isTruthy = (value) => Boolean(value);
const getPercentageColor = (value) => {
  if (value > 0) {
    return vars.colors.positive;
  } else if (value < 0) {
    return vars.colors.negative;
  } else {
    return vars.colors.text50;
  }
};
const getPercentagePriceChange = (balance, prices) => {
  var _a2;
  const priceForToken = prices.find((p2) => compareAddress(p2.token.contractAddress, balance.contractAddress));
  if (!priceForToken) {
    return 0;
  }
  const price24HourChange = ((_a2 = priceForToken == null ? void 0 : priceForToken.price24hChange) == null ? void 0 : _a2.value) || 0;
  return price24HourChange;
};
const computeBalanceFiat = ({ balance, prices, decimals, conversionRate }) => {
  var _a2;
  let totalUsd = 0;
  const priceForToken = prices.find((p2) => compareAddress(p2.token.contractAddress, balance.contractAddress));
  if (!priceForToken) {
    return "0.00";
  }
  const priceFiat = ((_a2 = priceForToken.price) == null ? void 0 : _a2.value) || 0;
  const valueFormatted = formatUnits$1(balance.balance, decimals);
  const usdValue = parseFloat(valueFormatted) * priceFiat;
  totalUsd += usdValue;
  const fiatValue = totalUsd * conversionRate;
  return `${fiatValue.toFixed(2)}`;
};
const compareTokenBalanceIds = (a2, b2) => {
  return (a2.tokenID || "").localeCompare(b2.tokenID || "");
};
const sortBalancesByType = (balances) => {
  const nativeTokens = [];
  const erc20Tokens = [];
  const collectibles = [];
  balances.forEach((balance) => {
    if (balance.contractAddress === AddressZero) {
      nativeTokens.push(balance);
    } else if (balance.contractType === "ERC20") {
      erc20Tokens.push(balance);
    } else if (balance.contractType === "ERC721" || balance.contractType === "ERC1155") {
      collectibles.push(balance);
    }
  });
  const sortedNativeTokens = nativeTokens.sort(compareTokenBalanceIds);
  const sortedErc20Tokens = erc20Tokens.sort(compareTokenBalanceIds);
  const sortedCollectibles = collectibles.sort(compareTokenBalanceIds);
  return {
    nativeTokens: sortedNativeTokens,
    erc20Tokens: sortedErc20Tokens,
    collectibles: sortedCollectibles
  };
};
const flattenPaginatedTransactionHistory = (transactionHistoryData) => {
  const transactionHistory = [];
  transactionHistoryData == null ? void 0 : transactionHistoryData.pages.forEach((page) => {
    transactionHistory.push(...page.transactions);
  });
  return transactionHistory;
};
const time = {
  oneSecond: 1 * 1e3,
  oneMinute: 60 * 1e3,
  oneHour: 60 * 60 * 1e3
};
const getBalancesAssetsSummary = async (apiClient, metadataClient, indexerClients, { accountAddress, displayAssets, hideCollectibles, verifiedOnly }) => {
  const indexerClientsArr = Array.from(indexerClients.entries());
  const MAX_COLLECTIBLES_AMOUNTS = 10;
  let tokenBalances = [];
  const customDisplayAssets = displayAssets.length > 0;
  try {
    if (customDisplayAssets) {
      const nativeTokens2 = displayAssets.filter((asset) => compareAddress(asset.contractAddress, AddressZero));
      const otherAssets = displayAssets.filter((asset) => !compareAddress(asset.contractAddress, AddressZero));
      const nativeTokensByChainId = {};
      const otherAssetsByChainId = {};
      nativeTokens2.forEach((asset) => {
        if (!nativeTokensByChainId[asset.chainId]) {
          nativeTokensByChainId[asset.chainId] = [];
        }
        nativeTokensByChainId[asset.chainId].push(asset);
      });
      otherAssets.forEach((asset) => {
        if (!otherAssetsByChainId[asset.chainId]) {
          otherAssetsByChainId[asset.chainId] = [];
        }
        otherAssetsByChainId[asset.chainId].push(asset);
      });
      tokenBalances = (await Promise.all([
        ...Object.keys(nativeTokensByChainId).map((chainId) => {
          const indexerClient = indexerClients.get(Number(chainId));
          if (!indexerClient) {
            console.error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
            return null;
          }
          return getNativeTokenBalance(indexerClient, Number(chainId), accountAddress);
        }),
        ...Object.keys(otherAssetsByChainId).map((chainId) => otherAssetsByChainId[Number(chainId)].map((asset) => {
          const indexerClient = indexerClients.get(Number(chainId));
          if (!indexerClient) {
            console.error(`Indexer client not found for chainId: ${chainId}, did you forget to add this Chain?`);
            return [];
          }
          return getTokenBalances(indexerClient, {
            accountAddress,
            contractAddress: asset.contractAddress,
            includeMetadata: false,
            hideCollectibles,
            verifiedOnly
          });
        })).flat()
      ])).flat().filter(isTruthy);
    } else {
      tokenBalances = (await Promise.all([
        ...indexerClientsArr.map(([chainId, indexerClient]) => getNativeTokenBalance(indexerClient, chainId, accountAddress)),
        ...indexerClientsArr.map(([_chainId, indexerClient]) => getTokenBalances(indexerClient, {
          accountAddress,
          hideCollectibles,
          includeMetadata: false,
          verifiedOnly
        }))
      ])).flat();
    }
    const { nativeTokens, erc20Tokens, collectibles: collectionBalances } = sortBalancesByType(tokenBalances);
    const fetchPricesPromise = new Promise(async (resolve) => {
      if (erc20Tokens.length > 0) {
        const tokens = erc20Tokens.map((token) => ({
          chainId: token.chainId,
          contractAddress: token.contractAddress
        }));
        const prices2 = await getCoinPrices(apiClient, tokens) || [];
        resolve(prices2);
      } else {
        resolve([]);
      }
    });
    const fetchCollectiblesPromises = collectionBalances.map(async (collectionBalance) => {
      if (customDisplayAssets) {
        return collectionBalance;
      }
      const indexerClient = indexerClients.get(collectionBalance.chainId);
      if (!indexerClient) {
        throw new Error(`Indexer client not found for chainId: ${collectionBalance.chainId}, did you forget to add this Chain?`);
      }
      const balance = await getCollectionBalance(indexerClient, {
        accountAddress,
        chainId: collectionBalance.chainId,
        contractAddress: collectionBalance.contractAddress,
        includeMetadata: false
      });
      return balance;
    });
    const fetchErc20ContractInfoPromise = async () => {
      const contractInfoMapByChainId2 = {};
      const erc20BalanceByChainId = {};
      erc20Tokens.forEach((erc20Token) => {
        if (!erc20BalanceByChainId[erc20Token.chainId]) {
          erc20BalanceByChainId[erc20Token.chainId] = [erc20Token];
        } else {
          erc20BalanceByChainId[erc20Token.chainId].push(erc20Token);
        }
      });
      const contractInfoPromises = Object.keys(erc20BalanceByChainId).map(async (chainId) => {
        const tokenBalances2 = erc20BalanceByChainId[Number(chainId)];
        const contractAddresses = tokenBalances2.map((balance) => balance.contractAddress);
        const result = await metadataClient.getContractInfoBatch({
          chainID: String(chainId),
          contractAddresses
        });
        contractInfoMapByChainId2[Number(chainId)] = result;
      });
      await Promise.all([...contractInfoPromises]);
      return contractInfoMapByChainId2;
    };
    const [prices, contractInfoMapByChainId, ...collectionCollectibles] = await Promise.all([
      fetchPricesPromise,
      fetchErc20ContractInfoPromise(),
      ...fetchCollectiblesPromises
    ]);
    const erc20HighestValue = erc20Tokens.sort((a2, b2) => {
      var _a2, _b2;
      const aPriceData = prices.find((price) => compareAddress(price.token.contractAddress, a2.contractAddress));
      const bPriceData = prices.find((price) => compareAddress(price.token.contractAddress, b2.contractAddress));
      const aPrice = (aPriceData == null ? void 0 : aPriceData.price) ? aPriceData.price.value : 0;
      const bPrice = (bPriceData == null ? void 0 : bPriceData.price) ? bPriceData.price.value : 0;
      const aDecimals = (_a2 = contractInfoMapByChainId[a2.chainId].contractInfoMap[a2.contractAddress]) == null ? void 0 : _a2.decimals;
      const bDecimals = (_b2 = contractInfoMapByChainId[b2.chainId].contractInfoMap[b2.contractAddress]) == null ? void 0 : _b2.decimals;
      const aFormattedBalance = aDecimals === void 0 ? 0 : Number(formatUnits$1(a2.balance, aDecimals));
      const bFormattedBalance = bDecimals === void 0 ? 0 : Number(formatUnits$1(b2.balance, bDecimals));
      const aValue = aFormattedBalance * aPrice;
      const bValue = bFormattedBalance * bPrice;
      return bValue - aValue;
    });
    const collectibles = sampleSize(collectionCollectibles.flat(), MAX_COLLECTIBLES_AMOUNTS).sort((a2, b2) => {
      return a2.contractAddress.localeCompare(b2.contractAddress);
    });
    if (hideCollectibles) {
      const summaryBalances2 = [
        ...nativeTokens.length > 0 ? [nativeTokens[0]] : [],
        // the spots normally occupied by collectibles will be filled by erc20 tokens
        ...erc20HighestValue.length > 0 ? erc20HighestValue.slice(0, MAX_COLLECTIBLES_AMOUNTS + 1) : []
      ];
      return summaryBalances2;
    }
    const summaryBalances = [
      ...nativeTokens.length > 0 ? [nativeTokens[0]] : [],
      ...erc20HighestValue.length > 0 ? [erc20HighestValue[0]] : [],
      ...collectibles.length > 0 ? [...collectibles] : []
    ];
    return summaryBalances;
  } catch (e2) {
    console.error(e2);
    return [];
  }
};
const useBalancesAssetsSummary = (args) => {
  const apiClient = useAPIClient();
  const metadataClient = useMetadataClient();
  const indexerClients = useIndexerClients(args.chainIds);
  return useQuery$1({
    queryKey: ["balancesAssetsSummary", args],
    queryFn: () => getBalancesAssetsSummary(apiClient, metadataClient, indexerClients, args),
    retry: true,
    refetchInterval: time.oneSecond * 4,
    refetchOnMount: true,
    staleTime: time.oneSecond,
    enabled: args.chainIds.length > 0 && !!args.accountAddress
  });
};
const getTransactionHistorySummary = async (indexerClients, { accountAddress }) => {
  const histories = await Promise.all(Array.from(indexerClients.values()).map((indexerClient) => getTransactionHistory(indexerClient, {
    accountAddress,
    page: {
      page: 1
    }
  })));
  const unorderedTransactions = histories.map((history) => history.transactions).flat();
  const orderedTransactions = unorderedTransactions.sort((a2, b2) => {
    const firstDate = new Date(a2.timestamp).getTime();
    const secondDate = new Date(b2.timestamp).getTime();
    return secondDate - firstDate;
  });
  return orderedTransactions;
};
const useTransactionHistorySummary = (args) => {
  const indexerClients = useIndexerClients(args.chainIds);
  return useQuery$1({
    queryKey: ["transactionHistorySummary", args],
    queryFn: () => getTransactionHistorySummary(indexerClients, args),
    retry: true,
    staleTime: time.oneSecond,
    refetchOnMount: true,
    enabled: args.chainIds.length > 0 && !!args.accountAddress
  });
};
const useNavigation = () => {
  const { setHistory, history } = useNavigationContext();
  const setNavigation = (navigation) => {
    const childElement = document.getElementById("sequence-kit-wallet-content");
    const parentElement = childElement == null ? void 0 : childElement.parentElement;
    parentElement == null ? void 0 : parentElement.scrollTo(0, 0);
    const newHistory = navigation.location === "home" ? [] : [...history, navigation];
    setHistory(newHistory);
  };
  const goBack = () => {
    const newHistory = [...history];
    newHistory.pop();
    setHistory(newHistory);
  };
  return { setNavigation, history, setHistory, goBack };
};
const useSettings = () => {
  const { chains: chains2 } = useConfig();
  const getSettingsFromStorage = () => {
    let hideUnlistedTokens = true;
    let hideCollectibles = false;
    let fiatCurrency = defaultFiatCurrency;
    let selectedNetworks = chains2.map((chain) => chain.id);
    try {
      const settingsStorage = localStorage.getItem(LocalStorageKey.Settings);
      const settings2 = JSON.parse(settingsStorage || "{}");
      if ((settings2 == null ? void 0 : settings2.hideUnlistedTokens) !== void 0) {
        hideUnlistedTokens = settings2 == null ? void 0 : settings2.hideUnlistedTokens;
      }
      if ((settings2 == null ? void 0 : settings2.hideCollectibles) !== void 0) {
        hideCollectibles = settings2 == null ? void 0 : settings2.hideCollectibles;
      }
      if ((settings2 == null ? void 0 : settings2.fiatCurrency) !== void 0) {
        fiatCurrency = settings2 == null ? void 0 : settings2.fiatCurrency;
      }
      if ((settings2 == null ? void 0 : settings2.selectedNetworks) !== void 0) {
        let areSelectedNetworksValid = true;
        settings2.selectedNetworks.forEach((chainId) => {
          if (chains2.find((chain) => chain.id === chainId) === void 0) {
            areSelectedNetworksValid = false;
          }
        });
        if (areSelectedNetworksValid) {
          selectedNetworks = settings2 == null ? void 0 : settings2.selectedNetworks;
        }
      }
    } catch (e2) {
      console.error(e2, "Failed to fetch settings");
    }
    return {
      hideUnlistedTokens,
      hideCollectibles,
      fiatCurrency,
      selectedNetworks
    };
  };
  const defaultSettings = getSettingsFromStorage();
  const [settings, setSettings] = reactExports.useState(defaultSettings);
  const setHideUnlistedTokens = (newState) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      hideUnlistedTokens: newState
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  const setHideCollectibles = (newState) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      hideCollectibles: newState
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  const setFiatCurrency = (newFiatCurrency) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      fiatCurrency: newFiatCurrency
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  const setSelectedNetworks = (newSelectedNetworks) => {
    const oldSettings = getSettingsFromStorage();
    const newSettings = {
      ...oldSettings,
      selectedNetworks: newSelectedNetworks
    };
    localStorage.setItem(LocalStorageKey.Settings, JSON.stringify(newSettings));
    setSettings(newSettings);
  };
  return {
    ...settings,
    setFiatCurrency,
    setHideCollectibles,
    setHideUnlistedTokens,
    setSelectedNetworks
  };
};
const CoinTileContent = ({ logoUrl, tokenName, balance, balanceFiat, priceChangePercentage, symbol, chainId }) => {
  const { fiatCurrency } = useSettings();
  const priceChangeSymbol = priceChangePercentage > 0 ? "+" : "";
  return jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", width: "full", height: "full", borderRadius: "md", padding: "4", flexDirection: "column", justifyContent: "center", alignItems: "flex-start", gap: "1", children: [jsxRuntimeExports$1.jsx(Box, { marginBottom: "1", children: jsxRuntimeExports$1.jsx(TokenImage, { src: logoUrl, symbol, size: "xl" }) }), jsxRuntimeExports$1.jsxs(Box, { marginBottom: "3", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "1", justifyContent: "flex-start", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", whiteSpace: "nowrap", color: "text100", style: { maxWidth: "130px", textOverflow: "ellipsis", overflow: "hidden" }, children: tokenName }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] }), jsxRuntimeExports$1.jsx(Text, { color: "text50", whiteSpace: "nowrap", style: { display: "block", maxWidth: "150px", textOverflow: "ellipsis", overflow: "hidden" }, children: `${balance} ${symbol}` })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", color: "text100", children: `${fiatCurrency.sign}${balanceFiat}` }) }), jsxRuntimeExports$1.jsx(Text, { style: { color: getPercentageColor(priceChangePercentage) }, children: `${priceChangeSymbol}${priceChangePercentage.toFixed(2)}%` })] })] });
};
const CoinTile = ({ balance }) => {
  const { chains: chains2 } = useConfig();
  const { fiatCurrency } = useSettings();
  const isNativeToken = compareAddress(balance.contractAddress, AddressZero);
  const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
  const { data: dataCoinPrices = [], isPending: isPendingCoinPrice } = useCoinPrices([
    {
      chainId: balance.chainId,
      contractAddress: balance.contractAddress
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const { data: contractInfo, isPending: isPendingContractInfo } = useContractInfo(balance.chainId, balance.contractAddress);
  const isPending = isPendingCoinPrice || isPendingConversionRate || isPendingContractInfo;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", width: "full", height: "full", borderRadius: "md" });
  }
  if (isNativeToken) {
    const computedBalance2 = computeBalanceFiat({
      balance,
      prices: dataCoinPrices,
      conversionRate,
      decimals: nativeTokenInfo.decimals
    });
    const priceChangePercentage2 = getPercentagePriceChange(balance, dataCoinPrices);
    const formattedBalance2 = formatUnits$1(balance.balance, nativeTokenInfo.decimals);
    const balanceDisplayed2 = formatDisplay(formattedBalance2);
    return jsxRuntimeExports$1.jsx(CoinTileContent, { chainId: balance.chainId, logoUrl: nativeTokenInfo.logoURI, tokenName: nativeTokenInfo.name, balance: balanceDisplayed2, balanceFiat: computedBalance2, priceChangePercentage: priceChangePercentage2, symbol: nativeTokenInfo.symbol });
  }
  const decimals = (contractInfo == null ? void 0 : contractInfo.decimals) ?? 18;
  const computedBalance = computeBalanceFiat({
    balance,
    prices: dataCoinPrices,
    conversionRate,
    decimals
  });
  const priceChangePercentage = getPercentagePriceChange(balance, dataCoinPrices);
  const formattedBalance = formatUnits$1(balance.balance, decimals);
  const balanceDisplayed = formatDisplay(formattedBalance);
  const name2 = (contractInfo == null ? void 0 : contractInfo.name) || "Unknown";
  const symbol = (contractInfo == null ? void 0 : contractInfo.name) || "TOKEN";
  const url = contractInfo == null ? void 0 : contractInfo.logoURI;
  return jsxRuntimeExports$1.jsx(CoinTileContent, { chainId: balance.chainId, logoUrl: url, tokenName: name2, balance: balanceDisplayed, balanceFiat: computedBalance, priceChangePercentage, symbol });
};
const CollectibleTileImage = ({ imageUrl }) => {
  return jsxRuntimeExports$1.jsx(Card, { padding: "0", aspectRatio: "1/1", justifyContent: "center", alignItems: "center", overflow: "hidden", borderRadius: "sm", background: "backgroundSecondary", children: jsxRuntimeExports$1.jsx(Image$1, { style: { height: "100%" }, src: imageUrl }) });
};
const CollectibleTile = ({ balance }) => {
  var _a2;
  const { data: tokenMetadata } = useTokenMetadata(balance.chainId, balance.contractAddress, [balance.tokenID || ""]);
  const imageUrl = (_a2 = tokenMetadata == null ? void 0 : tokenMetadata[0]) == null ? void 0 : _a2.image;
  return jsxRuntimeExports$1.jsx(CollectibleTileImage, { imageUrl });
};
const SkeletonTiles = () => {
  return jsxRuntimeExports$1.jsx(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, children: Array(12).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Skeleton, { height: "full", width: "full", aspectRatio: "1/1" }) }, i)) });
};
const AssetSummary = () => {
  const { address } = useAccount();
  const { setNavigation } = useNavigation();
  const { displayedAssets } = useWalletSettings();
  const { hideUnlistedTokens, hideCollectibles, selectedNetworks } = useSettings();
  const { data: balances = [], isPending: isPendingBalances } = useBalancesAssetsSummary({
    accountAddress: address || "",
    chainIds: selectedNetworks,
    displayAssets: displayedAssets,
    hideCollectibles,
    verifiedOnly: hideUnlistedTokens
  });
  if (isPendingBalances) {
    return jsxRuntimeExports$1.jsx(SkeletonTiles, {});
  }
  const { nativeTokens, erc20Tokens, collectibles } = sortBalancesByType(balances);
  const onClickItem = (balance) => {
    if (balance.contractType === "ERC1155" || balance.contractType === "ERC721") {
      setNavigation && setNavigation({
        location: "collectible-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId,
          tokenId: balance.tokenID || ""
        }
      });
    } else if (balance.contractType === "ERC20") {
      setNavigation && setNavigation({
        location: "coin-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    } else {
      setNavigation && setNavigation({
        location: "coin-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, children: [nativeTokens.map((balance, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, aspectRatio: "1/1", onClick: () => onClickItem(balance), children: jsxRuntimeExports$1.jsx(CoinTile, { balance }) }, index2);
  }), erc20Tokens.map((balance, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, aspectRatio: "1/1", onClick: () => onClickItem(balance), children: jsxRuntimeExports$1.jsx(CoinTile, { balance }) }, index2);
  }), collectibles.map((balance, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, aspectRatio: "1/1", onClick: () => onClickItem(balance), children: jsxRuntimeExports$1.jsx(CollectibleTile, { balance }) }, index2);
  })] });
};
const Home = () => {
  return jsxRuntimeExports$1.jsx(Box, { paddingX: "4", paddingBottom: "5", gap: "4", flexDirection: "column", children: jsxRuntimeExports$1.jsx(AssetSummary, {}) });
};
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */
var qrcodegen;
((qrcodegen2) => {
  const _QrCode = class {
    constructor(version2, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version2;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version2 < _QrCode.MIN_VERSION || version2 > _QrCode.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7)
        throw new RangeError("Mask value out of range");
      this.size = version2 * 4 + 17;
      let row = [];
      for (let i = 0; i < this.size; i++)
        row.push(false);
      for (let i = 0; i < this.size; i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i = 0; i < 8; i++) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i);
        }
      }
      assert2(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    static encodeText(text2, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text2);
      return _QrCode.encodeSegments(segs, ecl);
    }
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return _QrCode.encodeSegments([seg], ecl);
    }
    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7)
        throw new RangeError("Invalid value");
      let version2;
      let dataUsedBits;
      for (version2 = minVersion; ; version2++) {
        const dataCapacityBits2 = _QrCode.getNumDataCodewords(version2, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version2);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version2 >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version2, newEcl) * 8)
          ecl = newEcl;
      }
      let bb2 = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb2);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb2);
        for (const b2 of seg.getData())
          bb2.push(b2);
      }
      assert2(bb2.length == dataUsedBits);
      const dataCapacityBits = _QrCode.getNumDataCodewords(version2, ecl) * 8;
      assert2(bb2.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb2.length), bb2);
      appendBits(0, (8 - bb2.length % 8) % 8, bb2);
      assert2(bb2.length % 8 == 0);
      for (let padByte = 236; bb2.length < dataCapacityBits; padByte ^= 236 ^ 17)
        appendBits(padByte, 8, bb2);
      let dataCodewords = [];
      while (dataCodewords.length * 8 < bb2.length)
        dataCodewords.push(0);
      bb2.forEach((b2, i) => dataCodewords[i >>> 3] |= b2 << 7 - (i & 7));
      return new _QrCode(version2, ecl, dataCodewords, mask);
    }
    getModule(x, y2) {
      return 0 <= x && x < this.size && 0 <= y2 && y2 < this.size && this.modules[y2][x];
    }
    getModules() {
      return this.modules;
    }
    drawFunctionPatterns() {
      for (let i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; i++) {
        for (let j2 = 0; j2 < numAlign; j2++) {
          if (!(i == 0 && j2 == 0 || i == 0 && j2 == numAlign - 1 || i == numAlign - 1 && j2 == 0))
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j2]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    drawFormatBits(mask) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask;
      let rem = data;
      for (let i = 0; i < 10; i++)
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert2(bits >>> 15 == 0);
      for (let i = 0; i <= 5; i++)
        this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; i++)
        this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; i++)
        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; i++)
        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    drawVersion() {
      if (this.version < 7)
        return;
      let rem = this.version;
      for (let i = 0; i < 12; i++)
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert2(bits >>> 18 == 0);
      for (let i = 0; i < 18; i++) {
        const color2 = getBit(bits, i);
        const a2 = this.size - 11 + i % 3;
        const b2 = Math.floor(i / 3);
        this.setFunctionModule(a2, b2, color2);
        this.setFunctionModule(b2, a2, color2);
      }
    }
    drawFinderPattern(x, y2) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist2 = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x + dx;
          const yy = y2 + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
            this.setFunctionModule(xx, yy, dist2 != 2 && dist2 != 4);
        }
      }
    }
    drawAlignmentPattern(x, y2) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x + dx, y2 + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    setFunctionModule(x, y2, isDark) {
      this.modules[y2][x] = isDark;
      this.isFunction[y2][x] = true;
    }
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != _QrCode.getNumDataCodewords(ver, ecl))
        throw new RangeError("Invalid argument");
      const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      let blocks = [];
      const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);
      for (let i = 0, k2 = 0; i < numBlocks; i++) {
        let dat = data.slice(k2, k2 + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k2 += dat.length;
        const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks)
          dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      let result = [];
      for (let i = 0; i < blocks[0].length; i++) {
        blocks.forEach((block, j2) => {
          if (i != shortBlockLen - blockEccLen || j2 >= numShortBlocks)
            result.push(block[i]);
        });
      }
      assert2(result.length == rawCodewords);
      return result;
    }
    drawCodewords(data) {
      if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let i = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6)
          right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j2 = 0; j2 < 2; j2++) {
            const x = right - j2;
            const upward = (right + 1 & 2) == 0;
            const y2 = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y2][x] && i < data.length * 8) {
              this.modules[y2][x] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert2(i == data.length * 8);
    }
    applyMask(mask) {
      if (mask < 0 || mask > 7)
        throw new RangeError("Mask value out of range");
      for (let y2 = 0; y2 < this.size; y2++) {
        for (let x = 0; x < this.size; x++) {
          let invert2;
          switch (mask) {
            case 0:
              invert2 = (x + y2) % 2 == 0;
              break;
            case 1:
              invert2 = y2 % 2 == 0;
              break;
            case 2:
              invert2 = x % 3 == 0;
              break;
            case 3:
              invert2 = (x + y2) % 3 == 0;
              break;
            case 4:
              invert2 = (Math.floor(x / 3) + Math.floor(y2 / 2)) % 2 == 0;
              break;
            case 5:
              invert2 = x * y2 % 2 + x * y2 % 3 == 0;
              break;
            case 6:
              invert2 = (x * y2 % 2 + x * y2 % 3) % 2 == 0;
              break;
            case 7:
              invert2 = ((x + y2) % 2 + x * y2 % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y2][x] && invert2)
            this.modules[y2][x] = !this.modules[y2][x];
        }
      }
    }
    getPenaltyScore() {
      let result = 0;
      for (let y2 = 0; y2 < this.size; y2++) {
        let runColor = false;
        let runX = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x = 0; x < this.size; x++) {
          if (this.modules[y2][x] == runColor) {
            runX++;
            if (runX == 5)
              result += _QrCode.PENALTY_N1;
            else if (runX > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y2][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let x = 0; x < this.size; x++) {
        let runColor = false;
        let runY = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y2 = 0; y2 < this.size; y2++) {
          if (this.modules[y2][x] == runColor) {
            runY++;
            if (runY == 5)
              result += _QrCode.PENALTY_N1;
            else if (runY > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y2][x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let y2 = 0; y2 < this.size - 1; y2++) {
        for (let x = 0; x < this.size - 1; x++) {
          const color2 = this.modules[y2][x];
          if (color2 == this.modules[y2][x + 1] && color2 == this.modules[y2 + 1][x] && color2 == this.modules[y2 + 1][x + 1])
            result += _QrCode.PENALTY_N2;
        }
      }
      let dark2 = 0;
      for (const row of this.modules)
        dark2 = row.reduce((sum, color2) => sum + (color2 ? 1 : 0), dark2);
      const total = this.size * this.size;
      const k2 = Math.ceil(Math.abs(dark2 * 20 - total * 10) / total) - 1;
      assert2(0 <= k2 && k2 <= 9);
      result += k2 * _QrCode.PENALTY_N4;
      assert2(0 <= result && result <= 2568888);
      return result;
    }
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        let result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step)
          result.splice(1, 0, pos);
        return result;
      }
    }
    static getNumRawDataModules(ver) {
      if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7)
          result -= 36;
      }
      assert2(208 <= result && result <= 29648);
      return result;
    }
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255)
        throw new RangeError("Degree out of range");
      let result = [];
      for (let i = 0; i < degree - 1; i++)
        result.push(0);
      result.push(1);
      let root2 = 1;
      for (let i = 0; i < degree; i++) {
        for (let j2 = 0; j2 < result.length; j2++) {
          result[j2] = _QrCode.reedSolomonMultiply(result[j2], root2);
          if (j2 + 1 < result.length)
            result[j2] ^= result[j2 + 1];
        }
        root2 = _QrCode.reedSolomonMultiply(root2, 2);
      }
      return result;
    }
    static reedSolomonComputeRemainder(data, divisor) {
      let result = divisor.map((_) => 0);
      for (const b2 of data) {
        const factor = b2 ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i) => result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    static reedSolomonMultiply(x, y2) {
      if (x >>> 8 != 0 || y2 >>> 8 != 0)
        throw new RangeError("Byte out of range");
      let z = 0;
      for (let i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y2 >>> i & 1) * x;
      }
      assert2(z >>> 8 == 0);
      return z;
    }
    finderPenaltyCountPatterns(runHistory) {
      const n2 = runHistory[1];
      assert2(n2 <= this.size * 3);
      const core2 = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
      return (core2 && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core2 && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
    }
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0)
        currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  };
  let QrCode = _QrCode;
  QrCode.MIN_VERSION = 1;
  QrCode.MAX_VERSION = 40;
  QrCode.PENALTY_N1 = 3;
  QrCode.PENALTY_N2 = 3;
  QrCode.PENALTY_N3 = 40;
  QrCode.PENALTY_N4 = 10;
  QrCode.ECC_CODEWORDS_PER_BLOCK = [
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  ];
  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  ];
  qrcodegen2.QrCode = QrCode;
  function appendBits(val, len, bb2) {
    if (len < 0 || len > 31 || val >>> len != 0)
      throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--)
      bb2.push(val >>> i & 1);
  }
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  function assert2(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  const _QrSegment = class {
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0)
        throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    static makeBytes(data) {
      let bb2 = [];
      for (const b2 of data)
        appendBits(b2, 8, bb2);
      return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb2);
    }
    static makeNumeric(digits) {
      if (!_QrSegment.isNumeric(digits))
        throw new RangeError("String contains non-numeric characters");
      let bb2 = [];
      for (let i = 0; i < digits.length; ) {
        const n2 = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substr(i, n2), 10), n2 * 3 + 1, bb2);
        i += n2;
      }
      return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb2);
    }
    static makeAlphanumeric(text2) {
      if (!_QrSegment.isAlphanumeric(text2))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let bb2 = [];
      let i;
      for (i = 0; i + 2 <= text2.length; i += 2) {
        let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)) * 45;
        temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i + 1));
        appendBits(temp, 11, bb2);
      }
      if (i < text2.length)
        appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)), 6, bb2);
      return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text2.length, bb2);
    }
    static makeSegments(text2) {
      if (text2 == "")
        return [];
      else if (_QrSegment.isNumeric(text2))
        return [_QrSegment.makeNumeric(text2)];
      else if (_QrSegment.isAlphanumeric(text2))
        return [_QrSegment.makeAlphanumeric(text2)];
      else
        return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text2))];
    }
    static makeEci(assignVal) {
      let bb2 = [];
      if (assignVal < 0)
        throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7)
        appendBits(assignVal, 8, bb2);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb2);
        appendBits(assignVal, 14, bb2);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb2);
        appendBits(assignVal, 21, bb2);
      } else
        throw new RangeError("ECI assignment value out of range");
      return new _QrSegment(_QrSegment.Mode.ECI, 0, bb2);
    }
    static isNumeric(text2) {
      return _QrSegment.NUMERIC_REGEX.test(text2);
    }
    static isAlphanumeric(text2) {
      return _QrSegment.ALPHANUMERIC_REGEX.test(text2);
    }
    getData() {
      return this.bitData.slice();
    }
    static getTotalBits(segs, version2) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version2);
        if (seg.numChars >= 1 << ccbits)
          return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      let result = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%")
          result.push(str.charCodeAt(i));
        else {
          result.push(parseInt(str.substr(i + 1, 2), 16));
          i += 2;
        }
      }
      return result;
    }
  };
  let QrSegment = _QrSegment;
  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  qrcodegen2.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrCode2) => {
    const _Ecc = class {
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    };
    let Ecc = _Ecc;
    Ecc.LOW = new _Ecc(0, 1);
    Ecc.MEDIUM = new _Ecc(1, 0);
    Ecc.QUARTILE = new _Ecc(2, 3);
    Ecc.HIGH = new _Ecc(3, 2);
    QrCode2.Ecc = Ecc;
  })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrSegment2) => {
    const _Mode = class {
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    };
    let Mode = _Mode;
    Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
    Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
    Mode.BYTE = new _Mode(4, [8, 16, 16]);
    Mode.KANJI = new _Mode(8, [8, 10, 12]);
    Mode.ECI = new _Mode(7, [0, 0, 0]);
    QrSegment2.Mode = Mode;
  })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var MARGIN_SIZE = 4;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
  const ops = [];
  modules.forEach(function(row, y2) {
    let start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push(`M${start + margin} ${y2 + margin}h${x - start}v1H${start + margin}z`);
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x + margin},${y2 + margin} h1v1H${x + margin}z`);
        } else {
          ops.push(`M${start + margin},${y2 + margin} h${x + 1 - start}v1H${start + margin}z`);
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y2) => {
    if (y2 < excavation.y || y2 >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x) => {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size2, includeMargin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size2 * DEFAULT_IMG_SCALE);
  const scale2 = numCells / size2;
  const w2 = (imageSettings.width || defaultSize) * scale2;
  const h2 = (imageSettings.height || defaultSize) * scale2;
  const x = imageSettings.x == null ? cells.length / 2 - w2 / 2 : imageSettings.x * scale2;
  const y2 = imageSettings.y == null ? cells.length / 2 - h2 / 2 : imageSettings.y * scale2;
  let excavation = null;
  if (imageSettings.excavate) {
    let floorX = Math.floor(x);
    let floorY = Math.floor(y2);
    let ceilW = Math.ceil(w2 + x - floorX);
    let ceilH = Math.ceil(h2 + y2 - floorY);
    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };
  }
  return { x, y: y2, h: h2, w: w2, excavation };
}
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e2) {
    return false;
  }
  return true;
}();
function QRCodeCanvas(props) {
  const _a2 = props, {
    value,
    size: size2 = DEFAULT_SIZE,
    level = DEFAULT_LEVEL,
    bgColor = DEFAULT_BGCOLOR,
    fgColor = DEFAULT_FGCOLOR,
    includeMargin = DEFAULT_INCLUDEMARGIN,
    style,
    imageSettings
  } = _a2, otherProps = __objRest(_a2, [
    "value",
    "size",
    "level",
    "bgColor",
    "fgColor",
    "includeMargin",
    "style",
    "imageSettings"
  ]);
  const imgSrc = imageSettings == null ? void 0 : imageSettings.src;
  const _canvas = reactExports.useRef(null);
  const _image = reactExports.useRef(null);
  const [isImgLoaded, setIsImageLoaded] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (_canvas.current != null) {
      const canvas = _canvas.current;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return;
      }
      let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
      const margin = includeMargin ? MARGIN_SIZE : 0;
      const numCells = cells.length + margin * 2;
      const calculatedImageSettings = getImageSettings(cells, size2, includeMargin, imageSettings);
      const image = _image.current;
      const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
      if (haveImageToRender) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }
      }
      const pixelRatio = window.devicePixelRatio || 1;
      canvas.height = canvas.width = size2 * pixelRatio;
      const scale2 = size2 / numCells * pixelRatio;
      ctx.scale(scale2, scale2);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, numCells, numCells);
      ctx.fillStyle = fgColor;
      if (SUPPORTS_PATH2D) {
        ctx.fill(new Path2D(generatePath(cells, margin)));
      } else {
        cells.forEach(function(row, rdx) {
          row.forEach(function(cell, cdx) {
            if (cell) {
              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
            }
          });
        });
      }
      if (haveImageToRender) {
        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
      }
    }
  });
  reactExports.useEffect(() => {
    setIsImageLoaded(false);
  }, [imgSrc]);
  const canvasStyle = __spreadValues({ height: size2, width: size2 }, style);
  let img2 = null;
  if (imgSrc != null) {
    img2 = /* @__PURE__ */ React.createElement("img", {
      src: imgSrc,
      key: imgSrc,
      style: { display: "none" },
      onLoad: () => {
        setIsImageLoaded(true);
      },
      ref: _image
    });
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("canvas", __spreadValues({
    style: canvasStyle,
    height: size2,
    width: size2,
    ref: _canvas
  }, otherProps)), img2);
}
function QRCodeSVG(props) {
  const _a2 = props, {
    value,
    size: size2 = DEFAULT_SIZE,
    level = DEFAULT_LEVEL,
    bgColor = DEFAULT_BGCOLOR,
    fgColor = DEFAULT_FGCOLOR,
    includeMargin = DEFAULT_INCLUDEMARGIN,
    imageSettings
  } = _a2, otherProps = __objRest(_a2, [
    "value",
    "size",
    "level",
    "bgColor",
    "fgColor",
    "includeMargin",
    "imageSettings"
  ]);
  let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const calculatedImageSettings = getImageSettings(cells, size2, includeMargin, imageSettings);
  let image = null;
  if (imageSettings != null && calculatedImageSettings != null) {
    if (calculatedImageSettings.excavation != null) {
      cells = excavateModules(cells, calculatedImageSettings.excavation);
    }
    image = /* @__PURE__ */ React.createElement("image", {
      xlinkHref: imageSettings.src,
      height: calculatedImageSettings.h,
      width: calculatedImageSettings.w,
      x: calculatedImageSettings.x + margin,
      y: calculatedImageSettings.y + margin,
      preserveAspectRatio: "none"
    });
  }
  const fgPath = generatePath(cells, margin);
  return /* @__PURE__ */ React.createElement("svg", __spreadValues({
    height: size2,
    width: size2,
    viewBox: `0 0 ${numCells} ${numCells}`
  }, otherProps), /* @__PURE__ */ React.createElement("path", {
    fill: bgColor,
    d: `M0,0 h${numCells}v${numCells}H0z`,
    shapeRendering: "crispEdges"
  }), /* @__PURE__ */ React.createElement("path", {
    fill: fgColor,
    d: fgPath,
    shapeRendering: "crispEdges"
  }), image);
}
var QRCode = (props) => {
  const _a2 = props, { renderAs } = _a2, otherProps = __objRest(_a2, ["renderAs"]);
  if (renderAs === "svg") {
    return /* @__PURE__ */ React.createElement(QRCodeSVG, __spreadValues({}, otherProps));
  }
  return /* @__PURE__ */ React.createElement(QRCodeCanvas, __spreadValues({}, otherProps));
};
var Component = {};
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range2) {
        selection.addRange(range2);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$1(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text2, options) {
  var debug2, message, reselectPrevious, range2, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug2 = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range2 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text2;
    mark.ariaHidden = "true";
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug2 && console.warn("unable to use e.clipboardData");
          debug2 && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text2);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text2);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range2.selectNodeContents(mark);
    selection.addRange(range2);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug2 && console.error("unable to copy using execCommand: ", err);
    debug2 && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text2);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug2 && console.error("unable to copy using clipboardData: ", err2);
      debug2 && console.error("falling back to prompt");
      message = format$1("message" in options ? options.message : defaultMessage);
      window.prompt(message, text2);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range2);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy;
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
Object.defineProperty(Component, "__esModule", {
  value: true
});
Component.CopyToClipboard = void 0;
var _react = _interopRequireDefault(reactExports);
var _copyToClipboard = _interopRequireDefault(copyToClipboard);
var _excluded = ["text", "onCopy", "options", "children"];
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CopyToClipboard$1 = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(CopyToClipboard2, _React$PureComponent);
  var _super = _createSuper(CopyToClipboard2);
  function CopyToClipboard2() {
    var _this;
    _classCallCheck(this, CopyToClipboard2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
      var _this$props = _this.props, text2 = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
      var elem = _react["default"].Children.only(children);
      var result = (0, _copyToClipboard["default"])(text2, options);
      if (onCopy) {
        onCopy(text2, result);
      }
      if (elem && elem.props && typeof elem.props.onClick === "function") {
        elem.props.onClick(event);
      }
    });
    return _this;
  }
  _createClass(CopyToClipboard2, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props;
      _this$props2.text;
      _this$props2.onCopy;
      _this$props2.options;
      var children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
      var elem = _react["default"].Children.only(children);
      return /* @__PURE__ */ _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
        onClick: this.onClick
      }));
    }
  }]);
  return CopyToClipboard2;
}(_react["default"].PureComponent);
Component.CopyToClipboard = CopyToClipboard$1;
_defineProperty(CopyToClipboard$1, "defaultProps", {
  onCopy: void 0,
  options: void 0
});
var _require = Component, CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib = CopyToClipboard;
const Receive = () => {
  const { address, chain } = useAccount();
  const { chains: chains2 } = useConfig();
  const [isCopied, setCopied] = reactExports.useState(false);
  const nativeTokenInfo = getNativeTokenInfoByChainId((chain == null ? void 0 : chain.id) || 1, chains2);
  reactExports.useEffect(() => {
    if (isCopied) {
      setTimeout(() => {
        setCopied(false);
      }, 4e3);
    }
  }, [isCopied]);
  const onClickCopy = () => {
    setCopied(true);
  };
  const onClickShare = () => {
    if (typeof window !== "undefined") {
      window.open(`https://twitter.com/intent/tweet?text=Here%20is%20my%20address%20${address}`);
    }
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "4", children: [jsxRuntimeExports$1.jsx(Box, { marginTop: "1", width: "fit", background: "white", borderRadius: "md", alignItems: "center", justifyContent: "center", padding: "4", children: jsxRuntimeExports$1.jsx(QRCode, { value: address || "", size: 200, bgColor: "white", fgColor: "black", "data-id": "receiveQR" }) }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", textAlign: "center", lineHeight: "inherit", style: { fontWeight: "700" }, children: "My Wallet" }), jsxRuntimeExports$1.jsx(Image$1, { width: "5", src: nativeTokenInfo.logoURI, alt: "icon" })] }), jsxRuntimeExports$1.jsx(Box, { marginTop: "2", style: { maxWidth: "180px", textAlign: "center" }, children: jsxRuntimeExports$1.jsx(Text, { textAlign: "center", color: "text50", style: {
    fontSize: "14px",
    maxWidth: "180px",
    overflowWrap: "anywhere"
  }, children: address }) })] }), jsxRuntimeExports$1.jsxs(Box, { gap: "3", children: [jsxRuntimeExports$1.jsx(lib.CopyToClipboard, { text: address || "", children: jsxRuntimeExports$1.jsx(Button, { onClick: onClickCopy, leftIcon: SvgCopyIcon, label: isCopied ? "Copied!" : "Copy" }) }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickShare, leftIcon: SvgShareIcon, label: "Share" })] }), jsxRuntimeExports$1.jsx(Box, { justifyContent: "center", alignItems: "center", style: { maxWidth: "260px", textAlign: "center" }, children: jsxRuntimeExports$1.jsx(Text, { color: "text100", variant: "small", style: {
    maxWidth: "260px",
    overflowWrap: "anywhere"
  }, children: `This is a ${nativeTokenInfo.name} address. Please only send assets on the ${nativeTokenInfo.name} network.` }) })] }) });
};
const SendItemInfo = ({ imageUrl, name: name2, decimals, balance, symbol, fiatValue, chainId, showSquareImage }) => {
  const { fiatCurrency } = useSettings();
  const formattedBalance = formatUnits$1(balance, decimals);
  const balanceDisplayed = formatDisplay(formattedBalance);
  return jsxRuntimeExports$1.jsxs(Box, { alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { justifyContent: "space-between", alignItems: "center", gap: "2", children: [showSquareImage ? jsxRuntimeExports$1.jsx(Box, { style: { width: "40px" }, children: jsxRuntimeExports$1.jsx(CollectibleTileImage, { imageUrl }) }) : jsxRuntimeExports$1.jsx(TokenImage, { src: imageUrl, size: "xl" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", gap: "1", children: [jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text100", children: name2 }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] }), jsxRuntimeExports$1.jsxs(Text, { color: "text50", variant: "normal", children: [" ", `${balanceDisplayed} ${symbol} available`] })] })] }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", alignItems: "flex-end", justifyContent: "flex-end", children: fiatValue && jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", children: `${fiatCurrency.sign}${fiatValue}` }) })] });
};
const SendCoin = ({ chainId, contractAddress }) => {
  var _a2, _b2, _c2, _d2, _e2;
  const { setNavigation } = useNavigation();
  const { analytics } = useAnalyticsContext();
  const { chains: chains2 } = useConfig();
  const connectedChainId = useChainId();
  const { address: accountAddress = "", connector } = useAccount();
  const isConnectorSequenceBased = !!((_a2 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a2.isSequenceBased);
  const isCorrectChainId = connectedChainId === chainId;
  const showSwitchNetwork = !isCorrectChainId && !isConnectorSequenceBased;
  const { switchChainAsync } = useSwitchChain();
  const amountInputRef = reactExports.useRef(null);
  const { fiatCurrency } = useSettings();
  const [amount, setAmount] = reactExports.useState("0");
  const [toAddress, setToAddress] = reactExports.useState("");
  const { sendTransaction: sendTransaction2 } = useSendTransaction();
  const [isSendTxnPending, setIsSendTxnPending] = reactExports.useState(false);
  const { data: balances = [], isPending: isPendingBalances } = useBalances({
    chainIds: [chainId],
    accountAddress,
    contractAddress
  });
  const nativeTokenInfo = getNativeTokenInfoByChainId(chainId, chains2);
  const tokenBalance = balances.find((b2) => b2.contractAddress === contractAddress);
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices([
    {
      chainId,
      contractAddress
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingBalances || isPendingCoinPrices || isPendingConversionRate;
  if (isPending) {
    return null;
  }
  const isNativeCoin = compareAddress(contractAddress, AddressZero);
  const decimals = isNativeCoin ? nativeTokenInfo.decimals : ((_b2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _b2.decimals) || 18;
  const name2 = isNativeCoin ? nativeTokenInfo.name : ((_c2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _c2.name) || "";
  const imageUrl = isNativeCoin ? nativeTokenInfo.logoURI : (_d2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _d2.logoURI;
  const symbol = isNativeCoin ? nativeTokenInfo.symbol : ((_e2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _e2.symbol) || "";
  const amountToSendFormatted = amount === "" ? "0" : amount;
  const amountRaw = parseUnits$1(amountToSendFormatted, decimals);
  const amountToSendFiat = computeBalanceFiat({
    balance: {
      ...tokenBalance,
      balance: amountRaw.toString()
    },
    prices: coinPrices,
    conversionRate,
    decimals
  });
  const insufficientFunds = amountRaw.gt((tokenBalance == null ? void 0 : tokenBalance.balance) || "0");
  const isNonZeroAmount = amountRaw.gt(0);
  const handleChangeAmount = (ev) => {
    const { value } = ev.target;
    const formattedValue = limitDecimals(value, decimals);
    setAmount(formattedValue);
  };
  const handleMax = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const maxAmount = formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals).toString();
    setAmount(maxAmount);
  };
  const handlePaste = async () => {
    const result = await navigator.clipboard.readText();
    setToAddress(result);
  };
  const handleToAddressClear = () => {
    setToAddress("");
  };
  const executeTransaction = async (e2) => {
    var _a3, _b3;
    if (!isCorrectChainId && isConnectorSequenceBased) {
      await switchChainAsync({ chainId });
    }
    e2.preventDefault();
    const sendAmount = parseUnits$1(amountToSendFormatted, decimals);
    if (isNativeCoin) {
      analytics == null ? void 0 : analytics.track({
        event: "SEND_TRANSACTION_REQUEST",
        props: {
          walletClient: ((_a3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a3.id) || "unknown",
          source: "sequence-kit/wallet"
        }
      });
      setIsSendTxnPending(true);
      sendTransaction2({
        to: toAddress,
        value: BigInt(sendAmount.toString()),
        gas: null
      }, {
        onSettled: (result) => {
          if (result) {
            setNavigation({
              location: "home"
            });
          }
          setIsSendTxnPending(false);
        }
      });
    } else {
      analytics == null ? void 0 : analytics.track({
        event: "SEND_TRANSACTION_REQUEST",
        props: {
          walletClient: ((_b3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _b3.id) || "unknown",
          source: "sequence-kit/wallet"
        }
      });
      setIsSendTxnPending(true);
      sendTransaction2({
        to: tokenBalance == null ? void 0 : tokenBalance.contractAddress,
        data: new Interface(ERC_20_ABI).encodeFunctionData("transfer", [
          toAddress,
          sendAmount.toHexString()
        ]),
        gas: null
      }, {
        onSettled: (result) => {
          if (result) {
            setNavigation({
              location: "home"
            });
          }
          setIsSendTxnPending(false);
        }
      });
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", style: {
    marginTop: HEADER_HEIGHT
  }, gap: "2", flexDirection: "column", as: "form", onSubmit: executeTransaction, pointerEvents: isSendTxnPending ? "none" : "auto", children: [jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(SendItemInfo, { imageUrl, decimals, name: name2, symbol, balance: (tokenBalance == null ? void 0 : tokenBalance.balance) || "0", fiatValue: computeBalanceFiat({
    balance: tokenBalance,
    prices: coinPrices,
    conversionRate,
    decimals
  }), chainId }), jsxRuntimeExports$1.jsx(NumericInput, { ref: amountInputRef, style: { fontSize: vars.fontSizes.xlarge, fontWeight: vars.fontWeights.bold }, name: "amount", value: amount, onChange: handleChangeAmount, controls: jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", whiteSpace: "nowrap", children: `~${fiatCurrency.sign}${amountToSendFiat}` }), jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Max", onClick: handleMax, "data-id": "maxCoin", flexShrink: "0" }), jsxRuntimeExports$1.jsx(Text, { fontSize: "xlarge", fontWeight: "bold", color: "text100", children: symbol })] }) }), insufficientFunds && jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "negative", marginTop: "2", children: "Insufficient Funds" })] }), jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", color: "text50", children: "To" }), isEthAddress(toAddress) ? jsxRuntimeExports$1.jsxs(Card, { clickable: true, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", onClick: handleToAddressClear, style: { height: "52px" }, children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: toAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle(toAddress.substring(2), 8)}` })] }), jsxRuntimeExports$1.jsx(SvgCloseIcon, { size: "xs" })] }) : jsxRuntimeExports$1.jsx(TextInput, { value: toAddress, onChange: (ev) => setToAddress(ev.target.value), placeholder: `${nativeTokenInfo.name} Address (0x...)`, name: "to-address", "data-1p-ignore": true, controls: jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Paste", onClick: handlePaste, "data-id": "to-address", flexShrink: "0", leftIcon: SvgCopyIcon }) })] }), showSwitchNetwork && jsxRuntimeExports$1.jsxs(Box, { marginTop: "3", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "negative", marginBottom: "2", children: "The wallet is connected to the wrong network. Please switch network before proceeding" }), jsxRuntimeExports$1.jsx(Button, { marginTop: "2", width: "full", variant: "primary", type: "button", label: "Switch Network", onClick: async () => await switchChainAsync({ chainId }), disabled: isCorrectChainId, style: { height: "52px", borderRadius: vars.radii.md } })] }), jsxRuntimeExports$1.jsx(Box, { style: { height: "52px" }, alignItems: "center", justifyContent: "center", children: isSendTxnPending ? jsxRuntimeExports$1.jsx(Spinner, {}) : jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "3", width: "full", variant: "primary", type: "submit", disabled: !isNonZeroAmount || !isEthAddress(toAddress) || insufficientFunds || !isCorrectChainId && !isConnectorSequenceBased, label: "Send", rightIcon: SvgChevronRightIcon, style: { height: "52px", borderRadius: vars.radii.md } }) })] });
};
const SendCollectible = ({ chainId, contractAddress, tokenId }) => {
  var _a2, _b2, _c2, _d2, _e2;
  const { setNavigation } = useNavigation();
  const { analytics } = useAnalyticsContext();
  const { chains: chains2 } = useConfig();
  const connectedChainId = useChainId();
  const { address: accountAddress = "", connector } = useAccount();
  const isConnectorSequenceBased = !!((_a2 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a2.isSequenceBased);
  const isCorrectChainId = connectedChainId === chainId;
  const showSwitchNetwork = !isCorrectChainId && !isConnectorSequenceBased;
  const { switchChain: switchChain2 } = useSwitchChain();
  const amountInputRef = reactExports.useRef(null);
  const [amount, setAmount] = reactExports.useState("0");
  const [toAddress, setToAddress] = reactExports.useState("");
  const [showAmountControls, setShowAmountControls] = reactExports.useState(false);
  const { sendTransaction: sendTransaction2 } = useSendTransaction();
  const [isSendTxnPending, setIsSendTxnPending] = reactExports.useState(false);
  const { data: tokenBalance, isPending: isPendingBalances } = useCollectibleBalance({
    accountAddress,
    chainId,
    contractAddress,
    tokenId,
    verifiedOnly: false
  });
  const { contractType } = tokenBalance;
  reactExports.useEffect(() => {
    if (tokenBalance) {
      if (contractType === "ERC721") {
        setAmount("1");
        setShowAmountControls(false);
      } else if (contractType === "ERC1155") {
        if (Number(formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals)) >= 1) {
          setAmount("1");
        }
        setShowAmountControls(true);
      }
    }
  }, [tokenBalance]);
  const nativeTokenInfo = getNativeTokenInfoByChainId(chainId, chains2);
  const isPending = isPendingBalances;
  if (isPending) {
    return null;
  }
  const decimals = ((_b2 = tokenBalance == null ? void 0 : tokenBalance.tokenMetadata) == null ? void 0 : _b2.decimals) || 0;
  const name2 = ((_c2 = tokenBalance == null ? void 0 : tokenBalance.tokenMetadata) == null ? void 0 : _c2.name) || "Unknown";
  const imageUrl = ((_d2 = tokenBalance == null ? void 0 : tokenBalance.tokenMetadata) == null ? void 0 : _d2.image) || ((_e2 = tokenBalance == null ? void 0 : tokenBalance.contractInfo) == null ? void 0 : _e2.logoURI) || "";
  const amountToSendFormatted = amount === "" ? "0" : amount;
  const amountRaw = parseUnits$1(amountToSendFormatted, decimals);
  const insufficientFunds = amountRaw.gt((tokenBalance == null ? void 0 : tokenBalance.balance) || "0");
  const isNonZeroAmount = amountRaw.gt(0);
  const handleChangeAmount = (ev) => {
    const { value } = ev.target;
    const formattedValue = limitDecimals(value, decimals);
    setAmount(formattedValue);
  };
  const handleSubtractOne = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const decrementedAmount = Number(amount) - 1;
    const newAmount = Math.max(decrementedAmount, 0).toString();
    setAmount(newAmount);
  };
  const handleAddOne = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const incrementedAmount = Number(amount) + 1;
    const maxAmount2 = Number(formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals));
    const newAmount = Math.min(incrementedAmount, maxAmount2).toString();
    setAmount(newAmount);
  };
  const handleMax = () => {
    var _a3;
    (_a3 = amountInputRef.current) == null ? void 0 : _a3.focus();
    const maxAmount2 = formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals).toString();
    setAmount(maxAmount2);
  };
  const handlePaste = async () => {
    const result = await navigator.clipboard.readText();
    setToAddress(result);
  };
  const handleToAddressClear = () => {
    setToAddress("");
  };
  const executeTransaction = async (e2) => {
    var _a3, _b3;
    e2.preventDefault();
    if (!isCorrectChainId && isConnectorSequenceBased) {
      switchChain2({ chainId });
    }
    const sendAmount = parseUnits$1(amountToSendFormatted, decimals);
    switch (contractType) {
      case "ERC721":
        analytics == null ? void 0 : analytics.track({
          event: "SEND_TRANSACTION_REQUEST",
          props: {
            walletClient: ((_a3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _a3.id) || "unknown",
            source: "sequence-kit/wallet"
          }
        });
        setIsSendTxnPending(true);
        sendTransaction2({
          to: tokenBalance.contractAddress,
          data: new Interface(ERC_721_ABI).encodeFunctionData("safeTransferFrom", [
            accountAddress,
            toAddress,
            tokenId
          ]),
          gas: null
        }, {
          onSettled: (result) => {
            if (result) {
              setNavigation({
                location: "home"
              });
            }
            setIsSendTxnPending(false);
          }
        });
        break;
      case "ERC1155":
      default:
        analytics == null ? void 0 : analytics.track({
          event: "SEND_TRANSACTION_REQUEST",
          props: {
            walletClient: ((_b3 = connector == null ? void 0 : connector._wallet) == null ? void 0 : _b3.id) || "unknown",
            source: "sequence-kit/wallet"
          }
        });
        setIsSendTxnPending(true);
        sendTransaction2({
          to: tokenBalance.contractAddress,
          data: new Interface(ERC_1155_ABI).encodeFunctionData("safeBatchTransferFrom", [
            accountAddress,
            toAddress,
            [tokenId],
            [sendAmount.toHexString()],
            []
          ]),
          gas: null
        }, {
          onSettled: (result) => {
            if (result) {
              setNavigation({
                location: "home"
              });
            }
            setIsSendTxnPending(false);
          }
        });
    }
  };
  const maxAmount = formatUnits$1((tokenBalance == null ? void 0 : tokenBalance.balance) || 0, decimals).toString();
  const isMinimum = Number(amount) === 0;
  const isMaximum = Number(amount) >= Number(maxAmount);
  return jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", style: {
    marginTop: HEADER_HEIGHT
  }, gap: "2", flexDirection: "column", as: "form", onSubmit: executeTransaction, pointerEvents: isSendTxnPending ? "none" : "auto", children: [jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(SendItemInfo, { imageUrl, showSquareImage: true, decimals, name: name2, symbol: "", balance: (tokenBalance == null ? void 0 : tokenBalance.balance) || "0", chainId }), jsxRuntimeExports$1.jsx(NumericInput, { ref: amountInputRef, style: { fontSize: vars.fontSizes.xlarge, fontWeight: vars.fontWeights.bold }, name: "amount", value: amount, onChange: handleChangeAmount, disabled: !showAmountControls, controls: jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: showAmountControls && jsxRuntimeExports$1.jsxs(Box, { gap: "2", children: [jsxRuntimeExports$1.jsx(Button, { disabled: isMinimum, size: "xs", onClick: handleSubtractOne, leftIcon: SvgSubtractIcon }), jsxRuntimeExports$1.jsx(Button, { disabled: isMaximum, size: "xs", onClick: handleAddOne, leftIcon: SvgAddIcon }), jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Max", onClick: handleMax, "data-id": "maxCoin", flexShrink: "0" })] }) }) }), insufficientFunds && jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "negative", marginTop: "2", children: "Insufficient Balance" })] }), jsxRuntimeExports$1.jsxs(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", color: "text50", children: "To" }), isEthAddress(toAddress) ? jsxRuntimeExports$1.jsxs(Card, { clickable: true, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", onClick: handleToAddressClear, style: { height: "52px" }, children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "2", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: toAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: `0x${truncateAtMiddle(toAddress.substring(2), 8)}` })] }), jsxRuntimeExports$1.jsx(SvgCloseIcon, { size: "xs" })] }) : jsxRuntimeExports$1.jsx(TextInput, { value: toAddress, onChange: (ev) => setToAddress(ev.target.value), placeholder: `${nativeTokenInfo.name} Address (0x...)`, name: "to-address", "data-1p-ignore": true, controls: jsxRuntimeExports$1.jsx(Button, { size: "xs", shape: "square", label: "Paste", onClick: handlePaste, "data-id": "to-address", flexShrink: "0", leftIcon: SvgCopyIcon }) })] }), showSwitchNetwork && jsxRuntimeExports$1.jsxs(Box, { marginTop: "3", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "negative", marginBottom: "2", children: "The wallet is connected to the wrong network. Please switch network before proceeding" }), jsxRuntimeExports$1.jsx(Button, { marginTop: "2", width: "full", variant: "primary", type: "button", label: "Switch Network", onClick: () => switchChain2({ chainId }), disabled: isCorrectChainId, style: { height: "52px", borderRadius: vars.radii.md } })] }), jsxRuntimeExports$1.jsx(Box, { style: { height: "52px" }, alignItems: "center", justifyContent: "center", children: isSendTxnPending ? jsxRuntimeExports$1.jsx(Spinner, {}) : jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "3", width: "full", variant: "primary", type: "submit", disabled: !isNonZeroAmount || !isEthAddress(toAddress) || insufficientFunds || !isCorrectChainId && !isConnectorSequenceBased, label: "Send", rightIcon: SvgChevronRightIcon, style: { height: "52px", borderRadius: vars.radii.md } }) })] });
};
var dayjs_min = { exports: {} };
(function(module2, exports) {
  !function(t2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v3 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t3(e3, n3) {
      if (e3.date() < n3.date())
        return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c2), s3 = n3 - i2 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p2]);
    }, w2 = function t3(e3, n3, r3) {
      var i2;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i2 = s3), n3 && (D2[s3] = n3, i2 = s3);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i2 = a3;
      }
      return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;
    }, O2 = function(t3, e3) {
      if (S2(t3))
        return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _(n3);
    }, b2 = v3;
    b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
      return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _ = function() {
      function M3(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($);
            if (r3) {
              var i2 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return b2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n3 = O2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return O2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < O2(t3);
      }, m3.$g = function(t3, e3, n3) {
        return b2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
          var i2 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i2 : i2.endOf(a2);
        }, $2 = function(t4, e4) {
          return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return $2(v5 + "Hours", 0);
          case u2:
            return $2(v5 + "Minutes", 1);
          case s2:
            return $2(v5 + "Seconds", 2);
          case i:
            return $2(v5 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[b2.p(t3)]();
      }, m3.add = function(r3, f3) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $2 = b2.p(f3), y3 = function(t3) {
          var e3 = O2(l3);
          return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($2 === c2)
          return this.set(c2, this.$M + r3);
        if ($2 === h2)
          return this.set(h2, this.$y + r3);
        if ($2 === a2)
          return y3(1);
        if ($2 === o2)
          return y3(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
        return b2.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i3, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s4);
        }, d3 = function(t4) {
          return b2.s(s3 % 12 || 12, t4, "0");
        }, $2 = f3 || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t4, r4) {
          return r4 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $2(s3, u3, true);
              case "A":
                return $2(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $2, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v5 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
          return b2.m(y3, m4);
        };
        switch (M4) {
          case h2:
            $2 = D3() / 12;
            break;
          case c2:
            $2 = D3();
            break;
          case f2:
            $2 = D3() / 3;
            break;
          case o2:
            $2 = (g3 - v5) / 6048e5;
            break;
          case a2:
            $2 = (g3 - v5) / 864e5;
            break;
          case u2:
            $2 = g3 / n2;
            break;
          case s2:
            $2 = g3 / e2;
            break;
          case i:
            $2 = g3 / t2;
            break;
          default:
            $2 = g3;
        }
        return l3 ? $2 : b2.a($2);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = w2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return b2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _.prototype;
    return O2.prototype = k2, [["$ms", r2], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
      k2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _, O2), t3.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
      return O2(1e3 * t3);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs$1(dayjs_minExports);
const TransactionHistoryItem = ({ transaction: transaction2 }) => {
  var _a2;
  const { chains: chains2 } = useConfig();
  const { fiatCurrency } = useSettings();
  const { setNavigation } = useNavigation();
  const onClickTransaction = () => {
    setNavigation({
      location: "transaction-details",
      params: {
        transaction: transaction2
      }
    });
  };
  const tokenContractAddresses = [];
  (_a2 = transaction2.transfers) == null ? void 0 : _a2.forEach((transfer) => {
    const tokenContractAddress = transfer.contractAddress;
    if (!tokenContractAddresses.includes(tokenContractAddress)) {
      tokenContractAddresses.push(tokenContractAddress);
    }
  });
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices(tokenContractAddresses.map((contractAddress) => ({
    contractAddress,
    chainId: transaction2.chainId
  })));
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingCoinPrices || isPendingConversionRate;
  const { transfers } = transaction2;
  const getTransactionIconByType = (transferType) => {
    switch (transferType) {
      case TxnTransferType.SEND:
        return jsxRuntimeExports$1.jsx(SvgArrowRightIcon, { style: {
          transform: "rotate(270deg)",
          width: "16px"
        } });
      case TxnTransferType.RECEIVE:
        return jsxRuntimeExports$1.jsx(SvgArrowRightIcon, { style: {
          transform: "rotate(90deg)",
          width: "16px"
        } });
      case TxnTransferType.UNKNOWN:
      default:
        return jsxRuntimeExports$1.jsx(SvgTransactionIcon, { style: { width: "14px" } });
    }
  };
  const getTansactionLabelByType = (transferType) => {
    switch (transferType) {
      case TxnTransferType.SEND:
        return "Sent";
      case TxnTransferType.RECEIVE:
        return "Received";
      case TxnTransferType.UNKNOWN:
      default:
        return "Transacted";
    }
  };
  const getTransferAmountLabel = (amount, symbol, transferType) => {
    let sign3 = "";
    if (transferType === TxnTransferType.SEND) {
      sign3 = "-";
    } else if (transferType === TxnTransferType.RECEIVE) {
      sign3 = "+";
    }
    let textColor = "text50";
    if (transferType === TxnTransferType.SEND) {
      textColor = vars.colors.negative;
    } else if (transferType === TxnTransferType.RECEIVE) {
      textColor = vars.colors.positive;
    }
    return jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "normal", style: { color: textColor }, children: `${sign3}${amount} ${symbol}` });
  };
  const getTransfer = ({ transfer, isFirstItem }) => {
    const { amounts } = transfer;
    const date = dayjs(transaction2.timestamp).format("MMM DD, YYYY");
    return jsxRuntimeExports$1.jsxs(Box, { gap: "2", width: "full", flexDirection: "column", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { color: "text50", gap: "1", flexDirection: "row", justifyContent: "center", alignItems: "center", children: [getTransactionIconByType(transfer.transferType), jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", fontSize: "normal", color: "text100", children: getTansactionLabelByType(transfer.transferType) }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId: transaction2.chainId, size: "xs" })] }), isFirstItem && jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", fontSize: "normal", color: "text50", children: date }) })] }), amounts.map((amount, index2) => {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
      const nativeTokenInfo = getNativeTokenInfoByChainId(transaction2.chainId, chains2);
      const isNativeToken = compareAddress(transfer.contractAddress, AddressZero);
      const isCollectible = ((_a3 = transfer.contractInfo) == null ? void 0 : _a3.type) === "ERC721" || ((_b2 = transfer.contractInfo) == null ? void 0 : _b2.type) === "ERC1155";
      let decimals;
      const tokenId = (_c2 = transfer.tokenIds) == null ? void 0 : _c2[index2];
      if (isCollectible && tokenId) {
        decimals = ((_e2 = (_d2 = transfer.tokenMetadata) == null ? void 0 : _d2[tokenId]) == null ? void 0 : _e2.decimals) || 0;
      } else {
        decimals = isNativeToken ? nativeTokenInfo.decimals : (_f2 = transfer.contractInfo) == null ? void 0 : _f2.decimals;
      }
      const amountValue = formatUnits$1(amount, decimals);
      const symbol = isNativeToken ? nativeTokenInfo.symbol : ((_g2 = transfer.contractInfo) == null ? void 0 : _g2.symbol) || "";
      const tokenLogoUri = isNativeToken ? nativeTokenInfo.logoURI : (_h2 = transfer.contractInfo) == null ? void 0 : _h2.logoURI;
      const fiatConversionRate = (_j2 = (_i2 = coinPrices.find((coinPrice) => compareAddress(coinPrice.token.contractAddress, transfer.contractAddress))) == null ? void 0 : _i2.price) == null ? void 0 : _j2.value;
      return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", justifyContent: "center", alignItems: "center", children: [tokenLogoUri && jsxRuntimeExports$1.jsx(Image$1, { src: tokenLogoUri, width: "5", alt: "token logo" }), getTransferAmountLabel(formatDisplay(amountValue), symbol, transfer.transferType)] }), isPending && jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "35px", height: "20px" } }), fiatConversionRate && jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", fontSize: "normal", color: "text50", children: `${fiatCurrency.sign}${(Number(amountValue) * fiatConversionRate * conversionRate).toFixed(2)}` })] }, index2);
    })] });
  };
  return jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", borderRadius: "md", padding: "4", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, onClick: () => onClickTransaction(), children: transfers == null ? void 0 : transfers.map((transfer, position) => {
    return jsxRuntimeExports$1.jsx(Box, { width: "full", children: getTransfer({
      transfer,
      isFirstItem: position === 0
    }) }, `${transaction2.txnHash}-${position}`);
  }) });
};
const TransactionHistorySkeleton = () => {
  const getTransactionItem = () => {
    return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", width: "full", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "65px", height: "20px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "75px", height: "17px" } })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "120px", height: "20px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "35px", height: "17px" } })] })] });
  };
  return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "70px", height: "17px" } }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: Array(8).fill(null).map((_, index2) => {
    return jsxRuntimeExports$1.jsx(Box, { borderRadius: "md", padding: "4", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", background: "backgroundSecondary", children: getTransactionItem() }, index2);
  }) })] });
};
const TransactionHistoryList = ({ transactions: transactions2, isPending, isFetchingNextPage }) => {
  const transactionPeriods = [
    {
      id: "today",
      label: "Today"
    },
    {
      id: "yesterday",
      label: "Yesterday"
    },
    {
      id: "week",
      label: "Last Week"
    },
    {
      id: "month",
      label: "Last Month"
    },
    {
      id: "year",
      label: "Last Year"
    },
    {
      id: "years",
      label: "Past Years"
    }
  ];
  const transactionsByTime = reactExports.useMemo(() => {
    const todayTreshold = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0)).getTime();
    const yesterdayTreshold = new Date((/* @__PURE__ */ new Date()).setDate(new Date(todayTreshold).getDate() - 1)).getTime();
    const weekTreshold = new Date((/* @__PURE__ */ new Date()).setDate((/* @__PURE__ */ new Date()).getDate() - 7)).getTime();
    const monthTreshold = new Date((/* @__PURE__ */ new Date()).setDate((/* @__PURE__ */ new Date()).getDate() - 30)).getTime();
    const yearTreshold = new Date((/* @__PURE__ */ new Date()).setDate((/* @__PURE__ */ new Date()).getDate() - 365)).getTime();
    const transactionsByTime2 = {
      today: [],
      yesterday: [],
      week: [],
      month: [],
      year: [],
      years: []
    };
    transactions2.forEach((transaction2) => {
      const transactionTime = new Date(transaction2.timestamp).getTime();
      if (transactionTime > todayTreshold) {
        transactionsByTime2.today.push(transaction2);
      } else if (transactionTime > yesterdayTreshold) {
        transactionsByTime2.yesterday.push(transaction2);
      } else if (transactionTime > weekTreshold) {
        transactionsByTime2.week.push(transaction2);
      } else if (transactionTime > monthTreshold) {
        transactionsByTime2.month.push(transaction2);
      } else if (transactionTime > yearTreshold) {
        transactionsByTime2.year.push(transaction2);
      } else {
        transactionsByTime2.years.push(transaction2);
      }
    });
    return transactionsByTime2;
  }, [transactions2]);
  if (isPending) {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: jsxRuntimeExports$1.jsx(TransactionHistorySkeleton, {}) });
  }
  const TimeLabel = ({ label }) => {
    return jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { color: "text50", fontWeight: "medium", fontSize: "normal", children: label }) });
  };
  const TransactionsList = ({ transactions: transactions3 }) => {
    return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: transactions3.map((transaction2, index2) => {
      return jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: jsxRuntimeExports$1.jsx(TransactionHistoryItem, { transaction: transaction2 }) }, `${transaction2.txnHash}-${index2}`);
    }) });
  };
  return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "5", children: [transactionPeriods.map((period) => {
    const txs = transactionsByTime[period.id];
    if (txs.length === 0) {
      return null;
    }
    return jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [jsxRuntimeExports$1.jsx(TimeLabel, { label: period.label }), jsxRuntimeExports$1.jsx(TransactionsList, { transactions: txs })] }, period.id);
  }), transactions2.length === 0 && jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [jsxRuntimeExports$1.jsx(TimeLabel, { label: "History" }), jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No Recent Transaction History Found" })] }), isFetchingNextPage && jsxRuntimeExports$1.jsx(Box, { margin: "4", alignItems: "center", justifyContent: "center", children: jsxRuntimeExports$1.jsx(Spinner, {}) })] });
};
const History = () => {
  const { selectedNetworks } = useSettings();
  const { address: accountAddress } = useAccount();
  const { data: transactionHistory = [], isPending: isPendingTransactionHistory } = useTransactionHistorySummary({
    accountAddress: accountAddress || "",
    chainIds: selectedNetworks
  });
  return jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", children: jsxRuntimeExports$1.jsx(TransactionHistoryList, { transactions: transactionHistory, isPending: isPendingTransactionHistory, isFetchingNextPage: false }) }) });
};
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key2) => `Invalid value for key ${key2}`;
const PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
const MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key2) => `Property 'weight' in key '${key2}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key2) => {
      let obj = createKey(key2);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key2) => {
      key2.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key2) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key2) || isArray(key2)) {
    src = key2;
    path = createKeyPath(key2);
    id2 = createKeyId(key2);
  } else {
    if (!hasOwn.call(key2, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name2 = key2.name;
    src = name2;
    if (hasOwn.call(key2, "weight")) {
      weight = key2.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
      }
    }
    path = createKeyPath(name2);
    id2 = createKeyId(name2);
    getFn = key2.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key2) {
  return isArray(key2) ? key2 : key2.split(".");
}
function createKeyId(key2) {
  return isArray(key2) ? key2.join(".") : key2;
}
function get(obj, path) {
  let list2 = [];
  let arr = false;
  const deepGet = (obj2, path2, index2) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index2]) {
      list2.push(obj2);
    } else {
      let key2 = path2[index2];
      const value = obj2[key2];
      if (!isDefined(value)) {
        return;
      }
      if (index2 === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list2.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index2 + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index2 + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list2 : list2[0];
}
const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
};
const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m2 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n2 = parseFloat(Math.round(norm2 * m2) / m2);
      cache.set(numTokens, n2);
      return n2;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key2, idx) => {
      this._keysMap[key2.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item2, keyId) {
    return item2[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key2, keyIndex) => {
      let value = key2.getFn ? key2.getFn(doc) : this.getFn(doc, key2.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item2, k2) => {
              stack.push({
                nestedArrIndex: k2,
                value: item2
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors: errors2 = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance: distance2 = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors2 / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance2) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance2;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location: location2 = Config.location,
  distance: distance2 = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index2 + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance: distance2,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j2 = finish; j2 >= start; j2 -= 1) {
      let currentLocation = j2 - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];
      }
      if (bitArr[j2] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance: distance2,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance: distance2,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location2 + startIndex,
        distance: distance2,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index2 = text2.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location2 = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text2.indexOf(this.pattern, location2)) > -1) {
      location2 = index2 + patternLen;
      indices.push([index2, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item2) => {
    let query = item2.trim().split(SPACE_RE).filter((item3) => item3 && !!item3.trim());
    let results2 = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results2.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results2.push(new searcher(token, options));
          break;
        }
      }
    }
    return results2;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance: distance2
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {
        const searcher = searchers2[j2];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key2) => ({
    [key2]: query[key2]
  }))
});
function parse$1(query, options, { auto: auto2 = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key2 = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key2];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key2));
      }
      const obj = {
        keyId: createKeyId(key2),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key2) => {
      const value = query2[key2];
      if (isArray(value)) {
        value.forEach((item2) => {
          node.children.push(next(item2));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results2, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results2.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key: key2, norm: norm2, score }) => {
      const weight = key2 ? key2.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results2, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results2.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index2) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results2 = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results2.push(doc);
      }
    }
    return results2;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results2 = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results2, { ignoreFieldNorm });
    if (shouldSort) {
      results2.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results2 = results2.slice(0, limit);
    }
    return format(results2, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results2 = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results2.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results2;
  }
  _searchLogical(query) {
    const expression = parse$1(query, this.options);
    const evaluate2 = (node, item2, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item2, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item: item2,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate2(child, item2, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results2 = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (isDefined(item2)) {
        let expResults = evaluate2(expression, item2, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item: item2, matches: [] };
            results2.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results2;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results2 = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (!isDefined(item2)) {
        return;
      }
      let matches = [];
      keys.forEach((key2, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key: key2,
            value: item2[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results2.push({
          idx,
          item: item2,
          matches
        });
      }
    });
    return results2;
  }
  _findMatches({ key: key2, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key: key2,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key: key2, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse$1;
}
{
  register(ExtendedSearch);
}
const BalanceItem = ({ balance }) => {
  var _a2, _b2, _c2;
  const { chains: chains2 } = useConfig();
  const { setNavigation } = useNavigation();
  const isNativeToken = compareAddress(balance.contractAddress, AddressZero);
  const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
  const logoURI = isNativeToken ? nativeTokenInfo.logoURI : (_a2 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _a2.logoURI;
  const tokenName = isNativeToken ? nativeTokenInfo.name : ((_b2 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _b2.name) || "Unknown";
  const symbol = isNativeToken ? nativeTokenInfo.symbol : (_c2 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _c2.symbol;
  const getQuantity = () => {
    var _a3, _b3;
    if (balance.contractType === "ERC721" || balance.contractType === "ERC1155") {
      return balance.balance;
    }
    const decimals = isNativeToken ? nativeTokenInfo.decimals : (_a3 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _a3.decimals;
    const bal = formatUnits$1(balance.balance, decimals || 0);
    const displayBalance = formatDisplay(bal);
    const symbol2 = isNativeToken ? nativeTokenInfo.symbol : (_b3 = balance == null ? void 0 : balance.contractInfo) == null ? void 0 : _b3.symbol;
    return `${displayBalance} ${symbol2}`;
  };
  const onClick = () => {
    const isCollection = balance.contractType === "ERC721" || balance.contractType === "ERC1155";
    if (isCollection) {
      setNavigation({
        location: "collection-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    } else {
      setNavigation({
        location: "coin-details",
        params: {
          contractAddress: balance.contractAddress,
          chainId: balance.chainId
        }
      });
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { onClick, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsxs(Box, { gap: "3", flexDirection: "row", alignItems: "center", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: logoURI, symbol, size: "md" }), jsxRuntimeExports$1.jsxs(Box, { gap: "1", flexDirection: "row", alignItems: "center", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", fontSize: "normal", style: {
    textOverflow: "ellipsis",
    overflow: "hidden",
    maxWidth: "250px",
    // @ts-ignore-next-line
    textWrap: "nowrap"
  }, children: tokenName }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId: balance.chainId, size: "xs" })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "1", children: [jsxRuntimeExports$1.jsx(Text, { color: "text50", fontWeight: "bold", fontSize: "normal", children: getQuantity() }), jsxRuntimeExports$1.jsx(SvgChevronRightIcon, { color: "text50" })] })] }, balance.contractAddress);
};
const WalletLink = ({ toLocation, label }) => {
  const { setNavigation } = useNavigation();
  const onClick = () => {
    setNavigation(toLocation);
  };
  return jsxRuntimeExports$1.jsxs(Box, { onClick, width: "full", flexDirection: "row", justifyContent: "space-between", alignItems: "center", userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsx(Text, { color: "text50", fontSize: "normal", fontWeight: "medium", children: label }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text50", fontSize: "normal", fontWeight: "medium", children: "View all" }), jsxRuntimeExports$1.jsx(SvgChevronRightIcon, { color: "text50", size: "sm" })] })] });
};
const SearchWallet = () => {
  const { chains: chains2 } = useConfig();
  const { fiatCurrency, hideUnlistedTokens, selectedNetworks } = useSettings();
  const [search2, setSearch] = reactExports.useState("");
  const { address: accountAddress } = useAccount();
  const { data: tokenBalancesData, isPending: isPendingTokenBalances } = useBalances({
    chainIds: selectedNetworks,
    accountAddress: accountAddress || "",
    verifiedOnly: hideUnlistedTokens
  });
  const coinBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC20" || compareAddress(b2.contractAddress, AddressZero))) || [];
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices(coinBalancesUnordered.map((token) => ({
    chainId: token.chainId,
    contractAddress: token.contractAddress
  })));
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const coinBalances = coinBalancesUnordered.sort((a2, b2) => {
    var _a2, _b2;
    const isHigherFiat = Number(computeBalanceFiat({
      balance: b2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_a2 = b2.contractInfo) == null ? void 0 : _a2.decimals) || 18
    })) - Number(computeBalanceFiat({
      balance: a2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_b2 = b2.contractInfo) == null ? void 0 : _b2.decimals) || 18
    }));
    return isHigherFiat;
  });
  const collectionBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC721" || b2.contractType === "ERC1155")) || [];
  const collectionBalances = collectionBalancesUnordered.sort((a2, b2) => {
    return Number(b2.balance) - Number(a2.balance);
  });
  const isPending = isPendingTokenBalances || isPendingCoinPrices || isPendingConversionRate;
  const indexedCollectionBalances = collectionBalances.map((balance, index2) => {
    var _a2;
    return {
      index: index2,
      name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
    };
  });
  const indexedCoinBalances = coinBalances.map((balance, index2) => {
    var _a2;
    if (compareAddress(balance.contractAddress, AddressZero)) {
      const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
      return {
        index: index2,
        name: nativeTokenInfo.name
      };
    } else {
      return {
        index: index2,
        name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
      };
    }
  });
  const coinBalancesAmount = coinBalances.length;
  const collectionBalancesAmount = collectionBalances.length;
  const fuzzySearchCoinBalances = new Fuse(indexedCoinBalances, {
    keys: ["name"]
  });
  const fuzzySearchCollections = new Fuse(indexedCollectionBalances, {
    keys: ["name"]
  });
  const foundCoinBalances = (search2 === "" ? indexedCoinBalances : fuzzySearchCoinBalances.search(search2).map((result) => result.item)).slice(0, 5);
  const foundCollectionBalances = (search2 === "" ? indexedCollectionBalances : fuzzySearchCollections.search(search2).map((result) => result.item)).slice(0, 5);
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", flexDirection: "column", gap: "10", alignItems: "center", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(Box, { width: "full", children: jsxRuntimeExports$1.jsx(TextInput, { autoFocus: true, name: "search wallet", leftIcon: SvgSearchIcon, value: search2, onChange: (ev) => setSearch(ev.target.value), placeholder: "Search your wallet", "data-1p-ignore": true }) }), jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "5", children: [jsxRuntimeExports$1.jsx(WalletLink, { toLocation: {
    location: "search-view-all",
    params: {
      defaultTab: "collections"
    }
  }, label: `Collections (${collectionBalancesAmount})` }), isPending ? Array(5).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", height: "8" }, i)) : foundCollectionBalances.length === 0 ? jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No collections found" }) : foundCollectionBalances.map((indexedItem, index2) => {
    const balance = collectionBalances[indexedItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance }, index2);
  })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "5", children: [jsxRuntimeExports$1.jsx(WalletLink, { toLocation: {
    location: "search-view-all",
    params: {
      defaultTab: "coins"
    }
  }, label: `Coins (${coinBalancesAmount})` }), isPending ? Array(5).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", height: "8" }, i)) : foundCoinBalances.length === 0 ? jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No coins found" }) : foundCoinBalances.map((indexItem, index2) => {
    const balance = coinBalances[indexItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance }, index2);
  })] })] });
};
const SearchWalletViewAll = ({ defaultTab }) => {
  const { chains: chains2 } = useConfig();
  const { fiatCurrency, hideUnlistedTokens, selectedNetworks } = useSettings();
  const [search2, setSearch] = reactExports.useState("");
  const [selectedTab, setSelectedTab] = reactExports.useState(defaultTab);
  reactExports.useEffect(() => {
    setSearch("");
  }, [selectedTab]);
  const { address: accountAddress } = useAccount();
  const { data: tokenBalancesData, isPending: isPendingTokenBalances } = useBalances({
    chainIds: selectedNetworks,
    accountAddress: accountAddress || "",
    verifiedOnly: hideUnlistedTokens
  });
  const coinBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC20" || compareAddress(b2.contractAddress, AddressZero))) || [];
  const { data: coinPrices = [], isPending: isPendingCoinPrices } = useCoinPrices(coinBalancesUnordered.map((token) => ({
    chainId: token.chainId,
    contractAddress: token.contractAddress
  })));
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const coinBalances = coinBalancesUnordered.sort((a2, b2) => {
    var _a2, _b2;
    const isHigherFiat = Number(computeBalanceFiat({
      balance: b2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_a2 = b2.contractInfo) == null ? void 0 : _a2.decimals) || 18
    })) - Number(computeBalanceFiat({
      balance: a2,
      prices: coinPrices,
      conversionRate,
      decimals: ((_b2 = a2.contractInfo) == null ? void 0 : _b2.decimals) || 18
    }));
    return isHigherFiat;
  });
  const collectionBalancesUnordered = (tokenBalancesData == null ? void 0 : tokenBalancesData.filter((b2) => b2.contractType === "ERC721" || b2.contractType === "ERC1155")) || [];
  const collectionBalances = collectionBalancesUnordered.sort((a2, b2) => {
    return Number(b2.balance) - Number(a2.balance);
  });
  const coinBalancesAmount = coinBalances.length;
  const collectionBalancesAmount = collectionBalances.length;
  const isPending = isPendingTokenBalances || isPendingCoinPrices || isPendingConversionRate;
  const indexedCollectionBalances = collectionBalances.map((balance, index2) => {
    var _a2;
    return {
      index: index2,
      name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
    };
  });
  const indexedCoinBalances = coinBalances.map((balance, index2) => {
    var _a2;
    if (compareAddress(balance.contractAddress, AddressZero)) {
      const nativeTokenInfo = getNativeTokenInfoByChainId(balance.chainId, chains2);
      return {
        index: index2,
        name: nativeTokenInfo.name
      };
    } else {
      return {
        index: index2,
        name: ((_a2 = balance.contractInfo) == null ? void 0 : _a2.name) || "Unknown"
      };
    }
  });
  const fuzzySearchCoinBalances = new Fuse(indexedCoinBalances, {
    keys: ["name"]
  });
  const fuzzySearchCollections = new Fuse(indexedCollectionBalances, {
    keys: ["name"]
  });
  const foundCoinBalances = search2 === "" ? indexedCoinBalances : fuzzySearchCoinBalances.search(search2).map((result) => result.item);
  const foundCollectionBalances = search2 === "" ? indexedCollectionBalances : fuzzySearchCollections.search(search2).map((result) => result.item);
  const TabsHeaderSkeleton = () => {
    return jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "360px", height: "48px" } });
  };
  const ItemsSkeletons = () => {
    return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: Array(8).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", height: "8" }, i)) });
  };
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", flexDirection: "column", gap: "5", alignItems: "center", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(Box, { width: "full", children: jsxRuntimeExports$1.jsx(TextInput, { autoFocus: true, name: "search wallet", leftIcon: SvgSearchIcon, value: search2, onChange: (ev) => setSearch(ev.target.value), placeholder: "Search your wallet", "data-1p-ignore": true }) }), jsxRuntimeExports$1.jsx(Box, { width: "full", children: jsxRuntimeExports$1.jsxs(TabsRoot, { value: selectedTab, onValueChange: (value) => setSelectedTab(value), children: [jsxRuntimeExports$1.jsxs(Box, { marginBottom: "5", children: [!isPending && jsxRuntimeExports$1.jsx(TabsHeader, { value: selectedTab, tabs: [
    { label: `Collections (${collectionBalancesAmount})`, value: "collections" },
    { label: `Coins (${coinBalancesAmount})`, value: "coins" }
  ] }), isPending && jsxRuntimeExports$1.jsx(TabsHeaderSkeleton, {})] }), jsxRuntimeExports$1.jsx(TabsContent, { value: "collections", children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [isPending && jsxRuntimeExports$1.jsx(ItemsSkeletons, {}), !isPending && foundCollectionBalances.length === 0 && jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No Collectibles Found" }), !isPending && foundCollectionBalances.length > 0 && foundCollectionBalances.map((indexItem, index2) => {
    const collectionBalance = collectionBalances[indexItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance: collectionBalance }, index2);
  })] }) }), jsxRuntimeExports$1.jsx(TabsContent, { value: "coins", children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "3", children: [isPending && jsxRuntimeExports$1.jsx(ItemsSkeletons, {}), !isPending && coinBalances.length == 0 && jsxRuntimeExports$1.jsx(Text, { color: "text100", children: "No Coins Found" }), !isPending && foundCoinBalances.length > 0 && foundCoinBalances.map((indexedItem, index2) => {
    const coinBalance = coinBalances[indexedItem.index];
    return jsxRuntimeExports$1.jsx(BalanceItem, { balance: coinBalance }, index2);
  })] }) })] }) })] });
};
const SettingsMenu = () => {
  const { setNavigation } = useNavigation();
  const onClickGeneral = () => {
    setNavigation({
      location: "settings-general"
    });
  };
  const onClickCurrency = () => {
    setNavigation({
      location: "settings-currency"
    });
  };
  const onClickNetworks = () => {
    setNavigation({
      location: "settings-networks"
    });
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsx(Box, { padding: "5", paddingTop: "3", children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", children: [jsxRuntimeExports$1.jsx(Button, { onClick: onClickGeneral, leftIcon: SvgSettingsIcon, rightIcon: SvgChevronRightIcon, width: "full", label: "General", style: {
    height: "52px",
    borderRadius: vars.radii.md
  } }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickCurrency, leftIcon: SvgCurrencyIcon, rightIcon: SvgChevronRightIcon, width: "full", label: "Currency", style: {
    height: "52px",
    borderRadius: vars.radii.md
  } }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickNetworks, leftIcon: SvgNetworkIcon, rightIcon: SvgChevronRightIcon, width: "full", label: "Networks", style: {
    height: "52px",
    borderRadius: vars.radii.md
  } })] }) }) });
};
const SettingsGeneral = () => {
  const { hideUnlistedTokens, setHideUnlistedTokens, hideCollectibles, setHideCollectibles } = useSettings();
  const onChangeHideUnlistedTokens = () => {
    setHideUnlistedTokens(!hideUnlistedTokens);
  };
  const onChangeHideCollectibles = () => {
    setHideCollectibles(!hideCollectibles);
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { gap: "2", padding: "5", paddingTop: "3", flexDirection: "column", children: [jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", children: "Hide unlisted tokens" }), jsxRuntimeExports$1.jsx(Switch, { checked: hideUnlistedTokens, onCheckedChange: onChangeHideUnlistedTokens })] }), jsxRuntimeExports$1.jsxs(Card, { flexDirection: "row", justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", children: "Hide collectibles" }), jsxRuntimeExports$1.jsx(Switch, { checked: hideCollectibles, onCheckedChange: onChangeHideCollectibles })] })] }) });
};
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e2)
        e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++)
    (e2 = arguments[f2]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const SelectedIndicator = (props) => {
  const { selected, className, squareIndicator = false } = props;
  return jsxRuntimeExports$1.jsx(Box, { borderStyle: "solid", borderColor: squareIndicator && selected ? "transparent" : "borderNormal", borderWidth: "thin", position: "relative", alignItems: "center", justifyContent: "center", flexShrink: "0", className, style: {
    borderRadius: squareIndicator ? "4px" : vars.radii.circle,
    width: "20px",
    height: "20px"
  }, children: jsxRuntimeExports$1.jsx(Box, { as: motion.div, background: squareIndicator ? "borderNormal" : "backgroundInverse", position: "absolute", color: "textInverse100", initial: { opacity: selected ? 1 : 0, scale: selected ? 1 : 0.5 }, animate: { opacity: selected ? 1 : 0, scale: selected ? 1 : 0.5 }, transition: { ease: "backOut" }, style: {
    borderRadius: squareIndicator ? "4px" : vars.radii.circle,
    width: squareIndicator ? "20px" : "14px",
    height: squareIndicator ? "20px" : "14px"
  }, justifyContent: "center", alignItems: "center", children: squareIndicator && jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { color: "white", style: { width: "14px", height: "14px" } }) }) });
};
const SelectButton = (props) => {
  const { value, selected, children, disabled, onClick, className, hideIndicator, squareIndicator = false, ...rest } = props;
  return jsxRuntimeExports$1.jsxs(Card, { as: "button", clickable: true, className: clsx(className), disabled, onClick: () => onClick(value), userSelect: "none", alignItems: "center", justifyContent: "space-between", textAlign: "left", width: "full", border: "none", style: {
    appearance: "none"
  }, ...rest, children: [children, !hideIndicator && jsxRuntimeExports$1.jsx(SelectedIndicator, { selected, squareIndicator })] });
};
const SettingsCurrency = () => {
  const { fiatCurrency, setFiatCurrency } = useSettings();
  return jsxRuntimeExports$1.jsx(Box, { paddingBottom: "5", paddingX: "4", paddingTop: "3", children: jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", children: supportedFiatCurrencies.map((currency) => {
    return jsxRuntimeExports$1.jsx(SelectButton, { value: currency.symbol, selected: currency.symbol === fiatCurrency.symbol, onClick: () => setFiatCurrency && setFiatCurrency(currency), children: jsxRuntimeExports$1.jsxs(Box, { gap: "2", justifyContent: "flex-start", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", children: currency.symbol }), jsxRuntimeExports$1.jsx(Text, { color: "text50", children: currency.name.message })] }) }, currency.symbol);
  }) }) });
};
const SettingsNetwork = () => {
  const { selectedNetworks, setSelectedNetworks } = useSettings();
  const { chains: chains2 } = useConfig();
  const onClickNetwork = (chainId) => {
    if (selectedNetworks.includes(chainId)) {
      if (selectedNetworks.length === 1) {
        return;
      }
      setSelectedNetworks(selectedNetworks.filter((id2) => id2 !== chainId));
    } else {
      setSelectedNetworks([...selectedNetworks, chainId]);
    }
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", children: [jsxRuntimeExports$1.jsx(Text, { variant: "small", fontWeight: "bold", color: "text50", children: "Networks" }), jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", gap: "2", marginTop: "4", children: chains2.map((chain) => {
    return jsxRuntimeExports$1.jsx(SelectButton, { disabled: selectedNetworks.length === 1 && selectedNetworks.includes(chain.id), selected: selectedNetworks.includes(chain.id), onClick: () => onClickNetwork(chain.id), value: chain.id, squareIndicator: true, children: jsxRuntimeExports$1.jsxs(Box, { gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: `https://assets.sequence.info/images/networks/medium/${chain.id}.webp` }), jsxRuntimeExports$1.jsx(Text, { color: "text100", variant: "normal", fontWeight: "bold", children: chain.name })] }) }, chain.id);
  }) })] }) });
};
const useIntersectionObserver = (ref, options) => {
  const [entry, setEntry] = reactExports.useState(null);
  const observer = reactExports.useMemo(() => new IntersectionObserver(([entry2]) => setEntry(entry2), options), []);
  reactExports.useEffect(() => {
    if (ref.current) {
      observer.observe(ref.current);
    }
    return () => {
      if (ref.current) {
        observer.disconnect();
      }
    };
  }, [ref.current, observer]);
  return (entry == null ? void 0 : entry.isIntersecting) ?? false;
};
const InfiniteScroll = (props) => {
  const { onLoad, hasMore = true, children } = props;
  const [pageNumber, setPageNumber] = reactExports.useState(0);
  const [isLoading, setLoading] = reactExports.useState(false);
  const bottomRef = reactExports.useRef(null);
  const isBottom = useIntersectionObserver(bottomRef);
  reactExports.useEffect(() => {
    if (isBottom && hasMore && !isLoading) {
      handleLoad();
    }
  }, [isBottom]);
  const handleLoad = async () => {
    setLoading(true);
    await onLoad(pageNumber);
    setPageNumber((pageNumber2) => pageNumber2 + 1);
    setLoading(false);
  };
  return jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [children, jsxRuntimeExports$1.jsx("div", { ref: bottomRef })] });
};
const NetworkBadge = ({ chainId }) => {
  const network2 = getNetwork(chainId);
  const chainColor = getNetworkColor(chainId);
  const chainBGColor = getNetworkBackgroundColor(chainId);
  return jsxRuntimeExports$1.jsxs(Box, { height: "6", paddingY: "1", paddingLeft: "1.5", paddingRight: "2", gap: "1", style: {
    background: chainBGColor
  }, borderRadius: "xs", flexDirection: "row", justifyContent: "center", alignItems: "center", width: "fit", children: [jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "xsmall", style: {
    color: chainColor
  }, children: capitalize(network2.title ?? network2.name) })] });
};
const CoinDetailsSkeleton = ({ chainId }) => {
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: { marginTop: "-20px" }, children: [jsxRuntimeExports$1.jsxs(Box, { marginBottom: "10", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "32px", height: "32px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { height: "24px", width: "70px" } }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", color: "text50", fontSize: "normal", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "150px", height: "36px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "33px", height: "17px" } })] })] }), jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "4", marginBottom: "10", width: "full", variant: "primary", leftIcon: SvgSendIcon, label: "Send", disabled: true, onClick: () => {
  } }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(TransactionHistorySkeleton, {}) })] }) });
};
const CoinDetails = ({ contractAddress, chainId }) => {
  var _a2, _b2, _c2, _d2;
  const { chains: chains2 } = useConfig();
  const { setNavigation } = useNavigation();
  const { fiatCurrency, hideUnlistedTokens } = useSettings();
  const { address: accountAddress } = useAccount();
  const { data: dataTransactionHistory, isPending: isPendingTransactionHistory, fetchNextPage, hasNextPage: hasNextPage2, isFetchingNextPage } = useTransactionHistory({
    chainId,
    accountAddress: accountAddress || "",
    contractAddress
  });
  const transactionHistory = flattenPaginatedTransactionHistory(dataTransactionHistory);
  const { data: dataCoinBalance, isPending: isPendingCoinBalance } = useCoinBalance({
    accountAddress: accountAddress || "",
    contractAddress,
    chainId,
    verifiedOnly: hideUnlistedTokens
  });
  const { data: dataCoinPrices, isPending: isPendingCoinPrices } = useCoinPrices([
    {
      chainId,
      contractAddress
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingCoinBalance || isPendingCoinPrices || isPendingConversionRate;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(CoinDetailsSkeleton, { chainId });
  }
  const isNativeToken = compareAddress(contractAddress, AddressZero);
  const logo = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).logoURI : (_a2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _a2.logoURI;
  const symbol = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).symbol : (_b2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _b2.symbol;
  const name2 = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).name : (_c2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _c2.name;
  const decimals = isNativeToken ? getNativeTokenInfoByChainId(chainId, chains2).decimals : (_d2 = dataCoinBalance == null ? void 0 : dataCoinBalance.contractInfo) == null ? void 0 : _d2.decimals;
  const formattedBalance = formatUnits$1((dataCoinBalance == null ? void 0 : dataCoinBalance.balance) || "0", decimals);
  const balanceDisplayed = formatDisplay(formattedBalance);
  const coinBalanceFiat = dataCoinBalance ? computeBalanceFiat({
    balance: dataCoinBalance,
    prices: dataCoinPrices || [],
    conversionRate,
    decimals: decimals || 0
  }) : "0";
  const onClickSend = () => {
    setNavigation({
      location: "send-coin",
      params: {
        chainId,
        contractAddress
      }
    });
  };
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: { marginTop: "-20px" }, children: [jsxRuntimeExports$1.jsxs(Box, { marginBottom: "10", gap: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Image$1, { width: "8", src: logo, alt: "logo" }), jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", fontSize: "large", children: name2 }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", color: "text50", fontSize: "normal", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", color: "text100", fontSize: "xlarge", children: `${balanceDisplayed} ${symbol}` }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", color: "text50", fontSize: "normal", children: `${fiatCurrency.sign}${coinBalanceFiat}` })] })] }), jsxRuntimeExports$1.jsx(Button, { width: "full", variant: "primary", leftIcon: SvgSendIcon, color: "text100", label: "Send", onClick: onClickSend }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(InfiniteScroll, { onLoad: () => fetchNextPage(), hasMore: hasNextPage2, children: jsxRuntimeExports$1.jsx(TransactionHistoryList, { transactions: transactionHistory, isPending: isPendingTransactionHistory, isFetchingNextPage }) }) })] }) });
};
const CollectionDetailsSkeleton = ({ chainId }) => {
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", marginTop: "8", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "10", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "32px", height: "32px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "100px", height: "24px" } }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "142px", height: "17px" } })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "168px", height: "20px" } }), jsxRuntimeExports$1.jsx(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, width: "full", marginTop: "3", children: Array(8).fill(null).map((_, i) => jsxRuntimeExports$1.jsx(Skeleton, { width: "full", aspectRatio: "1/1" }, i)) })] })] });
};
const CollectionDetails = ({ chainId, contractAddress }) => {
  var _a2;
  const { setNavigation } = useNavigation();
  const { address: accountAddress } = useAccount();
  const { data: collectionBalanceData, isPending: isPendingCollectionBalance } = useCollectionBalance({
    chainId,
    accountAddress: accountAddress || "",
    contractAddress
  });
  const contractInfo = (_a2 = collectionBalanceData == null ? void 0 : collectionBalanceData[0]) == null ? void 0 : _a2.contractInfo;
  const collectionLogoURI = contractInfo == null ? void 0 : contractInfo.logoURI;
  if (isPendingCollectionBalance) {
    return jsxRuntimeExports$1.jsx(CollectionDetailsSkeleton, { chainId });
  }
  const onClickItem = (balance) => {
    setNavigation && setNavigation({
      location: "collectible-details",
      params: {
        contractAddress: balance.contractAddress,
        chainId: balance.chainId,
        tokenId: balance.tokenID || ""
      }
    });
  };
  return jsxRuntimeExports$1.jsxs(Box, { paddingX: "4", paddingBottom: "5", paddingTop: "3", marginTop: "8", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "10", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(TokenImage, { src: collectionLogoURI, size: "lg" }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "large", color: "text100", children: (contractInfo == null ? void 0 : contractInfo.name) || "Unknown" }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", fontSize: "normal", color: "text50", children: `${(collectionBalanceData == null ? void 0 : collectionBalanceData.length) || 0} Unique Collectibles` })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", fontSize: "normal", color: "text50", children: `Owned (${(collectionBalanceData == null ? void 0 : collectionBalanceData.length) || 0})` }), jsxRuntimeExports$1.jsx(Box, { style: {
    display: "grid",
    gridTemplateColumns: `calc(50% - ${vars.space[1]}) calc(50% - ${vars.space[1]})`,
    gap: vars.space[2]
  }, width: "full", marginTop: "3", children: collectionBalanceData == null ? void 0 : collectionBalanceData.map((balance, index2) => {
    var _a3, _b2, _c2;
    const unformattedBalance = balance.balance;
    const decimals = ((_a3 = balance == null ? void 0 : balance.tokenMetadata) == null ? void 0 : _a3.decimals) || 0;
    const formattedBalance = formatDisplay(formatUnits$1(unformattedBalance, decimals));
    return jsxRuntimeExports$1.jsxs(Box, { onClick: () => onClickItem(balance), userSelect: "none", cursor: "pointer", opacity: { hover: "80" }, children: [jsxRuntimeExports$1.jsx(Box, { background: "backgroundSecondary", aspectRatio: "1/1", width: "full", borderRadius: "md", justifyContent: "center", alignItems: "center", marginBottom: "2", children: jsxRuntimeExports$1.jsx(Image$1, { style: { height: "100%" }, src: (_b2 = balance.tokenMetadata) == null ? void 0 : _b2.image }) }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "normal", color: "text100", children: `${(_c2 = balance.tokenMetadata) == null ? void 0 : _c2.name}` }) }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsxs(Text, { marginTop: "1", fontWeight: "medium", fontSize: "normal", color: "text50", children: [formattedBalance, " Owned"] }) })] }, index2);
  }) })] })] });
};
const CollectibleDetailsSkeleton = () => {
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: {
    marginTop: "-20px"
  }, children: [jsxRuntimeExports$1.jsxs(Box, { gap: "3", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "120px", height: "30px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "140px", height: "40px" } })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "347px", height: "347px" } }) }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", color: "text50", fontSize: "normal", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "44px", height: "36px" } }), jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "34px", height: "17px" } })] })] }), jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "4", width: "full", variant: "primary", leftIcon: SvgSendIcon, label: "Send", onClick: () => {
  } })] }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", color: "text50", fontWeight: "medium", children: "This week" }), jsxRuntimeExports$1.jsx(TransactionHistorySkeleton, {})] })] }) });
};
const CollectibleDetails = ({ contractAddress, chainId, tokenId }) => {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const { address: accountAddress } = useAccount();
  const { fiatCurrency } = useSettings();
  const { setNavigation } = useNavigation();
  const { data: dataTransactionHistory, isPending: isPendingTransactionHistory, fetchNextPage, hasNextPage: hasNextPage2, isFetchingNextPage } = useTransactionHistory({
    chainId,
    accountAddress: accountAddress || "",
    contractAddress,
    tokenId
  });
  const transactionHistory = flattenPaginatedTransactionHistory(dataTransactionHistory);
  const { data: dataCollectibleBalance, isPending: isPendingCollectibleBalance } = useCollectibleBalance({
    accountAddress: accountAddress || "",
    contractAddress,
    chainId,
    tokenId,
    verifiedOnly: false
  });
  const { data: dataCollectiblePrices, isPending: isPendingCollectiblePrices } = useCollectiblePrices([
    {
      chainId,
      contractAddress,
      tokenId
    }
  ]);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const isPending = isPendingCollectibleBalance || isPendingCollectiblePrices || isPendingConversionRate;
  if (isPending) {
    return jsxRuntimeExports$1.jsx(CollectibleDetailsSkeleton, {});
  }
  const onClickSend = () => {
    setNavigation({
      location: "send-collectible",
      params: {
        chainId,
        contractAddress,
        tokenId
      }
    });
  };
  const collectionLogo = (_a2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.contractInfo) == null ? void 0 : _a2.logoURI;
  const collectionName = ((_b2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.contractInfo) == null ? void 0 : _b2.name) || "Unknown Collection";
  const decimals = ((_c2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.tokenMetadata) == null ? void 0 : _c2.decimals) || 0;
  const rawBalance = (dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.balance) || "0";
  const balance = formatUnits$1(rawBalance, decimals);
  const formattedBalance = formatDisplay(Number(balance));
  const valueFiat = dataCollectibleBalance ? computeBalanceFiat({
    balance: dataCollectibleBalance,
    prices: dataCollectiblePrices || [],
    conversionRate,
    decimals
  }) : "0";
  return jsxRuntimeExports$1.jsx(Box, { style: { paddingTop: HEADER_HEIGHT }, children: jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "10", paddingBottom: "5", paddingX: "4", paddingTop: "0", style: {
    marginTop: "-20px"
  }, children: [jsxRuntimeExports$1.jsxs(Box, { gap: "3", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Image$1, { borderRadius: "circle", width: "8", src: collectionLogo, alt: "collection logo", style: {
    objectFit: "cover"
  } }), jsxRuntimeExports$1.jsxs(Box, { gap: "1", flexDirection: "row", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "small", color: "text100", children: collectionName }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "xs" })] })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", justifyContent: "center", alignItems: "center", children: [jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "bold", fontSize: "large", children: ((_d2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.tokenMetadata) == null ? void 0 : _d2.name) || "Unknown Collectible" }), jsxRuntimeExports$1.jsx(Text, { color: "text50", fontSize: "small", fontWeight: "medium", children: `#${tokenId}` })] })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(CollectibleTileImage, { imageUrl: (_e2 = dataCollectibleBalance == null ? void 0 : dataCollectibleBalance.tokenMetadata) == null ? void 0 : _e2.image }) }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", color: "text50", fontSize: "normal", children: "Balance" }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "flex-end", justifyContent: "space-between", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", color: "text100", fontSize: "xlarge", children: formattedBalance }), dataCollectiblePrices && ((_f2 = dataCollectiblePrices[0].price) == null ? void 0 : _f2.value) && jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", color: "text50", fontSize: "normal", children: `${fiatCurrency.symbol} ${valueFiat}` })] })] }), jsxRuntimeExports$1.jsx(Button, { color: "text100", marginTop: "4", width: "full", variant: "primary", leftIcon: SvgSendIcon, label: "Send", onClick: onClickSend })] }), jsxRuntimeExports$1.jsx(Box, { children: jsxRuntimeExports$1.jsx(InfiniteScroll, { onLoad: () => fetchNextPage(), hasMore: hasNextPage2, children: jsxRuntimeExports$1.jsx(TransactionHistoryList, { transactions: transactionHistory, isPending: isPendingTransactionHistory, isFetchingNextPage }) }) })] }) });
};
const CopyButton = (props) => {
  const { buttonVariant = "icon", text: text2, size: size2 = "xs", ...rest } = props;
  const [isCopied, setCopy] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isCopied) {
      setTimeout(() => {
        setCopy(false);
      }, 4e3);
    }
  }, [isCopied]);
  const handleCopy = () => {
    setCopy(true);
  };
  const label = isCopied ? "Copied!" : "Copy";
  const backgroundColor = buttonVariant === "icon" ? "rgba(0,0,0,0)" : vars.colors.buttonGlass;
  return jsxRuntimeExports$1.jsx(lib.CopyToClipboard, { text: text2, onCopy: handleCopy, children: jsxRuntimeExports$1.jsx(IconButton, { size: size2, icon: isCopied ? SvgCheckmarkIcon : SvgCopyIcon, ...rest, style: { background: backgroundColor, ...props == null ? void 0 : props.style }, label: buttonVariant === "with-label" ? label : void 0 }) });
};
const TransactionDetails = ({ transaction: transaction2 }) => {
  var _a2, _b2;
  const { chains: chains2 } = useConfig();
  const { fiatCurrency } = useSettings();
  const coins = [];
  const collectibles = [];
  (_a2 = transaction2.transfers) == null ? void 0 : _a2.forEach((transfer) => {
    var _a3, _b3, _c2, _d2;
    if (((_a3 = transfer.contractInfo) == null ? void 0 : _a3.type) === "ERC721" || ((_b3 = transfer.contractInfo) == null ? void 0 : _b3.type) === "ERC1155") {
      (_c2 = transfer.tokenIds) == null ? void 0 : _c2.forEach((tokenId) => {
        var _a4;
        const foundCollectible = collectibles.find((collectible) => {
          var _a5;
          return collectible.chainId === transaction2.chainId && compareAddress(collectible.contractAddress, ((_a5 = transfer.contractInfo) == null ? void 0 : _a5.address) || "") && collectible.tokenId === tokenId;
        });
        if (!foundCollectible) {
          collectibles.push({
            chainId: transaction2.chainId,
            contractAddress: ((_a4 = transfer.contractInfo) == null ? void 0 : _a4.address) || "",
            tokenId
          });
        }
      });
    } else {
      const contractAddress = ((_d2 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _d2.address) || AddressZero;
      const foundCoin = coins.find((coin) => coin.chainId === transaction2.chainId && compareAddress(coin.contractAddress, contractAddress));
      if (!foundCoin) {
        coins.push({
          chainId: transaction2.chainId,
          contractAddress
        });
      }
    }
  });
  const { data: coinPricesData, isPending: isPendingCoinPrices } = useCoinPrices(coins);
  const { data: collectiblePricesData, isPending: isPendingCollectiblePrices } = useCollectiblePrices(collectibles);
  const { data: conversionRate = 1, isPending: isPendingConversionRate } = useExchangeRate(fiatCurrency.symbol);
  const arePricesLoading = coins.length > 0 && isPendingCoinPrices || collectibles.length > 0 && isPendingCollectiblePrices || isPendingConversionRate;
  const nativeTokenInfo = getNativeTokenInfoByChainId(transaction2.chainId, chains2);
  const date = dayjs(transaction2.timestamp).format("ddd MMM DD YYYY, h:m:s a");
  const onClickBlockExplorer = () => {
    if (typeof window !== "undefined") {
      window.open(`${nativeTokenInfo.blockExplorerUrl}/tx/${transaction2.txnHash}`, "_blank");
    }
  };
  const Transfer = ({ transfer }) => {
    var _a3, _b3, _c2, _d2;
    const recipientAddress = transfer.to;
    const recipientAddressFormatted = recipientAddress.substring(0, 10) + "..." + recipientAddress.substring(transfer.to.length - 4, transfer.to.length);
    const isNativeToken = compareAddress(((_a3 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _a3.address) || "", AddressZero);
    const logoURI = isNativeToken ? nativeTokenInfo.logoURI : (_b3 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _b3.logoURI;
    const symbol = isNativeToken ? nativeTokenInfo.symbol : ((_c2 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _c2.symbol) || "";
    return jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, { children: (_d2 = transfer.amounts) == null ? void 0 : _d2.map((amount, index2) => {
      var _a4, _b4, _c3, _d3, _e2, _f2, _g2, _h2;
      const isCollectible = transfer.contractType === "ERC721" || transfer.contractType === "ERC1155";
      const tokenId = ((_a4 = transfer.tokenIds) == null ? void 0 : _a4[index2]) || "0";
      const collectibleDecimals = ((_c3 = (_b4 = transfer == null ? void 0 : transfer.tokenMetadata) == null ? void 0 : _b4[tokenId]) == null ? void 0 : _c3.decimals) || 0;
      const coinDecimals = isNativeToken ? nativeTokenInfo.decimals : ((_d3 = transfer == null ? void 0 : transfer.contractInfo) == null ? void 0 : _d3.decimals) || 0;
      const decimals = isCollectible ? collectibleDecimals : coinDecimals;
      const formattedBalance = formatUnits$1(amount, decimals);
      const balanceDisplayed = formatDisplay(formattedBalance);
      const fiatPrice = isCollectible ? (_f2 = (_e2 = collectiblePricesData == null ? void 0 : collectiblePricesData.find((collectible) => {
        var _a5, _b5;
        return compareAddress(collectible.token.contractAddress, ((_a5 = transfer.contractInfo) == null ? void 0 : _a5.address) || "") && collectible.token.tokenId === ((_b5 = transfer.tokenIds) == null ? void 0 : _b5[index2]) && collectible.token.chainId === transaction2.chainId;
      })) == null ? void 0 : _e2.price) == null ? void 0 : _f2.value : (_h2 = (_g2 = coinPricesData == null ? void 0 : coinPricesData.find((coin) => {
        var _a5;
        return compareAddress(coin.token.contractAddress, ((_a5 = transfer.contractInfo) == null ? void 0 : _a5.address) || AddressZero) && coin.token.chainId === transaction2.chainId;
      })) == null ? void 0 : _g2.price) == null ? void 0 : _h2.value;
      const fiatValue = (parseFloat(formattedBalance) * (conversionRate * (fiatPrice || 0))).toFixed(2);
      return jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "row", gap: "2", justifyContent: "space-between", alignItems: "center", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "flex-start", alignItems: "center", gap: "2", height: "12", borderRadius: "md", background: "buttonGlass", padding: "2", style: { flexBasis: "100%" }, children: [jsxRuntimeExports$1.jsx(TokenImage, { src: logoURI, symbol, size: "sm" }), jsxRuntimeExports$1.jsxs(Box, { gap: "0.5", flexDirection: "column", alignItems: "flex-start", justifyContent: "center", children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "xsmall", color: "text100", children: `${balanceDisplayed} ${symbol}` }), arePricesLoading ? jsxRuntimeExports$1.jsx(Skeleton, { style: { width: "44px", height: "12px" } }) : jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "xsmall", color: "text50", children: fiatPrice ? `${fiatCurrency.sign}${fiatValue}` : "" })] })] }), jsxRuntimeExports$1.jsx(SvgArrowRightIcon, { color: "text50", style: { width: "16px" } }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "flex-start", alignItems: "center", gap: "2", height: "12", borderRadius: "md", background: "buttonGlass", padding: "2", style: { flexBasis: "100%" }, children: [jsxRuntimeExports$1.jsx(GradientAvatar, { address: recipientAddress, style: { width: "20px" } }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "bold", fontSize: "xsmall", color: "text100", children: recipientAddressFormatted })] })] }, index2);
    }) });
  };
  return jsxRuntimeExports$1.jsxs(Box, { padding: "5", paddingTop: "3", flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "10", marginTop: "5", children: [jsxRuntimeExports$1.jsxs(Box, { marginTop: "6", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "1", children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", fontWeight: "medium", children: "Transaction details" }), jsxRuntimeExports$1.jsx(Text, { marginBottom: "1", fontSize: "small", fontWeight: "medium", color: "text50", children: date }), jsxRuntimeExports$1.jsx(NetworkBadge, { chainId: transaction2.chainId })] }), jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "4", width: "full", padding: "4", background: "backgroundSecondary", borderRadius: "md", children: [jsxRuntimeExports$1.jsxs(Box, { width: "full", gap: "1", flexDirection: "row", alignItems: "center", justifyContent: "flex-start", children: [jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", fontWeight: "medium", color: "text50", children: "Transfer" }), jsxRuntimeExports$1.jsx(NetworkImage, { chainId: transaction2.chainId, size: "xs" })] }), (_b2 = transaction2.transfers) == null ? void 0 : _b2.map((transfer, index2) => jsxRuntimeExports$1.jsx(Box, { width: "full", flexDirection: "column", justifyContent: "center", alignItems: "center", gap: "4", children: jsxRuntimeExports$1.jsx(Transfer, { transfer }) }, `transfer-${index2}`))] }), jsxRuntimeExports$1.jsx(Button, { onClick: onClickBlockExplorer, width: "full", borderRadius: "md", rightIcon: SvgLinkIcon, label: `View on ${nativeTokenInfo.blockExplorerName}` }), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Divider, { width: "full", margin: "0", style: { marginBottom: "-4px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text50", fontSize: "normal", fontWeight: "medium", children: "Status" }), jsxRuntimeExports$1.jsx(Text, { fontSize: "normal", fontWeight: "medium", color: "text100", children: "Complete" })] }), jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: "column", gap: "2", justifyContent: "center", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsx(Divider, { width: "full", margin: "0", style: { marginBottom: "-4px" } }), jsxRuntimeExports$1.jsx(Text, { color: "text50", fontSize: "normal", fontWeight: "medium", children: "Transaction Hash" }), jsxRuntimeExports$1.jsx(Text, { color: "text100", fontSize: "normal", fontWeight: "medium", style: { overflowWrap: "anywhere" }, children: transaction2.txnHash }), jsxRuntimeExports$1.jsx(CopyButton, { marginTop: "2", buttonVariant: "with-label", text: transaction2.txnHash })] })] })] });
};
const NavigationHeader = ({ secondaryText, primaryText }) => {
  const { goBack, history } = useNavigation();
  const onClickBack = () => {
    goBack();
  };
  return jsxRuntimeExports$1.jsxs(Box, { background: "backgroundPrimary", zIndex: "20", position: "fixed", width: "full", flexDirection: "row", alignItems: "center", justifyContent: "space-between", paddingX: "4", style: {
    height: HEADER_HEIGHT,
    paddingTop: "6px"
  }, children: [history.length > 0 ? jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickBack, icon: SvgChevronLeftIcon, size: "xs" }) : jsxRuntimeExports$1.jsx(Box, {}), jsxRuntimeExports$1.jsxs(Box, { children: [jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text50", children: secondaryText }), jsxRuntimeExports$1.jsx(Text, { fontWeight: "medium", variant: "small", color: "text100", children: primaryText })] }), jsxRuntimeExports$1.jsx(Box, { style: {
    width: "44px"
  } })] });
};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts2 = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ reactExports.createContext(defaultContext);
    const index2 = defaultContexts2.length;
    defaultContexts2 = [
      ...defaultContexts2,
      defaultContext
    ];
    function Provider2(props) {
      const { scope, children, ...context2 } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(
        () => context2,
        Object.values(context2)
      );
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context2 = reactExports.useContext(Context);
      if (context2)
        return context2;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [
      Provider2,
      useContext
    ];
  }
  const createScope2 = () => {
    const scopeContexts = defaultContexts2.map((defaultContext) => {
      return /* @__PURE__ */ reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope2.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope2, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return reactExports.useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1)
          return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children))
    return /* @__PURE__ */ reactExports.cloneElement(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
    });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
const $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
const $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    reactExports.useEffect(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ reactExports.createElement(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node2
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    reactDomExports.flushSync(
      () => target.dispatchEvent(event)
    );
}
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}
const $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
const $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
const $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
let $5cb92bef7577960e$var$originalBodyPointerEvents;
const $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
const $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _node$ownerDocument;
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context2 = reactExports.useContext($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = reactExports.useState(null);
  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
  const [, force] = reactExports.useState({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context2.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context2.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context2.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context2.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context2.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch)
      return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context2.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  reactExports.useEffect(() => {
    if (!node1)
      return;
    if (disableOutsidePointerEvents) {
      if (context2.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context2.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context2.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context2.layersWithOutsidePointerEventsDisabled.size === 1)
        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    ownerDocument,
    disableOutsidePointerEvents,
    context2
  ]);
  reactExports.useEffect(() => {
    return () => {
      if (!node1)
        return;
      context2.layers.delete(node1);
      context2.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context2
  ]);
  reactExports.useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent();
      } else
        ownerDocument.removeEventListener("click", handleClickRef.current);
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name2, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}
let $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  reactExports.useEffect(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node) => node.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1)
          return;
        const target = event.target;
        if (container1.contains(target))
          lastFocusedElementRef.current = target;
        else
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container1.contains(relatedTarget))
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleMutations = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations)
          if (mutation.removedNodes.length > 0)
            $d3863c46a17e8a28$var$focus(container1);
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container1)
        mutationObserver.observe(container1, {
          childList: true,
          subtree: true
        });
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  reactExports.useEffect(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement)
            $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented)
            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
              select: true
            });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = reactExports.useCallback((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(first, {
              select: true
            });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(last, {
              select: true
            });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container
    }))
      return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
      element.select();
  }
}
const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item2) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item2);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item2) => item2.tagName !== "A"
  );
}
const $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
const $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id2, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v3) => ({
  x: v3,
  y: v3
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
    }
  }
  return list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding2) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding2
  };
}
function getPaddingObject(padding2) {
  return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
    top: padding2,
    right: padding2,
    bottom: padding2,
    left: padding2
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x,
    right: x + width,
    bottom: y2 + height,
    x,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding: padding2 = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding2);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding: padding2 = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding2);
    const coords = {
      x,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$12 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$12, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y3
            } = _ref;
            return {
              x: x2,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y: y2
  });
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector2) => {
    try {
      return element.matches(selector2);
    } catch (e2) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll2.scrollLeft * scale2.x + offsets.x,
    y: rect.y * scale2.y - scroll2.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll2 = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll2.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll2.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll2.scrollLeft - offsets.x;
  const y2 = rect.top + scroll2.scrollTop - offsets.y;
  return {
    x,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update5, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update5, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update5);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update5) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update5();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update5();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update5();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update5);
      ancestorResize && ancestor.removeEventListener("resize", update5);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a2[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key2 = keys[i];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key2], b2[key2])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update5 = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update5);
      }
      update5();
    }
  }, [referenceEl, floatingEl, update5, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update: update5,
    refs,
    elements,
    floatingStyles
  }), [data, update5, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding: padding2
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding: padding2
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding: padding2
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
const $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ reactExports.createElement("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
const $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size2;
}
const $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
const [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
const [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
const $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
const $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
const $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context2 = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  reactExports.useEffect(() => {
    context2.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
const $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
const [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
const $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, avoidCollisions = true, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, updatePositionStrategy = "optimized", onPlaced, ...contentProps } = props;
  const context2 = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content2, setContent] = reactExports.useState(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow$12, setArrow] = reactExports.useState(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow$12);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: (...args) => {
      const cleanup = autoUpdate(...args, {
        animationFrame: updatePositionStrategy === "always"
      });
      return cleanup;
    },
    elements: {
      reference: context2.anchor
    },
    middleware: [
      offset({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions && shift({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? limitShift() : void 0,
        ...detectOverflowOptions
      }),
      avoidCollisions && flip({
        ...detectOverflowOptions
      }),
      size({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle2 = elements.floating.style;
          contentStyle2.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle2.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle2.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle2.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow$12 && arrow({
        element: arrow$12,
        padding: arrowPadding
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached && hide({
        strategy: "referenceHidden",
        ...detectOverflowOptions
      })
    ]
  });
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPositioned)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPositioned,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content2)
      setContentZIndex(window.getComputedStyle(content2).zIndex);
  }, [
    content2
  ]);
  return /* @__PURE__ */ reactExports.createElement("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    "data-side": placedSide,
    "data-align": placedAlign
  }, contentProps, {
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPositioned ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  }))));
});
const $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
const $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ reactExports.forwardRef(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ reactExports.createElement("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ reactExports.createElement($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
/* @__PURE__ */ Object.assign($cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0, {
  displayName: $cf1ac5d9fe0e8206$var$ARROW_NAME
});
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
const $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x,
        y: y2
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
const $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
const $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
const $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
const $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ $7SXl2$reactdom.createPortal(/* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
const $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : reactExports.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ reactExports.cloneElement(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          reactDomExports.flushSync(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: reactExports.useCallback((node) => {
      if (node)
        stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = reactExports.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent2, targets) {
  return targets.map(function(target) {
    if (parent2.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent2.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent2, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent2) {
    if (!parent2 || elementsToStop.has(parent2)) {
      return;
    }
    Array.prototype.forEach.call(parent2.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item2 = middleware(data, assigned);
      buffer2.push(item2);
      return function() {
        buffer2 = buffer2.filter(function(x) {
          return x !== item2;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
      }
      buffer2 = {
        push: function(x) {
          return cb2(x);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign$3({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest$2(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign$3({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, rest = __rest$2(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign$3(__assign$3({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$3(__assign$3({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign$3({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle2(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), s2 = _a2[1], d2 = _a2[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (availableScroll === 0 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (availableScrollTop === 0 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y2) {
  return x[0] === y2[0] && x[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray$1([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent2) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent2, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign$3({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
const $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
const [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
const $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
const [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
const $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
  const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverProvider, {
    scope: __scopePopover,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: reactExports.useCallback(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    hasCustomAnchor,
    onCustomAnchorAdd: reactExports.useCallback(
      () => setHasCustomAnchor(true),
      []
    ),
    onCustomAnchorRemove: reactExports.useCallback(
      () => setHasCustomAnchor(false),
      []
    ),
    modal
  }, children));
};
const $cb5cc270b50c6fcd$var$ANCHOR_NAME = "PopoverAnchor";
const $cb5cc270b50c6fcd$export$96e5381f42521a79 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...anchorProps } = props;
  const context2 = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$ANCHOR_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const { onCustomAnchorAdd, onCustomAnchorRemove } = context2;
  reactExports.useEffect(() => {
    onCustomAnchorAdd();
    return () => onCustomAnchorRemove();
  }, [
    onCustomAnchorAdd,
    onCustomAnchorRemove
  ]);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {
    ref: forwardedRef
  }));
});
const $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
const $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context2 = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context2.triggerRef);
  const trigger2 = /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context2.open,
    "aria-controls": context2.contentId,
    "data-state": $cb5cc270b50c6fcd$var$getState(context2.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context2.onOpenToggle)
  }));
  return context2.hasCustomAnchor ? trigger2 : /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), trigger2);
});
const $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
const [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
  forceMount: void 0
});
const $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context2 = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PortalProvider, {
    scope: __scopePopover,
    forceMount
  }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context2.open
  }, /* @__PURE__ */ reactExports.createElement($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
const $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
const $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context2 = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context2.open
  }, context2.modal ? /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
const $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context2 = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const contentRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const isRightClickOutsideRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const content2 = contentRef.current;
    if (content2)
      return hideOthers(content2);
  }, []);
  return /* @__PURE__ */ reactExports.createElement(ReactRemoveScroll, {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  }, /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context2.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        (_context$triggerRef$c = context2.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, {
      checkForDefaultPrevented: false
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
const $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context2 = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const hasInteractedOutsideRef = reactExports.useRef(false);
  const hasPointerDownOutsideRef = reactExports.useRef(false);
  return /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context2.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown")
          hasPointerDownOutsideRef.current = true;
      }
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context2.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
        event.preventDefault();
    }
  }));
});
const $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context2 = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onDismiss: () => context2.onOpenChange(false)
  }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": $cb5cc270b50c6fcd$var$getState(context2.open),
    role: "dialog",
    id: context2.contentId
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
function $cb5cc270b50c6fcd$var$getState(open) {
  return open ? "open" : "closed";
}
const $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
const $cb5cc270b50c6fcd$export$b688253958b8dfe7 = $cb5cc270b50c6fcd$export$96e5381f42521a79;
const $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
const $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4;
const $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
const AccountInformation = reactExports.forwardRef(({ onClickAccount }, ref) => {
  const { address } = useAccount();
  return jsxRuntimeExports$1.jsx(Box, { gap: "2", alignItems: "center", children: jsxRuntimeExports$1.jsx(Box, { width: "full", flexDirection: "column", alignItems: "center", justifyContent: "center", children: jsxRuntimeExports$1.jsxs(Box, {
    onClick: onClickAccount,
    gap: "2",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    userSelect: "none",
    cursor: "pointer",
    opacity: { hover: "80" },
    // @ts-ignore-next-line
    ref,
    children: [jsxRuntimeExports$1.jsx(GradientAvatar, { size: "sm", address: address || "" }), jsxRuntimeExports$1.jsx(Text, { color: "text100", fontWeight: "medium", variant: "normal", children: formatAddress(address || "") }), jsxRuntimeExports$1.jsx(SvgChevronDownIcon, { color: "text100" })]
  }) }) });
});
const WalletDropdownContent = reactExports.forwardRef(({ setOpenWalletDropdown }, ref) => {
  const { setNavigation } = useNavigation();
  const { setOpenWalletModal } = useOpenWalletModal();
  const { address } = useAccount();
  const { disconnect: disconnect2 } = useDisconnect();
  const { theme } = useTheme();
  const onClickReceive = () => {
    setOpenWalletDropdown(false);
    setNavigation({
      location: "receive"
    });
  };
  const onClickHistory = () => {
    setOpenWalletDropdown(false);
    setNavigation({
      location: "history"
    });
  };
  const onClickSettings = () => {
    setOpenWalletDropdown(false);
    setNavigation({
      location: "settings"
    });
  };
  const onClickSignout = () => {
    setOpenWalletModal(false);
    setOpenWalletDropdown(false);
    disconnect2();
  };
  const getDropdownBackgroundColor = () => {
    switch (theme) {
      case "dark":
        return "rgba(38, 38, 38, 0.85)";
      case "light":
        return "rgba(217, 217, 217, 0.85)";
      default:
        return vars.colors.transparent;
    }
  };
  return jsxRuntimeExports$1.jsxs(Box, { padding: "3", ref, zIndex: "30", borderRadius: "md", style: {
    position: "relative",
    pointerEvents: "auto",
    width: "370px",
    backdropFilter: "blur(12.5px)",
    top: "16px",
    left: "15px",
    background: getDropdownBackgroundColor()
  }, children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "space-between", alignItems: "flex-start", children: [jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", justifyContent: "center", alignItems: "center", gap: "3", marginLeft: "2", color: "text100", children: [jsxRuntimeExports$1.jsx(GradientAvatar, { style: { width: "28px" }, size: "md", address: address || "" }), jsxRuntimeExports$1.jsx(Text, { fontSize: "large", style: { fontWeight: "700" }, color: "text100", children: formatAddress(address || "") }), jsxRuntimeExports$1.jsx(CopyButton, { buttonVariant: "icon", size: "md", text: address || "", color: "text100", style: { marginLeft: "-16px" } })] }), jsxRuntimeExports$1.jsx(IconButton, { onClick: () => setOpenWalletDropdown(false), size: "xs", background: "buttonGlass", icon: SvgCloseIcon })] }), jsxRuntimeExports$1.jsxs(Box, { gap: "2", marginTop: "3", flexDirection: "column", children: [jsxRuntimeExports$1.jsx(Button, { variant: "glass", style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgQrCodeIcon, label: "Receive", onClick: onClickReceive }), jsxRuntimeExports$1.jsx(Button, { style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgTransactionIcon, label: "History", onClick: onClickHistory }), jsxRuntimeExports$1.jsx(Button, { style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgSettingsIcon, label: "Settings", onClick: onClickSettings }), jsxRuntimeExports$1.jsx(Button, { label: "Sign Out", style: { borderRadius: vars.radii.md }, width: "full", leftIcon: SvgSignoutIcon, onClick: onClickSignout })] })] });
});
const WalletHeader = () => {
  const { openWalletModalState } = useOpenWalletModal();
  const [openWalletDropdown, setOpenWalletDropdown] = reactExports.useState(false);
  const { goBack, history, setNavigation } = useNavigation();
  const hasDropdownOpened = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (!openWalletModalState) {
      setOpenWalletDropdown(false);
    }
  }, [openWalletModalState]);
  reactExports.useEffect(() => {
    if (openWalletDropdown) {
      if (!hasDropdownOpened.current) {
        hasDropdownOpened.current = true;
      } else {
        setOpenWalletDropdown(false);
      }
    } else {
      hasDropdownOpened.current = false;
    }
  }, [history.length, openWalletDropdown]);
  const onClickAccount = () => {
    setOpenWalletDropdown(true);
  };
  const onClickBack = () => {
    goBack();
  };
  const onClickSearch = () => {
    setNavigation({
      location: "search"
    });
  };
  return jsxRuntimeExports$1.jsx(Box, { as: motion.div, children: jsxRuntimeExports$1.jsxs($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { open: openWalletDropdown, children: [jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$b688253958b8dfe7, {}), jsxRuntimeExports$1.jsxs(Box, { background: "backgroundPrimary", zIndex: "20", position: "fixed", flexDirection: "row", alignItems: "center", justifyContent: "space-between", width: "full", paddingX: "4", style: {
    height: HEADER_HEIGHT,
    paddingTop: "6px"
  }, children: [history.length > 0 ? jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickBack, icon: SvgChevronLeftIcon, size: "xs" }) : jsxRuntimeExports$1.jsx(IconButton, { onClick: onClickSearch, icon: SvgSearchIcon, size: "xs" }), jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { asChild: true, children: jsxRuntimeExports$1.jsx(AccountInformation, { onClickAccount }) }), jsxRuntimeExports$1.jsx(Box, { style: { width: "44px" } })] }), jsxRuntimeExports$1.jsx(AnimatePresence, { children: openWalletDropdown && jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2, { asChild: true, side: "bottom", align: "start", children: jsxRuntimeExports$1.jsx(WalletDropdownContent, { setOpenWalletDropdown }) }) })] }) });
};
const getContent = (navigation) => {
  const { location: location2 } = navigation;
  switch (location2) {
    case "send-coin":
      return jsxRuntimeExports$1.jsx(SendCoin, { chainId: navigation.params.chainId, contractAddress: navigation.params.contractAddress });
    case "send-collectible":
      return jsxRuntimeExports$1.jsx(SendCollectible, { chainId: navigation.params.chainId, contractAddress: navigation.params.contractAddress, tokenId: navigation.params.tokenId });
    case "receive":
      return jsxRuntimeExports$1.jsx(Receive, {});
    case "history":
      return jsxRuntimeExports$1.jsx(History, {});
    case "search":
      return jsxRuntimeExports$1.jsx(SearchWallet, {});
    case "search-view-all":
      return jsxRuntimeExports$1.jsx(SearchWalletViewAll, { defaultTab: navigation.params.defaultTab });
    case "settings":
      return jsxRuntimeExports$1.jsx(SettingsMenu, {});
    case "settings-general":
      return jsxRuntimeExports$1.jsx(SettingsGeneral, {});
    case "settings-currency":
      return jsxRuntimeExports$1.jsx(SettingsCurrency, {});
    case "settings-networks":
      return jsxRuntimeExports$1.jsx(SettingsNetwork, {});
    case "coin-details":
      return jsxRuntimeExports$1.jsx(CoinDetails, { contractAddress: navigation.params.contractAddress, chainId: navigation.params.chainId });
    case "collectible-details":
      return jsxRuntimeExports$1.jsx(CollectibleDetails, { contractAddress: navigation.params.contractAddress, chainId: navigation.params.chainId, tokenId: navigation.params.tokenId });
    case "collection-details":
      return jsxRuntimeExports$1.jsx(CollectionDetails, { contractAddress: navigation.params.contractAddress, chainId: navigation.params.chainId });
    case "transaction-details":
      return jsxRuntimeExports$1.jsx(TransactionDetails, { transaction: navigation.params.transaction });
    case "home":
    default:
      return jsxRuntimeExports$1.jsx(Home, {});
  }
};
const getHeader = (navigation) => {
  const { location: location2 } = navigation;
  switch (location2) {
    case "search":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { primaryText: "Search wallet" });
    case "search-view-all":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Search wallet / ", primaryText: "View all" });
    case "settings":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "Settings" });
    case "settings-general":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / Settings / ", primaryText: "General" });
    case "settings-currency":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / Settings / ", primaryText: "Currency" });
    case "settings-networks":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / Settings / ", primaryText: "Networks" });
    case "receive":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "Receive" });
    case "history":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "History" });
    case "coin-details":
      return jsxRuntimeExports$1.jsx(WalletHeader, {});
    case "collectible-details":
      return jsxRuntimeExports$1.jsx(WalletHeader, {});
    case "transaction-details":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "", primaryText: "" });
    case "send-collectible":
    case "send-coin":
      return jsxRuntimeExports$1.jsx(NavigationHeader, { secondaryText: "Wallet / ", primaryText: "Send" });
    case "home":
    default:
      return jsxRuntimeExports$1.jsx(WalletHeader, {});
  }
};
const DEFAULT_LOCATION = {
  location: "home"
};
const KitWalletProvider = (props) => {
  const queryClient2 = new QueryClient();
  return jsxRuntimeExports$1.jsx(QueryClientProvider, { client: queryClient2, children: jsxRuntimeExports$1.jsx(KitWalletContent, { ...props }) });
};
const KitWalletContent = ({ children }) => {
  const { theme, position } = useTheme();
  const [openWalletModal, setOpenWalletModal] = reactExports.useState(false);
  const [history, setHistory] = reactExports.useState([]);
  const navigation = history.length > 0 ? history[history.length - 1] : DEFAULT_LOCATION;
  const displayScrollbar = navigation.location === "home" || navigation.location === "collection-details" || navigation.location === "collectible-details" || navigation.location === "coin-details" || navigation.location === "history" || navigation.location === "search" || navigation.location === "search-view-all" || navigation.location === "settings-currency";
  reactExports.useEffect(() => {
    if (openWalletModal) {
      setHistory([]);
    }
  }, [openWalletModal]);
  return jsxRuntimeExports$1.jsx(WalletModalContextProvider, { value: { setOpenWalletModal, openWalletModalState: openWalletModal }, children: jsxRuntimeExports$1.jsxs(NavigationContextProvider, { value: { setHistory, history }, children: [jsxRuntimeExports$1.jsx("div", { id: "kit-provider", children: jsxRuntimeExports$1.jsx(ThemeProvider, { root: "#kit-provider", scope: "kit", theme, children: jsxRuntimeExports$1.jsx(AnimatePresence, { children: openWalletModal && jsxRuntimeExports$1.jsx(Modal, { contentProps: {
    style: {
      maxWidth: "400px",
      height: "fit-content",
      ...getModalPositionCss(position)
    }
  }, scroll: false, backdropColor: "backgroundBackdrop", onClose: () => setOpenWalletModal(false), children: jsxRuntimeExports$1.jsxs(Box, { id: "sequence-kit-wallet-content", children: [getHeader(navigation), displayScrollbar ? jsxRuntimeExports$1.jsx(Scroll, { style: { paddingTop: HEADER_HEIGHT, height: "min(800px, 80vh)" }, children: getContent(navigation) }) : getContent(navigation)] }) }) }) }) }), children] }) });
};
const Header = () => {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    Box,
    {
      position: "fixed",
      top: "0",
      width: "full",
      padding: "4",
      justifyContent: "space-between",
      background: "backgroundOverlay",
      backdropFilter: "blur",
      zIndex: "1",
      style: { borderBottom: "1px solid #222" },
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "3", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Image$1, { style: { width: "36px" }, src: "images/kit-logo.svg", alt: "Sequence kit", disableAnimation: true }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Image$1,
            {
              style: {
                width: "24px"
                // filter: theme === 'dark' ? 'invert(0)' : 'invert(1)'
              },
              src: "images/kit-logo-text.svg",
              alt: "Sequence Kit Text Logo",
              disableAnimation: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", alignItems: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(NetworkSelect, {}),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(AccountMenu, {})
        ] })
      ]
    }
  );
};
const AccountMenu = () => {
  const [isOpen, toggleOpen] = reactExports.useState(false);
  const { address, connector } = useAccount();
  const { disconnect: disconnect2 } = useDisconnect();
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { open: isOpen, onOpenChange: toggleOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Box,
      {
        borderColor: isOpen ? "borderFocus" : "borderNormal",
        borderWidth: "thin",
        borderStyle: "solid",
        borderRadius: "md",
        paddingX: "4",
        paddingY: "3",
        cursor: "pointer",
        gap: "2",
        alignItems: "center",
        userSelect: "none",
        opacity: { hover: "80" },
        style: { height: 52 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { flexDirection: "column", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", gap: "2", justifyContent: "flex-end", alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(GradientAvatar, { address: String(address), size: "sm" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: truncateAddress(String(address), 4) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { color: "text50", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SvgChevronDownIcon, {}) })
        ]
      }
    ) }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$602eac185826482c, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2, { side: "bottom", sideOffset: 8, align: "end", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Card,
      {
        zIndex: "20",
        background: "backgroundRaised",
        backdropFilter: "blur",
        position: "relative",
        padding: "2",
        style: { minWidth: 360 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Card, { children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", justifyContent: "space-between", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: "Account" }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: connector == null ? void 0 : connector.name })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { as: "div", marginTop: "2", variant: "normal", color: "text80", children: address })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { marginTop: "2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Button,
            {
              width: "full",
              shape: "square",
              variant: "emphasis",
              rightIcon: SvgSignoutIcon,
              label: "Sign out",
              onClick: () => disconnect2()
            }
          ) })
        ]
      }
    ) }) })
  ] });
};
const NetworkSelect = () => {
  var _a2;
  const chains2 = useChains();
  const chainId = useChainId();
  const { switchChain: switchChain2 } = useSwitchChain();
  const [isOpen, toggleOpen] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { open: isOpen, onOpenChange: toggleOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      Box,
      {
        borderColor: isOpen ? "borderFocus" : "borderNormal",
        borderWidth: "thin",
        borderStyle: "solid",
        borderRadius: "md",
        paddingX: "4",
        paddingY: "3",
        cursor: "pointer",
        gap: "2",
        alignItems: "center",
        userSelect: "none",
        opacity: { hover: "80" },
        style: { height: 52 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { alignItems: "center", gap: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(NetworkImage, { chainId, size: "sm" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { display: { sm: "none", lg: "block" }, variant: "normal", fontWeight: "bold", color: "text100", children: ((_a2 = chains2.find((chain) => chain.id === chainId)) == null ? void 0 : _a2.name) || chainId })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { color: "text50", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(SvgChevronDownIcon, {}) })
        ]
      }
    ) }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$602eac185826482c, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2, { side: "bottom", sideOffset: 8, align: "end", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Card,
      {
        zIndex: "20",
        background: "backgroundRaised",
        backdropFilter: "blur",
        position: "relative",
        padding: "2",
        flexDirection: "column",
        gap: "2",
        children: chains2.map((chain) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Button,
          {
            width: "full",
            shape: "square",
            onClick: () => {
              switchChain2({ chainId: chain.id });
              toggleOpen(false);
            },
            leftIcon: () => /* @__PURE__ */ jsxRuntimeExports$1.jsx(NetworkImage, { chainId: chain.id, size: "sm" }),
            label: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { alignItems: "center", gap: "2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: chain.name }) })
          },
          chain.id
        ))
      }
    ) }) })
  ] });
};
const bottomPageLinks = [
  {
    label: "Terms",
    url: "https://sequence.xyz/terms"
  },
  {
    label: "About",
    url: "https://github.com/0xsequence/kit"
  },
  {
    label: "Blog",
    url: "https://sequence.xyz/blog"
  },
  {
    label: "Builder",
    url: "https://sequence.build"
  },
  {
    label: "Docs",
    url: "https://docs.sequence.xyz/wallet/connectors/kit/kit/overview"
  }
];
const socialLinks = [
  {
    id: "discord",
    url: "https://discord.gg/sequence",
    icon: "images/discord.svg"
  },
  {
    id: "twitter",
    url: "https://www.twitter.com/0xsequence",
    icon: "images/twitter.svg"
  },
  {
    id: "youtube",
    url: "https://www.youtube.com/channel/UC1zHgUyV-doddTcnFNqt62Q",
    icon: "images/youtube.svg"
  },
  {
    id: "github",
    url: "https://github.com/0xsequence",
    icon: "images/github.svg"
  }
];
const Footer = () => {
  const { theme } = useTheme$1();
  const onClickLinkUrl = (url) => {
    if (typeof window !== "undefined") {
      window.open(url);
    }
  };
  const Links = () => {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { flexDirection: "row", gap: "4", children: bottomPageLinks.map((link, index2) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Button,
      {
        variant: "text",
        onClick: () => onClickLinkUrl(link.url),
        gap: "4",
        label: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "small", children: link.label })
      },
      index2
    )) });
  };
  const Socials = () => {
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { gap: "4", justifyContent: "center", alignItems: "center", children: socialLinks.map((socialLink, index2) => {
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        Box,
        {
          cursor: "pointer",
          opacity: { hover: "80" },
          onClick: () => {
            if (typeof window !== "undefined") {
              window.open(socialLink.url);
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Image$1,
            {
              height: "3",
              src: socialLink.icon,
              alt: socialLink.id,
              style: {
                filter: theme === "dark" ? "invert(0)" : "invert(1)"
              },
              disableAnimation: true
            }
          )
        },
        index2
      );
    }) });
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    Box,
    {
      padding: "5",
      style: { height: "60px", borderTop: "1px solid #222" },
      position: "fixed",
      bottom: "0",
      width: "full",
      justifyContent: "space-between",
      background: "backgroundOverlay",
      backdropFilter: "blur",
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Links, {}),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Socials, {})
      ]
    }
  );
};
const CardButton = (props) => {
  const { title, description: description2, onClick, isPending } = props;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Card, { clickable: true, onClick, children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: "text100", children: title }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "text50", marginTop: "2", children: description2 }),
    isPending && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", alignItems: "center", marginTop: "4", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Spinner, { size: "sm" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "small", color: "text50", children: "Pending..." })
    ] })
  ] });
};
const messageToSign = "Two roads diverged in a yellow wood";
const abi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "address", name: "owner", type: "address" }
    ],
    name: "ERC721IncorrectOwner",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "ERC721InsufficientApproval",
    type: "error"
  },
  { inputs: [{ internalType: "address", name: "approver", type: "address" }], name: "ERC721InvalidApprover", type: "error" },
  { inputs: [{ internalType: "address", name: "operator", type: "address" }], name: "ERC721InvalidOperator", type: "error" },
  { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "ERC721InvalidOwner", type: "error" },
  { inputs: [{ internalType: "address", name: "receiver", type: "address" }], name: "ERC721InvalidReceiver", type: "error" },
  { inputs: [{ internalType: "address", name: "sender", type: "address" }], name: "ERC721InvalidSender", type: "error" },
  { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "ERC721NonexistentToken", type: "error" },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "owner", type: "address" },
      { indexed: true, internalType: "address", name: "approved", type: "address" },
      { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "owner", type: "address" },
      { indexed: true, internalType: "address", name: "operator", type: "address" },
      { indexed: false, internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint256", name: "_fromTokenId", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "_toTokenId", type: "uint256" }
    ],
    name: "BatchMetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [{ indexed: false, internalType: "uint256", name: "_tokenId", type: "uint256" }],
    name: "MetadataUpdate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "player", type: "address" },
      { internalType: "string", name: "tokenURI", type: "string" }
    ],
    name: "awardItem",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "getApproved",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "operator", type: "address" }
    ],
    name: "isApprovedForAll",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "ownerOf",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "tokenURI",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const orderbookAbi = [
  {
    inputs: [
      { internalType: "uint256", name: "requestId", type: "uint256" },
      { internalType: "uint256", name: "quantity", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256[]", name: "additionalFees", type: "uint256[]" },
      { internalType: "address[]", name: "additionalFeeRecipients", type: "address[]" }
    ],
    name: "acceptRequest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const delay = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
const getCheckoutSettings = (args) => {
  const checkoutSettings = {
    creditCardCheckout: {
      defaultPaymentMethodType: "us_debit",
      onSuccess: (hash2) => {
        console.log("credit card checkout success", hash2);
      },
      onError: (e2) => {
        console.log("credit card checkout error", e2);
      },
      ...args
    }
    // orderSummaryItems: [
    //   {
    //     chainId: args.chainId,
    //     contractAddress: args.nftAddress,
    //     tokenId: args.nftId,
    //     quantityRaw: String(args.nftQuantity)
    //   }
    // ]
  };
  return checkoutSettings;
};
const getOrderbookCalldata = ({ orderId, quantity, recipient }) => {
  const calldata = encodeFunctionData({
    abi: orderbookAbi,
    functionName: "acceptRequest",
    args: [BigInt(orderId), BigInt(quantity), recipient, [], []]
  });
  return calldata;
};
const searchParams$2 = new URLSearchParams(location.search);
const isDebugMode$1 = searchParams$2.has("debug");
const Connected = () => {
  var _a2;
  const { address } = useAccount();
  const { setOpenWalletModal } = useOpenWalletModal();
  const { triggerCheckout } = useCheckoutModal();
  const { triggerAddFunds } = useAddFundsModal();
  const { data: walletClient } = useWalletClient();
  const storage = useStorage();
  const [isCheckoutInfoModalOpen, setIsCheckoutInfoModalOpen] = React.useState(false);
  const [checkoutOrderId, setCheckoutOrderId] = React.useState("");
  const [checkoutTokenContractAddress, setCheckoutTokenContractAddress] = React.useState("");
  const [checkoutTokenId, setCheckoutTokenId] = React.useState("");
  const connections = useConnections();
  const isWaasConnection = connections.find((c2) => c2.connector.id.includes("waas")) !== void 0;
  const { data: txnData, sendTransaction: sendTransaction2, isPending: isPendingSendTxn, error } = useSendTransaction();
  const { data: txnData2, isPending: isPendingMintTxn, writeContract: writeContract2 } = useWriteContract();
  const [isSigningMessage, setIsSigningMessage] = React.useState(false);
  const [isMessageValid, setIsMessageValid] = React.useState();
  const [messageSig, setMessageSig] = React.useState();
  const [lastTxnDataHash, setLastTxnDataHash] = React.useState();
  const [lastTxnDataHash2, setLastTxnDataHash2] = React.useState();
  const [confirmationEnabled, setConfirmationEnabled] = React.useState(
    localStorage.getItem("confirmationEnabled") === "true"
  );
  const [pendingFeeOptionConfirmation, confirmPendingFeeOption] = useWaasFeeOptions();
  const [selectedFeeOptionTokenName, setSelectedFeeOptionTokenName] = React.useState();
  reactExports.useEffect(() => {
    if (pendingFeeOptionConfirmation) {
      setSelectedFeeOptionTokenName(pendingFeeOptionConfirmation.options[0].token.name);
    }
  }, [pendingFeeOptionConfirmation]);
  reactExports.useEffect(() => {
    if (error == null ? void 0 : error.message) {
      console.log(error == null ? void 0 : error.message);
    }
  }, [error]);
  const chainId = useChainId();
  const indexerClient = useIndexerClient(chainId);
  const [feeOptionBalances, setFeeOptionBalances] = React.useState([]);
  const [feeOptionAlert, setFeeOptionAlert] = React.useState(void 0);
  reactExports.useEffect(() => {
    checkTokenBalancesForFeeOptions();
  }, [pendingFeeOptionConfirmation]);
  const checkTokenBalancesForFeeOptions = async () => {
    if (pendingFeeOptionConfirmation && walletClient) {
      const [account2] = await walletClient.getAddresses();
      const nativeTokenBalance = await indexerClient.getEtherBalance({ accountAddress: account2 });
      const tokenBalances = await indexerClient.getTokenBalances({
        accountAddress: account2
      });
      console.log("feeOptions", pendingFeeOptionConfirmation.options);
      console.log("nativeTokenBalance", nativeTokenBalance);
      console.log("tokenBalances", tokenBalances);
      const balances = pendingFeeOptionConfirmation.options.map((option) => {
        var _a3;
        if (option.token.contractAddress === null) {
          return {
            tokenName: option.token.name,
            decimals: option.token.decimals || 0,
            balance: nativeTokenBalance.balance.balanceWei
          };
        } else {
          return {
            tokenName: option.token.name,
            decimals: option.token.decimals || 0,
            balance: ((_a3 = tokenBalances.balances.find((b2) => {
              var _a4;
              return b2.contractAddress.toLowerCase() === ((_a4 = option.token.contractAddress) == null ? void 0 : _a4.toLowerCase());
            })) == null ? void 0 : _a3.balance) || "0"
          };
        }
      });
      setFeeOptionBalances(balances);
    }
  };
  const networkForCurrentChainId = allNetworks.find((n2) => n2.chainId === chainId);
  const publicClient = usePublicClient({ chainId });
  const generateEthAuthProof = async () => {
    if (!walletClient || !publicClient || !storage) {
      return;
    }
    try {
      const proof = await signEthAuthProof(walletClient, storage);
      console.log("proof:", proof);
      const isValid2 = await validateEthProof(walletClient, publicClient, proof);
      console.log("isValid?:", isValid2);
    } catch (e2) {
      console.error(e2);
    }
  };
  reactExports.useEffect(() => {
    if (txnData) {
      setLastTxnDataHash(txnData.hash ?? txnData);
    }
    if (txnData2) {
      setLastTxnDataHash2(txnData2.hash ?? txnData);
    }
  }, [txnData, txnData2]);
  const signMessage2 = async () => {
    if (!walletClient || !publicClient) {
      return;
    }
    setIsSigningMessage(true);
    try {
      const message = messageToSign;
      const sig = await walletClient.signMessage({
        account: address || "",
        message
      });
      console.log("address", address);
      console.log("signature:", sig);
      console.log("chainId in homepage", chainId);
      const [account2] = await walletClient.getAddresses();
      const isValid2 = await publicClient.verifyMessage({
        address: account2,
        message,
        signature: sig
      });
      setIsSigningMessage(false);
      setIsMessageValid(isValid2);
      setMessageSig(sig);
      console.log("isValid?", isValid2);
    } catch (e2) {
      setIsSigningMessage(false);
      console.error(e2);
    }
  };
  const runSendTransaction = async () => {
    if (!walletClient) {
      return;
    }
    const contractAbiInterface = new Interface(["function demo()"]);
    const data = contractAbiInterface.encodeFunctionData("demo", []);
    sendTransaction2({
      to: "0x37470dac8a0255141745906c972e414b1409b470",
      data,
      gas: null
    });
  };
  const runMintNFT = async () => {
    if (!walletClient) {
      return;
    }
    const [account2] = await walletClient.getAddresses();
    writeContract2({
      address: "0x0d402C63cAe0200F0723B3e6fa0914627a48462E",
      abi,
      functionName: "awardItem",
      args: [account2, "https://dev-metadata.sequence.app/projects/277/collections/62/tokens/0.json"]
    });
  };
  const onClickCheckout = () => {
    setIsCheckoutInfoModalOpen(true);
  };
  const onCheckoutInfoConfirm = () => {
    setIsCheckoutInfoModalOpen(false);
    if (checkoutOrderId !== "" && checkoutTokenContractAddress !== "" && checkoutTokenId !== "") {
      const chainId2 = ChainId.POLYGON;
      const orderbookAddress = "0xB537a160472183f2150d42EB1c3DD6684A55f74c";
      const recipientAddress = address || "";
      const nftQuantity = "1";
      const checkoutSettings = getCheckoutSettings({
        chainId: chainId2,
        contractAddress: orderbookAddress,
        recipientAddress,
        currencyQuantity: "100000",
        currencySymbol: "USDC",
        currencyAddress: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
        currencyDecimals: "6",
        nftId: checkoutTokenId,
        nftAddress: checkoutTokenContractAddress,
        nftQuantity,
        isDev: true,
        approvedSpenderAddress: orderbookAddress,
        calldata: getOrderbookCalldata({
          orderId: checkoutOrderId,
          quantity: nftQuantity,
          recipient: recipientAddress
        })
      });
      triggerCheckout(checkoutSettings);
    }
  };
  const onClickAddFunds = () => {
    triggerAddFunds({
      walletAddress: address || ""
    });
  };
  reactExports.useEffect(() => {
    setLastTxnDataHash(void 0);
    setLastTxnDataHash2(void 0);
    setIsMessageValid(void 0);
  }, [chainId]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { paddingX: "4", flexDirection: "column", justifyContent: "center", alignItems: "center", style: { margin: "140px 0" }, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "4", style: { maxWidth: breakpoints.md }, children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { color: "text50", fontSize: "small", fontWeight: "medium", children: "Demos" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Inventory",
            description: "Connect a Sequence wallet to view, swap, send, and receive collections",
            onClick: () => setOpenWalletModal(true)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Send transaction",
            description: "Send a transaction with your wallet",
            isPending: isPendingSendTxn,
            onClick: runSendTransaction
          }
        ),
        networkForCurrentChainId.blockExplorer && lastTxnDataHash && ((txnData == null ? void 0 : txnData.chainId) === chainId || txnData) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
          Text,
          {
            as: "a",
            marginLeft: "4",
            variant: "small",
            underline: true,
            href: `${networkForCurrentChainId.blockExplorer.rootUrl}/tx/${txnData.hash ?? txnData}`,
            target: "_blank",
            rel: "noreferrer",
            children: [
              "View on ",
              networkForCurrentChainId.blockExplorer.name
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Sign message",
            description: "Sign a message with your wallet",
            onClick: signMessage2,
            isPending: isSigningMessage
          }
        ),
        isMessageValid && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Card, { style: { width: "332px" }, color: "text100", flexDirection: "column", gap: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", children: "Signed message:" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { children: messageToSign }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", children: "Signature:" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "code", as: "p", ellipsis: true, children: messageSig }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Text, { variant: "medium", children: [
            "isValid: ",
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "code", children: isMessageValid.toString() })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(CardButton, { title: "Add Funds", description: "Buy Cryptocurrency with a Credit Card", onClick: () => onClickAddFunds() }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          CardButton,
          {
            title: "Mint an NFT",
            description: "Test minting an NFT to your wallet",
            isPending: isPendingMintTxn,
            onClick: runMintNFT
          }
        ),
        networkForCurrentChainId.blockExplorer && lastTxnDataHash2 && ((txnData2 == null ? void 0 : txnData2.chainId) === chainId || txnData2) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
          Text,
          {
            as: "a",
            marginLeft: "4",
            variant: "small",
            underline: true,
            href: `${networkForCurrentChainId.blockExplorer.rootUrl}/tx/${txnData2.hash ?? txnData2}`,
            target: "_blank",
            rel: "noreferrer",
            children: [
              "View on ",
              networkForCurrentChainId.blockExplorer.name
            ]
          }
        ),
        isDebugMode$1 && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(CardButton, { title: "Generate EthAuth proof", description: "Generate EthAuth proof", onClick: generateEthAuthProof }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            CardButton,
            {
              title: "NFT Checkout",
              description: "Set orderbook order id, token contract address and token id to test checkout (on Polygon)",
              onClick: onClickCheckout
            }
          )
        ] })
      ] }),
      pendingFeeOptionConfirmation && feeOptionBalances.length > 0 && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { marginY: "3", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Select,
          {
            name: "feeOption",
            labelLocation: "top",
            label: "Pick a fee option",
            onValueChange: (val) => {
              var _a3;
              const selected = (_a3 = pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.options) == null ? void 0 : _a3.find((option) => option.token.name === val);
              if (selected) {
                setSelectedFeeOptionTokenName(selected.token.name);
                setFeeOptionAlert(void 0);
              }
            },
            value: selectedFeeOptionTokenName,
            options: [
              ...(_a2 = pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.options) == null ? void 0 : _a2.map((option) => {
                var _a3;
                return {
                  label: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { alignItems: "flex-start", flexDirection: "column", fontSize: "xsmall", children: [
                    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", children: [
                      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Text, { children: [
                        "Fee (in ",
                        option.token.name,
                        "): "
                      ] }),
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { children: formatUnits(BigInt(option.value), option.token.decimals || 0) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", children: [
                      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Text, { children: [
                        "Wallet balance for ",
                        option.token.name,
                        ": "
                      ] }),
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { children: formatUnits(
                        BigInt(((_a3 = feeOptionBalances.find((b2) => b2.tokenName === option.token.name)) == null ? void 0 : _a3.balance) || "0"),
                        option.token.decimals || 0
                      ) })
                    ] })
                  ] }),
                  value: option.token.name
                };
              })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { marginY: "2", alignItems: "center", justifyContent: "center", flexDirection: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Button,
            {
              onClick: () => {
                var _a3, _b2;
                const selected = (_a3 = pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.options) == null ? void 0 : _a3.find(
                  (option) => option.token.name === selectedFeeOptionTokenName
                );
                if ((selected == null ? void 0 : selected.token.contractAddress) !== void 0) {
                  const balance = parseUnits(
                    ((_b2 = feeOptionBalances.find((b2) => b2.tokenName === selected.token.name)) == null ? void 0 : _b2.balance) || "0",
                    selected.token.decimals || 0
                  );
                  const feeOptionValue = parseUnits(selected.value, selected.token.decimals || 0);
                  if (balance && balance < feeOptionValue) {
                    setFeeOptionAlert({
                      title: "Insufficient balance",
                      description: `You do not have enough balance to pay the fee with ${selected.token.name}, please make sure you have enough balance in your wallet for the selected fee option.`,
                      secondaryDescription: "You can also switch network to Arbitrum Sepolia to test a gasless transaction.",
                      variant: "warning"
                    });
                    return;
                  }
                  confirmPendingFeeOption(pendingFeeOptionConfirmation == null ? void 0 : pendingFeeOptionConfirmation.id, selected.token.contractAddress);
                }
              },
              label: "Confirm fee option"
            }
          ),
          feeOptionAlert && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { marginTop: "3", style: { maxWidth: "332px" }, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Alert,
            {
              title: feeOptionAlert.title,
              description: feeOptionAlert.description,
              secondaryDescription: feeOptionAlert.secondaryDescription,
              variant: feeOptionAlert.variant,
              buttonProps: feeOptionAlert.buttonProps
            }
          ) })
        ] })
      ] }),
      isWaasConnection && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { marginY: "3", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { as: "label", flexDirection: "row", alignItems: "center", justifyContent: "space-between", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { fontWeight: "semibold", variant: "small", color: "text50", children: "Confirmations" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { alignItems: "center", gap: "2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Switch,
          {
            name: "confirmations",
            checked: confirmationEnabled,
            onCheckedChange: async (checked) => {
              if (checked) {
                localStorage.setItem("confirmationEnabled", "true");
                setConfirmationEnabled(true);
              } else {
                localStorage.removeItem("confirmationEnabled");
                setConfirmationEnabled(false);
              }
              await delay(300);
              window.location.reload();
            }
          }
        ) })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(AnimatePresence, { children: isCheckoutInfoModalOpen && /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Modal,
      {
        contentProps: {
          style: {
            maxWidth: "400px",
            height: "auto",
            ...getModalPositionCss("center")
          }
        },
        scroll: false,
        backdropColor: "backgroundBackdrop",
        onClose: () => setIsCheckoutInfoModalOpen(false),
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { id: "sequence-kit-checkout-info-modal", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { paddingTop: "16", paddingBottom: "8", paddingX: "6", gap: "2", flexDirection: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text50", children: "Order ID" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            TextInput,
            {
              autoFocus: true,
              name: "orderId",
              value: checkoutOrderId,
              onChange: (ev) => setCheckoutOrderId(ev.target.value),
              placeholder: "Order Id",
              "data-1p-ignore": true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text50", children: "Token Contract Address" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            TextInput,
            {
              autoFocus: true,
              name: "tokenContractAddress",
              value: checkoutTokenContractAddress,
              onChange: (ev) => setCheckoutTokenContractAddress(ev.target.value),
              placeholder: "Token Contract Address",
              "data-1p-ignore": true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "medium", color: "text50", children: "Token ID" }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            TextInput,
            {
              autoFocus: true,
              name: "tokenId",
              value: checkoutTokenId,
              onChange: (ev) => setCheckoutTokenId(ev.target.value),
              placeholder: "Token Id",
              "data-1p-ignore": true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            Button,
            {
              marginTop: "4",
              onClick: () => {
                onCheckoutInfoConfirm();
              },
              label: "Trigger checkout"
            }
          )
        ] }) })
      }
    ) })
  ] });
};
const Alert = ({ title, description: description2, secondaryDescription, variant, buttonProps, children }) => {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { borderRadius: "md", background: variant, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    Box,
    {
      background: "backgroundOverlay",
      borderRadius: "md",
      paddingX: { sm: "4", md: "5" },
      paddingY: "4",
      width: "full",
      flexDirection: "column",
      gap: "3",
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { width: "full", flexDirection: { sm: "column", md: "row" }, gap: "2", justifyContent: "space-between", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", gap: "1", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text100", fontWeight: "medium", children: title }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: description2 }),
            secondaryDescription && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", color: "text80", fontWeight: "medium", children: secondaryDescription })
          ] }),
          buttonProps ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { background: variant, borderRadius: "sm", width: "min", height: "min", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Button, { variant: "emphasis", shape: "square", flexShrink: "0", ...buttonProps }) }) : null
        ] }),
        children
      ]
    }
  ) });
};
const searchParams$1 = new URLSearchParams(location.search);
const connectionMode$1 = searchParams$1.get("mode") === "universal" ? "universal" : "waas";
const Homepage = () => {
  const { theme } = useTheme$1();
  const { isConnected } = useAccount();
  const { setOpenConnectModal } = useOpenConnectModal();
  const handleSwitchConnectionMode = (mode) => {
    const searchParams2 = new URLSearchParams();
    searchParams2.set("mode", mode);
    window.location.search = searchParams2.toString();
  };
  const onClickConnect = () => {
    setOpenConnectModal(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("main", { children: [
    !isConnected ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center", gap: "5", height: "vh", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { flexDirection: "row", alignItems: "center", justifyContent: "center", gap: "3", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Image$1, { style: { width: "48px" }, src: "images/kit-logo.svg" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Image$1,
          {
            style: {
              width: "32px",
              filter: theme === "dark" ? "invert(0)" : "invert(1)"
            },
            src: "images/kit-logo-text.svg"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, { gap: "2", flexDirection: "row", alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Button, { onClick: onClickConnect, variant: "feature", label: "Connect" }) }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", flexDirection: "column", paddingX: "4", marginTop: "10", width: "full", style: { maxWidth: breakpoints.md }, children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          ConnectionModeSelect,
          {
            mode: "waas",
            title: "Embedded Wallet (WaaS)",
            description: "Connect to an embedded wallet for a seamless experience.",
            onClick: handleSwitchConnectionMode
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          ConnectionModeSelect,
          {
            mode: "universal",
            title: "Universal Wallet",
            description: "Connect to the universal sequence wallet or EIP6963 Injected wallet providers (web extension wallets).",
            onClick: handleSwitchConnectionMode
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(Connected, {}),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Footer, {})
  ] });
};
const ConnectionModeSelect = (props) => {
  const { mode, title, description: description2, onClick } = props;
  const isSelected = connectionMode$1 === mode;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    Card,
    {
      width: "full",
      clickable: true,
      outlined: true,
      borderWidth: "thick",
      style: {
        boxShadow: isSelected ? "0 0 24px rgb(127 59 158 / 0.8)" : "none",
        borderColor: isSelected ? "rgb(127 59 200)" : "var(--seq-colors-border-normal)"
      },
      onClick: () => onClick(mode),
      children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { gap: "2", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { variant: "normal", fontWeight: "bold", color: isSelected ? "text100" : "text80", children: title }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Text, { as: "div", variant: "normal", color: "text50", marginTop: "2", children: description2 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(SvgCheckmarkIcon, { size: "md", style: { color: "rgb(127 59 200)" }, visibility: isSelected ? "visible" : "hidden" })
      ] })
    }
  );
};
const searchParams = new URLSearchParams(location.search);
const connectionMode = searchParams.get("mode") === "universal" ? "universal" : "waas";
const isDebugMode = searchParams.has("debug");
const projectAccessKey = isDebugMode ? "AQAAAAAAAAK2JvvZhWqZ51riasWBftkrVXE" : "AQAAAAAAAEGvyZiWA9FMslYeG_yayXaHnSI";
const chains = getDefaultChains([ChainId.ARBITRUM_NOVA, ChainId.ARBITRUM_SEPOLIA, ChainId.POLYGON]);
const transports = chains.reduce((acc, chain) => {
  acc[chain.id] = http();
  return acc;
}, {});
const waasConfigKey = isDebugMode ? "eyJwcm9qZWN0SWQiOjY5NCwicnBjU2VydmVyIjoiaHR0cHM6Ly9kZXYtd2Fhcy5zZXF1ZW5jZS5hcHAiLCJlbWFpbFJlZ2lvbiI6ImNhLWNlbnRyYWwtMSIsImVtYWlsQ2xpZW50SWQiOiI1NGF0bjV1cGk2M3FjNTlhMWVtM3ZiaHJzbiJ9" : "eyJwcm9qZWN0SWQiOjE2ODE1LCJlbWFpbFJlZ2lvbiI6ImNhLWNlbnRyYWwtMSIsImVtYWlsQ2xpZW50SWQiOiI2N2V2NXVvc3ZxMzVmcGI2OXI3NnJoYnVoIiwicnBjU2VydmVyIjoiaHR0cHM6Ly93YWFzLnNlcXVlbmNlLmFwcCJ9";
const googleClientId = isDebugMode ? "603294233249-6h5saeg2uiu8akpcbar3r2aqjp6j7oem.apps.googleusercontent.com" : "970987756660-35a6tc48hvi8cev9cnknp0iugv9poa23.apps.googleusercontent.com";
const appleClientId = "com.horizon.sequence.waas";
const appleRedirectURI = window.location.origin + window.location.pathname;
const getWaasConnectors = () => {
  const connectors = [
    ...getDefaultWaasConnectors({
      walletConnectProjectId: "c65a6cb1aa83c4e24500130f23a437d8",
      defaultChainId: ChainId.ARBITRUM_NOVA,
      waasConfigKey,
      googleClientId,
      appleClientId,
      appleRedirectURI,
      appName: "Kit Demo",
      projectAccessKey,
      // emailAuthVersion: 1,
      enableConfirmationModal: localStorage.getItem("confirmationEnabled") === "true",
      isDev: isDebugMode
    })
    // ...(isDebugMode
    //   ? getKitConnectWallets(projectAccessKey, [
    //       mock({
    //         accounts: ['0xCb88b6315507e9d8c35D81AFB7F190aB6c3227C9']
    //       })
    //     ])
    //   : [])
  ];
  return connectors;
};
const getUniversalConnectors = () => {
  const connectors = [
    ...getDefaultConnectors({
      walletConnectProjectId: "c65a6cb1aa83c4e24500130f23a437d8",
      defaultChainId: ChainId.ARBITRUM_NOVA,
      appName: "demo app",
      projectAccessKey
    }),
    ...isDebugMode ? getKitConnectWallets(projectAccessKey, [
      mock({
        accounts: ["0xCb88b6315507e9d8c35D81AFB7F190aB6c3227C9"]
      })
    ]) : []
  ];
  return connectors;
};
const wagmiConfig = createConfig({
  transports,
  chains,
  connectors: connectionMode === "waas" ? getWaasConnectors() : getUniversalConnectors()
});
const kitConfig = {
  isDev: isDebugMode,
  projectAccessKey,
  defaultTheme: "dark",
  signIn: {
    projectName: "Kit Demo",
    // logoUrl: 'sw-logo-white.svg',
    useMock: isDebugMode
  },
  displayedAssets: [
    // Native token
    {
      contractAddress: zeroAddress,
      chainId: ChainId.ARBITRUM_NOVA
    },
    // Native token
    {
      contractAddress: zeroAddress,
      chainId: ChainId.ARBITRUM_SEPOLIA
    },
    // Waas demo NFT
    {
      contractAddress: "0x0d402c63cae0200f0723b3e6fa0914627a48462e",
      chainId: ChainId.ARBITRUM_NOVA
    },
    // Waas demo NFT
    {
      contractAddress: "0x0d402c63cae0200f0723b3e6fa0914627a48462e",
      chainId: ChainId.ARBITRUM_SEPOLIA
    },
    // Skyweaver assets
    {
      contractAddress: "0x631998e91476da5b870d741192fc5cbc55f5a52e",
      chainId: ChainId.POLYGON
    }
  ]
};
const queryClient = new QueryClient();
const App = () => {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(WagmiProvider, { config: wagmiConfig, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(KitProvider, { config: kitConfig, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(KitWalletProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(KitCheckoutProvider, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { id: "app", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ThemeProvider, { root: "#app", scope: "app", theme: "dark", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Homepage, {}) }) }) }) }) }) }) });
};
console.log("VERSION:", "0.7.14");
const root = client.createRoot(document.getElementById("root"));
root.render(
  /* @__PURE__ */ jsxRuntimeExports$1.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(App, {}) })
);
export {
  Buffer2 as B,
  HttpRequestError as H,
  __vitePreload as _,
  getAugmentedNamespace as a,
  bnExports as b,
  commonjsGlobal as c,
  require$$0$2 as d,
  eventemitter3Exports as e,
  global$1 as f,
  getDefaultExportFromCjs$1 as g,
  BaseError$2 as h,
  inherits_browserExports as i,
  getUrl as j,
  decodeErrorResult as k,
  isAddressEqual as l,
  call as m,
  concat as n,
  encodeAbiParameters as o,
  process$1 as p,
  isHex as q,
  require$$2$1 as r,
  stringify as s,
  tslib_es6$2 as t
};
